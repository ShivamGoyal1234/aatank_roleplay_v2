import { d as defaultBaseStyle, H as HudBaseStyles } from '../config/hud/styles/base.js';
import { N as NotificationBaseStyles } from '../config/notification/styles/base.js';
import { N as NotificationThemeStyles } from '../config/notification/styles/theme.js';
import { N as NotificationThemes } from '../config/notification/themes.js';
import { H as HudImages } from '../config/hud/images.js';
import { H as HudThemes, S as SpeedometerThemes } from '../config/hud/themes.js';
import { P as ProgressBarThemes } from '../config/progressbar/themes.js';
import { P as PlayerStatusStyles, S as ServerInfoStyles, L as LocationStyles, W as WeaponStyles, A as AccountStyles, V as VehicleStyles, a as SettingsStyles } from '../config/hud/styles/theme.js';
import { H as HudIcons } from '../config/hud/icons.js';
import { P as ProgressbarStyles } from '../config/progressbar/styles/theme.js';
import { P as ProgressbarBaseStyle } from '../config/progressbar/styles/base.js';
import { N as NotificationSounds } from '../config/notification/sounds.js';

function _mergeNamespaces(n, m) {
	for (var i = 0; i < m.length; i++) {
		const e = m[i];
		if (typeof e !== 'string' && !Array.isArray(e)) { for (const k in e) {
			if (k !== 'default' && !(k in n)) {
				const d = Object.getOwnPropertyDescriptor(e, k);
				if (d) {
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: () => e[k]
					});
				}
			}
		} }
	}
	return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

var react = {exports: {}};

var react_production_min = {};

/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7=Symbol.for("react.element"),n$7=Symbol.for("react.portal"),p$8=Symbol.for("react.fragment"),q$7=Symbol.for("react.strict_mode"),r$7=Symbol.for("react.profiler"),t$7=Symbol.for("react.provider"),u$b=Symbol.for("react.context"),v$6=Symbol.for("react.forward_ref"),w$7=Symbol.for("react.suspense"),x$7=Symbol.for("react.memo"),y$9=Symbol.for("react.lazy"),z$6=Symbol.iterator;function A$7(a){if(null===a||"object"!==typeof a)return null;a=z$6&&a[z$6]||a["@@iterator"];return "function"===typeof a?a:null}
var B$5={isMounted:function(){return !1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$7=Object.assign,D$5={};function E$5(a,b,e){this.props=a;this.context=b;this.refs=D$5;this.updater=e||B$5;}E$5.prototype.isReactComponent={};
E$5.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState");};E$5.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F$7(){}F$7.prototype=E$5.prototype;function G$5(a,b,e){this.props=a;this.context=b;this.refs=D$5;this.updater=e||B$5;}var H$8=G$5.prototype=new F$7;
H$8.constructor=G$5;C$7(H$8,E$5.prototype);H$8.isPureReactComponent=!0;var I$6=Array.isArray,J=Object.prototype.hasOwnProperty,K$5={current:null},L$6={key:!0,ref:!0,__self:!0,__source:!0};
function M$6(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L$6.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l$7,type:a,key:k,ref:h,props:c,_owner:K$5.current}}
function N$4(a,b){return {$$typeof:l$7,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O$5(a){return "object"===typeof a&&null!==a&&a.$$typeof===l$7}function escape(a){var b={"=":"=0",":":"=2"};return "$"+a.replace(/[=:]/g,function(a){return b[a]})}var P$8=/\/+/g;function Q$2(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R$5(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l$7:case n$7:h=!0;}}if(h)return h=a,c=c(h),a=""===d?"."+Q$2(h,0):d,I$6(c)?(e="",null!=a&&(e=a.replace(P$8,"$&/")+"/"),R$5(c,b,e,"",function(a){return a})):null!=c&&(O$5(c)&&(c=N$4(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P$8,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I$6(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q$2(k,g);h+=R$5(k,b,e,f,c);}else if(f=A$7(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q$2(k,g++),h+=R$5(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S$7(a,b,e){if(null==a)return a;var d=[],c=0;R$5(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T$8(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}
var U$5={current:null},V$4={transition:null},W$2={ReactCurrentDispatcher:U$5,ReactCurrentBatchConfig:V$4,ReactCurrentOwner:K$5};function X$3(){throw Error("act(...) is not supported in production builds of React.");}
react_production_min.Children={map:S$7,forEach:function(a,b,e){S$7(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S$7(a,function(){b++;});return b},toArray:function(a){return S$7(a,function(a){return a})||[]},only:function(a){if(!O$5(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E$5;react_production_min.Fragment=p$8;react_production_min.Profiler=r$7;react_production_min.PureComponent=G$5;react_production_min.StrictMode=q$7;react_production_min.Suspense=w$7;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$2;react_production_min.act=X$3;
react_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C$7({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K$5.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L$6.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l$7,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u$b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t$7,_context:a};return a.Consumer=a};react_production_min.createElement=M$6;react_production_min.createFactory=function(a){var b=M$6.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};
react_production_min.forwardRef=function(a){return {$$typeof:v$6,render:a}};react_production_min.isValidElement=O$5;react_production_min.lazy=function(a){return {$$typeof:y$9,_payload:{_status:-1,_result:a},_init:T$8}};react_production_min.memo=function(a,b){return {$$typeof:x$7,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V$4.transition;V$4.transition={};try{a();}finally{V$4.transition=b;}};react_production_min.unstable_act=X$3;react_production_min.useCallback=function(a,b){return U$5.current.useCallback(a,b)};react_production_min.useContext=function(a){return U$5.current.useContext(a)};
react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U$5.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U$5.current.useEffect(a,b)};react_production_min.useId=function(){return U$5.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U$5.current.useImperativeHandle(a,b,e)};react_production_min.useInsertionEffect=function(a,b){return U$5.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U$5.current.useLayoutEffect(a,b)};
react_production_min.useMemo=function(a,b){return U$5.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U$5.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U$5.current.useRef(a)};react_production_min.useState=function(a){return U$5.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U$5.current.useSyncExternalStore(a,b,e)};react_production_min.useTransition=function(){return U$5.current.useTransition()};react_production_min.version="18.3.1";

{
  react.exports = react_production_min;
}

var reactExports = react.exports;
const React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

const React$1 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: React
}, [reactExports]);

/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$b=reactExports,k$5=Symbol.for("react.element"),l$6=Symbol.for("react.fragment"),m$9=Object.prototype.hasOwnProperty,n$6=f$b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$7={key:!0,ref:!0,__self:!0,__source:!0};
function q$6(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m$9.call(a,b)&&!p$7.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:k$5,type:c,key:e,ref:h,props:d,_owner:n$6.current}}reactJsxRuntime_production_min.Fragment=l$6;reactJsxRuntime_production_min.jsx=q$6;reactJsxRuntime_production_min.jsxs=q$6;

{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}

var jsxRuntimeExports = jsxRuntime.exports;

var client = {};

var reactDom = {exports: {}};

var reactDom_production_min = {};

var scheduler = {exports: {}};

var scheduler_production_min = {};

/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (exports) {
function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
	function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()};}else {var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q};}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
	"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t);}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else {var b=h(t);null!==b&&K(H,b.startTime-a);}}
	function J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b);}else k(r);v=h(r);}if(null!==v)var w=!0;else {var m=h(t);null!==m&&K(H,m.startTime-b);w=!1;}return w}finally{v=null,y=c,z=!1;}}var N=!1,O=null,L=-1,P=5,Q=-1;
	function M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a);}finally{b?S():(N=!1,O=null);}}else N=!1;}var S;if("function"===typeof F)S=function(){F(R);};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null);};}else S=function(){D(R,0);};function I(a){O=a;N||(N=!0,S());}function K(a,b){L=D(function(){a(exports.unstable_now());},b);}
	exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null;};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J));};
	exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5;};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y;}var c=y;y=b;try{return a()}finally{y=c;}};exports.unstable_pauseExecution=function(){};
	exports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=y;y=a;try{return b()}finally{y=c;}};
	exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3;}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};
	exports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c;}}}; 
} (scheduler_production_min));

{
  scheduler.exports = scheduler_production_min;
}

var schedulerExports = scheduler.exports;

/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa=reactExports,ca=schedulerExports;function p$6(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b);}
function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a]);}
var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
{},ma={};function oa(a){if(ja.call(ma,a))return !0;if(ja.call(la,a))return !1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return !1}function pa(a,b,c,d){if(null!==c&&0===c.type)return !1;switch(typeof b){case "function":case "symbol":return !0;case "boolean":if(d)return !1;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return !1}}
function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return !0;if(d)return !1;if(null!==c)switch(c.type){case 3:return !b;case 4:return !1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return !1}function v$5(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g;}var z$5={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z$5[a]=new v$5(a,0,!1,a,null,!1,!1);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z$5[b]=new v$5(b,1,!1,a[1],null,!1,!1);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z$5[a]=new v$5(a,2,!1,a.toLowerCase(),null,!1,!1);});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z$5[a]=new v$5(a,2,!1,a,null,!1,!1);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z$5[a]=new v$5(a,3,!1,a.toLowerCase(),null,!1,!1);});
["checked","multiple","muted","selected"].forEach(function(a){z$5[a]=new v$5(a,3,!0,a,null,!1,!1);});["capture","download"].forEach(function(a){z$5[a]=new v$5(a,4,!1,a,null,!1,!1);});["cols","rows","size","span"].forEach(function(a){z$5[a]=new v$5(a,6,!1,a,null,!1,!1);});["rowSpan","start"].forEach(function(a){z$5[a]=new v$5(a,5,!1,a.toLowerCase(),null,!1,!1);});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
sa);z$5[b]=new v$5(b,1,!1,a,null,!1,!1);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z$5[b]=new v$5(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z$5[b]=new v$5(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1);});["tabIndex","crossOrigin"].forEach(function(a){z$5[a]=new v$5(a,1,!1,a.toLowerCase(),null,!1,!1);});
z$5.xlinkHref=new v$5("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z$5[a]=new v$5(a,1,!1,a.toLowerCase(),null,!0,!0);});
function ta(a,b,c,d){var e=z$5.hasOwnProperty(b)?z$5[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)));}
var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");var Ia=Symbol.for("react.offscreen");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return "function"===typeof a?a:null}var A$6=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||"";}return "\n"+La+a}var Na=!1;
function Oa(a,b){if(!a||Na)return "";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[]);}catch(l){var d=l;}Reflect.construct(a,[],b);}else {try{b.call();}catch(l){d=l;}a.call(b.prototype);}else {try{throw Error();}catch(l){d=l;}a();}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c;}return (a=a?a.displayName||a.name:"")?Ma(a):""}
function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return ""}}
function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return "Fragment";case wa:return "Portal";case Aa:return "Profiler";case za:return "StrictMode";case Ea:return "Suspense";case Fa:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return (a.displayName||"Context")+".Consumer";case Ba:return (a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
function Ra(a){var b=a.type;switch(a.tag){case 24:return "Cache";case 9:return (b.displayName||"Context")+".Consumer";case 10:return (b._context.displayName||"Context")+".Provider";case 18:return "DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return "Fragment";case 5:return b;case 4:return "Portal";case 3:return "Root";case 6:return "Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return "Offscreen";
case 12:return "Profiler";case 21:return "Scope";case 13:return "Suspense";case 19:return "SuspenseList";case 25:return "TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return ""}}
function Ta(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
null;delete a[b];}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a));}function Wa(a){if(!a)return !1;var b=a._valueTracker;if(!b)return !0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return A$6({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,!1);}
function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}var eb=Array.isArray;
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0);}else {c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=!0);}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p$6(91));return A$6({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p$6(92));if(eb(c)){if(1<c.length)throw Error(p$6(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:Sa(c)};}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}function kb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}
function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var mb,nb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else {mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,
zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a];});});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var tb=A$6({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p$6(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p$6(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p$6(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p$6(62));}}
function vb(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return !1;default:return !0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p$6(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b));}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a;}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a]);}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb();}}
function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1;}if(a)return null;if(c&&"function"!==
typeof c)throw Error(p$6(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0;}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb);}catch(a){Lb=!1;}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a;}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments);}
function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null;}else throw Error(p$6(198));Qb||(Qb=!0,Rb=l);}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p$6(188));}
function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p$6(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling;}throw Error(p$6(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(p$6(189));}}if(c.alternate!==d)throw Error(p$6(190));}if(3!==c.tag)throw Error(p$6(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling;}return null}
var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B$4=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128));}catch(b){}}
var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)));}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return -1;case 134217728:case 268435456:case 536870912:case 1073741824:return -1;default:return -1}}
function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b);}else k<=b&&(a.expiredLanes|=h);f&=~h;}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c;}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f;}}
function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e;}}var C$6=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId);}}
function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),!0;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),!0;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return !0;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return !1}
function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c);});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}
function Xc(a){if(null!==a.blockedOn)return !1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null;}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift();}return !0}function Zc(a,b,c){Xc(a)&&c.delete(b);}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc);}
function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)));}
function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift();}var cd=ua.ReactCurrentBatchConfig,dd=!0;
function ed(a,b,c,d){var e=C$6,f=cd.transition;cd.transition=null;try{C$6=1,fd(a,b,c,d);}finally{C$6=e,cd.transition=f;}}function gd(a,b,c,d){var e=C$6,f=cd.transition;cd.transition=null;try{C$6=4,fd(a,b,c,d);}finally{C$6=e,cd.transition=f;}}
function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id$2,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id$2,c);if(f===e)break;e=f;}null!==e&&d.stopPropagation();}else hd(a,b,d,null,c);}}var id$2=null;
function Yc(a,b,c,d){id$2=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null;}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null;}else b!==a&&(a=null);id$2=a;return null}
function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return !0}function qd(){return !1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A$6(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd);},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A$6({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A$6({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return "movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A$6({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A$6({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A$6({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A$6({},sd,{clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A$6({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=A$6({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return "keypress"===a.type?od(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A$6({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A$6({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A$6({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A$6({},Ad,{deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be$1=null;ia&&"documentMode"in document&&(be$1=document.documentMode);var ce$1=ia&&"TextEvent"in window&&!be$1,de=ia&&(!ae||be$1&&8<be$1&&11>=be$1),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return -1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return !0;default:return !1}}function he(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return "compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe$1(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}));}var pe$1=null,qe=null;function re(a){se(a,0);}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(ia){var xe$1;if(ia){var ye$1="oninput"in document;if(!ye$1){var ze$1=document.createElement("div");ze$1.setAttribute("oninput","return;");ye$1="function"===typeof ze$1.oninput;}xe$1=ye$1;}else xe$1=!1;we=xe$1&&(!document.documentMode||9<document.documentMode);}function Ae(){pe$1&&(pe$1.detachEvent("onpropertychange",Be),qe=pe$1=null);}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b);}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe$1=b,qe=c,pe$1.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae();}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe$1(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
function Ie(a,b){if(He(a,b))return !0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return !1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return !1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return !1}return !0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Je(c);}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Me$1(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=!1;}if(c)a=b.contentWindow;else break;b=Xa(a.document);}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
function Oe(a){var b=Me$1(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)));}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top;}}
var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe$1=null,Re$1=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe$1||Qe$1!==Xa(d)||(d=Qe$1,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe$1(Re$1,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe$1)));}
function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye$1={};
ia&&(Ye$1=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze$1(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye$1)return Xe[a]=b[c];return a}var $e=Ze$1("animationend"),af=Ze$1("animationiteration"),bf=Ze$1("animationstart"),cf=Ze$1("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a,b){df.set(a,b);fa(b,[a]);}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf);}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null;}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}
function D$4(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,!1),c.add(d));}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b);}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a));});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf("selectionchange",!1,b));}}
function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd;}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1);}
function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return;}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode;}}d=d.return;}Jb(function(){var d=f,e=xb(c),g=[];
a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td;}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return;}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}));}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null;}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x);}t=null;}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0);}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe$1;else {na=De;var xa=Ce;}else (k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
xa.controlled&&"number"===h.type&&cb(h,"number",h.value);}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe$1=xa,Re$1=d,Se=null;break;case "focusout":Se=Re$1=Qe$1=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e);}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0;}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),xa=oe$1(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce$1?je(a,c):ke(a,c))d=oe$1(d,"onBeforeInput"),
0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a);}se(g,b);});}function tf(a,b,c){return {instance:a,listener:b,currentTarget:c}}function oe$1(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return;}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return;}0!==g.length&&a.push({event:b,listeners:g});}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return ("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p$6(425));}function Bf(){}
var Cf=null,Df=null;function Ef(a,b){return "textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;});}
function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--;}else "$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e;}while(c);bd(b);}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--;}else "/$"===c&&b++;}a=a.previousSibling;}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a);}return b}a=c;c=a.parentNode;}return null}function Cb(a){a=a[Of]||a[uf];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p$6(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return {current:a}}
function E$4(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--);}function G$4(a,b){Tf++;Sf[Tf]=a.current;a.current=b;}var Vf={},H$7=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E$4(Wf);E$4(H$7);}function ag(a,b,c){if(H$7.current!==Vf)throw Error(p$6(168));G$4(H$7,b);G$4(Wf,c);}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p$6(108,Ra(a)||"Unknown",e));return A$6({},c,d)}
function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H$7.current;G$4(H$7,a);G$4(Wf,Wf.current);return !0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p$6(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E$4(Wf),E$4(H$7),G$4(H$7,a)):E$4(Wf);G$4(Wf,c);}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a);}function ig(a){fg=!0;hg(a);}
function jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C$6;try{var c=eg;for(C$6=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1;}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C$6=b,gg=!1;}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b;}
function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a;}else rg=1<<f|c<<e|d,sg=a;}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0));}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null;}var xg=null,yg=null,I$5=!1,zg=null;
function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c);}
function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
null,!0):!1;default:return !1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I$5){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p$6(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I$5=!1,xg=a);}}else {if(Dg(a))throw Error(p$6(418));a.flags=a.flags&-4097|2;I$5=!1;xg=a;}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a;}
function Gg(a){if(a!==xg)return !1;if(!I$5)return Fg(a),I$5=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p$6(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling);}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p$6(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--;}else "$"!==c&&"$!"!==c&&"$?"!==c||b++;}a=a.nextSibling;}yg=
null;}}else yg=xg?Lf(a.stateNode.nextSibling):null;return !0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling);}function Ig(){yg=xg=null;I$5=!1;}function Jg(a){null===zg?zg=[a]:zg.push(a);}var Kg=ua.ReactCurrentBatchConfig;
function Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p$6(309));var d=c.stateNode;}if(!d)throw Error(p$6(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a;};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p$6(284));if(!c._owner)throw Error(p$6(290,a));}return a}
function Mg(a,b){a=Object.prototype.toString.call(b);throw Error(p$6(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng(a){var b=a._init;return b(a._payload)}
function Og(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c);}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&Ng(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=Rg(b.type,b.key,b.props,null,a.mode,c),
c.ref=Lg(a,null,b),c.return=a,c;case wa:return b=Sg(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Tg(b,a.mode,c,null),b.return=a,b;Mg(a,b);}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);Mg(a,c);}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg(b,d);}return null}
function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x;}if(w===h.length)return c(e,u),I$5&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I$5&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I$5&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p$6(150));h=l.call(h);if(null==h)throw Error(p$6(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x;}if(n.done)return c(e,
m),I$5&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I$5&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I$5&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&Ng(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling;}f.type===ya?(d=Tg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h);}return g(a);case wa:a:{for(l=f.key;null!==
d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=d.sibling;}d=Sg(f,a.mode,h);d.return=a;a=d;}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);Mg(a,f);}return "string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
(c(a,d),d=Qg(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null;}function ah(a){var b=Wg.current;E$4(Wg);a._currentValue=b;}function bh(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return;}}
function ch(a,b){Xg=a;Zg=Yg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh=!0),a.firstContext=null);}function eh(a){var b=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg){if(null===Xg)throw Error(p$6(308));Yg=a;Xg.dependencies={lanes:0,firstContext:a};}else Yg=Yg.next=a;return b}var fh=null;function gh(a){null===fh?fh=[a]:fh.push(a);}
function hh(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih(a,d)}function ih(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh=!1;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null};}
function lh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects});}function mh(a,b){return {eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
function nh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K$4&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih(a,c)}e=d.interleaved;null===e?(b.next=b,gh(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih(a,c)}function oh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c);}}
function ph(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next;}while(null!==c);null===f?e=f=b:f=f.next=b;}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b;}
function qh(a,b,c,d){var e=a.updateQueue;jh=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k));}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A$6({},q,r);break a;case 2:jh=!0;}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h));}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null;}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh|=g;a.lanes=g;a.memoizedState=q;}}
function sh(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p$6(191,e));e.call(d);}}}var th={},uh=Uf(th),vh$1=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p$6(174));return a}
function yh(a,b){G$4(wh,b);G$4(vh$1,a);G$4(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a);}E$4(uh);G$4(uh,b);}function zh(){E$4(uh);E$4(vh$1);E$4(wh);}function Ah(a){xh(wh.current);var b=xh(uh.current);var c=lb(b,a.type);b!==c&&(G$4(vh$1,a),G$4(uh,c));}function Bh(a){vh$1.current===a&&(E$4(uh),E$4(vh$1));}var L$5=Uf(0);
function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}var Dh=[];
function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0;}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M$5=null,N$3=null,O$4=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P$7(){throw Error(p$6(321));}function Mh(a,b){if(null===b)return !1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return !1;return !0}
function Nh(a,b,c,d,e,f){Hh=f;M$5=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=!1;Kh=0;if(25<=f)throw Error(p$6(301));f+=1;O$4=N$3=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e);}while(Jh)}Fh.current=Rh;b=null!==N$3&&null!==N$3.next;Hh=0;O$4=N$3=M$5=null;Ih=!1;if(b)throw Error(p$6(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}
function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O$4?M$5.memoizedState=O$4=a:O$4=O$4.next=a;return O$4}function Uh(){if(null===N$3){var a=M$5.alternate;a=null!==a?a.memoizedState:null;}else a=N$3.next;var b=null===O$4?M$5.memoizedState:O$4.next;if(null!==b)O$4=b,N$3=a;else {if(null===a)throw Error(p$6(310));N$3=a;a={memoizedState:N$3.memoizedState,baseState:N$3.baseState,baseQueue:N$3.baseQueue,queue:N$3.queue,next:null};null===O$4?M$5.memoizedState=O$4=a:O$4=O$4.next=a;}return O$4}
function Vh(a,b){return "function"===typeof b?b(a):b}
function Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p$6(311));c.lastRenderedReducer=a;var d=N$3,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else {var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M$5.lanes|=m;rh|=m;}l=l.next;}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(dh=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d;}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M$5.lanes|=f,rh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return [b.memoizedState,c.dispatch]}
function Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p$6(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(dh=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}function Yh(){}
function Zh(a,b){var c=M$5,d=Uh(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,dh=!0);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O$4&&O$4.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===Q$1)throw Error(p$6(349));0!==(Hh&30)||di(c,b,e);}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M$5.updateQueue;null===b?(b={lastEffect:null,stores:null},M$5.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a));}
function ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&fi(a);}function ai(a,b,c){return c(function(){ei(b)&&fi(a);})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return !He(a,c)}catch(d){return !0}}function fi(a){var b=ih(a,1);null!==b&&gi(b,a,1,-1);}
function hi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii.bind(null,M$5,a);return [b.memoizedState,a]}
function bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M$5.updateQueue;null===b?(b={lastEffect:null,stores:null},M$5.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji(){return Uh().memoizedState}function ki(a,b,c,d){var e=Th();M$5.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d);}
function li(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==N$3){var g=N$3.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}M$5.flags|=a;e.memoizedState=bi(1|b,c,f,d);}function mi(a,b){return ki(8390656,8,a,b)}function $h(a,b){return li(2048,8,a,b)}function ni(a,b){return li(4,2,a,b)}function oi(a,b){return li(4,4,a,b)}
function pi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function qi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li(4,4,pi.bind(null,b,a),c)}function ri(){}function si(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
function ti(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui(a,b,c){if(0===(Hh&21))return a.baseState&&(a.baseState=!1,dh=!0),a.memoizedState=c;He(c,b)||(c=yc(),M$5.lanes|=c,rh|=c,a.baseState=!0);return b}function vi(a,b){var c=C$6;C$6=0!==c&&4>c?c:4;a(!0);var d=Gh.transition;Gh.transition={};try{a(!1),b();}finally{C$6=c,Gh.transition=d;}}function wi(){return Uh().memoizedState}
function xi(a,b,c){var d=yi(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,c);else if(c=hh(a,b,c,d),null!==c){var e=R$4();gi(c,a,d,e);Bi(c,b,d);}}
function ii(a,b,c){var d=yi(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(b,e);else {var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,gh(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh(a,b,e,d);null!==c&&(e=R$4(),gi(c,a,d,e),Bi(c,b,d));}}
function zi(a){var b=a.alternate;return a===M$5||null!==b&&b===M$5}function Ai(a,b){Jh=Ih=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}function Bi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c);}}
var Rh={readContext:eh,useCallback:P$7,useContext:P$7,useEffect:P$7,useImperativeHandle:P$7,useInsertionEffect:P$7,useLayoutEffect:P$7,useMemo:P$7,useReducer:P$7,useRef:P$7,useState:P$7,useDebugValue:P$7,useDeferredValue:P$7,useTransition:P$7,useMutableSource:P$7,useSyncExternalStore:P$7,useId:P$7,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki(4194308,
4,pi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi.bind(null,M$5,a);return [d.memoizedState,a]},useRef:function(a){var b=
Th();a={current:a};return b.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(!1),b=a[0];a=vi.bind(null,a[1]);Th().memoizedState=a;return [b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M$5,e=Th();if(I$5){if(void 0===c)throw Error(p$6(407));c=c();}else {c=b();if(null===Q$1)throw Error(p$6(349));0!==(Hh&30)||di(d,b,c);}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi(ai.bind(null,d,
f,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=Q$1.identifierPrefix;if(I$5){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":";}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},
useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return ui(b,N$3.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return null===
N$3?b.memoizedState=a:ui(b,N$3.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(a,b){if(a&&a.defaultProps){b=A$6({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A$6({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c);}
var Ei={isMounted:function(a){return (a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R$4(),e=yi(a),f=mh(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e));},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R$4(),e=yi(a),f=mh(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e));},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R$4(),d=
yi(a),e=mh(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh(a,e,d);null!==b&&(gi(b,a,d,c),oh(b,a,d));}};function Fi(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}
function Gi(a,b,c){var d=!1,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=eh(f):(e=Zf(b)?Xf:H$7.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Hi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei.enqueueReplaceState(b,b.state,null);}
function Ii(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh(f):(f=Zf(b)?Xf:H$7.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei.enqueueReplaceState(e,e.state,null),qh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308);}function Ji(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c;}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack;}return {value:a,source:b,stack:e,digest:null}}
function Ki(a,b,c){return {value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li(a,b){try{console.error(b.value);}catch(c){setTimeout(function(){throw c;});}}var Mi="function"===typeof WeakMap?WeakMap:Map;function Ni(a,b,c){c=mh(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi||(Oi=!0,Pi=d);Li(a,b);};return c}
function Qi(a,b,c){c=mh(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li(a,b);};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li(a,b);"function"!==typeof d&&(null===Ri?Ri=new Set([this]):Ri.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
function Si(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi;var e=new Set;d.set(b,e);}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti.bind(null,a,b,c),b.then(a,a));}function Ui(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return;}while(null!==a);return null}
function Vi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh(-1,1),b.tag=2,nh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug(b,a.child,c,d);}
function Yi(a,b,c,d,e){c=c.render;var f=b.ref;ch(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I$5&&c&&vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}
function $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=Pg(f,d);a.ref=b.ref;a.return=b;return b.child=a}
function bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(dh=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh=!0);else return b.lanes=a.lanes,Zi(a,b,e)}return cj(a,b,c,d,e)}
function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G$4(ej,fj),fj|=c;else {if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G$4(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G$4(ej,fj);fj|=d;}else null!==
f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G$4(ej,fj),fj|=d;Xi(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152;}function cj(a,b,c,d,e){var f=Zf(c)?Xf:H$7.current;f=Yf(b,f);ch(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I$5&&d&&vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}
function hj(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b);}else f=!1;ch(b,e);if(null===b.stateNode)ij(a,b),Gi(b,c,d),Ii(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh(l):(l=Zf(c)?Xf:H$7.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
(h!==d||k!==l)&&Hi(b,g,d,l);jh=!1;var r=b.memoizedState;g.state=r;qh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh?("function"===typeof m&&(Di(b,c,m,d),k=b.memoizedState),(h=jh||Fi(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1);}else {g=b.stateNode;lh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh(k):(k=Zf(c)?Xf:H$7.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi(b,g,d,k);jh=!1;r=b.memoizedState;g.state=r;qh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh?("function"===typeof y&&(Di(b,c,y,d),n=b.memoizedState),(l=jh||Fi(b,c,l,d,r,n,k)||!1)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1);}return jj(a,b,c,d,f,e)}
function jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug(b,a.child,null,f),b.child=Ug(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);yh(a,b.containerInfo);}
function lj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Xi(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return {baseLanes:a,cachePool:null,transitions:null}}
function oj(a,b,c){var d=b.pendingProps,e=L$5.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G$4(L$5,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
g):f=pj(g,d,0,null),a=Tg(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg(h,f):(f=Tg(f,g,c,null),f.flags|=2);f.return=
b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
function qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg(d);Ug(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
function rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki(Error(p$6(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
if(d)var h=d.dgst;d=h;f=Error(p$6(419));d=Ki(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh||h){d=Q$1;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0;}e=0!==(e&(d.suspendedLanes|g))?0:e;
0!==e&&e!==f.retryLane&&(f.retryLane=e,ih(a,e),gi(d,a,e,-1));}tj();d=Ki(Error(p$6(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I$5=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh(a.return,b,c);}
function wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e);}
function xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=L$5.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else {if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}G$4(L$5,d);if(0===(b.mode&1))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,!1,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}wj(b,!0,c,null,f);break;case "together":wj(b,!1,null,null,void 0);break;default:b.memoizedState=null;}return b.child}
function ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);}function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p$6(153));if(null!==b.child){a=b.child;c=Pg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}
function yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G$4(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G$4(L$5,L$5.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G$4(L$5,L$5.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}G$4(L$5,L$5.current&1);break;case 19:d=0!==(c&
b.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G$4(L$5,L$5.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}var zj,Aj,Bj,Cj;
zj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};Aj=function(){};
Bj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A$6({},e,{value:void 0});d=A$6({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf);}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
(c||(c={}),c[g]="");}else "dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g]);}else c||(f||(f=[]),f.push(l,
c)),c=k;else "dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D$4("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k));}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4;}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4);};
function Dj(a,b){if(!I$5)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
function S$6(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
function Ej(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S$6(b),null;case 1:return Zf(b.type)&&$f(),S$6(b),null;case 3:d=b.stateNode;zh();E$4(Wf);E$4(H$7);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S$6(b);return null;case 5:Bh(b);var e=xh(wh.current);
c=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else {if(!d){if(null===b.stateNode)throw Error(p$6(166));S$6(b);return null}a=xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D$4("cancel",d);D$4("close",d);break;case "iframe":case "object":case "embed":D$4("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D$4(lf[e],d);break;case "source":D$4("error",d);break;case "img":case "image":case "link":D$4("error",
d);D$4("load",d);break;case "details":D$4("toggle",d);break;case "input":Za(d,f);D$4("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D$4("invalid",d);break;case "textarea":hb(d,f),D$4("invalid",d);}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,
h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D$4("scroll",d);}switch(c){case "input":Va(d);db(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf);}d=e;b.updateQueue=d;null!==d&&(b.flags|=4);}else {g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;zj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D$4("cancel",a);D$4("close",a);e=d;break;case "iframe":case "object":case "embed":D$4("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D$4(lf[e],a);e=d;break;case "source":D$4("error",a);e=d;break;case "img":case "image":case "link":D$4("error",
a);D$4("load",a);e=d;break;case "details":D$4("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D$4("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A$6({},d,{value:void 0});D$4("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D$4("invalid",a);break;default:e=d;}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D$4("scroll",a):null!=k&&ta(a,f,k,g));}switch(c){case "input":Va(a);db(a,d,!1);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
!0);break;default:"function"===typeof e.onClick&&(a.onclick=Bf);}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=!0;break a;default:d=!1;}}d&&(b.flags|=4);}null!==b.ref&&(b.flags|=512,b.flags|=2097152);}S$6(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(p$6(166));c=xh(wh.current);xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1));}f&&(b.flags|=4);}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d;}S$6(b);return null;case 13:E$4(L$5);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I$5&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
a){if(!f)throw Error(p$6(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p$6(317));f[Of]=b;}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S$6(b);f=!1;}else null!==zg&&(Fj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L$5.current&1)?0===T$7&&(T$7=3):tj()));null!==b.updateQueue&&(b.flags|=4);S$6(b);return null;case 4:return zh(),
Aj(a,b),null===a&&sf(b.stateNode.containerInfo),S$6(b),null;case 10:return ah(b.type._context),S$6(b),null;case 17:return Zf(b.type)&&$f(),S$6(b),null;case 19:E$4(L$5);f=b.memoizedState;if(null===f)return S$6(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,!1);else {if(0!==T$7||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G$4(L$5,L$5.current&1|2);return b.child}a=
a.sibling;}null!==f.tail&&B$4()>Gj&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304);}else {if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,!0),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I$5)return S$6(b),null}else 2*B$4()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=!0,Dj(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g);}if(null!==f.tail)return b=f.tail,f.rendering=
b,f.tail=b.sibling,f.renderingStartTime=B$4(),b.sibling=null,c=L$5.current,G$4(L$5,d?c&1|2:c&1),b;S$6(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S$6(b),b.subtreeFlags&6&&(b.flags|=8192)):S$6(b),null;case 24:return null;case 25:return null}throw Error(p$6(156,b.tag));}
function Ij(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),E$4(Wf),E$4(H$7),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:E$4(L$5);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p$6(340));Ig();}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E$4(L$5),null;case 4:return zh(),null;case 10:return ah(b.type._context),null;case 22:case 23:return Hj(),
null;case 24:return null;default:return null}}var Jj=!1,U$4=!1,Kj="function"===typeof WeakSet?WeakSet:Set,V$3=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null);}catch(d){W$1(a,b,d);}else c.current=null;}function Mj(a,b,c){try{c();}catch(d){W$1(a,b,d);}}var Nj=!1;
function Oj(a,b){Cf=dd;a=Me$1();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType;}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y;}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode;}q=y;}c=-1===h||-1===k?null:{start:h,end:k};}else c=null;}c=c||{start:0,end:0};}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V$3=b;null!==V$3;)if(b=V$3,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V$3=a;else for(;null!==V$3;){b=V$3;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w;}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$6(163));}}catch(F){W$1(b,b.return,F);}a=b.sibling;if(null!==a){a.return=b.return;V$3=a;break}V$3=b.return;}n=Nj;Nj=!1;return n}
function Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f);}e=e.next;}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c;}"function"===typeof b?b(a):b.current=a;}}
function Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null;}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}
function Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return;}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child;}if(!(a.flags&2))return a.stateNode}}
function Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling;}
function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling;}var X$2=null,Xj=!1;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling;}
function Zj(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c);}catch(h){}switch(c.tag){case 5:U$4||Lj(c,b);case 6:var d=X$2,e=Xj;X$2=null;Yj(a,b,c);X$2=d;Xj=e;null!==X$2&&(Xj?(a=X$2,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X$2.removeChild(c.stateNode));break;case 18:null!==X$2&&(Xj?(a=X$2,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X$2,c.stateNode));break;case 4:d=X$2;e=Xj;X$2=c.stateNode.containerInfo;Xj=!0;
Yj(a,b,c);X$2=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U$4&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next;}while(e!==d)}Yj(a,b,c);break;case 1:if(!U$4&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount();}catch(h){W$1(c,b,h);}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U$4=(d=U$4)||null!==
c.memoizedState,Yj(a,b,c),U$4=d):Yj(a,b,c);break;default:Yj(a,b,c);}}function ak(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
function ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X$2=h.stateNode;Xj=!1;break a;case 3:X$2=h.stateNode.containerInfo;Xj=!0;break a;case 4:X$2=h.stateNode.containerInfo;Xj=!0;break a}h=h.return;}if(null===X$2)throw Error(p$6(160));Zj(f,g,e);X$2=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null;}catch(l){W$1(e,b,l);}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling;}
function dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a);}catch(t){W$1(a,a.return,t);}try{Pj(5,a,a.return);}catch(t){W$1(a,a.return,t);}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"");}catch(t){W$1(a,a.return,t);}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l);}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1));}e[Pf]=f;}catch(t){W$1(a,a.return,t);}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p$6(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f;}catch(t){W$1(a,a.return,t);}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo);}catch(t){W$1(a,a.return,t);}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
null!==e.alternate&&null!==e.alternate.memoizedState||(fk=B$4()));d&4&&ak(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U$4=(l=U$4)||m,ck(b,a),U$4=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V$3=a,m=a.child;null!==m;){for(q=V$3=m;null!==V$3;){r=V$3;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount();}catch(t){W$1(d,c,t);}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V$3=y):gk(q);}m=m.sibling;}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
rb("display",g));}catch(t){W$1(a,a.return,t);}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps;}catch(t){W$1(a,a.return,t);}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return;}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling;}}break;case 19:ck(b,a);ek(a);d&4&&ak(a);break;case 21:break;default:ck(b,
a),ek(a);}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return;}throw Error(p$6(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p$6(161));}}catch(k){W$1(a,a.return,k);}a.flags&=-3;}b&4096&&(a.flags&=-4097);}function hk(a,b,c){V$3=a;ik(a);}
function ik(a,b,c){for(var d=0!==(a.mode&1);null!==V$3;){var e=V$3,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U$4;h=Jj;var l=U$4;Jj=g;if((U$4=k)&&!l)for(V$3=e;null!==V$3;)g=V$3,k=g.child,22===g.tag&&null!==g.memoizedState?jk(e):null!==k?(k.return=g,V$3=k):jk(e);for(;null!==f;)V$3=f,ik(f),f=f.sibling;V$3=e;Jj=h;U$4=l;}kk(a);}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V$3=f):kk(a);}}
function kk(a){for(;null!==V$3;){var b=V$3;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U$4||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U$4)if(null===c)d.componentDidMount();else {var e=b.elementType===b.type?c.memoizedProps:Ci(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate);}var f=b.updateQueue;null!==f&&sh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
b.child.stateNode;break;case 1:c=b.child.stateNode;}sh(b,g,c);}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src);}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q);}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
default:throw Error(p$6(163));}U$4||b.flags&512&&Rj(b);}catch(r){W$1(b,b.return,r);}}if(b===a){V$3=null;break}c=b.sibling;if(null!==c){c.return=b.return;V$3=c;break}V$3=b.return;}}function gk(a){for(;null!==V$3;){var b=V$3;if(b===a){V$3=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V$3=c;break}V$3=b.return;}}
function jk(a){for(;null!==V$3;){var b=V$3;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b);}catch(k){W$1(b,c,k);}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount();}catch(k){W$1(b,e,k);}}var f=b.return;try{Rj(b);}catch(k){W$1(b,f,k);}break;case 5:var g=b.return;try{Rj(b);}catch(k){W$1(b,g,k);}}}catch(k){W$1(b,b.return,k);}if(b===a){V$3=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V$3=h;break}V$3=b.return;}}
var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K$4=0,Q$1=null,Y$1=null,Z$1=0,fj=0,ej=Uf(0),T$7=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R$4(){return 0!==(K$4&6)?B$4():-1!==Ak?Ak:Ak=B$4()}
function yi(a){if(0===(a.mode&1))return 1;if(0!==(K$4&2)&&0!==Z$1)return Z$1&-Z$1;if(null!==Kg.transition)return 0===Bk&&(Bk=yc()),Bk;a=C$6;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function gi(a,b,c,d){if(50<yk)throw yk=0,zk=null,Error(p$6(185));Ac(a,c,d);if(0===(K$4&2)||a!==Q$1)a===Q$1&&(0===(K$4&2)&&(qk|=c),4===T$7&&Ck(a,Z$1)),Dk(a,d),1===c&&0===K$4&&0===(b.mode&1)&&(Gj=B$4()+500,fg&&jg());}
function Dk(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===Q$1?Z$1:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){0===(K$4&6)&&jg();}),c=null;else {switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc;}c=Fk(c,Gk.bind(null,a));}a.callbackPriority=b;a.callbackNode=c;}}
function Gk(a,b){Ak=-1;Bk=0;if(0!==(K$4&6))throw Error(p$6(327));var c=a.callbackNode;if(Hk()&&a.callbackNode!==c)return null;var d=uc(a,a===Q$1?Z$1:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik(a,d);else {b=d;var e=K$4;K$4|=2;var f=Jk();if(Q$1!==a||Z$1!==b)uk=null,Gj=B$4()+500,Kk(a,b);do try{Lk();break}catch(h){Mk(a,h);}while(1);$g();mk.current=f;K$4=e;null!==Y$1?b=0:(Q$1=null,Z$1=0,b=T$7);}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Nk(a,e)));if(1===b)throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B$4()),c;if(6===b)Ck(a,d);
else {e=a.current.alternate;if(0===(d&30)&&!Ok(e)&&(b=Ik(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Nk(a,f))),1===b))throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B$4()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p$6(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B$4(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R$4();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===
d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f;}d=e;d=B$4()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p$6(329));}}}Dk(a,B$4());return a.callbackNode===c?Gk.bind(null,a):null}
function Nk(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk(a,b).flags|=256);a=Ik(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a);}
function Ok(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return !1}catch(g){return !1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else {if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return !0;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return !0}
function Ck(a,b){b&=~rk;b&=~qk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d;}}function Ek(a){if(0!==(K$4&6))throw Error(p$6(327));Hk();var b=uc(a,0);if(0===(b&1))return Dk(a,B$4()),null;var c=Ik(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Nk(a,d));}if(1===c)throw c=pk,Kk(a,0),Ck(a,b),Dk(a,B$4()),c;if(6===c)throw Error(p$6(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B$4());return null}
function Qk(a,b){var c=K$4;K$4|=1;try{return a(b)}finally{K$4=c,0===K$4&&(Gj=B$4()+500,fg&&jg());}}function Rk(a){null!==wk&&0===wk.tag&&0===(K$4&6)&&Hk();var b=K$4;K$4|=1;var c=ok.transition,d=C$6;try{if(ok.transition=null,C$6=1,a)return a()}finally{C$6=d,ok.transition=c,K$4=b,0===(K$4&6)&&jg();}}function Hj(){fj=ej.current;E$4(ej);}
function Kk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y$1)for(c=Y$1.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh();E$4(Wf);E$4(H$7);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:E$4(L$5);break;case 19:E$4(L$5);break;case 10:ah(d.type._context);break;case 22:case 23:Hj();}c=c.return;}Q$1=a;Y$1=a=Pg(a.current,null);Z$1=fj=b;T$7=0;pk=null;rk=qk=rh=0;tk=sk=null;if(null!==fh){for(b=
0;b<fh.length;b++)if(c=fh[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g;}c.pending=d;}fh=null;}return a}
function Mk(a,b){do{var c=Y$1;try{$g();Fh.current=Rh;if(Ih){for(var d=M$5.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next;}Ih=!1;}Hh=0;O$4=N$3=M$5=null;Jh=!1;Kh=0;nk.current=null;if(null===c||null===c.return){T$7=1;pk=b;Y$1=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z$1;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null);}var y=Ui(g);if(null!==y){y.flags&=-257;Vi(y,g,h,f,b);y.mode&1&&Si(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t;}else n.add(k);break a}else {if(0===(b&1)){Si(f,l,b);tj();break a}k=Error(p$6(426));}}else if(I$5&&h.mode&1){var J=Ui(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi(J,g,h,f,b);Jg(Ji(k,h));break a}}f=k=Ji(k,h);4!==T$7&&(T$7=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
b&=-b;f.lanes|=b;var x=Ni(f,k,b);ph(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri||!Ri.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi(f,h,b);ph(f,F);break a}}f=f.return;}while(null!==f)}Sk(c);}catch(na){b=na;Y$1===c&&null!==c&&(Y$1=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh;return null===a?Rh:a}
function tj(){if(0===T$7||3===T$7||2===T$7)T$7=4;null===Q$1||0===(rh&268435455)&&0===(qk&268435455)||Ck(Q$1,Z$1);}function Ik(a,b){var c=K$4;K$4|=2;var d=Jk();if(Q$1!==a||Z$1!==b)uk=null,Kk(a,b);do try{Tk();break}catch(e){Mk(a,e);}while(1);$g();K$4=c;mk.current=d;if(null!==Y$1)throw Error(p$6(261));Q$1=null;Z$1=0;return T$7}function Tk(){for(;null!==Y$1;)Uk(Y$1);}function Lk(){for(;null!==Y$1&&!cc();)Uk(Y$1);}function Uk(a){var b=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk(a):Y$1=b;nk.current=null;}
function Sk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y$1=c;return}}else {c=Ij(c,b);if(null!==c){c.flags&=32767;Y$1=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else {T$7=6;Y$1=null;return}}b=b.sibling;if(null!==b){Y$1=b;return}Y$1=b=a;}while(null!==b);0===T$7&&(T$7=5);}function Pk(a,b,c){var d=C$6,e=ok.transition;try{ok.transition=null,C$6=1,Wk(a,b,c,d);}finally{ok.transition=e,C$6=d;}return null}
function Wk(a,b,c,d){do Hk();while(null!==wk);if(0!==(K$4&6))throw Error(p$6(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p$6(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===Q$1&&(Y$1=Q$1=null,Z$1=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=!0,Fk(hc,function(){Hk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;
var g=C$6;C$6=1;var h=K$4;K$4|=4;nk.current=null;Oj(a,c);dk(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;hk(c);dc();K$4=h;C$6=g;ok.transition=f;}else a.current=c;vk&&(vk=!1,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri=null);mc(c.stateNode);Dk(a,B$4());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi)throw Oi=!1,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk();f=a.pendingLanes;0!==(f&1)?a===zk?yk++:(yk=0,zk=a):yk=0;jg();return null}
function Hk(){if(null!==wk){var a=Dc(xk),b=ok.transition,c=C$6;try{ok.transition=null;C$6=16>a?16:a;if(null===wk)var d=!1;else {a=wk;wk=null;xk=0;if(0!==(K$4&6))throw Error(p$6(331));var e=K$4;K$4|=4;for(V$3=a.current;null!==V$3;){var f=V$3,g=f.child;if(0!==(V$3.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V$3=l;null!==V$3;){var m=V$3;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f);}var q=m.child;if(null!==q)q.return=m,V$3=q;else for(;null!==V$3;){m=V$3;var r=m.sibling,y=m.return;Sj(m);if(m===
l){V$3=null;break}if(null!==r){r.return=y;V$3=r;break}V$3=y;}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J;}while(null!==t)}}V$3=f;}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V$3=g;else b:for(;null!==V$3;){f=V$3;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return);}var x=f.sibling;if(null!==x){x.return=f.return;V$3=x;break b}V$3=f.return;}}var w=a.current;for(V$3=w;null!==V$3;){g=V$3;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
u)u.return=g,V$3=u;else b:for(g=w;null!==V$3;){h=V$3;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h);}}catch(na){W$1(h,h.return,na);}if(h===g){V$3=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V$3=F;break b}V$3=h.return;}}K$4=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a);}catch(na){}d=!0;}return d}finally{C$6=c,ok.transition=b;}}return !1}function Xk(a,b,c){b=Ji(c,b);b=Ni(a,b,1);a=nh(a,b,1);b=R$4();null!==a&&(Ac(a,1,b),Dk(a,b));}
function W$1(a,b,c){if(3===a.tag)Xk(a,a,c);else for(;null!==b;){if(3===b.tag){Xk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri||!Ri.has(d))){a=Ji(c,a);a=Qi(b,a,1);b=nh(b,a,1);a=R$4();null!==b&&(Ac(b,1,a),Dk(b,a));break}}b=b.return;}}
function Ti(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R$4();a.pingedLanes|=a.suspendedLanes&c;Q$1===a&&(Z$1&c)===c&&(4===T$7||3===T$7&&(Z$1&130023424)===Z$1&&500>B$4()-fk?Kk(a,0):rk|=c);Dk(a,b);}function Yk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=R$4();a=ih(a,b);null!==a&&(Ac(a,b,c),Dk(a,c));}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk(a,c);}
function bk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p$6(314));}null!==d&&d.delete(b);Yk(a,c);}var Vk;
Vk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh=!0;else {if(0===(a.lanes&c)&&0===(b.flags&128))return dh=!1,yj(a,b,c);dh=0!==(a.flags&131072)?!0:!1;}else dh=!1,I$5&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf(b,H$7.current);ch(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
null,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei,b.stateNode=e,e._reactInternals=b,Ii(b,d,a,c),b=jj(null,b,d,!0,f,c)):(b.tag=0,I$5&&f&&vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk(d);a=Ci(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,Ci(d.type,a),c);break a}throw Error(p$6(306,
d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p$6(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh(a,b);qh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
f,b.memoizedState=f,b.flags&256){e=Ji(Error(p$6(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p$6(424)),b);b=lj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I$5=!0,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else {Ig();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c);}b=b.child;}return b;case 5:return Ah(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
gj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return oj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
g=e.value;G$4(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k;}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh(f.return,
c,b);h.lanes|=c;break}k=k.next;}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p$6(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh(g,c,b);g=f.sibling;}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return;}f=g;}Xi(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,d=b.pendingProps.children,ch(b,c),e=eh(e),d=d(e),b.flags|=1,Xi(a,b,d,c),
b.child;case 14:return d=b.type,e=Ci(d,b.pendingProps),e=Ci(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),ij(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,ch(b,c),Gi(b,d,e),Ii(b,d,e,c),jj(null,b,d,!0,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p$6(156,b.tag));};function Fk(a,b){return ac(a,b)}
function $k(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;}function Bg(a,b,c,d){return new $k(a,b,c,d)}function aj(a){a=a.prototype;return !(!a||!a.isReactComponent)}
function Zk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
function Pg(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Rg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Tg(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p$6(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function Qg(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
function Sg(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function al(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
null;}function bl(a,b,c,d,e,f,g,h,k){a=new al(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function dl(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p$6(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return;}while(null!==b);throw Error(p$6(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
function el(a,b,c,d,e,f,g,h,k){a=bl(c,d,!0,a,e,f,g,h,k);a.context=dl(null);c=a.current;d=R$4();e=yi(c);f=mh(d,e);f.callback=void 0!==b&&null!==b?b:null;nh(c,f,e);a.current.lanes=e;Ac(a,e,d);Dk(a,d);return a}function fl(a,b,c,d){var e=b.current,f=R$4(),g=yi(e);c=dl(c);null===b.context?b.context=c:b.pendingContext=c;b=mh(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh(e,b,g);null!==a&&(gi(a,e,g,f),oh(a,e,g));return g}
function gl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b;}}function il(a,b){hl(a,b);(a=a.alternate)&&hl(a,b);}function jl(){return null}var kl="function"===typeof reportError?reportError:function(a){console.error(a);};function ll(a){this._internalRoot=a;}
ml.prototype.render=ll.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p$6(409));fl(a,b,null,null);};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl(null,a,null,null);});b[uf]=null;}};function ml(a){this._internalRoot=a;}
ml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a);}};function nl(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}
function ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl(g);f.call(a);};}var g=el(b,d,a,0,null,!1,!1,"",pl);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl(k);h.call(a);};}var k=bl(a,0,!1,null,null,!1,!1,"",pl);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl(b,k,c,d);});return k}
function rl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl(g);h.call(a);};}fl(b,g,a,e);}else g=ql(c,b,a,e,d);return gl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Dk(b,B$4()),0===(K$4&6)&&(Gj=B$4()+500,jg()));}break;case 13:Rk(function(){var b=ih(a,1);if(null!==b){var c=R$4();gi(b,a,1,c);}}),il(a,1);}};
Fc=function(a){if(13===a.tag){var b=ih(a,134217728);if(null!==b){var c=R$4();gi(b,a,134217728,c);}il(a,134217728);}};Gc=function(a){if(13===a.tag){var b=yi(a),c=ih(a,b);if(null!==c){var d=R$4();gi(c,a,b,d);}il(a,b);}};Hc=function(){return C$6};Ic=function(a,b){var c=C$6;try{return C$6=a,b()}finally{C$6=c;}};
yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p$6(90));Wa(d);bb(d,e);}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1);}};Gb=Qk;Hb=Rk;
var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};
var ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||
jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl;}catch(a){}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;
reactDom_production_min.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl(b))throw Error(p$6(200));return cl(a,b,null,c)};reactDom_production_min.createRoot=function(a,b){if(!nl(a))throw Error(p$6(299));var c=!1,d="",e=kl;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll(b)};
reactDom_production_min.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p$6(188));a=Object.keys(a).join(",");throw Error(p$6(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};reactDom_production_min.flushSync=function(a){return Rk(a)};reactDom_production_min.hydrate=function(a,b,c){if(!ol(b))throw Error(p$6(200));return rl(null,a,b,!0,c)};
reactDom_production_min.hydrateRoot=function(a,b,c){if(!nl(a))throw Error(p$6(405));var d=null!=c&&c.hydratedSources||null,e=!1,f="",g=kl;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
e);return new ml(b)};reactDom_production_min.render=function(a,b,c){if(!ol(b))throw Error(p$6(200));return rl(null,a,b,!1,c)};reactDom_production_min.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p$6(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null;});}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol(c))throw Error(p$6(200));if(null==a||void 0===a._reactInternals)throw Error(p$6(38));return rl(a,b,c,!1,d)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";

function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}

var reactDomExports = reactDom.exports;

var m$8 = reactDomExports;
{
  client.createRoot = m$8.createRoot;
  client.hydrateRoot = m$8.hydrateRoot;
}

function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}

function isAnimationControls(v) {
    return (v !== null &&
        typeof v === "object" &&
        typeof v.start === "function");
}

const isKeyframesTarget = (v) => {
    return Array.isArray(v);
};

function shallowCompare(next, prev) {
    if (!Array.isArray(prev))
        return false;
    const prevLength = prev.length;
    if (prevLength !== next.length)
        return false;
    for (let i = 0; i < prevLength; i++) {
        if (prev[i] !== next[i])
            return false;
    }
    return true;
}

/**
 * Decides if the supplied variable is variant label
 */
function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
}

function getValueState(visualElement) {
    const state = [{}, {}];
    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
        state[0][key] = value.get();
        state[1][key] = value.getVelocity();
    });
    return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
    /**
     * If the variant definition is a function, resolve.
     */
    if (typeof definition === "function") {
        const [current, velocity] = getValueState(visualElement);
        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
    }
    /**
     * If the variant definition is a variant label, or
     * the function returned a variant label, resolve.
     */
    if (typeof definition === "string") {
        definition = props.variants && props.variants[definition];
    }
    /**
     * At this point we've resolved both functions and variant labels,
     * but the resolved variant label might itself have been a function.
     * If so, resolve. This can only have returned a valid target object.
     */
    if (typeof definition === "function") {
        const [current, velocity] = getValueState(visualElement);
        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
    }
    return definition;
}

function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);
}

const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
];
const variantProps = ["initial", ...variantPriorityOrder];

/**
 * Generate a list of every possible transform key.
 */
const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
];
/**
 * A quick lookup for transform props.
 */
const transformProps = new Set(transformPropOrder);

/**
 * Converts seconds to milliseconds
 *
 * @param seconds - Time in seconds.
 * @return milliseconds - Converted time in milliseconds.
 */
const secondsToMilliseconds = (seconds) => seconds * 1000;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1000;

const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
};
const criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
});
const keyframesTransition = {
    type: "keyframes",
    duration: 0.8,
};
/**
 * Default easing curve is a slightly shallower version of
 * the default browser easing curve.
 */
const ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3,
};
const getDefaultTransition = (valueKey, { keyframes }) => {
    if (keyframes.length > 2) {
        return keyframesTransition;
    }
    else if (transformProps.has(valueKey)) {
        return valueKey.startsWith("scale")
            ? criticallyDampedSpring(keyframes[1])
            : underDampedSpring;
    }
    return ease;
};

function getValueTransition(transition, key) {
    return transition
        ? transition[key] ||
            transition["default"] ||
            transition
        : undefined;
}

const MotionGlobalConfig = {
    skipAnimations: false,
    useManualTiming: false,
};

const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes.filter(isNotNull);
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1
        ? 0
        : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === undefined
        ? resolvedKeyframes[index]
        : finalKeyframe;
}

const noop$1 = (any) => any;

function createRenderStep(runNextFrame) {
    /**
     * We create and reuse two queues, one to queue jobs for the current frame
     * and one for the next. We reuse to avoid triggering GC after x frames.
     */
    let thisFrame = new Set();
    let nextFrame = new Set();
    /**
     * Track whether we're currently processing jobs in this step. This way
     * we can decide whether to schedule new jobs for this frame or next.
     */
    let isProcessing = false;
    let flushNextFrame = false;
    /**
     * A set of processes which were marked keepAlive when scheduled.
     */
    const toKeepAlive = new WeakSet();
    let latestFrameData = {
        delta: 0.0,
        timestamp: 0.0,
        isProcessing: false,
    };
    function triggerCallback(callback) {
        if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
        }
        callback(latestFrameData);
    }
    const step = {
        /**
         * Schedule a process to run on the next frame.
         */
        schedule: (callback, keepAlive = false, immediate = false) => {
            const addToCurrentFrame = immediate && isProcessing;
            const queue = addToCurrentFrame ? thisFrame : nextFrame;
            if (keepAlive)
                toKeepAlive.add(callback);
            if (!queue.has(callback))
                queue.add(callback);
            return callback;
        },
        /**
         * Cancel the provided callback from running on the next frame.
         */
        cancel: (callback) => {
            nextFrame.delete(callback);
            toKeepAlive.delete(callback);
        },
        /**
         * Execute all schedule callbacks.
         */
        process: (frameData) => {
            latestFrameData = frameData;
            /**
             * If we're already processing we've probably been triggered by a flushSync
             * inside an existing process. Instead of executing, mark flushNextFrame
             * as true and ensure we flush the following frame at the end of this one.
             */
            if (isProcessing) {
                flushNextFrame = true;
                return;
            }
            isProcessing = true;
            [thisFrame, nextFrame] = [nextFrame, thisFrame];
            // Clear the next frame queue
            nextFrame.clear();
            // Execute this frame
            thisFrame.forEach(triggerCallback);
            isProcessing = false;
            if (flushNextFrame) {
                flushNextFrame = false;
                step.process(frameData);
            }
        },
    };
    return step;
}

const stepsOrder = [
    "read", // Read
    "resolveKeyframes", // Write/Read/Write/Read
    "update", // Compute
    "preRender", // Compute
    "render", // Write
    "postRender", // Compute
];
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state = {
        delta: 0.0,
        timestamp: 0.0,
        isProcessing: false,
    };
    const flagRunNextFrame = () => (runNextFrame = true);
    const steps = stepsOrder.reduce((acc, key) => {
        acc[key] = createRenderStep(flagRunNextFrame);
        return acc;
    }, {});
    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
    const processBatch = () => {
        const timestamp = performance.now();
        runNextFrame = false;
        state.delta = useDefaultElapsed
            ? 1000 / 60
            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
        state.timestamp = timestamp;
        state.isProcessing = true;
        // Unrolled render loop for better per-frame performance
        read.process(state);
        resolveKeyframes.process(state);
        update.process(state);
        preRender.process(state);
        render.process(state);
        postRender.process(state);
        state.isProcessing = false;
        if (runNextFrame && allowKeepAlive) {
            useDefaultElapsed = false;
            scheduleNextBatch(processBatch);
        }
    };
    const wake = () => {
        runNextFrame = true;
        useDefaultElapsed = true;
        if (!state.isProcessing) {
            scheduleNextBatch(processBatch);
        }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
        const step = steps[key];
        acc[key] = (process, keepAlive = false, immediate = false) => {
            if (!runNextFrame)
                wake();
            return step.schedule(process, keepAlive, immediate);
        };
        return acc;
    }, {});
    const cancel = (process) => {
        for (let i = 0; i < stepsOrder.length; i++) {
            steps[stepsOrder[i]].cancel(process);
        }
    };
    return { schedule, cancel, state, steps };
}

const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$1, true);

/*
  Bezier function generator
  This has been modified from Gaëtan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticiably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *
    t;
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
        currentT = lowerBound + (upperBound - lowerBound) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - x;
        if (currentX > 0.0) {
            upperBound = currentT;
        }
        else {
            lowerBound = currentT;
        }
    } while (Math.abs(currentX) > subdivisionPrecision &&
        ++i < subdivisionMaxIterations);
    return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
    // If this is a linear gradient, return linear easing
    if (mX1 === mY1 && mX2 === mY2)
        return noop$1;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    // If animation is at start/end, return t without easing
    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// Accepts an easing function and returns a new one that outputs mirrored values for
// the second half of the animation. Turns easeIn into easeInOut.
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

// Accepts an easing function and returns a new one that outputs reversed values.
// Turns easeIn into easeOut.
const reverseEasing = (easing) => (p) => 1 - easing(1 - p);

const backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /*@__PURE__*/ reverseEasing(backOut);
const backInOut = /*@__PURE__*/ mirrorEasing(backIn);

const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

const circIn = (p) => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);

/**
 * Check if the value is a zero value string like "0px" or "0%"
 */
const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

function isNone(value) {
    if (typeof value === "number") {
        return value === 0;
    }
    else if (value !== null) {
        return value === "none" || value === "0" || isZeroValueString(value);
    }
    else {
        return true;
    }
}

let invariant = noop$1;

/**
 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
 */
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = 
/*@__PURE__*/ checkStringStartsWith("--");
const startsAsVariableToken = 
/*@__PURE__*/ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
        return false;
    // Ensure any comments are stripped from the value as this can harm performance of the regex.
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

/**
 * Parse Framer's special CSS variable format into a CSS token and a fallback.
 *
 * ```
 * `var(--foo, #fff)` => [`--foo`, '#fff']
 * ```
 *
 * @param current
 */
const splitCSSVariableRegex = 
// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(current) {
    const match = splitCSSVariableRegex.exec(current);
    if (!match)
        return [,];
    const [, token1, token2, fallback] = match;
    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
    const [token, fallback] = parseCSSVariable(current);
    // No CSS variable detected
    if (!token)
        return;
    // Attempt to read this CSS variable off the element
    const resolved = window.getComputedStyle(element).getPropertyValue(token);
    if (resolved) {
        const trimmed = resolved.trim();
        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback)
        ? getVariableValue(fallback, element, depth + 1)
        : fallback;
}

const clamp$1 = (min, max, v) => {
    if (v > max)
        return max;
    if (v < min)
        return min;
    return v;
};

const number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v,
};
const alpha = {
    ...number,
    transform: (v) => clamp$1(0, 1, v),
};
const scale = {
    ...number,
    default: 1,
};

const createUnitType = (unit) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`,
});
const degrees = /*@__PURE__*/ createUnitType("deg");
const percent = /*@__PURE__*/ createUnitType("%");
const px = /*@__PURE__*/ createUnitType("px");
const vh = /*@__PURE__*/ createUnitType("vh");
const vw = /*@__PURE__*/ createUnitType("vw");
const progressPercentage = {
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100),
};

const positionalKeys = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
]);
const isNumOrPxType = (v) => v === number || v === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
    if (transform === "none" || !transform)
        return 0;
    const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
    if (matrix3d) {
        return getPosFromMatrix(matrix3d[1], pos3);
    }
    else {
        const matrix = transform.match(/^matrix\((.+)\)$/u);
        if (matrix) {
            return getPosFromMatrix(matrix[1], pos2);
        }
        else {
            return 0;
        }
    }
};
const transformKeys = new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (value !== undefined) {
            removedTransforms.push([key, value.get()]);
            value.set(key.startsWith("scale") ? 1 : 0);
        }
    });
    return removedTransforms;
}
const positionalValues = {
    // Dimensions
    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
    // Transform
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14),
};
// Alias translate longform names
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;

/**
 * Tests a provided value against a ValueType
 */
const testValueType = (v) => (type) => type.test(v);

/**
 * ValueType for "auto"
 */
const auto = {
    test: (v) => v === "auto",
    parse: (v) => v,
};

/**
 * A list of value types commonly used for dimensions
 */
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
/**
 * Tests a dimensional value against the list of dimension ValueTypes
 */
const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

const toResolve = new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
        const transformsToRestore = new Map();
        /**
         * Write pass
         * If we're measuring elements we want to remove bounding box-changing transforms.
         */
        elementsToMeasure.forEach((element) => {
            const removedTransforms = removeNonTranslationalTransform(element);
            if (!removedTransforms.length)
                return;
            transformsToRestore.set(element, removedTransforms);
            element.render();
        });
        // Read
        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
        // Write
        elementsToMeasure.forEach((element) => {
            element.render();
            const restore = transformsToRestore.get(element);
            if (restore) {
                restore.forEach(([key, value]) => {
                    var _a;
                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
                });
            }
        });
        // Read
        resolversToMeasure.forEach((resolver) => resolver.measureEndState());
        // Write
        resolversToMeasure.forEach((resolver) => {
            if (resolver.suspendedScrollY !== undefined) {
                window.scrollTo(0, resolver.suspendedScrollY);
            }
        });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete());
    toResolve.clear();
}
function readAllKeyframes() {
    toResolve.forEach((resolver) => {
        resolver.readKeyframes();
        if (resolver.needsMeasurement) {
            anyNeedsMeasurement = true;
        }
    });
}
function flushKeyframeResolvers() {
    readAllKeyframes();
    measureAllKeyframes();
}
class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {
        /**
         * Track whether this resolver has completed. Once complete, it never
         * needs to attempt keyframe resolution again.
         */
        this.isComplete = false;
        /**
         * Track whether this resolver is async. If it is, it'll be added to the
         * resolver queue and flushed in the next frame. Resolvers that aren't going
         * to trigger read/write thrashing don't need to be async.
         */
        this.isAsync = false;
        /**
         * Track whether this resolver needs to perform a measurement
         * to resolve its keyframes.
         */
        this.needsMeasurement = false;
        /**
         * Track whether this resolver is currently scheduled to resolve
         * to allow it to be cancelled and resumed externally.
         */
        this.isScheduled = false;
        this.unresolvedKeyframes = [...unresolvedKeyframes];
        this.onComplete = onComplete;
        this.name = name;
        this.motionValue = motionValue;
        this.element = element;
        this.isAsync = isAsync;
    }
    scheduleResolve() {
        this.isScheduled = true;
        if (this.isAsync) {
            toResolve.add(this);
            if (!isScheduled) {
                isScheduled = true;
                frame.read(readAllKeyframes);
                frame.resolveKeyframes(measureAllKeyframes);
            }
        }
        else {
            this.readKeyframes();
            this.complete();
        }
    }
    readKeyframes() {
        const { unresolvedKeyframes, name, element, motionValue } = this;
        /**
         * If a keyframe is null, we hydrate it either by reading it from
         * the instance, or propagating from previous keyframes.
         */
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
            if (unresolvedKeyframes[i] === null) {
                /**
                 * If the first keyframe is null, we need to find its value by sampling the element
                 */
                if (i === 0) {
                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();
                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
                    if (currentValue !== undefined) {
                        unresolvedKeyframes[0] = currentValue;
                    }
                    else if (element && name) {
                        const valueAsRead = element.readValue(name, finalKeyframe);
                        if (valueAsRead !== undefined && valueAsRead !== null) {
                            unresolvedKeyframes[0] = valueAsRead;
                        }
                    }
                    if (unresolvedKeyframes[0] === undefined) {
                        unresolvedKeyframes[0] = finalKeyframe;
                    }
                    if (motionValue && currentValue === undefined) {
                        motionValue.set(unresolvedKeyframes[0]);
                    }
                }
                else {
                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
                }
            }
        }
    }
    setFinalKeyframe() { }
    measureInitialState() { }
    renderEndStyles() { }
    measureEndState() { }
    complete() {
        this.isComplete = true;
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
        toResolve.delete(this);
    }
    cancel() {
        if (!this.isComplete) {
            this.isScheduled = false;
            toResolve.delete(this);
        }
    }
    resume() {
        if (!this.isComplete)
            this.scheduleResolve();
    }
}

// If this number is a decimal, make it just five decimal places
// to avoid exponents
const sanitize = (v) => Math.round(v * 100000) / 100000;

const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function isNullish(v) {
    return v == null;
}

const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

/**
 * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,
 * but false if a number or multiple colors
 */
const isColorString = (type, testProp) => (v) => {
    return Boolean((typeof v === "string" &&
        singleColorRegex.test(v) &&
        v.startsWith(type)) ||
        (testProp &&
            !isNullish(v) &&
            Object.prototype.hasOwnProperty.call(v, testProp)));
};
const splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
        return v;
    const [a, b, c, alpha] = v.match(floatRegex);
    return {
        [aName]: parseFloat(a),
        [bName]: parseFloat(b),
        [cName]: parseFloat(c),
        alpha: alpha !== undefined ? parseFloat(alpha) : 1,
    };
};

const clampRgbUnit = (v) => clamp$1(0, 255, v);
const rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v)),
};
const rgba = {
    test: /*@__PURE__*/ isColorString("rgb", "red"),
    parse: /*@__PURE__*/ splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" +
        rgbUnit.transform(red) +
        ", " +
        rgbUnit.transform(green) +
        ", " +
        rgbUnit.transform(blue) +
        ", " +
        sanitize(alpha.transform(alpha$1)) +
        ")",
};

function parseHex(v) {
    let r = "";
    let g = "";
    let b = "";
    let a = "";
    // If we have 6 characters, ie #FF0000
    if (v.length > 5) {
        r = v.substring(1, 3);
        g = v.substring(3, 5);
        b = v.substring(5, 7);
        a = v.substring(7, 9);
        // Or we have 3 characters, ie #F00
    }
    else {
        r = v.substring(1, 2);
        g = v.substring(2, 3);
        b = v.substring(3, 4);
        a = v.substring(4, 5);
        r += r;
        g += g;
        b += b;
        a += a;
    }
    return {
        red: parseInt(r, 16),
        green: parseInt(g, 16),
        blue: parseInt(b, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1,
    };
}
const hex = {
    test: /*@__PURE__*/ isColorString("#"),
    parse: parseHex,
    transform: rgba.transform,
};

const hsla = {
    test: /*@__PURE__*/ isColorString("hsl", "hue"),
    parse: /*@__PURE__*/ splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
        return ("hsla(" +
            Math.round(hue) +
            ", " +
            percent.transform(sanitize(saturation)) +
            ", " +
            percent.transform(sanitize(lightness)) +
            ", " +
            sanitize(alpha.transform(alpha$1)) +
            ")");
    },
};

const color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
        if (rgba.test(v)) {
            return rgba.parse(v);
        }
        else if (hsla.test(v)) {
            return hsla.parse(v);
        }
        else {
            return hex.parse(v);
        }
    },
    transform: (v) => {
        return typeof v === "string"
            ? v
            : v.hasOwnProperty("red")
                ? rgba.transform(v)
                : hsla.transform(v);
    },
};

const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function test(v) {
    var _a, _b;
    return (isNaN(v) &&
        typeof v === "string" &&
        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +
            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >
            0);
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
        color: [],
        number: [],
        var: [],
    };
    const types = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
        if (color.test(parsedValue)) {
            indexes.color.push(i);
            types.push(COLOR_TOKEN);
            values.push(color.parse(parsedValue));
        }
        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
            indexes.var.push(i);
            types.push(VAR_TOKEN);
            values.push(parsedValue);
        }
        else {
            indexes.number.push(i);
            types.push(NUMBER_TOKEN);
            values.push(parseFloat(parsedValue));
        }
        ++i;
        return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
}
function parseComplexValue(v) {
    return analyseComplexValue(v).values;
}
function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
        let output = "";
        for (let i = 0; i < numSections; i++) {
            output += split[i];
            if (v[i] !== undefined) {
                const type = types[i];
                if (type === NUMBER_TOKEN) {
                    output += sanitize(v[i]);
                }
                else if (type === COLOR_TOKEN) {
                    output += color.transform(v[i]);
                }
                else {
                    output += v[i];
                }
            }
        }
        return output;
    };
}
const convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone$1(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1,
};

/**
 * Properties that should default to 1 or 100%
 */
const maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
        return v;
    const [number] = value.match(floatRegex) || [];
    if (!number)
        return v;
    const unit = value.replace(number, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number !== value)
        defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
    ...complex,
    getAnimatableNone: (v) => {
        const functions = v.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    },
};

const browserNumberValueTypes = {
    // Border props
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    // Positioning props
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    // Spacing props
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    // Misc
    backgroundPositionX: px,
    backgroundPositionY: px,
};

const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
};

const int = {
    ...number,
    transform: Math.round,
};

const numberValueTypes = {
    ...browserNumberValueTypes,
    ...transformValueTypes,
    zIndex: int,
    size: px,
    // SVG
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int,
};

/**
 * A map of default value types for common values
 */
const defaultValueTypes = {
    ...numberValueTypes,
    // Color props
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    // Border props
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter,
};
/**
 * Gets the default ValueType for the provided value key
 */
const getDefaultValueType = (key) => defaultValueTypes[key];

function getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
        defaultValueType = complex;
    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
    return defaultValueType.getAnimatableNone
        ? defaultValueType.getAnimatableNone(value)
        : undefined;
}

/**
 * If we encounter keyframes like "none" or "0" and we also have keyframes like
 * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for
 * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into
 * zero equivalents, i.e. "#fff0" or "0px 0px".
 */
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i = 0;
    let animatableTemplate = undefined;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
        const keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string" &&
            !invalidTemplates.has(keyframe) &&
            analyseComplexValue(keyframe).values.length) {
            animatableTemplate = unresolvedKeyframes[i];
        }
        i++;
    }
    if (animatableTemplate && name) {
        for (const noneIndex of noneKeyframeIndexes) {
            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
        }
    }
}

class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);
    }
    readKeyframes() {
        const { unresolvedKeyframes, element, name } = this;
        if (!element || !element.current)
            return;
        super.readKeyframes();
        /**
         * If any keyframe is a CSS variable, we need to find its value by sampling the element
         */
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
            let keyframe = unresolvedKeyframes[i];
            if (typeof keyframe === "string") {
                keyframe = keyframe.trim();
                if (isCSSVariableToken(keyframe)) {
                    const resolved = getVariableValue(keyframe, element.current);
                    if (resolved !== undefined) {
                        unresolvedKeyframes[i] = resolved;
                    }
                    if (i === unresolvedKeyframes.length - 1) {
                        this.finalKeyframe = keyframe;
                    }
                }
            }
        }
        /**
         * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.
         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which
         * have a far bigger performance impact.
         */
        this.resolveNoneKeyframes();
        /**
         * Check to see if unit type has changed. If so schedule jobs that will
         * temporarily set styles to the destination keyframes.
         * Skip if we have more than two keyframes or this isn't a positional value.
         * TODO: We can throw if there are multiple keyframes and the value type changes.
         */
        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
            return;
        }
        const [origin, target] = unresolvedKeyframes;
        const originType = findDimensionValueType(origin);
        const targetType = findDimensionValueType(target);
        /**
         * Either we don't recognise these value types or we can animate between them.
         */
        if (originType === targetType)
            return;
        /**
         * If both values are numbers or pixels, we can animate between them by
         * converting them to numbers.
         */
        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
            for (let i = 0; i < unresolvedKeyframes.length; i++) {
                const value = unresolvedKeyframes[i];
                if (typeof value === "string") {
                    unresolvedKeyframes[i] = parseFloat(value);
                }
            }
        }
        else {
            /**
             * Else, the only way to resolve this is by measuring the element.
             */
            this.needsMeasurement = true;
        }
    }
    resolveNoneKeyframes() {
        const { unresolvedKeyframes, name } = this;
        const noneKeyframeIndexes = [];
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
            if (isNone(unresolvedKeyframes[i])) {
                noneKeyframeIndexes.push(i);
            }
        }
        if (noneKeyframeIndexes.length) {
            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
        }
    }
    measureInitialState() {
        const { element, unresolvedKeyframes, name } = this;
        if (!element || !element.current)
            return;
        if (name === "height") {
            this.suspendedScrollY = window.pageYOffset;
        }
        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        unresolvedKeyframes[0] = this.measuredOrigin;
        // Set final key frame to measure after next render
        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (measureKeyframe !== undefined) {
            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
        }
    }
    measureEndState() {
        var _a;
        const { element, name, unresolvedKeyframes } = this;
        if (!element || !element.current)
            return;
        const value = element.getValue(name);
        value && value.jump(this.measuredOrigin, false);
        const finalKeyframeIndex = unresolvedKeyframes.length - 1;
        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
        if (finalKeyframe !== null && this.finalKeyframe === undefined) {
            this.finalKeyframe = finalKeyframe;
        }
        // If we removed transform values, reapply them before the next render
        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
                element
                    .getValue(unsetTransformName)
                    .set(unsetTransformValue);
            });
        }
        this.resolveNoneKeyframes();
    }
}

function isGenerator(type) {
    return typeof type === "function";
}

let now;
function clearTime() {
    now = undefined;
}
/**
 * An eventloop-synchronous alternative to performance.now().
 *
 * Ensures that time measurements remain consistent within a synchronous context.
 * Usually calling performance.now() twice within the same synchronous context
 * will return different values which isn't useful for animations when we're usually
 * trying to sync animations to the same frame.
 */
const time = {
    now: () => {
        if (now === undefined) {
            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming
                ? frameData.timestamp
                : performance.now());
        }
        return now;
    },
    set: (newTime) => {
        now = newTime;
        queueMicrotask(clearTime);
    },
};

/**
 * Check if a value is animatable. Examples:
 *
 * ✅: 100, "100px", "#fff"
 * ❌: "block", "url(2.jpg)"
 * @param value
 *
 * @internal
 */
const isAnimatable = (value, name) => {
    // If the list of keys tat might be non-animatable grows, replace with Set
    if (name === "zIndex")
        return false;
    // If it's a number or a keyframes array, we can animate it. We might at some point
    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
    // but for now lets leave it like this for performance reasons
    if (typeof value === "number" || Array.isArray(value))
        return true;
    if (typeof value === "string" && // It's animatable if we have a string
        (complex.test(value) || value === "0") && // And it contains numbers and/or colors
        !value.startsWith("url(") // Unless it starts with "url("
    ) {
        return true;
    }
    return false;
};

function hasKeyframesChanged(keyframes) {
    const current = keyframes[0];
    if (keyframes.length === 1)
        return true;
    for (let i = 0; i < keyframes.length; i++) {
        if (keyframes[i] !== current)
            return true;
    }
}
function canAnimate(keyframes, name, type, velocity) {
    /**
     * Check if we're able to animate between the start and end keyframes,
     * and throw a warning if we're attempting to animate between one that's
     * animatable and another that isn't.
     */
    const originKeyframe = keyframes[0];
    if (originKeyframe === null)
        return false;
    /**
     * These aren't traditionally animatable but we do support them.
     * In future we could look into making this more generic or replacing
     * this function with mix() === mixImmediate
     */
    if (name === "display" || name === "visibility")
        return true;
    const targetKeyframe = keyframes[keyframes.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    // Always skip if any of these are true
    if (!isOriginAnimatable || !isTargetAnimatable) {
        return false;
    }
    return (hasKeyframesChanged(keyframes) ||
        ((type === "spring" || isGenerator(type)) && velocity));
}

/**
 * Maximum time allowed between an animation being created and it being
 * resolved for us to use the latter as the start time.
 *
 * This is to ensure that while we prefer to "start" an animation as soon
 * as it's triggered, we also want to avoid a visual jump if there's a big delay
 * between these two moments.
 */
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
    constructor({ autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
        // Track whether the animation has been stopped. Stopped animations won't restart.
        this.isStopped = false;
        this.hasAttemptedResolve = false;
        this.createdAt = time.now();
        this.options = {
            autoplay,
            delay,
            type,
            repeat,
            repeatDelay,
            repeatType,
            ...options,
        };
        this.updateFinishedPromise();
    }
    /**
     * This method uses the createdAt and resolvedAt to calculate the
     * animation startTime. *Ideally*, we would use the createdAt time as t=0
     * as the following frame would then be the first frame of the animation in
     * progress, which would feel snappier.
     *
     * However, if there's a delay (main thread work) between the creation of
     * the animation and the first commited frame, we prefer to use resolvedAt
     * to avoid a sudden jump into the animation.
     */
    calcStartTime() {
        if (!this.resolvedAt)
            return this.createdAt;
        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
            ? this.resolvedAt
            : this.createdAt;
    }
    /**
     * A getter for resolved data. If keyframes are not yet resolved, accessing
     * this.resolved will synchronously flush all pending keyframe resolvers.
     * This is a deoptimisation, but at its worst still batches read/writes.
     */
    get resolved() {
        if (!this._resolved && !this.hasAttemptedResolve) {
            flushKeyframeResolvers();
        }
        return this._resolved;
    }
    /**
     * A method to be called when the keyframes resolver completes. This method
     * will check if its possible to run the animation and, if not, skip it.
     * Otherwise, it will call initPlayback on the implementing class.
     */
    onKeyframesResolved(keyframes, finalKeyframe) {
        this.resolvedAt = time.now();
        this.hasAttemptedResolve = true;
        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;
        /**
         * If we can't animate this value with the resolved keyframes
         * then we should complete it immediately.
         */
        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {
            // Finish immediately
            if (!delay) {
                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));
                onComplete === null || onComplete === void 0 ? void 0 : onComplete();
                this.resolveFinishedPromise();
                return;
            }
            // Finish after a delay
            else {
                this.options.duration = 0;
            }
        }
        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);
        if (resolvedAnimation === false)
            return;
        this._resolved = {
            keyframes,
            finalKeyframe,
            ...resolvedAnimation,
        };
        this.onPostResolved();
    }
    onPostResolved() { }
    /**
     * Allows the returned animation to be awaited or promise-chained. Currently
     * resolves when the animation finishes at all but in a future update could/should
     * reject if its cancels.
     */
    then(resolve, reject) {
        return this.currentFinishedPromise.then(resolve, reject);
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise((resolve) => {
            this.resolveFinishedPromise = resolve;
        });
    }
}

/*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1000 / frameDuration) : 0;
}

const velocitySampleDuration = 5; // ms
function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}

const safeMin = 0.001;
const minDuration = 0.01;
const maxDuration$1 = 10.0;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {
    let envelope;
    let derivative;
    let dampingRatio = 1 - bounce;
    /**
     * Restrict dampingRatio and duration to within acceptable ranges.
     */
    dampingRatio = clamp$1(minDamping, maxDamping, dampingRatio);
    duration = clamp$1(minDuration, maxDuration$1, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
        /**
         * Underdamped spring
         */
        envelope = (undampedFreq) => {
            const exponentialDecay = undampedFreq * dampingRatio;
            const delta = exponentialDecay * duration;
            const a = exponentialDecay - velocity;
            const b = calcAngularFreq(undampedFreq, dampingRatio);
            const c = Math.exp(-delta);
            return safeMin - (a / b) * c;
        };
        derivative = (undampedFreq) => {
            const exponentialDecay = undampedFreq * dampingRatio;
            const delta = exponentialDecay * duration;
            const d = delta * velocity + velocity;
            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
            const f = Math.exp(-delta);
            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
            return (factor * ((d - e) * f)) / g;
        };
    }
    else {
        /**
         * Critically-damped spring
         */
        envelope = (undampedFreq) => {
            const a = Math.exp(-undampedFreq * duration);
            const b = (undampedFreq - velocity) * duration + 1;
            return -safeMin + a * b;
        };
        derivative = (undampedFreq) => {
            const a = Math.exp(-undampedFreq * duration);
            const b = (velocity - undampedFreq) * (duration * duration);
            return a * b;
        };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
        return {
            stiffness: 100,
            damping: 10,
            duration,
        };
    }
    else {
        const stiffness = Math.pow(undampedFreq, 2) * mass;
        return {
            stiffness,
            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
            duration,
        };
    }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
        result = result - envelope(result) / derivative(result);
    }
    return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== undefined);
}
function getSpringOptions(options) {
    let springOptions = {
        velocity: 0.0,
        stiffness: 100,
        damping: 10,
        mass: 1.0,
        isResolvedFromDuration: false,
        ...options,
    };
    // stiffness/damping/mass overrides duration/bounce
    if (!isSpringType(options, physicsKeys) &&
        isSpringType(options, durationKeys)) {
        const derived = findSpring(options);
        springOptions = {
            ...springOptions,
            ...derived,
            mass: 1.0,
        };
        springOptions.isResolvedFromDuration = true;
    }
    return springOptions;
}
function spring({ keyframes, restDelta, restSpeed, ...options }) {
    const origin = keyframes[0];
    const target = keyframes[keyframes.length - 1];
    /**
     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
     * to reduce GC during animation.
     */
    const state = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({
        ...options,
        velocity: -millisecondsToSeconds(options.velocity || 0),
    });
    const initialVelocity = velocity || 0.0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    /**
     * If we're working on a granular scale, use smaller defaults for determining
     * when the spring is finished.
     *
     * These defaults have been selected emprically based on what strikes a good
     * ratio between feeling good and finishing as soon as changes are imperceptible.
     */
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);
    let resolveSpring;
    if (dampingRatio < 1) {
        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
        // Underdamped spring
        resolveSpring = (t) => {
            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
            return (target -
                envelope *
                    (((initialVelocity +
                        dampingRatio * undampedAngularFreq * initialDelta) /
                        angularFreq) *
                        Math.sin(angularFreq * t) +
                        initialDelta * Math.cos(angularFreq * t)));
        };
    }
    else if (dampingRatio === 1) {
        // Critically damped spring
        resolveSpring = (t) => target -
            Math.exp(-undampedAngularFreq * t) *
                (initialDelta +
                    (initialVelocity + undampedAngularFreq * initialDelta) * t);
    }
    else {
        // Overdamped spring
        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
        resolveSpring = (t) => {
            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
            // When performing sinh or cosh values can hit Infinity so we cap them here
            const freqForT = Math.min(dampedAngularFreq * t, 300);
            return (target -
                (envelope *
                    ((initialVelocity +
                        dampingRatio * undampedAngularFreq * initialDelta) *
                        Math.sinh(freqForT) +
                        dampedAngularFreq *
                            initialDelta *
                            Math.cosh(freqForT))) /
                    dampedAngularFreq);
        };
    }
    return {
        calculatedDuration: isResolvedFromDuration ? duration || null : null,
        next: (t) => {
            const current = resolveSpring(t);
            if (!isResolvedFromDuration) {
                let currentVelocity = 0.0;
                /**
                 * We only need to calculate velocity for under-damped springs
                 * as over- and critically-damped springs can't overshoot, so
                 * checking only for displacement is enough.
                 */
                if (dampingRatio < 1) {
                    currentVelocity =
                        t === 0
                            ? secondsToMilliseconds(initialVelocity)
                            : calcGeneratorVelocity(resolveSpring, t, current);
                }
                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
                state.done =
                    isBelowVelocityThreshold && isBelowDisplacementThreshold;
            }
            else {
                state.done = t >= duration;
            }
            state.value = state.done ? target : current;
            return state;
        },
    };
}

function inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {
    const origin = keyframes[0];
    const state = {
        done: false,
        value: origin,
    };
    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);
    const nearestBoundary = (v) => {
        if (min === undefined)
            return max;
        if (max === undefined)
            return min;
        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
    /**
     * If the target has changed we need to re-calculate the amplitude, otherwise
     * the animation will start from the wrong position.
     */
    if (target !== ideal)
        amplitude = target - origin;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
        const delta = calcDelta(t);
        const latest = calcLatest(t);
        state.done = Math.abs(delta) <= restDelta;
        state.value = state.done ? target : latest;
    };
    /**
     * Ideally this would resolve for t in a stateless way, we could
     * do that by always precalculating the animation but as we know
     * this will be done anyway we can assume that spring will
     * be discovered during that.
     */
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
        if (!isOutOfBounds(state.value))
            return;
        timeReachedBoundary = t;
        spring$1 = spring({
            keyframes: [state.value, nearestBoundary(state.value)],
            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000
            damping: bounceDamping,
            stiffness: bounceStiffness,
            restDelta,
            restSpeed,
        });
    };
    checkCatchBoundary(0);
    return {
        calculatedDuration: null,
        next: (t) => {
            /**
             * We need to resolve the friction to figure out if we need a
             * spring but we don't want to do this twice per frame. So here
             * we flag if we updated for this frame and later if we did
             * we can skip doing it again.
             */
            let hasUpdatedFrame = false;
            if (!spring$1 && timeReachedBoundary === undefined) {
                hasUpdatedFrame = true;
                applyFriction(t);
                checkCatchBoundary(t);
            }
            /**
             * If we have a spring and the provided t is beyond the moment the friction
             * animation crossed the min/max boundary, use the spring.
             */
            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
                return spring$1.next(t - timeReachedBoundary);
            }
            else {
                !hasUpdatedFrame && applyFriction(t);
                return state;
            }
        },
    };
}

const easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);
const easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);

const isEasingArray = (ease) => {
    return Array.isArray(ease) && typeof ease[0] !== "number";
};

const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

const easingLookup = {
    linear: noop$1,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
};
const easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
        // If cubic bezier definition, create bezier curve
        invariant(definition.length === 4);
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
    }
    else if (typeof definition === "string") {
        // Else lookup from table
        invariant(easingLookup[definition] !== undefined);
        return easingLookup[definition];
    }
    return definition;
};

/**
 * Pipe
 * Compose other transformers to run linearily
 * pipe(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */
const combineFunctions = (a, b) => (v) => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);

/*
  Progress within given range

  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.

  @param [number]: Lower limit
  @param [number]: Upper limit
  @param [number]: Value to find progress within given range
  @return [number]: Progress of value within range as expressed 0-1
*/
const progress = (from, to, value) => {
    const toFromDifference = to - from;
    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};

/*
  Value in range from progress

  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (usually a number from 0 to 1)

  So progress = 0.5 would change

  from -------- to

  to

  from ---- to

  E.g. from = 10, to = 20, progress = 0.5 => 15

  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @param [number]: The progress between lower and upper limits expressed 0-1
  @return [number]: Value as calculated from progress within range (not limited within range)
*/
const mixNumber$1 = (from, to, progress) => {
    return from + (to - from) * progress;
};

// Adapted from https://gist.github.com/mjackson/5311256
function hueToRgb(p, q, t) {
    if (t < 0)
        t += 1;
    if (t > 1)
        t -= 1;
    if (t < 1 / 6)
        return p + (q - p) * 6 * t;
    if (t < 1 / 2)
        return q;
    if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
    return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
        red = green = blue = lightness;
    }
    else {
        const q = lightness < 0.5
            ? lightness * (1 + saturation)
            : lightness + saturation - lightness * saturation;
        const p = 2 * lightness - q;
        red = hueToRgb(p, q, hue + 1 / 3);
        green = hueToRgb(p, q, hue);
        blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255),
        alpha,
    };
}

function mixImmediate(a, b) {
    return (p) => (p > 0 ? b : a);
}

// Linear color space blending
// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
// Demonstrated http://codepen.io/osublake/pen/xGVVaN
const mixLinearColor = (from, to, v) => {
    const fromExpo = from * from;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color) {
    const type = getColorType(color);
    if (!Boolean(type))
        return false;
    let model = type.parse(color);
    if (type === hsla) {
        // TODO Remove this cast - needed since Framer Motion's stricter typing
        model = hslaToRgba(model);
    }
    return model;
}
const mixColor = (from, to) => {
    const fromRGBA = asRGBA(from);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
        return mixImmediate(from, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
        return rgba.transform(blended);
    };
};

const invisibleValues = new Set(["none", "hidden"]);
/**
 * Returns a function that, when provided a progress value between 0 and 1,
 * will return the "none" or "hidden" string only when the progress is that of
 * the origin or target.
 */
function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
        return (p) => (p <= 0 ? origin : target);
    }
    else {
        return (p) => (p >= 1 ? target : origin);
    }
}

function mixNumber(a, b) {
    return (p) => mixNumber$1(a, b, p);
}
function getMixer(a) {
    if (typeof a === "number") {
        return mixNumber;
    }
    else if (typeof a === "string") {
        return isCSSVariableToken(a)
            ? mixImmediate
            : color.test(a)
                ? mixColor
                : mixComplex;
    }
    else if (Array.isArray(a)) {
        return mixArray;
    }
    else if (typeof a === "object") {
        return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
}
function mixArray(a, b) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
    return (p) => {
        for (let i = 0; i < numValues; i++) {
            output[i] = blendValue[i](p);
        }
        return output;
    };
}
function mixObject(a, b) {
    const output = { ...a, ...b };
    const blendValue = {};
    for (const key in output) {
        if (a[key] !== undefined && b[key] !== undefined) {
            blendValue[key] = getMixer(a[key])(a[key], b[key]);
        }
    }
    return (v) => {
        for (const key in blendValue) {
            output[key] = blendValue[key](v);
        }
        return output;
    };
}
function matchOrder(origin, target) {
    var _a;
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
        const type = target.types[i];
        const originIndex = origin.indexes[type][pointers[type]];
        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
        orderedOrigin[i] = originValue;
        pointers[type]++;
    }
    return orderedOrigin;
}
const mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&
        originStats.indexes.color.length === targetStats.indexes.color.length &&
        originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
        if ((invisibleValues.has(origin) &&
            !targetStats.values.length) ||
            (invisibleValues.has(target) &&
                !originStats.values.length)) {
            return mixVisibility(origin, target);
        }
        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    }
    else {
        return mixImmediate(origin, target);
    }
};

function mix(from, to, p) {
    if (typeof from === "number" &&
        typeof to === "number" &&
        typeof p === "number") {
        return mixNumber$1(from, to, p);
    }
    const mixer = getMixer(from);
    return mixer(from, to);
}

function createMixers(output, ease, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
        let mixer = mixerFactory(output[i], output[i + 1]);
        if (ease) {
            const easingFunction = Array.isArray(ease) ? ease[i] || noop$1 : ease;
            mixer = pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
    }
    return mixers;
}
/**
 * Create a function that maps from a numerical input array to a generic output array.
 *
 * Accepts:
 *   - Numbers
 *   - Colors (hex, hsl, hsla, rgb, rgba)
 *   - Complex (combinations of one or more numbers or strings)
 *
 * ```jsx
 * const mixColor = interpolate([0, 1], ['#fff', '#000'])
 *
 * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
 * ```
 *
 * TODO Revist this approach once we've moved to data models for values,
 * probably not needed to pregenerate mixer functions.
 *
 * @public
 */
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length);
    /**
     * If we're only provided a single input, we can just make a function
     * that returns the output.
     */
    if (inputLength === 1)
        return () => output[0];
    if (inputLength === 2 && input[0] === input[1])
        return () => output[1];
    // If input runs highest -> lowest, reverse both arrays
    if (input[0] > input[inputLength - 1]) {
        input = [...input].reverse();
        output = [...output].reverse();
    }
    const mixers = createMixers(output, ease, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
        let i = 0;
        if (numMixers > 1) {
            for (; i < input.length - 2; i++) {
                if (v < input[i + 1])
                    break;
            }
        }
        const progressInRange = progress(input[i], input[i + 1], v);
        return mixers[i](progressInRange);
    };
    return isClamp
        ? (v) => interpolator(clamp$1(input[0], input[inputLength - 1], v))
        : interpolator;
}

function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i = 1; i <= remaining; i++) {
        const offsetProgress = progress(0, remaining, i);
        offset.push(mixNumber$1(min, 1, offsetProgress));
    }
}

function defaultOffset(arr) {
    const offset = [0];
    fillOffset(offset, arr.length - 1);
    return offset;
}

function convertOffsetToTimes(offset, duration) {
    return offset.map((o) => o * duration);
}

function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "easeInOut", }) {
    /**
     * Easing functions can be externally defined as strings. Here we convert them
     * into actual functions.
     */
    const easingFunctions = isEasingArray(ease)
        ? ease.map(easingDefinitionToFunction)
        : easingDefinitionToFunction(ease);
    /**
     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
     * to reduce GC during animation.
     */
    const state = {
        done: false,
        value: keyframeValues[0],
    };
    /**
     * Create a times array based on the provided 0-1 offsets
     */
    const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length
        ? times
        : defaultOffset(keyframeValues), duration);
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
        ease: Array.isArray(easingFunctions)
            ? easingFunctions
            : defaultEasing(keyframeValues, easingFunctions),
    });
    return {
        calculatedDuration: duration,
        next: (t) => {
            state.value = mapTimeToKeyframe(t);
            state.done = t >= duration;
            return state;
        },
    };
}

/**
 * Implement a practical max duration for keyframe generation
 * to prevent infinite loops
 */
const maxGeneratorDuration = 20000;
function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state = generator.next(duration);
    while (!state.done && duration < maxGeneratorDuration) {
        duration += timeStep;
        state = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
}

const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
        start: () => frame.update(passTimestamp, true),
        stop: () => cancelFrame(passTimestamp),
        /**
         * If we're processing this frame we can use the
         * framelocked timestamp to keep things in sync.
         */
        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
    };
};

const generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
const percentToProgress = (percent) => percent / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    this.holdTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.startTime = null;
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue, element, keyframes: keyframes2 } = this.options;
    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue, element);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: true, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress);
      let iterationProgress = progress % 1;
      if (!iterationProgress && progress >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$1(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    } else if (this.state === "finished") {
      this.startTime = now;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time) {
    this.startTime = 0;
    return this.tick(time, true);
  }
}
function animateValue(options) {
  return new MainThreadAnimation(options);
}

/**
 * A list of values that can be hardware-accelerated.
 */
const acceleratedValues = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
    // or until we implement support for linear() easing.
    // "background-color"
]);

// Create a linear easing point for every 10 ms
const resolution = 10;
const generateLinearEasing = (easing, duration // as milliseconds
) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
        points += easing(progress(0, numPoints - 1, i)) + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
};

function memo(callback) {
    let result;
    return () => {
        if (result === undefined)
            result = callback();
        return result;
    };
}

/**
 * Add the ability for test suites to manually set support flags
 * to better test more environments.
 */
const supportsFlags = {
    linearEasing: undefined,
};

function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };
}

const supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {
    try {
        document
            .createElement("div")
            .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    }
    catch (e) {
        return false;
    }
    return true;
}, "linearEasing");

function isWaapiSupportedEasing(easing) {
    return Boolean((typeof easing === "function" && supportsLinearEasing()) ||
        !easing ||
        (typeof easing === "string" &&
            (easing in supportedWaapiEasing || supportsLinearEasing())) ||
        isBezierDefinition(easing) ||
        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));
}
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
const supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
};
function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
        return undefined;
    }
    else if (typeof easing === "function" && supportsLinearEasing()) {
        return generateLinearEasing(easing, duration);
    }
    else if (isBezierDefinition(easing)) {
        return cubicBezierAsString(easing);
    }
    else if (Array.isArray(easing)) {
        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||
            supportedWaapiEasing.easeOut);
    }
    else {
        return supportedWaapiEasing[easing];
    }
}

function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease, times, } = {}) {
    const keyframeOptions = { [valueName]: keyframes };
    if (times)
        keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease, duration);
    /**
     * If this is an easing array, apply to keyframes, not animation as a whole
     */
    if (Array.isArray(easing))
        keyframeOptions.easing = easing;
    return element.animate(keyframeOptions, {
        delay,
        duration,
        easing: !Array.isArray(easing) ? easing : "linear",
        fill: "both",
        iterations: repeat + 1,
        direction: repeatType === "reverse" ? "alternate" : "normal",
    });
}

function attachTimeline(animation, timeline) {
    animation.timeline = timeline;
    animation.onfinish = null;
}

const supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

/**
 * 10ms is chosen here as it strikes a balance between smooth
 * results (more than one keyframe per frame at 60fps) and
 * keyframe quantity.
 */
const sampleDelta = 10; //ms
/**
 * Implement a practical max duration for keyframe generation
 * to prevent infinite loops
 */
const maxDuration = 20000;
/**
 * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.
 * WAAPI doesn't support spring or function easings so we run these as JS animation before
 * handing off.
 */
function requiresPregeneratedKeyframes(options) {
    return (isGenerator(options.type) ||
        options.type === "spring" ||
        !isWaapiSupportedEasing(options.ease));
}
function pregenerateKeyframes(keyframes, options) {
    /**
     * Create a main-thread animation to pregenerate keyframes.
     * We sample this at regular intervals to generate keyframes that we then
     * linearly interpolate between.
     */
    const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes,
        repeat: 0,
        delay: 0,
        isGenerator: true,
    });
    let state = { done: false, value: keyframes[0] };
    const pregeneratedKeyframes = [];
    /**
     * Bail after 20 seconds of pre-generated keyframes as it's likely
     * we're heading for an infinite loop.
     */
    let t = 0;
    while (!state.done && t < maxDuration) {
        state = sampleAnimation.sample(t);
        pregeneratedKeyframes.push(state.value);
        t += sampleDelta;
    }
    return {
        times: undefined,
        keyframes: pregeneratedKeyframes,
        duration: t - sampleDelta,
        ease: "linear",
    };
}
const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut,
};
function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
    constructor(options) {
        super(options);
        const { name, motionValue, element, keyframes } = this.options;
        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);
        this.resolver.scheduleResolve();
    }
    initPlayback(keyframes, finalKeyframe) {
        var _a;
        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;
        /**
         * If element has since been unmounted, return false to indicate
         * the animation failed to initialised.
         */
        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {
            return false;
        }
        /**
         * If the user has provided an easing function name that isn't supported
         * by WAAPI (like "anticipate"), we need to provide the corressponding
         * function. This will later get converted to a linear() easing function.
         */
        if (typeof ease === "string" &&
            supportsLinearEasing() &&
            isUnsupportedEase(ease)) {
            ease = unsupportedEasingFunctions[ease];
        }
        /**
         * If this animation needs pre-generated keyframes then generate.
         */
        if (requiresPregeneratedKeyframes(this.options)) {
            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;
            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);
            keyframes = pregeneratedAnimation.keyframes;
            // If this is a very short animation, ensure we have
            // at least two keyframes to animate between as older browsers
            // can't animate between a single keyframe.
            if (keyframes.length === 1) {
                keyframes[1] = keyframes[0];
            }
            duration = pregeneratedAnimation.duration;
            times = pregeneratedAnimation.times;
            ease = pregeneratedAnimation.ease;
            type = "keyframes";
        }
        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });
        // Override the browser calculated startTime with one synchronised to other JS
        // and WAAPI animations starting this event loop.
        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
        if (this.pendingTimeline) {
            attachTimeline(animation, this.pendingTimeline);
            this.pendingTimeline = undefined;
        }
        else {
            /**
             * Prefer the `onfinish` prop as it's more widely supported than
             * the `finished` promise.
             *
             * Here, we synchronously set the provided MotionValue to the end
             * keyframe. If we didn't, when the WAAPI animation is finished it would
             * be removed from the element which would then revert to its old styles.
             */
            animation.onfinish = () => {
                const { onComplete } = this.options;
                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));
                onComplete && onComplete();
                this.cancel();
                this.resolveFinishedPromise();
            };
        }
        return {
            animation,
            duration,
            times,
            type,
            ease,
            keyframes: keyframes,
        };
    }
    get duration() {
        const { resolved } = this;
        if (!resolved)
            return 0;
        const { duration } = resolved;
        return millisecondsToSeconds(duration);
    }
    get time() {
        const { resolved } = this;
        if (!resolved)
            return 0;
        const { animation } = resolved;
        return millisecondsToSeconds(animation.currentTime || 0);
    }
    set time(newTime) {
        const { resolved } = this;
        if (!resolved)
            return;
        const { animation } = resolved;
        animation.currentTime = secondsToMilliseconds(newTime);
    }
    get speed() {
        const { resolved } = this;
        if (!resolved)
            return 1;
        const { animation } = resolved;
        return animation.playbackRate;
    }
    set speed(newSpeed) {
        const { resolved } = this;
        if (!resolved)
            return;
        const { animation } = resolved;
        animation.playbackRate = newSpeed;
    }
    get state() {
        const { resolved } = this;
        if (!resolved)
            return "idle";
        const { animation } = resolved;
        return animation.playState;
    }
    get startTime() {
        const { resolved } = this;
        if (!resolved)
            return null;
        const { animation } = resolved;
        // Coerce to number as TypeScript incorrectly types this
        // as CSSNumberish
        return animation.startTime;
    }
    /**
     * Replace the default DocumentTimeline with another AnimationTimeline.
     * Currently used for scroll animations.
     */
    attachTimeline(timeline) {
        if (!this._resolved) {
            this.pendingTimeline = timeline;
        }
        else {
            const { resolved } = this;
            if (!resolved)
                return noop$1;
            const { animation } = resolved;
            attachTimeline(animation, timeline);
        }
        return noop$1;
    }
    play() {
        if (this.isStopped)
            return;
        const { resolved } = this;
        if (!resolved)
            return;
        const { animation } = resolved;
        if (animation.playState === "finished") {
            this.updateFinishedPromise();
        }
        animation.play();
    }
    pause() {
        const { resolved } = this;
        if (!resolved)
            return;
        const { animation } = resolved;
        animation.pause();
    }
    stop() {
        this.resolver.cancel();
        this.isStopped = true;
        if (this.state === "idle")
            return;
        this.resolveFinishedPromise();
        this.updateFinishedPromise();
        const { resolved } = this;
        if (!resolved)
            return;
        const { animation, keyframes, duration, type, ease, times } = resolved;
        if (animation.playState === "idle" ||
            animation.playState === "finished") {
            return;
        }
        /**
         * WAAPI doesn't natively have any interruption capabilities.
         *
         * Rather than read commited styles back out of the DOM, we can
         * create a renderless JS animation and sample it twice to calculate
         * its current value, "previous" value, and therefore allow
         * Motion to calculate velocity for any subsequent animation.
         */
        if (this.time) {
            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;
            const sampleAnimation = new MainThreadAnimation({
                ...options,
                keyframes,
                duration,
                type,
                ease,
                times,
                isGenerator: true,
            });
            const sampleTime = secondsToMilliseconds(this.time);
            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
        }
        const { onStop } = this.options;
        onStop && onStop();
        this.cancel();
    }
    complete() {
        const { resolved } = this;
        if (!resolved)
            return;
        resolved.animation.finish();
    }
    cancel() {
        const { resolved } = this;
        if (!resolved)
            return;
        resolved.animation.cancel();
    }
    static supports(options) {
        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;
        return (supportsWaapi() &&
            name &&
            acceleratedValues.has(name) &&
            motionValue &&
            motionValue.owner &&
            motionValue.owner.current instanceof HTMLElement &&
            /**
             * If we're outputting values to onUpdate then we can't use WAAPI as there's
             * no way to read the value from WAAPI every frame.
             */
            !motionValue.owner.getProps().onUpdate &&
            !repeatDelay &&
            repeatType !== "mirror" &&
            damping !== 0 &&
            type !== "inertia");
    }
}

const supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);

class GroupPlaybackControls {
    constructor(animations) {
        // Bound to accomodate common `return animation.stop` pattern
        this.stop = () => this.runAll("stop");
        this.animations = animations.filter(Boolean);
    }
    then(onResolve, onReject) {
        return Promise.all(this.animations).then(onResolve).catch(onReject);
    }
    /**
     * TODO: Filter out cancelled or stopped animations before returning
     */
    getAll(propName) {
        return this.animations[0][propName];
    }
    setAll(propName, newValue) {
        for (let i = 0; i < this.animations.length; i++) {
            this.animations[i][propName] = newValue;
        }
    }
    attachTimeline(timeline, fallback) {
        const subscriptions = this.animations.map((animation) => {
            if (supportsScrollTimeline() && animation.attachTimeline) {
                return animation.attachTimeline(timeline);
            }
            else {
                return fallback(animation);
            }
        });
        return () => {
            subscriptions.forEach((cancel, i) => {
                cancel && cancel();
                this.animations[i].stop();
            });
        };
    }
    get time() {
        return this.getAll("time");
    }
    set time(time) {
        this.setAll("time", time);
    }
    get speed() {
        return this.getAll("speed");
    }
    set speed(speed) {
        this.setAll("speed", speed);
    }
    get startTime() {
        return this.getAll("startTime");
    }
    get duration() {
        let max = 0;
        for (let i = 0; i < this.animations.length; i++) {
            max = Math.max(max, this.animations[i].duration);
        }
        return max;
    }
    runAll(methodName) {
        this.animations.forEach((controls) => controls[methodName]());
    }
    play() {
        this.runAll("play");
    }
    pause() {
        this.runAll("pause");
    }
    cancel() {
        this.runAll("cancel");
    }
    complete() {
        this.runAll("complete");
    }
}

/**
 * Decide whether a transition is defined on a given Transition.
 * This filters out orchestration options and returns true
 * if any options are left.
 */
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
}

const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    /**
     * Most transition values are currently completely overwritten by value-specific
     * transitions. In the future it'd be nicer to blend these transitions. But for now
     * delay actually does inherit from the root transition if not value-specific.
     */
    const delay = valueTransition.delay || transition.delay || 0;
    /**
     * Elapsed isn't a public transition option but can be passed through from
     * optimized appear effects in milliseconds.
     */
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay);
    let options = {
        keyframes: Array.isArray(target) ? target : [null, target],
        ease: "easeOut",
        velocity: value.getVelocity(),
        ...valueTransition,
        delay: -elapsed,
        onUpdate: (v) => {
            value.set(v);
            valueTransition.onUpdate && valueTransition.onUpdate(v);
        },
        onComplete: () => {
            onComplete();
            valueTransition.onComplete && valueTransition.onComplete();
        },
        name,
        motionValue: value,
        element: isHandoff ? undefined : element,
    };
    /**
     * If there's no transition defined for this value, we can generate
     * unqiue transition settings for this value.
     */
    if (!isTransitionDefined(valueTransition)) {
        options = {
            ...options,
            ...getDefaultTransition(name, options),
        };
    }
    /**
     * Both WAAPI and our internal animation functions use durations
     * as defined by milliseconds, while our external API defines them
     * as seconds.
     */
    if (options.duration) {
        options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (options.from !== undefined) {
        options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false ||
        (options.duration === 0 && !options.repeatDelay)) {
        options.duration = 0;
        if (options.delay === 0) {
            shouldSkip = true;
        }
    }
    /**
     * If we can or must skip creating the animation, and apply only
     * the final keyframe, do so. We also check once keyframes are resolved but
     * this early check prevents the need to create an animation at all.
     */
    if (shouldSkip && !isHandoff && value.get() !== undefined) {
        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
        if (finalKeyframe !== undefined) {
            frame.update(() => {
                options.onUpdate(finalKeyframe);
                options.onComplete();
            });
            // We still want to return some animation controls here rather
            // than returning undefined
            return new GroupPlaybackControls([]);
        }
    }
    /**
     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    if (!isHandoff && AcceleratedAnimation.supports(options)) {
        return new AcceleratedAnimation(options);
    }
    else {
        return new MainThreadAnimation(options);
    }
};

const isCustomValue = (v) => {
    return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
const resolveFinalValueInKeyframes = (v) => {
    // TODO maybe throw if v.length - 1 is placeholder token?
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};

function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
        arr.push(item);
}
function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
        arr.splice(index, 1);
}

class SubscriptionManager {
    constructor() {
        this.subscriptions = [];
    }
    add(handler) {
        addUniqueItem(this.subscriptions, handler);
        return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b, c) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions)
            return;
        if (numSubscriptions === 1) {
            /**
             * If there's only a single handler we can just call it without invoking a loop.
             */
            this.subscriptions[0](a, b, c);
        }
        else {
            for (let i = 0; i < numSubscriptions; i++) {
                /**
                 * Check whether the handler exists before firing as it's possible
                 * the subscriptions were modified during this loop running.
                 */
                const handler = this.subscriptions[i];
                handler && handler(a, b, c);
            }
        }
    }
    getSize() {
        return this.subscriptions.length;
    }
    clear() {
        this.subscriptions.length = 0;
    }
}

const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "11.11.8";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}

/**
 * Set VisualElement's MotionValue, creating a new MotionValue for it if
 * it doesn't exist.
 */
function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
        visualElement.getValue(key).set(value);
    }
    else {
        visualElement.addValue(key, motionValue(value));
    }
}
function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
        const value = resolveFinalValueInKeyframes(target[key]);
        setMotionValue(visualElement, key, value);
    }
}

/**
 * Convert camelCase to dash-case properties.
 */
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
}

const isMotionValue = (value) => Boolean(value && value.getVelocity);

function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
}

function getWillChangeName(name) {
    if (transformProps.has(name)) {
        return "transform";
    }
    else if (acceleratedValues.has(name)) {
        return camelToDash(name);
    }
}

function addValueToWillChange(visualElement, key) {
    var _a;
    if (!visualElement.applyWillChange)
        return;
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
        return willChange.add(key);
    }
    else if (!((_a = visualElement.props.style) === null || _a === void 0 ? void 0 : _a.willChange) &&
        getWillChangeName(key)) {
        visualElement.setStaticValue("willChange", "transform");
    }
}

/**
 * Decide whether we should block this animation. Previously, we achieved this
 * just by checking whether the key was listed in protectedKeys, but this
 * posed problems if an animation was triggered by afterChildren and protectedKeys
 * had been set to true in the meantime.
 */
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {
    var _a;
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
        transition = transitionOverride;
    const animations = [];
    const animationTypeState = type &&
        visualElement.animationState &&
        visualElement.animationState.getState()[type];
    for (const key in target) {
        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
        const valueTarget = target[key];
        if (valueTarget === undefined ||
            (animationTypeState &&
                shouldBlockAnimation(animationTypeState, key))) {
            continue;
        }
        const valueTransition = {
            delay,
            ...getValueTransition(transition || {}, key),
        };
        /**
         * If this is the first time a value is being animated, check
         * to see if we're handling off from an existing animation.
         */
        let isHandoff = false;
        if (window.MotionHandoffAnimation) {
            const appearId = getOptimisedAppearId(visualElement);
            if (appearId) {
                const startTime = window.MotionHandoffAnimation(appearId, key, frame);
                if (startTime !== null) {
                    valueTransition.startTime = startTime;
                    isHandoff = true;
                }
            }
        }
        addValueToWillChange(visualElement, key);
        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)
            ? { type: false }
            : valueTransition, visualElement, isHandoff));
        const animation = value.animation;
        if (animation) {
            animations.push(animation);
        }
    }
    if (transitionEnd) {
        Promise.all(animations).then(() => {
            frame.update(() => {
                transitionEnd && setTarget(visualElement, transitionEnd);
            });
        });
    }
    return animations;
}

function animateVariant(visualElement, variant, options = {}) {
    var _a;
    const resolved = resolveVariant(visualElement, variant, options.type === "exit"
        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom
        : undefined);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
        transition = options.transitionOverride;
    }
    /**
     * If we have a variant, create a callback that runs it as an animation.
     * Otherwise, we resolve a Promise immediately for a composable no-op.
     */
    const getAnimation = resolved
        ? () => Promise.all(animateTarget(visualElement, resolved, options))
        : () => Promise.resolve();
    /**
     * If we have children, create a callback that runs all their animations.
     * Otherwise, we resolve a Promise immediately for a composable no-op.
     */
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size
        ? (forwardDelay = 0) => {
            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;
            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
        }
        : () => Promise.resolve();
    /**
     * If the transition explicitly defines a "when" option, we need to resolve either
     * this animation or all children animations before playing the other.
     */
    const { when } = transition;
    if (when) {
        const [first, last] = when === "beforeChildren"
            ? [getAnimation, getChildAnimations]
            : [getChildAnimations, getAnimation];
        return first().then(() => last());
    }
    else {
        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations = [];
    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
    const generateStaggerDuration = staggerDirection === 1
        ? (i = 0) => i * staggerChildren
        : (i = 0) => maxStaggerDuration - i * staggerChildren;
    Array.from(visualElement.variantChildren)
        .sort(sortByTreeOrder)
        .forEach((child, i) => {
        child.notify("AnimationStart", variant);
        animations.push(animateVariant(child, variant, {
            ...options,
            delay: delayChildren + generateStaggerDuration(i),
        }).then(() => child.notify("AnimationComplete", variant)));
    });
    return Promise.all(animations);
}
function sortByTreeOrder(a, b) {
    return a.sortNodePosition(b);
}

function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));
        animation = Promise.all(animations);
    }
    else if (typeof definition === "string") {
        animation = animateVariant(visualElement, definition, options);
    }
    else {
        const resolvedDefinition = typeof definition === "function"
            ? resolveVariant(visualElement, definition, options.custom)
            : definition;
        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
        visualElement.notify("AnimationComplete", definition);
    });
}

const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
    if (!visualElement)
        return undefined;
    if (!visualElement.isControllingVariants) {
        const context = visualElement.parent
            ? getVariantContext(visualElement.parent) || {}
            : {};
        if (visualElement.props.initial !== undefined) {
            context.initial = visualElement.props.initial;
        }
        return context;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
        const name = variantProps[i];
        const prop = visualElement.props[name];
        if (isVariantLabel(prop) || prop === false) {
            context[name] = prop;
        }
    }
    return context;
}

const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state = createState();
    let isInitialRender = true;
    /**
     * This function will be used to reduce the animation definitions for
     * each active animation type into an object of resolved values for it.
     */
    const buildResolvedTypeValues = (type) => (acc, definition) => {
        var _a;
        const resolved = resolveVariant(visualElement, definition, type === "exit"
            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom
            : undefined);
        if (resolved) {
            const { transition, transitionEnd, ...target } = resolved;
            acc = { ...acc, ...target, ...transitionEnd };
        }
        return acc;
    };
    /**
     * This just allows us to inject mocked animation functions
     * @internal
     */
    function setAnimateFunction(makeAnimator) {
        animate = makeAnimator(visualElement);
    }
    /**
     * When we receive new props, we need to:
     * 1. Create a list of protected keys for each type. This is a directory of
     *    value keys that are currently being "handled" by types of a higher priority
     *    so that whenever an animation is played of a given type, these values are
     *    protected from being animated.
     * 2. Determine if an animation type needs animating.
     * 3. Determine if any values have been removed from a type and figure out
     *    what to animate those to.
     */
    function animateChanges(changedActiveType) {
        const { props } = visualElement;
        const context = getVariantContext(visualElement.parent) || {};
        /**
         * A list of animations that we'll build into as we iterate through the animation
         * types. This will get executed at the end of the function.
         */
        const animations = [];
        /**
         * Keep track of which values have been removed. Then, as we hit lower priority
         * animation types, we can check if they contain removed values and animate to that.
         */
        const removedKeys = new Set();
        /**
         * A dictionary of all encountered keys. This is an object to let us build into and
         * copy it without iteration. Each time we hit an animation type we set its protected
         * keys - the keys its not allowed to animate - to the latest version of this object.
         */
        let encounteredKeys = {};
        /**
         * If a variant has been removed at a given index, and this component is controlling
         * variant animations, we want to ensure lower-priority variants are forced to animate.
         */
        let removedVariantIndex = Infinity;
        /**
         * Iterate through all animation types in reverse priority order. For each, we want to
         * detect which values it's handling and whether or not they've changed (and therefore
         * need to be animated). If any values have been removed, we want to detect those in
         * lower priority props and flag for animation.
         */
        for (let i = 0; i < numAnimationTypes; i++) {
            const type = reversePriorityOrder[i];
            const typeState = state[type];
            const prop = props[type] !== undefined
                ? props[type]
                : context[type];
            const propIsVariant = isVariantLabel(prop);
            /**
             * If this type has *just* changed isActive status, set activeDelta
             * to that status. Otherwise set to null.
             */
            const activeDelta = type === changedActiveType ? typeState.isActive : null;
            if (activeDelta === false)
                removedVariantIndex = i;
            /**
             * If this prop is an inherited variant, rather than been set directly on the
             * component itself, we want to make sure we allow the parent to trigger animations.
             *
             * TODO: Can probably change this to a !isControllingVariants check
             */
            let isInherited = prop === context[type] &&
                prop !== props[type] &&
                propIsVariant;
            /**
             *
             */
            if (isInherited &&
                isInitialRender &&
                visualElement.manuallyAnimateOnMount) {
                isInherited = false;
            }
            /**
             * Set all encountered keys so far as the protected keys for this type. This will
             * be any key that has been animated or otherwise handled by active, higher-priortiy types.
             */
            typeState.protectedKeys = { ...encounteredKeys };
            // Check if we can skip analysing this prop early
            if (
            // If it isn't active and hasn't *just* been set as inactive
            (!typeState.isActive && activeDelta === null) ||
                // If we didn't and don't have any defined prop for this animation type
                (!prop && !typeState.prevProp) ||
                // Or if the prop doesn't define an animation
                isAnimationControls(prop) ||
                typeof prop === "boolean") {
                continue;
            }
            /**
             * As we go look through the values defined on this type, if we detect
             * a changed value or a value that was removed in a higher priority, we set
             * this to true and add this prop to the animation list.
             */
            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
            let shouldAnimateType = variantDidChange ||
                // If we're making this variant active, we want to always make it active
                (type === changedActiveType &&
                    typeState.isActive &&
                    !isInherited &&
                    propIsVariant) ||
                // If we removed a higher-priority variant (i is in reverse order)
                (i > removedVariantIndex && propIsVariant);
            let handledRemovedValues = false;
            /**
             * As animations can be set as variant lists, variants or target objects, we
             * coerce everything to an array if it isn't one already
             */
            const definitionList = Array.isArray(prop) ? prop : [prop];
            /**
             * Build an object of all the resolved values. We'll use this in the subsequent
             * animateChanges calls to determine whether a value has changed.
             */
            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
            if (activeDelta === false)
                resolvedValues = {};
            /**
             * Now we need to loop through all the keys in the prev prop and this prop,
             * and decide:
             * 1. If the value has changed, and needs animating
             * 2. If it has been removed, and needs adding to the removedKeys set
             * 3. If it has been removed in a higher priority type and needs animating
             * 4. If it hasn't been removed in a higher priority but hasn't changed, and
             *    needs adding to the type's protectedKeys list.
             */
            const { prevResolvedValues = {} } = typeState;
            const allKeys = {
                ...prevResolvedValues,
                ...resolvedValues,
            };
            const markToAnimate = (key) => {
                shouldAnimateType = true;
                if (removedKeys.has(key)) {
                    handledRemovedValues = true;
                    removedKeys.delete(key);
                }
                typeState.needsAnimating[key] = true;
                const motionValue = visualElement.getValue(key);
                if (motionValue)
                    motionValue.liveStyle = false;
            };
            for (const key in allKeys) {
                const next = resolvedValues[key];
                const prev = prevResolvedValues[key];
                // If we've already handled this we can just skip ahead
                if (encounteredKeys.hasOwnProperty(key))
                    continue;
                /**
                 * If the value has changed, we probably want to animate it.
                 */
                let valueHasChanged = false;
                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
                    valueHasChanged = !shallowCompare(next, prev);
                }
                else {
                    valueHasChanged = next !== prev;
                }
                if (valueHasChanged) {
                    if (next !== undefined && next !== null) {
                        // If next is defined and doesn't equal prev, it needs animating
                        markToAnimate(key);
                    }
                    else {
                        // If it's undefined, it's been removed.
                        removedKeys.add(key);
                    }
                }
                else if (next !== undefined && removedKeys.has(key)) {
                    /**
                     * If next hasn't changed and it isn't undefined, we want to check if it's
                     * been removed by a higher priority
                     */
                    markToAnimate(key);
                }
                else {
                    /**
                     * If it hasn't changed, we add it to the list of protected values
                     * to ensure it doesn't get animated.
                     */
                    typeState.protectedKeys[key] = true;
                }
            }
            /**
             * Update the typeState so next time animateChanges is called we can compare the
             * latest prop and resolvedValues to these.
             */
            typeState.prevProp = prop;
            typeState.prevResolvedValues = resolvedValues;
            /**
             *
             */
            if (typeState.isActive) {
                encounteredKeys = { ...encounteredKeys, ...resolvedValues };
            }
            if (isInitialRender && visualElement.blockInitialAnimation) {
                shouldAnimateType = false;
            }
            /**
             * If this is an inherited prop we want to skip this animation
             * unless the inherited variants haven't changed on this render.
             */
            const willAnimateViaParent = isInherited && variantDidChange;
            const needsAnimating = !willAnimateViaParent || handledRemovedValues;
            if (shouldAnimateType && needsAnimating) {
                animations.push(...definitionList.map((animation) => ({
                    animation: animation,
                    options: { type },
                })));
            }
        }
        /**
         * If there are some removed value that haven't been dealt with,
         * we need to create a new animation that falls back either to the value
         * defined in the style prop, or the last read value.
         */
        if (removedKeys.size) {
            const fallbackAnimation = {};
            removedKeys.forEach((key) => {
                const fallbackTarget = visualElement.getBaseTarget(key);
                const motionValue = visualElement.getValue(key);
                if (motionValue)
                    motionValue.liveStyle = true;
                // @ts-expect-error - @mattgperry to figure if we should do something here
                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
            });
            animations.push({ animation: fallbackAnimation });
        }
        let shouldAnimate = Boolean(animations.length);
        if (isInitialRender &&
            (props.initial === false || props.initial === props.animate) &&
            !visualElement.manuallyAnimateOnMount) {
            shouldAnimate = false;
        }
        isInitialRender = false;
        return shouldAnimate ? animate(animations) : Promise.resolve();
    }
    /**
     * Change whether a certain animation type is active.
     */
    function setActive(type, isActive) {
        var _a;
        // If the active state hasn't changed, we can safely do nothing here
        if (state[type].isActive === isActive)
            return Promise.resolve();
        // Propagate active change to children
        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });
        state[type].isActive = isActive;
        const animations = animateChanges(type);
        for (const key in state) {
            state[key].protectedKeys = {};
        }
        return animations;
    }
    return {
        animateChanges,
        setActive,
        setAnimateFunction,
        getState: () => state,
        reset: () => {
            state = createState();
            isInitialRender = true;
        },
    };
}
function checkVariantsDidChange(prev, next) {
    if (typeof next === "string") {
        return next !== prev;
    }
    else if (Array.isArray(next)) {
        return !shallowCompare(next, prev);
    }
    return false;
}
function createTypeState(isActive = false) {
    return {
        isActive,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {},
    };
}
function createState() {
    return {
        animate: createTypeState(true),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState(),
    };
}

class Feature {
    constructor(node) {
        this.isMounted = false;
        this.node = node;
    }
    update() { }
}

class AnimationFeature extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
        super(node);
        node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
        if (isAnimationControls(animate)) {
            this.unmountControls = animate.subscribe(this.node);
        }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
        this.updateAnimationControlsSubscription();
    }
    update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
            this.updateAnimationControlsSubscription();
        }
    }
    unmount() {
        var _a;
        this.node.animationState.reset();
        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
    }
}

let id$1 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments);
        this.id = id$1++;
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const { isPresent, onExitComplete } = this.node.presenceContext;
        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || isPresent === prevIsPresent) {
            return;
        }
        const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
        if (onExitComplete && !isPresent) {
            exitAnimation.then(() => onExitComplete(this.id));
        }
    }
    mount() {
        const { register } = this.node.presenceContext || {};
        if (register) {
            this.unmount = register(this.id);
        }
    }
    unmount() { }
}

const animations = {
    animation: {
        Feature: AnimationFeature,
    },
    exit: {
        Feature: ExitAnimationFeature,
    },
};

const isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
        return typeof event.button !== "number" || event.button <= 0;
    }
    else {
        /**
         * isPrimary is true for all mice buttons, whereas every touch point
         * is regarded as its own input. So subsequent concurrent touch points
         * will be false.
         *
         * Specifically match against false here as incomplete versions of
         * PointerEvents in very old browser might have it set as undefined.
         */
        return event.isPrimary !== false;
    }
};

function extractEventInfo(event, pointType = "page") {
    return {
        point: {
            x: event[`${pointType}X`],
            y: event[`${pointType}Y`],
        },
    };
}
const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};

function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
}

function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
}

const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
    // Multi-dimensional
    const xDelta = distance(a.x, b.x);
    const yDelta = distance(a.y, b.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}

/**
 * @internal
 */
class PanSession {
    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
        /**
         * @internal
         */
        this.startEvent = null;
        /**
         * @internal
         */
        this.lastMoveEvent = null;
        /**
         * @internal
         */
        this.lastMoveEventInfo = null;
        /**
         * @internal
         */
        this.handlers = {};
        /**
         * @internal
         */
        this.contextWindow = window;
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const info = getPanInfo(this.lastMoveEventInfo, this.history);
            const isPanStarted = this.startEvent !== null;
            // Only start panning if the offset is larger than 3 pixels. If we make it
            // any larger than this we'll want to reset the pointer history
            // on the first update to avoid visual snapping to the cursoe.
            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;
            if (!isPanStarted && !isDistancePastThreshold)
                return;
            const { point } = info;
            const { timestamp } = frameData;
            this.history.push({ ...point, timestamp });
            const { onStart, onMove } = this.handlers;
            if (!isPanStarted) {
                onStart && onStart(this.lastMoveEvent, info);
                this.startEvent = this.lastMoveEvent;
            }
            onMove && onMove(this.lastMoveEvent, info);
        };
        this.handlePointerMove = (event, info) => {
            this.lastMoveEvent = event;
            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
            // Throttle mouse move event to once per frame
            frame.update(this.updatePoint, true);
        };
        this.handlePointerUp = (event, info) => {
            this.end();
            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
            if (this.dragSnapToOrigin)
                resumeAnimation && resumeAnimation();
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const panInfo = getPanInfo(event.type === "pointercancel"
                ? this.lastMoveEventInfo
                : transformPoint(info, this.transformPagePoint), this.history);
            if (this.startEvent && onEnd) {
                onEnd(event, panInfo);
            }
            onSessionEnd && onSessionEnd(event, panInfo);
        };
        // If we have more than one touch, don't start detecting this gesture
        if (!isPrimaryPointer(event))
            return;
        this.dragSnapToOrigin = dragSnapToOrigin;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        this.contextWindow = contextWindow || window;
        const info = extractEventInfo(event);
        const initialInfo = transformPoint(info, this.transformPagePoint);
        const { point } = initialInfo;
        const { timestamp } = frameData;
        this.history = [{ ...point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart &&
            onSessionStart(event, getPanInfo(initialInfo, this.history));
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
        this.handlers = handlers;
    }
    end() {
        this.removeListeners && this.removeListeners();
        cancelFrame(this.updatePoint);
    }
}
function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
    return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
    return {
        point,
        delta: subtractPoint(point, lastDevicePoint(history)),
        offset: subtractPoint(point, startDevicePoint(history)),
        velocity: getVelocity(history, 0.1),
    };
}
function startDevicePoint(history) {
    return history[0];
}
function lastDevicePoint(history) {
    return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
    if (history.length < 2) {
        return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp >
            secondsToMilliseconds(timeDelta)) {
            break;
        }
        i--;
    }
    if (!timestampedPoint) {
        return { x: 0, y: 0 };
    }
    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time === 0) {
        return { x: 0, y: 0 };
    }
    const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time,
    };
    if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
    }
    return currentVelocity;
}

function createLock(name) {
    let lock = null;
    return () => {
        const openLock = () => {
            lock = null;
        };
        if (lock === null) {
            lock = name;
            return openLock;
        }
        return false;
    };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag) {
    let lock = false;
    if (drag === "y") {
        lock = globalVerticalLock();
    }
    else if (drag === "x") {
        lock = globalHorizontalLock();
    }
    else {
        const openHorizontal = globalHorizontalLock();
        const openVertical = globalVerticalLock();
        if (openHorizontal && openVertical) {
            lock = () => {
                openHorizontal();
                openVertical();
            };
        }
        else {
            // Release the locks because we don't use them
            if (openHorizontal)
                openHorizontal();
            if (openVertical)
                openVertical();
        }
    }
    return lock;
}
function isDragActive() {
    // Check the gesture lock - if we get it, it means no drag gesture is active
    // and we can safely fire the tap gesture.
    const openGestureLock = getGlobalLock(true);
    if (!openGestureLock)
        return true;
    openGestureLock();
    return false;
}

function isRefObject(ref) {
    return (ref &&
        typeof ref === "object" &&
        Object.prototype.hasOwnProperty.call(ref, "current"));
}

const SCALE_PRECISION = 0.0001;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
    return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate =
        mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||
        isNaN(delta.scale)) {
        delta.scale = 1.0;
    }
    if ((delta.translate >= TRANSLATE_MIN &&
        delta.translate <= TRANSLATE_MAX) ||
        isNaN(delta.translate)) {
        delta.translate = 0.0;
    }
}
function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);
}
function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
    target.min = layout.min - parent.min;
    target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
    calcRelativeAxisPosition(target.x, layout.x, parent.x);
    calcRelativeAxisPosition(target.y, layout.y, parent.y);
}

/**
 * Apply constraints to a point. These constraints are both physical along an
 * axis, and an elastic factor that determines how much to constrain the point
 * by if it does lie outside the defined parameters.
 */
function applyConstraints(point, { min, max }, elastic) {
    if (min !== undefined && point < min) {
        // If we have a min point defined, and this is outside of that, constrain
        point = elastic
            ? mixNumber$1(min, point, elastic.min)
            : Math.max(point, min);
    }
    else if (max !== undefined && point > max) {
        // If we have a max point defined, and this is outside of that, constrain
        point = elastic
            ? mixNumber$1(max, point, elastic.max)
            : Math.min(point, max);
    }
    return point;
}
/**
 * Calculate constraints in terms of the viewport when defined relatively to the
 * measured axis. This is measured from the nearest edge, so a max constraint of 200
 * on an axis with a max value of 300 would return a constraint of 500 - axis length
 */
function calcRelativeAxisConstraints(axis, min, max) {
    return {
        min: min !== undefined ? axis.min + min : undefined,
        max: max !== undefined
            ? axis.max + max - (axis.max - axis.min)
            : undefined,
    };
}
/**
 * Calculate constraints in terms of the viewport when
 * defined relatively to the measured bounding box.
 */
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
        x: calcRelativeAxisConstraints(layoutBox.x, left, right),
        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
    };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative axis
 */
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min = constraintsAxis.min - layoutAxis.min;
    let max = constraintsAxis.max - layoutAxis.max;
    // If the constraints axis is actually smaller than the layout axis then we can
    // flip the constraints
    if (constraintsAxis.max - constraintsAxis.min <
        layoutAxis.max - layoutAxis.min) {
        [min, max] = [max, min];
    }
    return { min, max };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative box
 */
function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
    };
}
/**
 * Calculate a transform origin relative to the source axis, between 0-1, that results
 * in an asthetically pleasing scale/transform needed to project from source to target.
 */
function calcOrigin$1(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
        origin = progress(target.min, target.max - sourceLength, source.min);
    }
    else if (sourceLength > targetLength) {
        origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp$1(0, 1, origin);
}
/**
 * Rebase the calculated viewport constraints relative to the layout.min point.
 */
function rebaseAxisConstraints(layout, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== undefined) {
        relativeConstraints.min = constraints.min - layout.min;
    }
    if (constraints.max !== undefined) {
        relativeConstraints.max = constraints.max - layout.min;
    }
    return relativeConstraints;
}
const defaultElastic = 0.35;
/**
 * Accepts a dragElastic prop and returns resolved elastic values for each axis.
 */
function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
        dragElastic = 0;
    }
    else if (dragElastic === true) {
        dragElastic = defaultElastic;
    }
    return {
        x: resolveAxisElastic(dragElastic, "left", "right"),
        y: resolveAxisElastic(dragElastic, "top", "bottom"),
    };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
        min: resolvePointElastic(dragElastic, minLabel),
        max: resolvePointElastic(dragElastic, maxLabel),
    };
}
function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number"
        ? dragElastic
        : dragElastic[label] || 0;
}

const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
});
const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta(),
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
    x: createAxis(),
    y: createAxis(),
});

function eachAxis(callback) {
    return [callback("x"), callback("y")];
}

/**
 * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
 * it's easier to consider each axis individually. This function returns a bounding box
 * as a map of single-axis min/max values.
 */
function convertBoundingBoxToBox({ top, left, right, bottom, }) {
    return {
        x: { min: left, max: right },
        y: { min: top, max: bottom },
    };
}
function convertBoxToBoundingBox({ x, y }) {
    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
/**
 * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
 * provided by Framer to allow measured points to be corrected for device scaling. This is used
 * when measuring DOM elements and DOM event points.
 */
function transformBoxPoints(point, transformPoint) {
    if (!transformPoint)
        return point;
    const topLeft = transformPoint({ x: point.left, y: point.top });
    const bottomRight = transformPoint({ x: point.right, y: point.bottom });
    return {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x,
    };
}

function isIdentityScale(scale) {
    return scale === undefined || scale === 1;
}
function hasScale({ scale, scaleX, scaleY }) {
    return (!isIdentityScale(scale) ||
        !isIdentityScale(scaleX) ||
        !isIdentityScale(scaleY));
}
function hasTransform(values) {
    return (hasScale(values) ||
        has2DTranslate(values) ||
        values.z ||
        values.rotate ||
        values.rotateX ||
        values.rotateY ||
        values.skewX ||
        values.skewY);
}
function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
    return value && value !== "0%";
}

/**
 * Scales a point based on a factor and an originPoint
 */
function scalePoint(point, scale, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale * distanceFromOrigin;
    return originPoint + scaled;
}
/**
 * Applies a translate/scale delta to a point
 */
function applyPointDelta(point, translate, scale, originPoint, boxScale) {
    if (boxScale !== undefined) {
        point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale, originPoint) + translate;
}
/**
 * Applies a translate/scale delta to an axis
 */
function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Applies a translate/scale delta to a box
 */
function applyBoxDelta(box, { x, y }) {
    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
/**
 * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
 * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
 *
 * This is the final nested loop within updateLayoutDelta for future refactoring
 */
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
        return;
    // Reset the treeScale
    treeScale.x = treeScale.y = 1;
    let node;
    let delta;
    for (let i = 0; i < treeLength; i++) {
        node = treePath[i];
        delta = node.projectionDelta;
        /**
         * TODO: Prefer to remove this, but currently we have motion components with
         * display: contents in Framer.
         */
        const { visualElement } = node.options;
        if (visualElement &&
            visualElement.props.style &&
            visualElement.props.style.display === "contents") {
            continue;
        }
        if (isSharedTransition &&
            node.options.layoutScroll &&
            node.scroll &&
            node !== node.root) {
            transformBox(box, {
                x: -node.scroll.offset.x,
                y: -node.scroll.offset.y,
            });
        }
        if (delta) {
            // Incoporate each ancestor's scale into a culmulative treeScale for this component
            treeScale.x *= delta.x.scale;
            treeScale.y *= delta.y.scale;
            // Apply each ancestor's calculated delta into this component's recorded layout box
            applyBoxDelta(box, delta);
        }
        if (isSharedTransition && hasTransform(node.latestValues)) {
            transformBox(box, node.latestValues);
        }
    }
    /**
     * Snap tree scale back to 1 if it's within a non-perceivable threshold.
     * This will help reduce useless scales getting rendered.
     */
    if (treeScale.x < TREE_SCALE_SNAP_MAX &&
        treeScale.x > TREE_SCALE_SNAP_MIN) {
        treeScale.x = 1.0;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX &&
        treeScale.y > TREE_SCALE_SNAP_MIN) {
        treeScale.y = 1.0;
    }
}
function translateAxis(axis, distance) {
    axis.min = axis.min + distance;
    axis.max = axis.max + distance;
}
/**
 * Apply a transform to an axis from the latest resolved motion values.
 * This function basically acts as a bridge between a flat motion value map
 * and applyAxisDelta
 */
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
    // Apply the axis delta to the final axis
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
/**
 * Apply a transform to a box from the latest resolved motion values.
 */
function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}

function measureViewportBox(instance, transformPoint) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
}
function measurePageBox(element, rootProjectionNode, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode;
    if (scroll) {
        translateAxis(viewportBox.x, scroll.offset.x);
        translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
}

// Fixes https://github.com/framer/motion/issues/2270
const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
};

const elementDragControls = new WeakMap();
/**
 *
 */
// let latestPointerEvent: PointerEvent
class VisualElementDragControls {
    constructor(visualElement) {
        // This is a reference to the global drag gesture lock, ensuring only one component
        // can "capture" the drag of one or both axes.
        // TODO: Look into moving this into pansession?
        this.openGlobalLock = null;
        this.isDragging = false;
        this.currentDirection = null;
        this.originPoint = { x: 0, y: 0 };
        /**
         * The permitted boundaries of travel, in pixels.
         */
        this.constraints = false;
        this.hasMutatedConstraints = false;
        /**
         * The per-axis resolved elastic values.
         */
        this.elastic = createBox();
        this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false } = {}) {
        /**
         * Don't start dragging if this component is exiting
         */
        const { presenceContext } = this.visualElement;
        if (presenceContext && presenceContext.isPresent === false)
            return;
        const onSessionStart = (event) => {
            const { dragSnapToOrigin } = this.getProps();
            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch
            // the component.
            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
            if (snapToCursor) {
                this.snapToCursor(extractEventInfo(event, "page").point);
            }
        };
        const onStart = (event, info) => {
            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
            const { drag, dragPropagation, onDragStart } = this.getProps();
            if (drag && !dragPropagation) {
                if (this.openGlobalLock)
                    this.openGlobalLock();
                this.openGlobalLock = getGlobalLock(drag);
                // If we don 't have the lock, don't start dragging
                if (!this.openGlobalLock)
                    return;
            }
            this.isDragging = true;
            this.currentDirection = null;
            this.resolveConstraints();
            if (this.visualElement.projection) {
                this.visualElement.projection.isAnimationBlocked = true;
                this.visualElement.projection.target = undefined;
            }
            /**
             * Record gesture origin
             */
            eachAxis((axis) => {
                let current = this.getAxisMotionValue(axis).get() || 0;
                /**
                 * If the MotionValue is a percentage value convert to px
                 */
                if (percent.test(current)) {
                    const { projection } = this.visualElement;
                    if (projection && projection.layout) {
                        const measuredAxis = projection.layout.layoutBox[axis];
                        if (measuredAxis) {
                            const length = calcLength(measuredAxis);
                            current = length * (parseFloat(current) / 100);
                        }
                    }
                }
                this.originPoint[axis] = current;
            });
            // Fire onDragStart event
            if (onDragStart) {
                frame.postRender(() => onDragStart(event, info));
            }
            addValueToWillChange(this.visualElement, "transform");
            const { animationState } = this.visualElement;
            animationState && animationState.setActive("whileDrag", true);
        };
        const onMove = (event, info) => {
            // latestPointerEvent = event
            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
            // If we didn't successfully receive the gesture lock, early return.
            if (!dragPropagation && !this.openGlobalLock)
                return;
            const { offset } = info;
            // Attempt to detect drag direction if directionLock is true
            if (dragDirectionLock && this.currentDirection === null) {
                this.currentDirection = getCurrentDirection(offset);
                // If we've successfully set a direction, notify listener
                if (this.currentDirection !== null) {
                    onDirectionLock && onDirectionLock(this.currentDirection);
                }
                return;
            }
            // Update each point with the latest position
            this.updateAxis("x", info.point, offset);
            this.updateAxis("y", info.point, offset);
            /**
             * Ideally we would leave the renderer to fire naturally at the end of
             * this frame but if the element is about to change layout as the result
             * of a re-render we want to ensure the browser can read the latest
             * bounding box to ensure the pointer and element don't fall out of sync.
             */
            this.visualElement.render();
            /**
             * This must fire after the render call as it might trigger a state
             * change which itself might trigger a layout update.
             */
            onDrag && onDrag(event, info);
        };
        const onSessionEnd = (event, info) => this.stop(event, info);
        const resumeAnimation = () => eachAxis((axis) => {
            var _a;
            return this.getAnimationState(axis) === "paused" &&
                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
        });
        const { dragSnapToOrigin } = this.getProps();
        this.panSession = new PanSession(originEvent, {
            onSessionStart,
            onStart,
            onMove,
            onSessionEnd,
            resumeAnimation,
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin,
            contextWindow: getContextWindow(this.visualElement),
        });
    }
    stop(event, info) {
        const isDragging = this.isDragging;
        this.cancel();
        if (!isDragging)
            return;
        const { velocity } = info;
        this.startAnimation(velocity);
        const { onDragEnd } = this.getProps();
        if (onDragEnd) {
            frame.postRender(() => onDragEnd(event, info));
        }
    }
    cancel() {
        this.isDragging = false;
        const { projection, animationState } = this.visualElement;
        if (projection) {
            projection.isAnimationBlocked = false;
        }
        this.panSession && this.panSession.end();
        this.panSession = undefined;
        const { dragPropagation } = this.getProps();
        if (!dragPropagation && this.openGlobalLock) {
            this.openGlobalLock();
            this.openGlobalLock = null;
        }
        animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset) {
        const { drag } = this.getProps();
        // If we're not dragging this axis, do an early return.
        if (!offset || !shouldDrag(axis, drag, this.currentDirection))
            return;
        const axisValue = this.getAxisMotionValue(axis);
        let next = this.originPoint[axis] + offset[axis];
        // Apply constraints
        if (this.constraints && this.constraints[axis]) {
            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
        }
        axisValue.set(next);
    }
    resolveConstraints() {
        var _a;
        const { dragConstraints, dragElastic } = this.getProps();
        const layout = this.visualElement.projection &&
            !this.visualElement.projection.layout
            ? this.visualElement.projection.measure(false)
            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
        const prevConstraints = this.constraints;
        if (dragConstraints && isRefObject(dragConstraints)) {
            if (!this.constraints) {
                this.constraints = this.resolveRefConstraints();
            }
        }
        else {
            if (dragConstraints && layout) {
                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
            }
            else {
                this.constraints = false;
            }
        }
        this.elastic = resolveDragElastic(dragElastic);
        /**
         * If we're outputting to external MotionValues, we want to rebase the measured constraints
         * from viewport-relative to component-relative.
         */
        if (prevConstraints !== this.constraints &&
            layout &&
            this.constraints &&
            !this.hasMutatedConstraints) {
            eachAxis((axis) => {
                if (this.constraints !== false &&
                    this.getAxisMotionValue(axis)) {
                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
                }
            });
        }
    }
    resolveRefConstraints() {
        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
        if (!constraints || !isRefObject(constraints))
            return false;
        const constraintsElement = constraints.current;
        const { projection } = this.visualElement;
        // TODO
        if (!projection || !projection.layout)
            return false;
        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
        /**
         * If there's an onMeasureDragConstraints listener we call it and
         * if different constraints are returned, set constraints to that
         */
        if (onMeasureDragConstraints) {
            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
            this.hasMutatedConstraints = !!userConstraints;
            if (userConstraints) {
                measuredConstraints = convertBoundingBoxToBox(userConstraints);
            }
        }
        return measuredConstraints;
    }
    startAnimation(velocity) {
        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();
        const constraints = this.constraints || {};
        const momentumAnimations = eachAxis((axis) => {
            if (!shouldDrag(axis, drag, this.currentDirection)) {
                return;
            }
            let transition = (constraints && constraints[axis]) || {};
            if (dragSnapToOrigin)
                transition = { min: 0, max: 0 };
            /**
             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
             * of spring animations so we should look into adding a disable spring option to `inertia`.
             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
             * using the value of `dragElastic`.
             */
            const bounceStiffness = dragElastic ? 200 : 1000000;
            const bounceDamping = dragElastic ? 40 : 10000000;
            const inertia = {
                type: "inertia",
                velocity: dragMomentum ? velocity[axis] : 0,
                bounceStiffness,
                bounceDamping,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...dragTransition,
                ...transition,
            };
            // If we're not animating on an externally-provided `MotionValue` we can use the
            // component's animation controls which will handle interactions with whileHover (etc),
            // otherwise we just have to animate the `MotionValue` itself.
            return this.startAxisValueAnimation(axis, inertia);
        });
        // Run all animations and then resolve the new drag constraints.
        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
        const axisValue = this.getAxisMotionValue(axis);
        addValueToWillChange(this.visualElement, axis);
        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });
    }
    getAnimationState(axis) {
        var _a;
        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
    }
    /**
     * Drag works differently depending on which props are provided.
     *
     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
     * - Otherwise, we apply the delta to the x/y motion values.
     */
    getAxisMotionValue(axis) {
        const dragKey = `_drag${axis.toUpperCase()}`;
        const props = this.visualElement.getProps();
        const externalMotionValue = props[dragKey];
        return externalMotionValue
            ? externalMotionValue
            : this.visualElement.getValue(axis, (props.initial
                ? props.initial[axis]
                : undefined) || 0);
    }
    snapToCursor(point) {
        eachAxis((axis) => {
            const { drag } = this.getProps();
            // If we're not dragging this axis, do an early return.
            if (!shouldDrag(axis, drag, this.currentDirection))
                return;
            const { projection } = this.visualElement;
            const axisValue = this.getAxisMotionValue(axis);
            if (projection && projection.layout) {
                const { min, max } = projection.layout.layoutBox[axis];
                axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));
            }
        });
    }
    /**
     * When the viewport resizes we want to check if the measured constraints
     * have changed and, if so, reposition the element within those new constraints
     * relative to where it was before the resize.
     */
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const { drag, dragConstraints } = this.getProps();
        const { projection } = this.visualElement;
        if (!isRefObject(dragConstraints) || !projection || !this.constraints)
            return;
        /**
         * Stop current animations as there can be visual glitching if we try to do
         * this mid-animation
         */
        this.stopAnimation();
        /**
         * Record the relative position of the dragged element relative to the
         * constraints box and save as a progress value.
         */
        const boxProgress = { x: 0, y: 0 };
        eachAxis((axis) => {
            const axisValue = this.getAxisMotionValue(axis);
            if (axisValue && this.constraints !== false) {
                const latest = axisValue.get();
                boxProgress[axis] = calcOrigin$1({ min: latest, max: latest }, this.constraints[axis]);
            }
        });
        /**
         * Update the layout of this element and resolve the latest drag constraints
         */
        const { transformTemplate } = this.visualElement.getProps();
        this.visualElement.current.style.transform = transformTemplate
            ? transformTemplate({}, "")
            : "none";
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
        this.resolveConstraints();
        /**
         * For each axis, calculate the current progress of the layout axis
         * within the new constraints.
         */
        eachAxis((axis) => {
            if (!shouldDrag(axis, drag, null))
                return;
            /**
             * Calculate a new transform based on the previous box progress
             */
            const axisValue = this.getAxisMotionValue(axis);
            const { min, max } = this.constraints[axis];
            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
        });
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        elementDragControls.set(this.visualElement, this);
        const element = this.visualElement.current;
        /**
         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
         */
        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
            const { drag, dragListener = true } = this.getProps();
            drag && dragListener && this.start(event);
        });
        const measureDragConstraints = () => {
            const { dragConstraints } = this.getProps();
            if (isRefObject(dragConstraints) && dragConstraints.current) {
                this.constraints = this.resolveRefConstraints();
            }
        };
        const { projection } = this.visualElement;
        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        if (projection && !projection.layout) {
            projection.root && projection.root.updateScroll();
            projection.updateLayout();
        }
        frame.read(measureDragConstraints);
        /**
         * Attach a window resize listener to scale the draggable target within its defined
         * constraints as the window resizes.
         */
        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
        /**
         * If the element's layout changes, calculate the delta and apply that to
         * the drag gesture's origin point.
         */
        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
            if (this.isDragging && hasLayoutChanged) {
                eachAxis((axis) => {
                    const motionValue = this.getAxisMotionValue(axis);
                    if (!motionValue)
                        return;
                    this.originPoint[axis] += delta[axis].translate;
                    motionValue.set(motionValue.get() + delta[axis].translate);
                });
                this.visualElement.render();
            }
        }));
        return () => {
            stopResizeListener();
            stopPointerListener();
            stopMeasureLayoutListener();
            stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
    }
    getProps() {
        const props = this.visualElement.getProps();
        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;
        return {
            ...props,
            drag,
            dragDirectionLock,
            dragPropagation,
            dragConstraints,
            dragElastic,
            dragMomentum,
        };
    }
}
function shouldDrag(direction, drag, currentDirection) {
    return ((drag === true || drag === direction) &&
        (currentDirection === null || currentDirection === direction));
}
/**
 * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
 * than the provided threshold, return `null`.
 *
 * @param offset - The x/y offset from origin.
 * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
 */
function getCurrentDirection(offset, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset.y) > lockThreshold) {
        direction = "y";
    }
    else if (Math.abs(offset.x) > lockThreshold) {
        direction = "x";
    }
    return direction;
}

class DragGesture extends Feature {
    constructor(node) {
        super(node);
        this.removeGroupControls = noop$1;
        this.removeListeners = noop$1;
        this.controls = new VisualElementDragControls(node);
    }
    mount() {
        // If we've been provided a DragControls for manual control over the drag gesture,
        // subscribe this component to it on mount.
        const { dragControls } = this.node.getProps();
        if (dragControls) {
            this.removeGroupControls = dragControls.subscribe(this.controls);
        }
        this.removeListeners = this.controls.addListeners() || noop$1;
    }
    unmount() {
        this.removeGroupControls();
        this.removeListeners();
    }
}

const asyncHandler = (handler) => (event, info) => {
    if (handler) {
        frame.postRender(() => handler(event, info));
    }
};
class PanGesture extends Feature {
    constructor() {
        super(...arguments);
        this.removePointerDownListener = noop$1;
    }
    onPointerDown(pointerDownEvent) {
        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node),
        });
    }
    createPanHandlers() {
        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
        return {
            onSessionStart: asyncHandler(onPanSessionStart),
            onStart: asyncHandler(onPanStart),
            onMove: onPan,
            onEnd: (event, info) => {
                delete this.session;
                if (onPanEnd) {
                    frame.postRender(() => onPanEnd(event, info));
                }
            },
        };
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
        this.removePointerDownListener();
        this.session && this.session.end();
    }
}

/**
 * @public
 */
const PresenceContext = reactExports.createContext(null);

/**
 * When a component is the child of `AnimatePresence`, it can use `usePresence`
 * to access information about whether it's still present in the React tree.
 *
 * ```jsx
 * import { usePresence } from "framer-motion"
 *
 * export const Component = () => {
 *   const [isPresent, safeToRemove] = usePresence()
 *
 *   useEffect(() => {
 *     !isPresent && setTimeout(safeToRemove, 1000)
 *   }, [isPresent])
 *
 *   return <div />
 * }
 * ```
 *
 * If `isPresent` is `false`, it means that a component has been removed the tree, but
 * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
 *
 * @public
 */
function usePresence() {
    const context = reactExports.useContext(PresenceContext);
    if (context === null)
        return [true, null];
    const { isPresent, onExitComplete, register } = context;
    // It's safe to call the following hooks conditionally (after an early return) because the context will always
    // either be null or non-null for the lifespan of the component.
    const id = reactExports.useId();
    reactExports.useEffect(() => register(id), []);
    const safeToRemove = reactExports.useCallback(() => onExitComplete && onExitComplete(id), [id, onExitComplete]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}

const LayoutGroupContext = reactExports.createContext({});

/**
 * Internal, exported only for usage in Framer
 */
const SwitchLayoutGroupContext = reactExports.createContext({});

/**
 * This should only ever be modified on the client otherwise it'll
 * persist through server requests. If we need instanced states we
 * could lazy-init via root.
 */
const globalProjectionState = {
    /**
     * Global flag as to whether the tree has animated since the last time
     * we resized the window
     */
    hasAnimatedSinceResize: true,
    /**
     * We set this to true once, on the first update. Any nodes added to the tree beyond that
     * update will be given a `data-projection-id` attribute.
     */
    hasEverUpdated: false,
};

function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
        return 0;
    return (pixels / (axis.max - axis.min)) * 100;
}
/**
 * We always correct borderRadius as a percentage rather than pixels to reduce paints.
 * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
 * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
 * borderRadius in both states. If we animate between the two in pixels that will trigger
 * a paint each time. If we animate between the two in percentage we'll avoid a paint.
 */
const correctBorderRadius = {
    correct: (latest, node) => {
        if (!node.target)
            return latest;
        /**
         * If latest is a string, if it's a percentage we can return immediately as it's
         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
         */
        if (typeof latest === "string") {
            if (px.test(latest)) {
                latest = parseFloat(latest);
            }
            else {
                return latest;
            }
        }
        /**
         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
         * pixel value as a percentage of each axis
         */
        const x = pixelsToPercent(latest, node.target.x);
        const y = pixelsToPercent(latest, node.target.y);
        return `${x}% ${y}%`;
    },
};

const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
        const original = latest;
        const shadow = complex.parse(latest);
        // TODO: Doesn't support multiple shadows
        if (shadow.length > 5)
            return original;
        const template = complex.createTransformer(latest);
        const offset = typeof shadow[0] !== "number" ? 1 : 0;
        // Calculate the overall context scale
        const xScale = projectionDelta.x.scale * treeScale.x;
        const yScale = projectionDelta.y.scale * treeScale.y;
        shadow[0 + offset] /= xScale;
        shadow[1 + offset] /= yScale;
        /**
         * Ideally we'd correct x and y scales individually, but because blur and
         * spread apply to both we have to take a scale average and apply that instead.
         * We could potentially improve the outcome of this by incorporating the ratio between
         * the two scales.
         */
        const averageScale = mixNumber$1(xScale, yScale, 0.5);
        // Blur
        if (typeof shadow[2 + offset] === "number")
            shadow[2 + offset] /= averageScale;
        // Spread
        if (typeof shadow[3 + offset] === "number")
            shadow[3 + offset] /= averageScale;
        return template(shadow);
    },
};

const scaleCorrectors = {};
function addScaleCorrector(correctors) {
    Object.assign(scaleCorrectors, correctors);
}

const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

class MeasureLayoutWithContext extends reactExports.Component {
    /**
     * This only mounts projection nodes for components that
     * need measuring, we might want to do it for all components
     * in order to incorporate transforms
     */
    componentDidMount() {
        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
        const { projection } = visualElement;
        addScaleCorrector(defaultScaleCorrectors);
        if (projection) {
            if (layoutGroup.group)
                layoutGroup.group.add(projection);
            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
                switchLayoutGroup.register(projection);
            }
            projection.root.didUpdate();
            projection.addEventListener("animationComplete", () => {
                this.safeToRemove();
            });
            projection.setOptions({
                ...projection.options,
                onExitComplete: () => this.safeToRemove(),
            });
        }
        globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
        const { layoutDependency, visualElement, drag, isPresent } = this.props;
        const projection = visualElement.projection;
        if (!projection)
            return null;
        /**
         * TODO: We use this data in relegate to determine whether to
         * promote a previous element. There's no guarantee its presence data
         * will have updated by this point - if a bug like this arises it will
         * have to be that we markForRelegation and then find a new lead some other way,
         * perhaps in didUpdate
         */
        projection.isPresent = isPresent;
        if (drag ||
            prevProps.layoutDependency !== layoutDependency ||
            layoutDependency === undefined) {
            projection.willUpdate();
        }
        else {
            this.safeToRemove();
        }
        if (prevProps.isPresent !== isPresent) {
            if (isPresent) {
                projection.promote();
            }
            else if (!projection.relegate()) {
                /**
                 * If there's another stack member taking over from this one,
                 * it's in charge of the exit animation and therefore should
                 * be in charge of the safe to remove. Otherwise we call it here.
                 */
                frame.postRender(() => {
                    const stack = projection.getStack();
                    if (!stack || !stack.members.length) {
                        this.safeToRemove();
                    }
                });
            }
        }
        return null;
    }
    componentDidUpdate() {
        const { projection } = this.props.visualElement;
        if (projection) {
            projection.root.didUpdate();
            microtask.postRender(() => {
                if (!projection.currentAnimation && projection.isLead()) {
                    this.safeToRemove();
                }
            });
        }
    }
    componentWillUnmount() {
        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;
        const { projection } = visualElement;
        if (projection) {
            projection.scheduleCheckAfterUnmount();
            if (layoutGroup && layoutGroup.group)
                layoutGroup.group.remove(projection);
            if (promoteContext && promoteContext.deregister)
                promoteContext.deregister(projection);
        }
    }
    safeToRemove() {
        const { safeToRemove } = this.props;
        safeToRemove && safeToRemove();
    }
    render() {
        return null;
    }
}
function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = reactExports.useContext(LayoutGroupContext);
    return (jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));
}
const defaultScaleCorrectors = {
    borderRadius: {
        ...correctBorderRadius,
        applyTo: [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
        ],
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow,
};

const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
        target.opacity = mixNumber$1(0, 
        // TODO Reinstate this if only child
        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));
        target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));
    }
    else if (isOnlyMember) {
        target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);
    }
    /**
     * Mix border radius
     */
    for (let i = 0; i < numBorders; i++) {
        const borderLabel = `border${borders[i]}Radius`;
        let followRadius = getRadius(follow, borderLabel);
        let leadRadius = getRadius(lead, borderLabel);
        if (followRadius === undefined && leadRadius === undefined)
            continue;
        followRadius || (followRadius = 0);
        leadRadius || (leadRadius = 0);
        const canMix = followRadius === 0 ||
            leadRadius === 0 ||
            isPx(followRadius) === isPx(leadRadius);
        if (canMix) {
            target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);
            if (percent.test(leadRadius) || percent.test(followRadius)) {
                target[borderLabel] += "%";
            }
        }
        else {
            target[borderLabel] = leadRadius;
        }
    }
    /**
     * Mix rotation
     */
    if (follow.rotate || lead.rotate) {
        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);
    }
}
function getRadius(values, radiusName) {
    return values[radiusName] !== undefined
        ? values[radiusName]
        : values.borderRadius;
}
// /**
//  * We only want to mix the background color if there's a follow element
//  * that we're not crossfading opacity between. For instance with switch
//  * AnimateSharedLayout animations, this helps the illusion of a continuous
//  * element being animated but also cuts down on the number of paints triggered
//  * for elements where opacity is doing that work for us.
//  */
// if (
//     !hasFollowElement &&
//     latestLeadValues.backgroundColor &&
//     latestFollowValues.backgroundColor
// ) {
//     /**
//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
//      * We could probably create a mixer that runs at the start of the animation but
//      * the idea behind the crossfader is that it runs dynamically between two potentially
//      * changing targets (ie opacity or borderRadius may be animating independently via variants)
//      */
//     leadState.backgroundColor = followState.backgroundColor = mixColor(
//         latestFollowValues.backgroundColor as string,
//         latestLeadValues.backgroundColor as string
//     )(p)
// }
const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop$1);
function compress(min, max, easing) {
    return (p) => {
        // Could replace ifs with clamp
        if (p < min)
            return 0;
        if (p > max)
            return 1;
        return easing(progress(min, max, p));
    };
}

/**
 * Reset an axis to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
}
/**
 * Reset a box to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
}
/**
 * Reset a delta to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
}

/**
 * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
 */
function removePointDelta(point, translate, scale, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale, originPoint);
    if (boxScale !== undefined) {
        point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
}
/**
 * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
 */
function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
        translate = parseFloat(translate);
        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
        translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
        return;
    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
        originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
/**
 * The names of the motion values we want to apply as translation, scale and origin.
 */
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
/**
 * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);
}

function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
    return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
    return (Math.round(a.min) === Math.round(b.min) &&
        Math.round(a.max) === Math.round(b.max));
}
function boxEqualsRounded(a, b) {
    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
    return (a.translate === b.translate &&
        a.scale === b.scale &&
        a.originPoint === b.originPoint);
}

class NodeStack {
    constructor() {
        this.members = [];
    }
    add(node) {
        addUniqueItem(this.members, node);
        node.scheduleRender();
    }
    remove(node) {
        removeItem(this.members, node);
        if (node === this.prevLead) {
            this.prevLead = undefined;
        }
        if (node === this.lead) {
            const prevLead = this.members[this.members.length - 1];
            if (prevLead) {
                this.promote(prevLead);
            }
        }
    }
    relegate(node) {
        const indexOfNode = this.members.findIndex((member) => node === member);
        if (indexOfNode === 0)
            return false;
        /**
         * Find the next projection node that is present
         */
        let prevLead;
        for (let i = indexOfNode; i >= 0; i--) {
            const member = this.members[i];
            if (member.isPresent !== false) {
                prevLead = member;
                break;
            }
        }
        if (prevLead) {
            this.promote(prevLead);
            return true;
        }
        else {
            return false;
        }
    }
    promote(node, preserveFollowOpacity) {
        const prevLead = this.lead;
        if (node === prevLead)
            return;
        this.prevLead = prevLead;
        this.lead = node;
        node.show();
        if (prevLead) {
            prevLead.instance && prevLead.scheduleRender();
            node.scheduleRender();
            node.resumeFrom = prevLead;
            if (preserveFollowOpacity) {
                node.resumeFrom.preserveOpacity = true;
            }
            if (prevLead.snapshot) {
                node.snapshot = prevLead.snapshot;
                node.snapshot.latestValues =
                    prevLead.animationValues || prevLead.latestValues;
            }
            if (node.root && node.root.isUpdating) {
                node.isLayoutDirty = true;
            }
            const { crossfade } = node.options;
            if (crossfade === false) {
                prevLead.hide();
            }
            /**
             * TODO:
             *   - Test border radius when previous node was deleted
             *   - boxShadow mixing
             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
             *   - Shared between element A in transformed container and element B (transform stays the same or changes)
             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
             * ---
             *   - Crossfade opacity of root nodes
             *   - layoutId changes after animation
             *   - layoutId changes mid animation
             */
        }
    }
    exitAnimationComplete() {
        this.members.forEach((node) => {
            const { options, resumingFrom } = node;
            options.onExitComplete && options.onExitComplete();
            if (resumingFrom) {
                resumingFrom.options.onExitComplete &&
                    resumingFrom.options.onExitComplete();
            }
        });
    }
    scheduleRender() {
        this.members.forEach((node) => {
            node.instance && node.scheduleRender(false);
        });
    }
    /**
     * Clear any leads that have been removed this render to prevent them from being
     * used in future animations and to prevent memory leaks
     */
    removeLeadSnapshot() {
        if (this.lead && this.lead.snapshot) {
            this.lead.snapshot = undefined;
        }
    }
}

function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    /**
     * The translations we use to calculate are always relative to the viewport coordinate space.
     * But when we apply scales, we also scale the coordinate space of an element and its children.
     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
     */
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
    if (xTranslate || yTranslate || zTranslate) {
        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    /**
     * Apply scale correction for the tree transform.
     * This will apply scale to the screen-orientated axes.
     */
    if (treeScale.x !== 1 || treeScale.y !== 1) {
        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
        if (transformPerspective)
            transform = `perspective(${transformPerspective}px) ${transform}`;
        if (rotate)
            transform += `rotate(${rotate}deg) `;
        if (rotateX)
            transform += `rotateX(${rotateX}deg) `;
        if (rotateY)
            transform += `rotateY(${rotateY}deg) `;
        if (skewX)
            transform += `skewX(${skewX}deg) `;
        if (skewY)
            transform += `skewY(${skewY}deg) `;
    }
    /**
     * Apply scale to match the size of the element to the size we want it.
     * This will apply scale to the element-orientated axes.
     */
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
        transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
}

const compareByDepth = (a, b) => a.depth - b.depth;

class FlatTree {
    constructor() {
        this.children = [];
        this.isDirty = false;
    }
    add(child) {
        addUniqueItem(this.children, child);
        this.isDirty = true;
    }
    remove(child) {
        removeItem(this.children, child);
        this.isDirty = true;
    }
    forEach(callback) {
        this.isDirty && this.children.sort(compareByDepth);
        this.isDirty = false;
        this.children.forEach(callback);
    }
}

/**
 * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
 *
 * TODO: Remove and move to library
 */
function resolveMotionValue(value) {
    const unwrappedValue = isMotionValue(value) ? value.get() : value;
    return isCustomValue(unwrappedValue)
        ? unwrappedValue.toValue()
        : unwrappedValue;
}

/**
 * Timeout defined in ms
 */
function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
        const elapsed = timestamp - start;
        if (elapsed >= timeout) {
            cancelFrame(checkElapsed);
            callback(elapsed - timeout);
        }
    };
    frame.read(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
}

function isSVGElement(element) {
    return element instanceof SVGElement && element.tagName !== "svg";
}

function animateSingleValue(value, keyframes, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
    return motionValue$1.animation;
}

const metrics = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
};
const isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = { visibility: "hidden" };
/**
 * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
 * which has a noticeable difference in spring animations
 */
const animationTarget = 1000;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    // Record the distorting transform and then temporarily set it to 0
    if (latestValues[key]) {
        values[key] = latestValues[key];
        visualElement.setStaticValue(key, 0);
        if (sharedAnimationValues) {
            sharedAnimationValues[key] = 0;
        }
    }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
        return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
        return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
        const { layout, layoutId } = projectionNode.options;
        window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(parent);
    }
}
function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {
    return class ProjectionNode {
        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
            /**
             * A unique ID generated for every projection node.
             */
            this.id = id++;
            /**
             * An id that represents a unique session instigated by startUpdate.
             */
            this.animationId = 0;
            /**
             * A Set containing all this component's children. This is used to iterate
             * through the children.
             *
             * TODO: This could be faster to iterate as a flat array stored on the root node.
             */
            this.children = new Set();
            /**
             * Options for the node. We use this to configure what kind of layout animations
             * we should perform (if any).
             */
            this.options = {};
            /**
             * We use this to detect when its safe to shut down part of a projection tree.
             * We have to keep projecting children for scale correction and relative projection
             * until all their parents stop performing layout animations.
             */
            this.isTreeAnimating = false;
            this.isAnimationBlocked = false;
            /**
             * Flag to true if we think this layout has been changed. We can't always know this,
             * currently we set it to true every time a component renders, or if it has a layoutDependency
             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
             * and if one node is dirtied, they all are.
             */
            this.isLayoutDirty = false;
            /**
             * Flag to true if we think the projection calculations for this node needs
             * recalculating as a result of an updated transform or layout animation.
             */
            this.isProjectionDirty = false;
            /**
             * Flag to true if the layout *or* transform has changed. This then gets propagated
             * throughout the projection tree, forcing any element below to recalculate on the next frame.
             */
            this.isSharedProjectionDirty = false;
            /**
             * Flag transform dirty. This gets propagated throughout the whole tree but is only
             * respected by shared nodes.
             */
            this.isTransformDirty = false;
            /**
             * Block layout updates for instant layout transitions throughout the tree.
             */
            this.updateManuallyBlocked = false;
            this.updateBlockedByResize = false;
            /**
             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
             * call.
             */
            this.isUpdating = false;
            /**
             * If this is an SVG element we currently disable projection transforms
             */
            this.isSVG = false;
            /**
             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
             * its projection styles.
             */
            this.needsReset = false;
            /**
             * Flags whether this node should have its transform reset prior to measuring.
             */
            this.shouldResetTransform = false;
            /**
             * Store whether this node has been checked for optimised appear animations. As
             * effects fire bottom-up, and we want to look up the tree for appear animations,
             * this makes sure we only check each path once, stopping at nodes that
             * have already been checked.
             */
            this.hasCheckedOptimisedAppear = false;
            /**
             * An object representing the calculated contextual/accumulated/tree scale.
             * This will be used to scale calculcated projection transforms, as these are
             * calculated in screen-space but need to be scaled for elements to layoutly
             * make it to their calculated destinations.
             *
             * TODO: Lazy-init
             */
            this.treeScale = { x: 1, y: 1 };
            /**
             *
             */
            this.eventHandlers = new Map();
            this.hasTreeAnimated = false;
            // Note: Currently only running on root node
            this.updateScheduled = false;
            this.scheduleUpdate = () => this.update();
            this.projectionUpdateScheduled = false;
            this.checkUpdateFailed = () => {
                if (this.isUpdating) {
                    this.isUpdating = false;
                    this.clearAllSnapshots();
                }
            };
            /**
             * This is a multi-step process as shared nodes might be of different depths. Nodes
             * are sorted by depth order, so we need to resolve the entire tree before moving to
             * the next step.
             */
            this.updateProjection = () => {
                this.projectionUpdateScheduled = false;
                /**
                 * Reset debug counts. Manually resetting rather than creating a new
                 * object each frame.
                 */
                if (isDebug) {
                    metrics.totalNodes =
                        metrics.resolvedTargetDeltas =
                            metrics.recalculatedProjection =
                                0;
                }
                this.nodes.forEach(propagateDirtyNodes);
                this.nodes.forEach(resolveTargetDelta);
                this.nodes.forEach(calcProjection);
                this.nodes.forEach(cleanDirtyNodes);
                if (isDebug) {
                    window.MotionDebug.record(metrics);
                }
            };
            /**
             * Frame calculations
             */
            this.resolvedRelativeTargetAt = 0.0;
            this.hasProjected = false;
            this.isVisible = true;
            this.animationProgress = 0;
            /**
             * Shared layout
             */
            // TODO Only running on root node
            this.sharedNodes = new Map();
            this.latestValues = latestValues;
            this.root = parent ? parent.root || parent : this;
            this.path = parent ? [...parent.path, parent] : [];
            this.parent = parent;
            this.depth = parent ? parent.depth + 1 : 0;
            for (let i = 0; i < this.path.length; i++) {
                this.path[i].shouldResetTransform = true;
            }
            if (this.root === this)
                this.nodes = new FlatTree();
        }
        addEventListener(name, handler) {
            if (!this.eventHandlers.has(name)) {
                this.eventHandlers.set(name, new SubscriptionManager());
            }
            return this.eventHandlers.get(name).add(handler);
        }
        notifyListeners(name, ...args) {
            const subscriptionManager = this.eventHandlers.get(name);
            subscriptionManager && subscriptionManager.notify(...args);
        }
        hasListeners(name) {
            return this.eventHandlers.has(name);
        }
        /**
         * Lifecycles
         */
        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = isSVGElement(instance);
            this.instance = instance;
            const { layoutId, layout, visualElement } = this.options;
            if (visualElement && !visualElement.current) {
                visualElement.mount(instance);
            }
            this.root.nodes.add(this);
            this.parent && this.parent.children.add(this);
            if (isLayoutDirty && (layout || layoutId)) {
                this.isLayoutDirty = true;
            }
            if (attachResizeListener) {
                let cancelDelay;
                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);
                attachResizeListener(instance, () => {
                    this.root.updateBlockedByResize = true;
                    cancelDelay && cancelDelay();
                    cancelDelay = delay(resizeUnblockUpdate, 250);
                    if (globalProjectionState.hasAnimatedSinceResize) {
                        globalProjectionState.hasAnimatedSinceResize = false;
                        this.nodes.forEach(finishAnimation);
                    }
                });
            }
            if (layoutId) {
                this.root.registerSharedNode(layoutId, this);
            }
            // Only register the handler if it requires layout animation
            if (this.options.animate !== false &&
                visualElement &&
                (layoutId || layout)) {
                this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, }) => {
                    if (this.isTreeAnimationBlocked()) {
                        this.target = undefined;
                        this.relativeTarget = undefined;
                        return;
                    }
                    // TODO: Check here if an animation exists
                    const layoutTransition = this.options.transition ||
                        visualElement.getDefaultTransition() ||
                        defaultLayoutTransition;
                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();
                    /**
                     * The target layout of the element might stay the same,
                     * but its position relative to its parent has changed.
                     */
                    const targetChanged = !this.targetLayout ||
                        !boxEqualsRounded(this.targetLayout, newLayout) ||
                        hasRelativeTargetChanged;
                    /**
                     * If the layout hasn't seemed to have changed, it might be that the
                     * element is visually in the same place in the document but its position
                     * relative to its parent has indeed changed. So here we check for that.
                     */
                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
                    if (this.options.layoutRoot ||
                        (this.resumeFrom && this.resumeFrom.instance) ||
                        hasOnlyRelativeTargetChanged ||
                        (hasLayoutChanged &&
                            (targetChanged || !this.currentAnimation))) {
                        if (this.resumeFrom) {
                            this.resumingFrom = this.resumeFrom;
                            this.resumingFrom.resumingFrom = undefined;
                        }
                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                        const animationOptions = {
                            ...getValueTransition(layoutTransition, "layout"),
                            onPlay: onLayoutAnimationStart,
                            onComplete: onLayoutAnimationComplete,
                        };
                        if (visualElement.shouldReduceMotion ||
                            this.options.layoutRoot) {
                            animationOptions.delay = 0;
                            animationOptions.type = false;
                        }
                        this.startAnimation(animationOptions);
                    }
                    else {
                        /**
                         * If the layout hasn't changed and we have an animation that hasn't started yet,
                         * finish it immediately. Otherwise it will be animating from a location
                         * that was probably never commited to screen and look like a jumpy box.
                         */
                        if (!hasLayoutChanged) {
                            finishAnimation(this);
                        }
                        if (this.isLead() && this.options.onExitComplete) {
                            this.options.onExitComplete();
                        }
                    }
                    this.targetLayout = newLayout;
                });
            }
        }
        unmount() {
            this.options.layoutId && this.willUpdate();
            this.root.nodes.remove(this);
            const stack = this.getStack();
            stack && stack.remove(this);
            this.parent && this.parent.children.delete(this);
            this.instance = undefined;
            cancelFrame(this.updateProjection);
        }
        // only on the root
        blockUpdate() {
            this.updateManuallyBlocked = true;
        }
        unblockUpdate() {
            this.updateManuallyBlocked = false;
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
        }
        isTreeAnimationBlocked() {
            return (this.isAnimationBlocked ||
                (this.parent && this.parent.isTreeAnimationBlocked()) ||
                false);
        }
        // Note: currently only running on root node
        startUpdate() {
            if (this.isUpdateBlocked())
                return;
            this.isUpdating = true;
            this.nodes && this.nodes.forEach(resetSkewAndRotation);
            this.animationId++;
        }
        getTransformTemplate() {
            const { visualElement } = this.options;
            return visualElement && visualElement.getProps().transformTemplate;
        }
        willUpdate(shouldNotifyListeners = true) {
            this.root.hasTreeAnimated = true;
            if (this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return;
            }
            /**
             * If we're running optimised appear animations then these must be
             * cancelled before measuring the DOM. This is so we can measure
             * the true layout of the element rather than the WAAPI animation
             * which will be unaffected by the resetSkewAndRotate step.
             *
             * Note: This is a DOM write. Worst case scenario is this is sandwiched
             * between other snapshot reads which will cause unnecessary style recalculations.
             * This has to happen here though, as we don't yet know which nodes will need
             * snapshots in startUpdate(), but we only want to cancel optimised animations
             * if a layout animation measurement is actually going to be affected by them.
             */
            if (window.MotionCancelOptimisedAnimation &&
                !this.hasCheckedOptimisedAppear) {
                cancelTreeOptimisedTransformAnimations(this);
            }
            !this.root.isUpdating && this.root.startUpdate();
            if (this.isLayoutDirty)
                return;
            this.isLayoutDirty = true;
            for (let i = 0; i < this.path.length; i++) {
                const node = this.path[i];
                node.shouldResetTransform = true;
                node.updateScroll("snapshot");
                if (node.options.layoutRoot) {
                    node.willUpdate(false);
                }
            }
            const { layoutId, layout } = this.options;
            if (layoutId === undefined && !layout)
                return;
            const transformTemplate = this.getTransformTemplate();
            this.prevTransformTemplateValue = transformTemplate
                ? transformTemplate(this.latestValues, "")
                : undefined;
            this.updateSnapshot();
            shouldNotifyListeners && this.notifyListeners("willUpdate");
        }
        update() {
            this.updateScheduled = false;
            const updateWasBlocked = this.isUpdateBlocked();
            // When doing an instant transition, we skip the layout update,
            // but should still clean up the measurements so that the next
            // snapshot could be taken correctly.
            if (updateWasBlocked) {
                this.unblockUpdate();
                this.clearAllSnapshots();
                this.nodes.forEach(clearMeasurements);
                return;
            }
            if (!this.isUpdating) {
                this.nodes.forEach(clearIsLayoutDirty);
            }
            this.isUpdating = false;
            /**
             * Write
             */
            this.nodes.forEach(resetTransformStyle);
            /**
             * Read ==================
             */
            // Update layout measurements of updated children
            this.nodes.forEach(updateLayout);
            /**
             * Write
             */
            // Notify listeners that the layout is updated
            this.nodes.forEach(notifyLayoutUpdate);
            this.clearAllSnapshots();
            /**
             * Manually flush any pending updates. Ideally
             * we could leave this to the following requestAnimationFrame but this seems
             * to leave a flash of incorrectly styled content.
             */
            const now = time.now();
            frameData.delta = clamp$1(0, 1000 / 60, now - frameData.timestamp);
            frameData.timestamp = now;
            frameData.isProcessing = true;
            frameSteps.update.process(frameData);
            frameSteps.preRender.process(frameData);
            frameSteps.render.process(frameData);
            frameData.isProcessing = false;
        }
        didUpdate() {
            if (!this.updateScheduled) {
                this.updateScheduled = true;
                microtask.read(this.scheduleUpdate);
            }
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot);
            this.sharedNodes.forEach(removeLeadSnapshots);
        }
        scheduleUpdateProjection() {
            if (!this.projectionUpdateScheduled) {
                this.projectionUpdateScheduled = true;
                frame.preRender(this.updateProjection, false, true);
            }
        }
        scheduleCheckAfterUnmount() {
            /**
             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
             * we manually call didUpdate to give a chance to the siblings to animate.
             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
             */
            frame.postRender(() => {
                if (this.isLayoutDirty) {
                    this.root.didUpdate();
                }
                else {
                    this.root.checkUpdateFailed();
                }
            });
        }
        /**
         * Update measurements
         */
        updateSnapshot() {
            if (this.snapshot || !this.instance)
                return;
            this.snapshot = this.measure();
        }
        updateLayout() {
            if (!this.instance)
                return;
            // TODO: Incorporate into a forwarded scroll offset
            this.updateScroll();
            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&
                !this.isLayoutDirty) {
                return;
            }
            /**
             * When a node is mounted, it simply resumes from the prevLead's
             * snapshot instead of taking a new one, but the ancestors scroll
             * might have updated while the prevLead is unmounted. We need to
             * update the scroll again to make sure the layout we measure is
             * up to date.
             */
            if (this.resumeFrom && !this.resumeFrom.instance) {
                for (let i = 0; i < this.path.length; i++) {
                    const node = this.path[i];
                    node.updateScroll();
                }
            }
            const prevLayout = this.layout;
            this.layout = this.measure(false);
            this.layoutCorrected = createBox();
            this.isLayoutDirty = false;
            this.projectionDelta = undefined;
            this.notifyListeners("measure", this.layout.layoutBox);
            const { visualElement } = this.options;
            visualElement &&
                visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);
        }
        updateScroll(phase = "measure") {
            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
            if (this.scroll &&
                this.scroll.animationId === this.root.animationId &&
                this.scroll.phase === phase) {
                needsMeasurement = false;
            }
            if (needsMeasurement) {
                const isRoot = checkIsScrollRoot(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase,
                    isRoot,
                    offset: measureScroll(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,
                };
            }
        }
        resetTransform() {
            if (!resetTransform)
                return;
            const isResetRequested = this.isLayoutDirty ||
                this.shouldResetTransform ||
                this.options.alwaysMeasureLayout;
            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
            const transformTemplate = this.getTransformTemplate();
            const transformTemplateValue = transformTemplate
                ? transformTemplate(this.latestValues, "")
                : undefined;
            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
            if (isResetRequested &&
                (hasProjection ||
                    hasTransform(this.latestValues) ||
                    transformTemplateHasChanged)) {
                resetTransform(this.instance, transformTemplateValue);
                this.shouldResetTransform = false;
                this.scheduleRender();
            }
        }
        measure(removeTransform = true) {
            const pageBox = this.measurePageBox();
            let layoutBox = this.removeElementScroll(pageBox);
            /**
             * Measurements taken during the pre-render stage
             * still have transforms applied so we remove them
             * via calculation.
             */
            if (removeTransform) {
                layoutBox = this.removeTransform(layoutBox);
            }
            roundBox(layoutBox);
            return {
                animationId: this.root.animationId,
                measuredBox: pageBox,
                layoutBox,
                latestValues: {},
                source: this.id,
            };
        }
        measurePageBox() {
            var _a;
            const { visualElement } = this.options;
            if (!visualElement)
                return createBox();
            const box = visualElement.measureViewportBox();
            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
            if (!wasInScrollRoot) {
                // Remove viewport scroll to give page-relative coordinates
                const { scroll } = this.root;
                if (scroll) {
                    translateAxis(box.x, scroll.offset.x);
                    translateAxis(box.y, scroll.offset.y);
                }
            }
            return box;
        }
        removeElementScroll(box) {
            var _a;
            const boxWithoutScroll = createBox();
            copyBoxInto(boxWithoutScroll, box);
            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
                return boxWithoutScroll;
            }
            /**
             * Performance TODO: Keep a cumulative scroll offset down the tree
             * rather than loop back up the path.
             */
            for (let i = 0; i < this.path.length; i++) {
                const node = this.path[i];
                const { scroll, options } = node;
                if (node !== this.root && scroll && options.layoutScroll) {
                    /**
                     * If this is a new scroll root, we want to remove all previous scrolls
                     * from the viewport box.
                     */
                    if (scroll.wasRoot) {
                        copyBoxInto(boxWithoutScroll, box);
                    }
                    translateAxis(boxWithoutScroll.x, scroll.offset.x);
                    translateAxis(boxWithoutScroll.y, scroll.offset.y);
                }
            }
            return boxWithoutScroll;
        }
        applyTransform(box, transformOnly = false) {
            const withTransforms = createBox();
            copyBoxInto(withTransforms, box);
            for (let i = 0; i < this.path.length; i++) {
                const node = this.path[i];
                if (!transformOnly &&
                    node.options.layoutScroll &&
                    node.scroll &&
                    node !== node.root) {
                    transformBox(withTransforms, {
                        x: -node.scroll.offset.x,
                        y: -node.scroll.offset.y,
                    });
                }
                if (!hasTransform(node.latestValues))
                    continue;
                transformBox(withTransforms, node.latestValues);
            }
            if (hasTransform(this.latestValues)) {
                transformBox(withTransforms, this.latestValues);
            }
            return withTransforms;
        }
        removeTransform(box) {
            const boxWithoutTransform = createBox();
            copyBoxInto(boxWithoutTransform, box);
            for (let i = 0; i < this.path.length; i++) {
                const node = this.path[i];
                if (!node.instance)
                    continue;
                if (!hasTransform(node.latestValues))
                    continue;
                hasScale(node.latestValues) && node.updateSnapshot();
                const sourceBox = createBox();
                const nodeBox = node.measurePageBox();
                copyBoxInto(sourceBox, nodeBox);
                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);
            }
            if (hasTransform(this.latestValues)) {
                removeBoxTransforms(boxWithoutTransform, this.latestValues);
            }
            return boxWithoutTransform;
        }
        setTargetDelta(delta) {
            this.targetDelta = delta;
            this.root.scheduleUpdateProjection();
            this.isProjectionDirty = true;
        }
        setOptions(options) {
            this.options = {
                ...this.options,
                ...options,
                crossfade: options.crossfade !== undefined ? options.crossfade : true,
            };
        }
        clearMeasurements() {
            this.scroll = undefined;
            this.layout = undefined;
            this.snapshot = undefined;
            this.prevTransformTemplateValue = undefined;
            this.targetDelta = undefined;
            this.target = undefined;
            this.isLayoutDirty = false;
        }
        forceRelativeParentToResolveTarget() {
            if (!this.relativeParent)
                return;
            /**
             * If the parent target isn't up-to-date, force it to update.
             * This is an unfortunate de-optimisation as it means any updating relative
             * projection will cause all the relative parents to recalculate back
             * up the tree.
             */
            if (this.relativeParent.resolvedRelativeTargetAt !==
                frameData.timestamp) {
                this.relativeParent.resolveTargetDelta(true);
            }
        }
        resolveTargetDelta(forceRecalculation = false) {
            var _a;
            /**
             * Once the dirty status of nodes has been spread through the tree, we also
             * need to check if we have a shared node of a different depth that has itself
             * been dirtied.
             */
            const lead = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
            const isShared = Boolean(this.resumingFrom) || this !== lead;
            /**
             * We don't use transform for this step of processing so we don't
             * need to check whether any nodes have changed transform.
             */
            const canSkip = !(forceRecalculation ||
                (isShared && this.isSharedProjectionDirty) ||
                this.isProjectionDirty ||
                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||
                this.attemptToResolveRelativeTarget ||
                this.root.updateBlockedByResize);
            if (canSkip)
                return;
            const { layout, layoutId } = this.options;
            /**
             * If we have no layout, we can't perform projection, so early return
             */
            if (!this.layout || !(layout || layoutId))
                return;
            this.resolvedRelativeTargetAt = frameData.timestamp;
            /**
             * If we don't have a targetDelta but do have a layout, we can attempt to resolve
             * a relativeParent. This will allow a component to perform scale correction
             * even if no animation has started.
             */
            if (!this.targetDelta && !this.relativeTarget) {
                const relativeParent = this.getClosestProjectingParent();
                if (relativeParent &&
                    relativeParent.layout &&
                    this.animationProgress !== 1) {
                    this.relativeParent = relativeParent;
                    this.forceRelativeParentToResolveTarget();
                    this.relativeTarget = createBox();
                    this.relativeTargetOrigin = createBox();
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                }
                else {
                    this.relativeParent = this.relativeTarget = undefined;
                }
            }
            /**
             * If we have no relative target or no target delta our target isn't valid
             * for this frame.
             */
            if (!this.relativeTarget && !this.targetDelta)
                return;
            /**
             * Lazy-init target data structure
             */
            if (!this.target) {
                this.target = createBox();
                this.targetWithTransforms = createBox();
            }
            /**
             * If we've got a relative box for this component, resolve it into a target relative to the parent.
             */
            if (this.relativeTarget &&
                this.relativeTargetOrigin &&
                this.relativeParent &&
                this.relativeParent.target) {
                this.forceRelativeParentToResolveTarget();
                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
                /**
                 * If we've only got a targetDelta, resolve it into a target
                 */
            }
            else if (this.targetDelta) {
                if (Boolean(this.resumingFrom)) {
                    // TODO: This is creating a new object every frame
                    this.target = this.applyTransform(this.layout.layoutBox);
                }
                else {
                    copyBoxInto(this.target, this.layout.layoutBox);
                }
                applyBoxDelta(this.target, this.targetDelta);
            }
            else {
                /**
                 * If no target, use own layout as target
                 */
                copyBoxInto(this.target, this.layout.layoutBox);
            }
            /**
             * If we've been told to attempt to resolve a relative target, do so.
             */
            if (this.attemptToResolveRelativeTarget) {
                this.attemptToResolveRelativeTarget = false;
                const relativeParent = this.getClosestProjectingParent();
                if (relativeParent &&
                    Boolean(relativeParent.resumingFrom) ===
                        Boolean(this.resumingFrom) &&
                    !relativeParent.options.layoutScroll &&
                    relativeParent.target &&
                    this.animationProgress !== 1) {
                    this.relativeParent = relativeParent;
                    this.forceRelativeParentToResolveTarget();
                    this.relativeTarget = createBox();
                    this.relativeTargetOrigin = createBox();
                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
                }
                else {
                    this.relativeParent = this.relativeTarget = undefined;
                }
            }
            /**
             * Increase debug counter for resolved target deltas
             */
            if (isDebug) {
                metrics.resolvedTargetDeltas++;
            }
        }
        getClosestProjectingParent() {
            if (!this.parent ||
                hasScale(this.parent.latestValues) ||
                has2DTranslate(this.parent.latestValues)) {
                return undefined;
            }
            if (this.parent.isProjecting()) {
                return this.parent;
            }
            else {
                return this.parent.getClosestProjectingParent();
            }
        }
        isProjecting() {
            return Boolean((this.relativeTarget ||
                this.targetDelta ||
                this.options.layoutRoot) &&
                this.layout);
        }
        calcProjection() {
            var _a;
            const lead = this.getLead();
            const isShared = Boolean(this.resumingFrom) || this !== lead;
            let canSkip = true;
            /**
             * If this is a normal layout animation and neither this node nor its nearest projecting
             * is dirty then we can't skip.
             */
            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
                canSkip = false;
            }
            /**
             * If this is a shared layout animation and this node's shared projection is dirty then
             * we can't skip.
             */
            if (isShared &&
                (this.isSharedProjectionDirty || this.isTransformDirty)) {
                canSkip = false;
            }
            /**
             * If we have resolved the target this frame we must recalculate the
             * projection to ensure it visually represents the internal calculations.
             */
            if (this.resolvedRelativeTargetAt === frameData.timestamp) {
                canSkip = false;
            }
            if (canSkip)
                return;
            const { layout, layoutId } = this.options;
            /**
             * If this section of the tree isn't animating we can
             * delete our target sources for the following frame.
             */
            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||
                this.currentAnimation ||
                this.pendingAnimation);
            if (!this.isTreeAnimating) {
                this.targetDelta = this.relativeTarget = undefined;
            }
            if (!this.layout || !(layout || layoutId))
                return;
            /**
             * Reset the corrected box with the latest values from box, as we're then going
             * to perform mutative operations on it.
             */
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            /**
             * Record previous tree scales before updating.
             */
            const prevTreeScaleX = this.treeScale.x;
            const prevTreeScaleY = this.treeScale.y;
            /**
             * Apply all the parent deltas to this box to produce the corrected box. This
             * is the layout box, as it will appear on screen as a result of the transforms of its parents.
             */
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
            /**
             * If this layer needs to perform scale correction but doesn't have a target,
             * use the layout as the target.
             */
            if (lead.layout &&
                !lead.target &&
                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
                lead.target = lead.layout.layoutBox;
                lead.targetWithTransforms = createBox();
            }
            const { target } = lead;
            if (!target) {
                /**
                 * If we don't have a target to project into, but we were previously
                 * projecting, we want to remove the stored transform and schedule
                 * a render to ensure the elements reflect the removed transform.
                 */
                if (this.prevProjectionDelta) {
                    this.createProjectionDeltas();
                    this.scheduleRender();
                }
                return;
            }
            if (!this.projectionDelta || !this.prevProjectionDelta) {
                this.createProjectionDeltas();
            }
            else {
                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
            }
            /**
             * Update the delta between the corrected box and the target box before user-set transforms were applied.
             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
             * for our layout reprojection, but still allow them to be scaled correctly by the user.
             * It might be that to simplify this we may want to accept that user-set scale is also corrected
             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
             * to allow people to choose whether these styles are corrected based on just the
             * layout reprojection or the final bounding box.
             */
            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
            if (this.treeScale.x !== prevTreeScaleX ||
                this.treeScale.y !== prevTreeScaleY ||
                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||
                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
                this.hasProjected = true;
                this.scheduleRender();
                this.notifyListeners("projectionUpdate", target);
            }
            /**
             * Increase debug counter for recalculated projections
             */
            if (isDebug) {
                metrics.recalculatedProjection++;
            }
        }
        hide() {
            this.isVisible = false;
            // TODO: Schedule render
        }
        show() {
            this.isVisible = true;
            // TODO: Schedule render
        }
        scheduleRender(notifyAll = true) {
            var _a;
            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
            if (notifyAll) {
                const stack = this.getStack();
                stack && stack.scheduleRender();
            }
            if (this.resumingFrom && !this.resumingFrom.instance) {
                this.resumingFrom = undefined;
            }
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = createDelta();
            this.projectionDelta = createDelta();
            this.projectionDeltaWithTransform = createDelta();
        }
        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
            const snapshot = this.snapshot;
            const snapshotLatestValues = snapshot
                ? snapshot.latestValues
                : {};
            const mixedValues = { ...this.latestValues };
            const targetDelta = createDelta();
            if (!this.relativeParent ||
                !this.relativeParent.options.layoutRoot) {
                this.relativeTarget = this.relativeTargetOrigin = undefined;
            }
            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
            const relativeLayout = createBox();
            const snapshotSource = snapshot ? snapshot.source : undefined;
            const layoutSource = this.layout ? this.layout.source : undefined;
            const isSharedLayoutAnimation = snapshotSource !== layoutSource;
            const stack = this.getStack();
            const isOnlyMember = !stack || stack.members.length <= 1;
            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&
                !isOnlyMember &&
                this.options.crossfade === true &&
                !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let prevRelativeTarget;
            this.mixTargetDelta = (latest) => {
                const progress = latest / 1000;
                mixAxisDelta(targetDelta.x, delta.x, progress);
                mixAxisDelta(targetDelta.y, delta.y, progress);
                this.setTargetDelta(targetDelta);
                if (this.relativeTarget &&
                    this.relativeTargetOrigin &&
                    this.layout &&
                    this.relativeParent &&
                    this.relativeParent.layout) {
                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
                    /**
                     * If this is an unchanged relative target we can consider the
                     * projection not dirty.
                     */
                    if (prevRelativeTarget &&
                        boxEquals(this.relativeTarget, prevRelativeTarget)) {
                        this.isProjectionDirty = false;
                    }
                    if (!prevRelativeTarget)
                        prevRelativeTarget = createBox();
                    copyBoxInto(prevRelativeTarget, this.relativeTarget);
                }
                if (isSharedLayoutAnimation) {
                    this.animationValues = mixedValues;
                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
                }
                this.root.scheduleUpdateProjection();
                this.scheduleRender();
                this.animationProgress = progress;
            };
            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
        }
        startAnimation(options) {
            this.notifyListeners("animationStart");
            this.currentAnimation && this.currentAnimation.stop();
            if (this.resumingFrom && this.resumingFrom.currentAnimation) {
                this.resumingFrom.currentAnimation.stop();
            }
            if (this.pendingAnimation) {
                cancelFrame(this.pendingAnimation);
                this.pendingAnimation = undefined;
            }
            /**
             * Start the animation in the next frame to have a frame with progress 0,
             * where the target is the same as when the animation started, so we can
             * calculate the relative positions correctly for instant transitions.
             */
            this.pendingAnimation = frame.update(() => {
                globalProjectionState.hasAnimatedSinceResize = true;
                this.currentAnimation = animateSingleValue(0, animationTarget, {
                    ...options,
                    onUpdate: (latest) => {
                        this.mixTargetDelta(latest);
                        options.onUpdate && options.onUpdate(latest);
                    },
                    onComplete: () => {
                        options.onComplete && options.onComplete();
                        this.completeAnimation();
                    },
                });
                if (this.resumingFrom) {
                    this.resumingFrom.currentAnimation = this.currentAnimation;
                }
                this.pendingAnimation = undefined;
            });
        }
        completeAnimation() {
            if (this.resumingFrom) {
                this.resumingFrom.currentAnimation = undefined;
                this.resumingFrom.preserveOpacity = undefined;
            }
            const stack = this.getStack();
            stack && stack.exitAnimationComplete();
            this.resumingFrom =
                this.currentAnimation =
                    this.animationValues =
                        undefined;
            this.notifyListeners("animationComplete");
        }
        finishAnimation() {
            if (this.currentAnimation) {
                this.mixTargetDelta && this.mixTargetDelta(animationTarget);
                this.currentAnimation.stop();
            }
            this.completeAnimation();
        }
        applyTransformsToTarget() {
            const lead = this.getLead();
            let { targetWithTransforms, target, layout, latestValues } = lead;
            if (!targetWithTransforms || !target || !layout)
                return;
            /**
             * If we're only animating position, and this element isn't the lead element,
             * then instead of projecting into the lead box we instead want to calculate
             * a new target that aligns the two boxes but maintains the layout shape.
             */
            if (this !== lead &&
                this.layout &&
                layout &&
                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
                target = this.target || createBox();
                const xLength = calcLength(this.layout.layoutBox.x);
                target.x.min = lead.target.x.min;
                target.x.max = target.x.min + xLength;
                const yLength = calcLength(this.layout.layoutBox.y);
                target.y.min = lead.target.y.min;
                target.y.max = target.y.min + yLength;
            }
            copyBoxInto(targetWithTransforms, target);
            /**
             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
             * This is the final box that we will then project into by calculating a transform delta and
             * applying it to the corrected box.
             */
            transformBox(targetWithTransforms, latestValues);
            /**
             * Update the delta between the corrected box and the final target box, after
             * user-set transforms are applied to it. This will be used by the renderer to
             * create a transform style that will reproject the element from its layout layout
             * into the desired bounding box.
             */
            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
        }
        registerSharedNode(layoutId, node) {
            if (!this.sharedNodes.has(layoutId)) {
                this.sharedNodes.set(layoutId, new NodeStack());
            }
            const stack = this.sharedNodes.get(layoutId);
            stack.add(node);
            const config = node.options.initialPromotionConfig;
            node.promote({
                transition: config ? config.transition : undefined,
                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity
                    ? config.shouldPreserveFollowOpacity(node)
                    : undefined,
            });
        }
        isLead() {
            const stack = this.getStack();
            return stack ? stack.lead === this : true;
        }
        getLead() {
            var _a;
            const { layoutId } = this.options;
            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
        }
        getPrevLead() {
            var _a;
            const { layoutId } = this.options;
            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;
        }
        getStack() {
            const { layoutId } = this.options;
            if (layoutId)
                return this.root.sharedNodes.get(layoutId);
        }
        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {
            const stack = this.getStack();
            if (stack)
                stack.promote(this, preserveFollowOpacity);
            if (needsReset) {
                this.projectionDelta = undefined;
                this.needsReset = true;
            }
            if (transition)
                this.setOptions({ transition });
        }
        relegate() {
            const stack = this.getStack();
            if (stack) {
                return stack.relegate(this);
            }
            else {
                return false;
            }
        }
        resetSkewAndRotation() {
            const { visualElement } = this.options;
            if (!visualElement)
                return;
            // If there's no detected skew or rotation values, we can early return without a forced render.
            let hasDistortingTransform = false;
            /**
             * An unrolled check for rotation values. Most elements don't have any rotation and
             * skipping the nested loop and new object creation is 50% faster.
             */
            const { latestValues } = visualElement;
            if (latestValues.z ||
                latestValues.rotate ||
                latestValues.rotateX ||
                latestValues.rotateY ||
                latestValues.rotateZ ||
                latestValues.skewX ||
                latestValues.skewY) {
                hasDistortingTransform = true;
            }
            // If there's no distorting values, we don't need to do any more.
            if (!hasDistortingTransform)
                return;
            const resetValues = {};
            if (latestValues.z) {
                resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
            }
            // Check the skew and rotate value of all axes and reset to 0
            for (let i = 0; i < transformAxes.length; i++) {
                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
            }
            // Force a render of this element to apply the transform with all skews and rotations
            // set to 0.
            visualElement.render();
            // Put back all the values we reset
            for (const key in resetValues) {
                visualElement.setStaticValue(key, resetValues[key]);
                if (this.animationValues) {
                    this.animationValues[key] = resetValues[key];
                }
            }
            // Schedule a render for the next frame. This ensures we won't visually
            // see the element with the reset rotate value applied.
            visualElement.scheduleRender();
        }
        getProjectionStyles(styleProp) {
            var _a, _b;
            if (!this.instance || this.isSVG)
                return undefined;
            if (!this.isVisible) {
                return hiddenVisibility;
            }
            const styles = {
                visibility: "",
            };
            const transformTemplate = this.getTransformTemplate();
            if (this.needsReset) {
                this.needsReset = false;
                styles.opacity = "";
                styles.pointerEvents =
                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
                styles.transform = transformTemplate
                    ? transformTemplate(this.latestValues, "")
                    : "none";
                return styles;
            }
            const lead = this.getLead();
            if (!this.projectionDelta || !this.layout || !lead.target) {
                const emptyStyles = {};
                if (this.options.layoutId) {
                    emptyStyles.opacity =
                        this.latestValues.opacity !== undefined
                            ? this.latestValues.opacity
                            : 1;
                    emptyStyles.pointerEvents =
                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
                }
                if (this.hasProjected && !hasTransform(this.latestValues)) {
                    emptyStyles.transform = transformTemplate
                        ? transformTemplate({}, "")
                        : "none";
                    this.hasProjected = false;
                }
                return emptyStyles;
            }
            const valuesToRender = lead.animationValues || lead.latestValues;
            this.applyTransformsToTarget();
            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
            if (transformTemplate) {
                styles.transform = transformTemplate(valuesToRender, styles.transform);
            }
            const { x, y } = this.projectionDelta;
            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
            if (lead.animationValues) {
                /**
                 * If the lead component is animating, assign this either the entering/leaving
                 * opacity
                 */
                styles.opacity =
                    lead === this
                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1
                        : this.preserveOpacity
                            ? this.latestValues.opacity
                            : valuesToRender.opacityExit;
            }
            else {
                /**
                 * Or we're not animating at all, set the lead component to its layout
                 * opacity and other components to hidden.
                 */
                styles.opacity =
                    lead === this
                        ? valuesToRender.opacity !== undefined
                            ? valuesToRender.opacity
                            : ""
                        : valuesToRender.opacityExit !== undefined
                            ? valuesToRender.opacityExit
                            : 0;
            }
            /**
             * Apply scale correction
             */
            for (const key in scaleCorrectors) {
                if (valuesToRender[key] === undefined)
                    continue;
                const { correct, applyTo } = scaleCorrectors[key];
                /**
                 * Only apply scale correction to the value if we have an
                 * active projection transform. Otherwise these values become
                 * vulnerable to distortion if the element changes size without
                 * a corresponding layout animation.
                 */
                const corrected = styles.transform === "none"
                    ? valuesToRender[key]
                    : correct(valuesToRender[key], lead);
                if (applyTo) {
                    const num = applyTo.length;
                    for (let i = 0; i < num; i++) {
                        styles[applyTo[i]] = corrected;
                    }
                }
                else {
                    styles[key] = corrected;
                }
            }
            /**
             * Disable pointer events on follow components. This is to ensure
             * that if a follow component covers a lead component it doesn't block
             * pointer events on the lead.
             */
            if (this.options.layoutId) {
                styles.pointerEvents =
                    lead === this
                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || ""
                        : "none";
            }
            return styles;
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = undefined;
        }
        // Only run on root
        resetTree() {
            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });
            this.root.nodes.forEach(clearMeasurements);
            this.root.sharedNodes.clear();
        }
    };
}
function updateLayout(node) {
    node.updateLayout();
}
function notifyLayoutUpdate(node) {
    var _a;
    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
    if (node.isLead() &&
        node.layout &&
        snapshot &&
        node.hasListeners("didUpdate")) {
        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
        const { animationType } = node.options;
        const isShared = snapshot.source !== node.layout.source;
        // TODO Maybe we want to also resize the layout snapshot so we don't trigger
        // animations for instance if layout="size" and an element has only changed position
        if (animationType === "size") {
            eachAxis((axis) => {
                const axisSnapshot = isShared
                    ? snapshot.measuredBox[axis]
                    : snapshot.layoutBox[axis];
                const length = calcLength(axisSnapshot);
                axisSnapshot.min = layout[axis].min;
                axisSnapshot.max = axisSnapshot.min + length;
            });
        }
        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
            eachAxis((axis) => {
                const axisSnapshot = isShared
                    ? snapshot.measuredBox[axis]
                    : snapshot.layoutBox[axis];
                const length = calcLength(layout[axis]);
                axisSnapshot.max = axisSnapshot.min + length;
                /**
                 * Ensure relative target gets resized and rerendererd
                 */
                if (node.relativeTarget && !node.currentAnimation) {
                    node.isProjectionDirty = true;
                    node.relativeTarget[axis].max =
                        node.relativeTarget[axis].min + length;
                }
            });
        }
        const layoutDelta = createDelta();
        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
        const visualDelta = createDelta();
        if (isShared) {
            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
        }
        else {
            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
        }
        const hasLayoutChanged = !isDeltaZero(layoutDelta);
        let hasRelativeTargetChanged = false;
        if (!node.resumeFrom) {
            const relativeParent = node.getClosestProjectingParent();
            /**
             * If the relativeParent is itself resuming from a different element then
             * the relative snapshot is not relavent
             */
            if (relativeParent && !relativeParent.resumeFrom) {
                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
                if (parentSnapshot && parentLayout) {
                    const relativeSnapshot = createBox();
                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
                    const relativeLayout = createBox();
                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
                        hasRelativeTargetChanged = true;
                    }
                    if (relativeParent.options.layoutRoot) {
                        node.relativeTarget = relativeLayout;
                        node.relativeTargetOrigin = relativeSnapshot;
                        node.relativeParent = relativeParent;
                    }
                }
            }
        }
        node.notifyListeners("didUpdate", {
            layout,
            snapshot,
            delta: visualDelta,
            layoutDelta,
            hasLayoutChanged,
            hasRelativeTargetChanged,
        });
    }
    else if (node.isLead()) {
        const { onExitComplete } = node.options;
        onExitComplete && onExitComplete();
    }
    /**
     * Clearing transition
     * TODO: Investigate why this transition is being passed in as {type: false } from Framer
     * and why we need it at all
     */
    node.options.transition = undefined;
}
function propagateDirtyNodes(node) {
    /**
     * Increase debug counter for nodes encountered this frame
     */
    if (isDebug) {
        metrics.totalNodes++;
    }
    if (!node.parent)
        return;
    /**
     * If this node isn't projecting, propagate isProjectionDirty. It will have
     * no performance impact but it will allow the next child that *is* projecting
     * but *isn't* dirty to just check its parent to see if *any* ancestor needs
     * correcting.
     */
    if (!node.isProjecting()) {
        node.isProjectionDirty = node.parent.isProjectionDirty;
    }
    /**
     * Propagate isSharedProjectionDirty and isTransformDirty
     * throughout the whole tree. A future revision can take another look at
     * this but for safety we still recalcualte shared nodes.
     */
    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||
        node.parent.isProjectionDirty ||
        node.parent.isSharedProjectionDirty));
    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
    node.isProjectionDirty =
        node.isSharedProjectionDirty =
            node.isTransformDirty =
                false;
}
function clearSnapshot(node) {
    node.clearSnapshot();
}
function clearMeasurements(node) {
    node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
    node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
    const { visualElement } = node.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
        visualElement.notify("BeforeLayoutMeasure");
    }
    node.resetTransform();
}
function finishAnimation(node) {
    node.finishAnimation();
    node.targetDelta = node.relativeTarget = node.target = undefined;
    node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
    node.resolveTargetDelta();
}
function calcProjection(node) {
    node.calcProjection();
}
function resetSkewAndRotation(node) {
    node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber$1(delta.translate, 0, p);
    output.scale = mixNumber$1(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
    output.min = mixNumber$1(from.min, to.min, p);
    output.max = mixNumber$1(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
    mixAxis(output.x, from.x, to.x, p);
    mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
    return (node.animationValues && node.animationValues.opacityExit !== undefined);
}
const defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1],
};
const userAgentContains = (string) => typeof navigator !== "undefined" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(string);
/**
 * Measured bounding boxes must be rounded in Safari and
 * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements
 * can appear to jump.
 */
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")
    ? Math.round
    : noop$1;
function roundAxis(axis) {
    // Round to the nearest .5 pixels to support subpixel layouts
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
}
function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
    return (animationType === "position" ||
        (animationType === "preserve-aspect" &&
            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));
}
function checkNodeWasScrollRoot(node) {
    var _a;
    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
}

const DocumentProjectionNode = createProjectionNode$1({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => true,
});

const rootProjectionNode = {
    current: undefined,
};
const HTMLProjectionNode = createProjectionNode$1({
    measureScroll: (instance) => ({
        x: instance.scrollLeft,
        y: instance.scrollTop,
    }),
    defaultParent: () => {
        if (!rootProjectionNode.current) {
            const documentNode = new DocumentProjectionNode({});
            documentNode.mount(window);
            documentNode.setOptions({ layoutScroll: true });
            rootProjectionNode.current = documentNode;
        }
        return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
        instance.style.transform = value !== undefined ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed"),
});

const drag = {
    pan: {
        Feature: PanGesture,
    },
    drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout,
    },
};

function addHoverEvent(node, isActive) {
    const eventName = isActive ? "pointerenter" : "pointerleave";
    const callbackName = isActive ? "onHoverStart" : "onHoverEnd";
    const handleEvent = (event, info) => {
        if (event.pointerType === "touch" || isDragActive())
            return;
        const props = node.getProps();
        if (node.animationState && props.whileHover) {
            node.animationState.setActive("whileHover", isActive);
        }
        const callback = props[callbackName];
        if (callback) {
            frame.postRender(() => callback(event, info));
        }
    };
    return addPointerEvent(node.current, eventName, handleEvent, {
        passive: !node.getProps()[callbackName],
    });
}
class HoverGesture extends Feature {
    mount() {
        this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
    }
    unmount() { }
}

class FocusGesture extends Feature {
    constructor() {
        super(...arguments);
        this.isActive = false;
    }
    onFocus() {
        let isFocusVisible = false;
        /**
         * If this element doesn't match focus-visible then don't
         * apply whileHover. But, if matches throws that focus-visible
         * is not a valid selector then in that browser outline styles will be applied
         * to the element by default and we want to match that behaviour with whileFocus.
         */
        try {
            isFocusVisible = this.node.current.matches(":focus-visible");
        }
        catch (e) {
            isFocusVisible = true;
        }
        if (!isFocusVisible || !this.node.animationState)
            return;
        this.node.animationState.setActive("whileFocus", true);
        this.isActive = true;
    }
    onBlur() {
        if (!this.isActive || !this.node.animationState)
            return;
        this.node.animationState.setActive("whileFocus", false);
        this.isActive = false;
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() { }
}

/**
 * Recursively traverse up the tree to check whether the provided child node
 * is the parent or a descendant of it.
 *
 * @param parent - Element to find
 * @param child - Element to test against parent
 */
const isNodeOrChild = (parent, child) => {
    if (!child) {
        return false;
    }
    else if (parent === child) {
        return true;
    }
    else {
        return isNodeOrChild(parent, child.parentElement);
    }
};

function fireSyntheticPointerEvent(name, handler) {
    if (!handler)
        return;
    const syntheticPointerEvent = new PointerEvent("pointer" + name);
    handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
    constructor() {
        super(...arguments);
        this.removeStartListeners = noop$1;
        this.removeEndListeners = noop$1;
        this.removeAccessibleListeners = noop$1;
        this.startPointerPress = (startEvent, startInfo) => {
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const props = this.node.getProps();
            const endPointerPress = (endEvent, endInfo) => {
                if (!this.checkPressEnd())
                    return;
                const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
                /**
                 * We only count this as a tap gesture if the event.target is the same
                 * as, or a child of, this component's element
                 */
                const handler = !globalTapTarget &&
                    !isNodeOrChild(this.node.current, endEvent.target)
                    ? onTapCancel
                    : onTap;
                if (handler) {
                    frame.update(() => handler(endEvent, endInfo));
                }
            };
            const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, {
                passive: !(props.onTap || props["onPointerUp"]),
            });
            const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), {
                passive: !(props.onTapCancel ||
                    props["onPointerCancel"]),
            });
            this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
            this.startPress(startEvent, startInfo);
        };
        this.startAccessiblePress = () => {
            const handleKeydown = (keydownEvent) => {
                if (keydownEvent.key !== "Enter" || this.isPressing)
                    return;
                const handleKeyup = (keyupEvent) => {
                    if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
                        return;
                    fireSyntheticPointerEvent("up", (event, info) => {
                        const { onTap } = this.node.getProps();
                        if (onTap) {
                            frame.postRender(() => onTap(event, info));
                        }
                    });
                };
                this.removeEndListeners();
                this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
                fireSyntheticPointerEvent("down", (event, info) => {
                    this.startPress(event, info);
                });
            };
            const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
            const handleBlur = () => {
                if (!this.isPressing)
                    return;
                fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
            };
            const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
            this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
        };
    }
    startPress(event, info) {
        this.isPressing = true;
        const { onTapStart, whileTap } = this.node.getProps();
        /**
         * Ensure we trigger animations before firing event callback
         */
        if (whileTap && this.node.animationState) {
            this.node.animationState.setActive("whileTap", true);
        }
        if (onTapStart) {
            frame.postRender(() => onTapStart(event, info));
        }
    }
    checkPressEnd() {
        this.removeEndListeners();
        this.isPressing = false;
        const props = this.node.getProps();
        if (props.whileTap && this.node.animationState) {
            this.node.animationState.setActive("whileTap", false);
        }
        return !isDragActive();
    }
    cancelPress(event, info) {
        if (!this.checkPressEnd())
            return;
        const { onTapCancel } = this.node.getProps();
        if (onTapCancel) {
            frame.postRender(() => onTapCancel(event, info));
        }
    }
    mount() {
        const props = this.node.getProps();
        const removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(props.onTapStart ||
                props["onPointerStart"]),
        });
        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
    }
    unmount() {
        this.removeStartListeners();
        this.removeEndListeners();
        this.removeAccessibleListeners();
    }
}

/**
 * Map an IntersectionHandler callback to an element. We only ever make one handler for one
 * element, so even though these handlers might all be triggered by different
 * observers, we can keep them in the same map.
 */
const observerCallbacks = new WeakMap();
/**
 * Multiple observers can be created for multiple element/document roots. Each with
 * different settings. So here we store dictionaries of observers to each root,
 * using serialised settings (threshold/margin) as lookup keys.
 */
const observers = new WeakMap();
const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
    const lookupRoot = root || document;
    /**
     * If we don't have an observer lookup map for this root, create one.
     */
    if (!observers.has(lookupRoot)) {
        observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    /**
     * If we don't have an observer for this combination of root and settings,
     * create one.
     */
    if (!rootObservers[key]) {
        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
    }
    return rootObservers[key];
}
function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
        observerCallbacks.delete(element);
        rootInteresectionObserver.unobserve(element);
    };
}

const thresholdNames = {
    some: 0,
    all: 1,
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments);
        this.hasEnteredView = false;
        this.isInView = false;
    }
    startObserver() {
        this.unmount();
        const { viewport = {} } = this.node.getProps();
        const { root, margin: rootMargin, amount = "some", once } = viewport;
        const options = {
            root: root ? root.current : undefined,
            rootMargin,
            threshold: typeof amount === "number" ? amount : thresholdNames[amount],
        };
        const onIntersectionUpdate = (entry) => {
            const { isIntersecting } = entry;
            /**
             * If there's been no change in the viewport state, early return.
             */
            if (this.isInView === isIntersecting)
                return;
            this.isInView = isIntersecting;
            /**
             * Handle hasEnteredView. If this is only meant to run once, and
             * element isn't visible, early return. Otherwise set hasEnteredView to true.
             */
            if (once && !isIntersecting && this.hasEnteredView) {
                return;
            }
            else if (isIntersecting) {
                this.hasEnteredView = true;
            }
            if (this.node.animationState) {
                this.node.animationState.setActive("whileInView", isIntersecting);
            }
            /**
             * Use the latest committed props rather than the ones in scope
             * when this observer is created
             */
            const { onViewportEnter, onViewportLeave } = this.node.getProps();
            const callback = isIntersecting ? onViewportEnter : onViewportLeave;
            callback && callback(entry);
        };
        return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
        this.startObserver();
    }
    update() {
        if (typeof IntersectionObserver === "undefined")
            return;
        const { props, prevProps } = this.node;
        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
        if (hasOptionsChanged) {
            this.startObserver();
        }
    }
    unmount() { }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
}

const gestureAnimations = {
    inView: {
        Feature: InViewFeature,
    },
    tap: {
        Feature: PressGesture,
    },
    focus: {
        Feature: FocusGesture,
    },
    hover: {
        Feature: HoverGesture,
    },
};

const layout = {
    layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout,
    },
};

/**
 * @public
 */
const MotionConfigContext = reactExports.createContext({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never",
});

const MotionContext = reactExports.createContext({});

const isBrowser$1 = typeof window !== "undefined";

const useIsomorphicLayoutEffect = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;

const LazyContext = reactExports.createContext({ strict: false });

function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    var _a, _b;
    const { visualElement: parent } = reactExports.useContext(MotionContext);
    const lazyContext = reactExports.useContext(LazyContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
    const visualElementRef = reactExports.useRef();
    /**
     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
     */
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
        visualElementRef.current = createVisualElement(Component, {
            visualState,
            parent,
            props,
            presenceContext,
            blockInitialAnimation: presenceContext
                ? presenceContext.initial === false
                : false,
            reducedMotionConfig,
        });
    }
    const visualElement = visualElementRef.current;
    /**
     * Load Motion gesture and animation features. These are rendered as renderless
     * components so each feature can optionally make use of React lifecycle methods.
     */
    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
    if (visualElement &&
        !visualElement.projection &&
        ProjectionNodeConstructor &&
        (visualElement.type === "html" || visualElement.type === "svg")) {
        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    reactExports.useInsertionEffect(() => {
        visualElement && visualElement.update(props, presenceContext);
    });
    /**
     * Cache this value as we want to know whether HandoffAppearAnimations
     * was present on initial render - it will be deleted after this.
     */
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) &&
        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&
        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
    useIsomorphicLayoutEffect(() => {
        if (!visualElement)
            return;
        window.MotionIsMounted = true;
        visualElement.updateFeatures();
        microtask.render(visualElement.render);
        /**
         * Ideally this function would always run in a useEffect.
         *
         * However, if we have optimised appear animations to handoff from,
         * it needs to happen synchronously to ensure there's no flash of
         * incorrect styles in the event of a hydration error.
         *
         * So if we detect a situtation where optimised appear animations
         * are running, we use useLayoutEffect to trigger animations.
         */
        if (wantsHandoff.current && visualElement.animationState) {
            visualElement.animationState.animateChanges();
        }
    });
    reactExports.useEffect(() => {
        if (!visualElement)
            return;
        if (!wantsHandoff.current && visualElement.animationState) {
            visualElement.animationState.animateChanges();
        }
        if (wantsHandoff.current) {
            // This ensures all future calls to animateChanges() in this component will run in useEffect
            queueMicrotask(() => {
                var _a;
                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);
            });
            wantsHandoff.current = false;
        }
    });
    return visualElement;
}
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"]
        ? undefined
        : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
        layoutId,
        layout,
        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),
        visualElement,
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout === "string" ? layout : "both",
        initialPromotionConfig,
        layoutScroll,
        layoutRoot,
    });
}
function getClosestProjectingNode(visualElement) {
    if (!visualElement)
        return undefined;
    return visualElement.options.allowProjection !== false
        ? visualElement.projection
        : getClosestProjectingNode(visualElement.parent);
}

/**
 * Creates a ref function that, when called, hydrates the provided
 * external ref and VisualElement.
 */
function useMotionRef(visualState, visualElement, externalRef) {
    return reactExports.useCallback((instance) => {
        instance && visualState.mount && visualState.mount(instance);
        if (visualElement) {
            if (instance) {
                visualElement.mount(instance);
            }
            else {
                visualElement.unmount();
            }
        }
        if (externalRef) {
            if (typeof externalRef === "function") {
                externalRef(instance);
            }
            else if (isRefObject(externalRef)) {
                externalRef.current = instance;
            }
        }
    }, 
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]);
}

function isControllingVariants(props) {
    return (isAnimationControls(props.animate) ||
        variantProps.some((name) => isVariantLabel(props[name])));
}
function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
}

function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
        const { initial, animate } = props;
        return {
            initial: initial === false || isVariantLabel(initial)
                ? initial
                : undefined,
            animate: isVariantLabel(animate) ? animate : undefined,
        };
    }
    return props.inherit !== false ? context : {};
}

function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
}

const featureProps = {
    animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
};
const featureDefinitions = {};
for (const key in featureProps) {
    featureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),
    };
}

function loadFeatures(features) {
    for (const key in features) {
        featureDefinitions[key] = {
            ...featureDefinitions[key],
            ...features[key],
        };
    }
}

const motionComponentSymbol = Symbol.for("motionComponentSymbol");

function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag, layout } = featureDefinitions;
  if (!drag && !layout)
    return {};
  const combined = { ...drag, ...layout };
  return {
    MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}

/**
 * We keep these listed separately as we use the lowercase tag names as part
 * of the runtime bundle to detect SVG components
 */
const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view",
];

function isSVGComponent(Component) {
    if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" ||
        /**
         * If it contains a dash, the element is a custom HTML webcomponent.
         */
        Component.includes("-")) {
        return false;
    }
    else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 ||
        /**
         * If it contains a capital letter, it's an SVG component
         */
        /[A-Z]/u.test(Component)) {
        return true;
    }
    return false;
}

function renderHTML(element, { style, vars }, styleProp, projection) {
    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
    // Loop over any CSS variables and assign those.
    for (const key in vars) {
        element.style.setProperty(key, vars[key]);
    }
}

/**
 * A set of attribute names that are always read/written as camel case.
 */
const camelCaseAttributes = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust",
]);

function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, undefined, projection);
    for (const key in renderState.attrs) {
        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
}

function isForcedMotionValue(key, { layout, layoutId }) {
    return (transformProps.has(key) ||
        key.startsWith("origin") ||
        ((layout || layoutId !== undefined) &&
            (!!scaleCorrectors[key] || key === "opacity")));
}

function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    var _a;
    const { style } = props;
    const newValues = {};
    for (const key in style) {
        if (isMotionValue(style[key]) ||
            (prevProps.style &&
                isMotionValue(prevProps.style[key])) ||
            isForcedMotionValue(key, props) ||
            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {
            newValues[key] = style[key];
        }
    }
    /**
     * If the willChange style has been manually set as a string, set
     * applyWillChange to false to prevent it from automatically being applied.
     */
    if (visualElement && style && typeof style.willChange === "string") {
        visualElement.applyWillChange = false;
    }
    return newValues;
}

function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
        if (isMotionValue(props[key]) ||
            isMotionValue(prevProps[key])) {
            const targetKey = transformPropOrder.indexOf(key) !== -1
                ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)
                : key;
            newValues[targetKey] = props[key];
        }
    }
    return newValues;
}

/**
 * Creates a constant value over the lifecycle of a component.
 *
 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
 * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
 * you can ensure that initialisers don't execute twice or more.
 */
function useConstant(init) {
    const ref = reactExports.useRef(null);
    if (ref.current === null) {
        ref.current = init();
    }
    return ref.current;
}

function makeState({ applyWillChange = false, scrapeMotionValuesFromProps, createRenderState, onMount, }, props, context, presenceContext, isStatic) {
    const state = {
        latestValues: makeLatestValues(props, context, presenceContext, isStatic ? false : applyWillChange, scrapeMotionValuesFromProps),
        renderState: createRenderState(),
    };
    if (onMount) {
        state.mount = (instance) => onMount(props, instance, state);
    }
    return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
    const context = reactExports.useContext(MotionContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext, isStatic);
    return isStatic ? make() : useConstant(make);
};
function forEachDefinition(props, definition, callback) {
    const list = Array.isArray(definition) ? definition : [definition];
    for (let i = 0; i < list.length; i++) {
        const resolved = resolveVariantFromProps(props, list[i]);
        if (resolved) {
            const { transitionEnd, transition, ...target } = resolved;
            callback(target, transitionEnd);
        }
    }
}
function makeLatestValues(props, context, presenceContext, shouldApplyWillChange, scrapeMotionValues) {
    var _a;
    const values = {};
    let applyWillChange = shouldApplyWillChange && ((_a = props.style) === null || _a === void 0 ? void 0 : _a.willChange) === undefined;
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
        values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context &&
        isVariantNode$1 &&
        !isControllingVariants$1 &&
        props.inherit !== false) {
        if (initial === undefined)
            initial = context.initial;
        if (animate === undefined)
            animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext
        ? presenceContext.initial === false
        : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet &&
        typeof variantToSet !== "boolean" &&
        !isAnimationControls(variantToSet)) {
        forEachDefinition(props, variantToSet, (target, transitionEnd) => {
            for (const key in target) {
                let valueTarget = target[key];
                if (Array.isArray(valueTarget)) {
                    /**
                     * Take final keyframe if the initial animation is blocked because
                     * we want to initialise at the end of that blocked animation.
                     */
                    const index = isInitialAnimationBlocked
                        ? valueTarget.length - 1
                        : 0;
                    valueTarget = valueTarget[index];
                }
                if (valueTarget !== null) {
                    values[key] = valueTarget;
                }
            }
            for (const key in transitionEnd) {
                values[key] = transitionEnd[key];
            }
        });
    }
    // Add animating values to will-change
    if (applyWillChange) {
        if (animate && initial !== false && !isAnimationControls(animate)) {
            forEachDefinition(props, animate, (target) => {
                for (const key in target) {
                    const willChangeName = getWillChangeName(key);
                    if (willChangeName) {
                        values.willChange = "transform";
                        return;
                    }
                }
            });
        }
    }
    return values;
}

const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {},
});

const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {},
});

/**
 * Provided a value and a ValueType, returns the value as that value type.
 */
const getValueAsType = (value, type) => {
    return type && typeof value === "number"
        ? type.transform(value)
        : value;
};

const translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
};
const numTransforms = transformPropOrder.length;
/**
 * Build a CSS transform style from individual x/y/scale etc properties.
 *
 * This outputs with a default order of transforms/scales/rotations, this can be customised by
 * providing a transformTemplate function.
 */
function buildTransform(latestValues, transform, transformTemplate) {
    // The transform string we're going to build into.
    let transformString = "";
    let transformIsDefault = true;
    /**
     * Loop over all possible transforms in order, adding the ones that
     * are present to the transform string.
     */
    for (let i = 0; i < numTransforms; i++) {
        const key = transformPropOrder[i];
        const value = latestValues[key];
        if (value === undefined)
            continue;
        let valueIsDefault = true;
        if (typeof value === "number") {
            valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
        }
        else {
            valueIsDefault = parseFloat(value) === 0;
        }
        if (!valueIsDefault || transformTemplate) {
            const valueAsType = getValueAsType(value, numberValueTypes[key]);
            if (!valueIsDefault) {
                transformIsDefault = false;
                const transformName = translateAlias[key] || key;
                transformString += `${transformName}(${valueAsType}) `;
            }
            if (transformTemplate) {
                transform[key] = valueAsType;
            }
        }
    }
    transformString = transformString.trim();
    // If we have a custom `transform` template, pass our transform values and
    // generated transformString to that before returning
    if (transformTemplate) {
        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    }
    else if (transformIsDefault) {
        transformString = "none";
    }
    return transformString;
}

function buildHTMLStyles(state, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state;
    // Track whether we encounter any transform or transformOrigin values.
    let hasTransform = false;
    let hasTransformOrigin = false;
    /**
     * Loop over all our latest animated values and decide whether to handle them
     * as a style or CSS variable.
     *
     * Transforms and transform origins are kept separately for further processing.
     */
    for (const key in latestValues) {
        const value = latestValues[key];
        if (transformProps.has(key)) {
            // If this is a transform, flag to enable further transform processing
            hasTransform = true;
            continue;
        }
        else if (isCSSVariableName(key)) {
            vars[key] = value;
            continue;
        }
        else {
            // Convert the value to its default value type, ie 0 -> "0px"
            const valueAsType = getValueAsType(value, numberValueTypes[key]);
            if (key.startsWith("origin")) {
                // If this is a transform origin, flag and enable further transform-origin processing
                hasTransformOrigin = true;
                transformOrigin[key] =
                    valueAsType;
            }
            else {
                style[key] = valueAsType;
            }
        }
    }
    if (!latestValues.transform) {
        if (hasTransform || transformTemplate) {
            style.transform = buildTransform(latestValues, state.transform, transformTemplate);
        }
        else if (style.transform) {
            /**
             * If we have previously created a transform but currently don't have any,
             * reset transform style to none.
             */
            style.transform = "none";
        }
    }
    /**
     * Build a transformOrigin style. Uses the same defaults as the browser for
     * undefined origins.
     */
    if (hasTransformOrigin) {
        const { originX = "50%", originY = "50%", originZ = 0, } = transformOrigin;
        style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
}

function calcOrigin(origin, offset, size) {
    return typeof origin === "string"
        ? origin
        : px.transform(offset + size * origin);
}
/**
 * The SVG transform origin defaults are different to CSS and is less intuitive,
 * so we use the measured dimensions of the SVG to reconcile these.
 */
function calcSVGTransformOrigin(dimensions, originX, originY) {
    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
    return `${pxOriginX} ${pxOriginY}`;
}

const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray",
};
const camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray",
};
/**
 * Build SVG path properties. Uses the path's measured length to convert
 * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
 * and stroke-dasharray attributes.
 *
 * This function is mutative to reduce per-frame GC.
 */
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
    // Normalise path length by setting SVG attribute pathLength to 1
    attrs.pathLength = 1;
    // We use dash case when setting attributes directly to the DOM node and camel case
    // when defining props on a React component.
    const keys = useDashCase ? dashKeys : camelKeys;
    // Build the dash offset
    attrs[keys.offset] = px.transform(-offset);
    // Build the dash array
    const pathLength = px.transform(length);
    const pathSpacing = px.transform(spacing);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}

/**
 * Build SVG visual attrbutes, like cx and style.transform
 */
function buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, 
// This is object creation, which we try to avoid per-frame.
...latest }, isSVGTag, transformTemplate) {
    buildHTMLStyles(state, latest, transformTemplate);
    /**
     * For svg tags we just want to make sure viewBox is animatable and treat all the styles
     * as normal HTML tags.
     */
    if (isSVGTag) {
        if (state.style.viewBox) {
            state.attrs.viewBox = state.style.viewBox;
        }
        return;
    }
    state.attrs = state.style;
    state.style = {};
    const { attrs, style, dimensions } = state;
    /**
     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
     * and copy it into style.
     */
    if (attrs.transform) {
        if (dimensions)
            style.transform = attrs.transform;
        delete attrs.transform;
    }
    // Parse transformOrigin
    if (dimensions &&
        (originX !== undefined || originY !== undefined || style.transform)) {
        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
    }
    // Render attrX/attrY/attrScale as attributes
    if (attrX !== undefined)
        attrs.x = attrX;
    if (attrY !== undefined)
        attrs.y = attrY;
    if (attrScale !== undefined)
        attrs.scale = attrScale;
    // Build SVG path if one has been defined
    if (pathLength !== undefined) {
        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
}

const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

const svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (props, instance, { renderState, latestValues }) => {
            frame.read(() => {
                try {
                    renderState.dimensions =
                        typeof instance.getBBox ===
                            "function"
                            ? instance.getBBox()
                            : instance.getBoundingClientRect();
                }
                catch (e) {
                    // Most likely trying to measure an unrendered element under Firefox
                    renderState.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                    };
                }
            });
            frame.render(() => {
                buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate);
                renderSVG(instance, renderState);
            });
        },
    }),
};

const htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        applyWillChange: true,
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState,
    }),
};

function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
            target[key] = source[key];
        }
    }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
    return reactExports.useMemo(() => {
        const state = createHtmlRenderState();
        buildHTMLStyles(state, visualState, transformTemplate);
        return Object.assign({}, state.vars, state.style);
    }, [visualState]);
}
function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    /**
     * Copy non-Motion Values straight into style
     */
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
}
function useHTMLProps(props, visualState) {
    // The `any` isn't ideal but it is the type of createElement props argument
    const htmlProps = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
        // Disable the ghost element when a user drags
        htmlProps.draggable = false;
        // Disable text selection
        style.userSelect =
            style.WebkitUserSelect =
                style.WebkitTouchCallout =
                    "none";
        // Disable scrolling on the draggable direction
        style.touchAction =
            props.drag === true
                ? "none"
                : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === undefined &&
        (props.onTap || props.onTapStart || props.whileTap)) {
        htmlProps.tabIndex = 0;
    }
    htmlProps.style = style;
    return htmlProps;
}

/**
 * A list of all valid MotionProps.
 *
 * @privateRemarks
 * This doesn't throw if a `MotionProp` name is missing - it should.
 */
const validMotionProps = new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport",
]);
/**
 * Check whether a prop name is a valid `MotionProp` key.
 *
 * @param key - Name of the property to check
 * @returns `true` is key is a valid `MotionProp`.
 *
 * @public
 */
function isValidMotionProp(key) {
    return (key.startsWith("while") ||
        (key.startsWith("drag") && key !== "draggable") ||
        key.startsWith("layout") ||
        key.startsWith("onTap") ||
        key.startsWith("onPan") ||
        key.startsWith("onLayout") ||
        validMotionProps.has(key));
}

let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
    if (!isValidProp)
        return;
    // Explicitly filter our events
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
/**
 * Emotion and Styled Components both allow users to pass through arbitrary props to their components
 * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
 * of these should be passed to the underlying DOM node.
 *
 * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
 * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
 * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
 * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
 *
 * By making it an optionalDependency we can offer this functionality only in the situations where it's
 * actually required.
 */
try {
    /**
     * We attempt to import this package but require won't be defined in esm environments, in that case
     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
     * in favour of explicit injection.
     */
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
}
catch (_a) {
    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
}
function filterProps(props, isDom, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
        /**
         * values is considered a valid prop by Emotion, so if it's present
         * this will be rendered out to the DOM unless explicitly filtered.
         *
         * We check the type as it could be used with the `feColorMatrix`
         * element, which we support.
         */
        if (key === "values" && typeof props.values === "object")
            continue;
        if (shouldForward(key) ||
            (forwardMotionProps === true && isValidMotionProp(key)) ||
            (!isDom && !isValidMotionProp(key)) ||
            // If trying to use native HTML drag events, forward drag listeners
            (props["draggable"] &&
                key.startsWith("onDrag"))) {
            filteredProps[key] =
                props[key];
        }
    }
    return filteredProps;
}

function useSVGProps(props, visualState, _isStatic, Component) {
    const visualProps = reactExports.useMemo(() => {
        const state = createSvgRenderState();
        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
        return {
            ...state.attrs,
            style: { ...state.style },
        };
    }, [visualState]);
    if (props.style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props.style, props);
        visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
}

function createUseRender(forwardMotionProps = false) {
    const useRender = (Component, props, ref, { latestValues }, isStatic) => {
        const useVisualProps = isSVGComponent(Component)
            ? useSVGProps
            : useHTMLProps;
        const visualProps = useVisualProps(props, latestValues, isStatic, Component);
        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
        const elementProps = Component !== reactExports.Fragment
            ? { ...filteredProps, ...visualProps, ref }
            : {};
        /**
         * If component has been handed a motion value as its child,
         * memoise its initial value and render that. Subsequent updates
         * will be handled by the onChange handler
         */
        const { children } = props;
        const renderedChildren = reactExports.useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);
        return reactExports.createElement(Component, {
            ...elementProps,
            children: renderedChildren,
        });
    };
    return useRender;
}

function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
        const baseConfig = isSVGComponent(Component)
            ? svgMotionConfig
            : htmlMotionConfig;
        const config = {
            ...baseConfig,
            preloadedFeatures,
            useRender: createUseRender(forwardMotionProps),
            createVisualElement,
            Component,
        };
        return createRendererMotionComponent(config);
    };
}

// Does this device prefer reduced motion? Returns `null` server-side.
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };

function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser$1)
        return;
    if (window.matchMedia) {
        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);
        motionMediaQuery.addListener(setReducedMotionPreferences);
        setReducedMotionPreferences();
    }
    else {
        prefersReducedMotion.current = false;
    }
}

function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}

const visualElementStore = new WeakMap();

/**
 * A list of all ValueTypes
 */
const valueTypes = [...dimensionValueTypes, color, complex];
/**
 * Tests a value against the list of ValueTypes
 */
const findValueType = (v) => valueTypes.find(testValueType(v));

const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.applyWillChange = false;
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now = time.now();
      if (this.renderScheduledAt < now) {
        this.renderScheduledAt = now;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}

class DOMVisualElement extends VisualElement {
    constructor() {
        super(...arguments);
        this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b) {
        /**
         * compareDocumentPosition returns a bitmask, by using the bitwise &
         * we're returning true if 2 in that bitmask is set to true. 2 is set
         * to true if b preceeds a.
         */
        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
        return props.style
            ? props.style[key]
            : undefined;
    }
    removeValueFromRenderState(key, { vars, style }) {
        delete vars[key];
        delete style[key];
    }
}

function getComputedStyle$2(element) {
    return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments);
        this.type = "html";
        this.applyWillChange = true;
        this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
            const defaultType = getDefaultValueType(key);
            return defaultType ? defaultType.default || 0 : 0;
        }
        else {
            const computedStyle = getComputedStyle$2(instance);
            const value = (isCSSVariableName(key)
                ? computedStyle.getPropertyValue(key)
                : computedStyle[key]) || 0;
            return typeof value === "string" ? value.trim() : value;
        }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
        return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
        buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
    handleChildMotionValue() {
        if (this.childSubscription) {
            this.childSubscription();
            delete this.childSubscription;
        }
        const { children } = this.props;
        if (isMotionValue(children)) {
            this.childSubscription = children.on("change", (latest) => {
                if (this.current)
                    this.current.textContent = `${latest}`;
            });
        }
    }
}

class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments);
        this.type = "svg";
        this.isSVGTag = false;
        this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
        return props[key];
    }
    readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
            const defaultType = getDefaultValueType(key);
            return defaultType ? defaultType.default || 0 : 0;
        }
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
    }
    renderInstance(instance, renderState, styleProp, projection) {
        renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
        this.isSVGTag = isSVGTag(instance.tagName);
        super.mount(instance);
    }
}

const createDomVisualElement = (Component, options) => {
    return isSVGComponent(Component)
        ? new SVGVisualElement(options)
        : new HTMLVisualElement(options, {
            allowProjection: Component !== reactExports.Fragment,
        });
};

const createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout,
}, createDomVisualElement);

const motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);

/**
 * Measurement functionality has to be within a separate component
 * to leverage snapshot lifecycle.
 */
class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
            const size = this.props.sizeRef.current;
            size.height = element.offsetHeight || 0;
            size.width = element.offsetWidth || 0;
            size.top = element.offsetTop;
            size.left = element.offsetLeft;
        }
        return null;
    }
    /**
     * Required with getSnapshotBeforeUpdate to stop React complaining.
     */
    componentDidUpdate() { }
    render() {
        return this.props.children;
    }
}
function PopChild({ children, isPresent }) {
    const id = reactExports.useId();
    const ref = reactExports.useRef(null);
    const size = reactExports.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
    });
    const { nonce } = reactExports.useContext(MotionConfigContext);
    /**
     * We create and inject a style block so we can apply this explicit
     * sizing in a non-destructive manner by just deleting the style block.
     *
     * We can't apply size via render as the measurement happens
     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
     * styles directly on the DOM node, we might be overwriting
     * styles set via the style prop.
     */
    reactExports.useInsertionEffect(() => {
        const { width, height, top, left } = size.current;
        if (isPresent || !ref.current || !width || !height)
            return;
        ref.current.dataset.motionPopId = id;
        const style = document.createElement("style");
        if (nonce)
            style.nonce = nonce;
        document.head.appendChild(style);
        if (style.sheet) {
            style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
        }
        return () => {
            document.head.removeChild(style);
        };
    }, [isPresent]);
    return (jsxRuntimeExports.jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: reactExports.cloneElement(children, { ref }) }));
}

const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id = reactExports.useId();
    const memoizedOnExitComplete = reactExports.useCallback((childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
                return; // can stop searching when any is incomplete
        }
        onExitComplete && onExitComplete();
    }, [presenceChildren, onExitComplete]);
    const context = reactExports.useMemo(() => ({
        id,
        initial,
        isPresent,
        custom,
        onExitComplete: memoizedOnExitComplete,
        register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
        },
    }), 
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout
        ? [Math.random(), memoizedOnExitComplete]
        : [isPresent, memoizedOnExitComplete]);
    reactExports.useMemo(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    /**
     * If there's no `motion` components to fire exit animations, we want to remove this
     * component immediately.
     */
    reactExports.useEffect(() => {
        !isPresent &&
            !presenceChildren.size &&
            onExitComplete &&
            onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
        children = jsxRuntimeExports.jsx(PopChild, { isPresent: isPresent, children: children });
    }
    return (jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children: children }));
};
function newChildrenMap() {
    return new Map();
}

const getChildKey = (child) => child.key || "";
function onlyElements(children) {
    const filtered = [];
    // We use forEach here instead of map as map mutates the component key by preprending `.$`
    reactExports.Children.forEach(children, (child) => {
        if (reactExports.isValidElement(child))
            filtered.push(child);
    });
    return filtered;
}

const AnimatePresence = ({ children, exitBeforeEnter, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync" }) => {
  const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
  const presentKeys = presentChildren.map(getChildKey);
  const isInitialRender = reactExports.useRef(true);
  const pendingPresentChildren = reactExports.useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return;
  }
  const { forceRender } = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent = presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = () => {
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender === null || forceRender === void 0 ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        onExitComplete && onExitComplete();
      }
    };
    return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom: isPresent ? void 0 : custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
  }) });
};

/**
 * Creates a `MotionValue` to track the state and velocity of a value.
 *
 * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.
 *
 * ```jsx
 * export const MyComponent = () => {
 *   const scale = useMotionValue(1)
 *
 *   return <motion.div style={{ scale }} />
 * }
 * ```
 *
 * @param initial - The initial state.
 *
 * @public
 */
function useMotionValue(initial) {
    const value = useConstant(() => motionValue(initial));
    /**
     * If this motion value is being used in static mode, like on
     * the Framer canvas, force components to rerender when the motion
     * value is updated.
     */
    const { isStatic } = reactExports.useContext(MotionConfigContext);
    if (isStatic) {
        const [, setLatest] = reactExports.useState(initial);
        reactExports.useEffect(() => value.on("change", setLatest), []);
    }
    return value;
}

function toNumber(v) {
    if (typeof v === "number")
        return v;
    return parseFloat(v);
}
/**
 * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.
 *
 * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber
 * to another `MotionValue`.
 *
 * @remarks
 *
 * ```jsx
 * const x = useSpring(0, { stiffness: 300 })
 * const y = useSpring(x, { damping: 10 })
 * ```
 *
 * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.
 * @param springConfig - Configuration options for the spring.
 * @returns `MotionValue`
 *
 * @public
 */
function useSpring(source, config = {}) {
    const { isStatic } = reactExports.useContext(MotionConfigContext);
    const activeSpringAnimation = reactExports.useRef(null);
    const value = useMotionValue(isMotionValue(source) ? toNumber(source.get()) : source);
    const latestValue = reactExports.useRef(value.get());
    const latestSetter = reactExports.useRef(() => { });
    const startAnimation = () => {
        /**
         * If the previous animation hasn't had the chance to even render a frame, render it now.
         */
        const animation = activeSpringAnimation.current;
        if (animation && animation.time === 0) {
            animation.sample(frameData.delta);
        }
        stopAnimation();
        activeSpringAnimation.current = animateValue({
            keyframes: [value.get(), latestValue.current],
            velocity: value.getVelocity(),
            type: "spring",
            restDelta: 0.001,
            restSpeed: 0.01,
            ...config,
            onUpdate: latestSetter.current,
        });
    };
    const stopAnimation = () => {
        if (activeSpringAnimation.current) {
            activeSpringAnimation.current.stop();
        }
    };
    reactExports.useInsertionEffect(() => {
        return value.attach((v, set) => {
            /**
             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations
             * at that level, but this will work for now
             */
            if (isStatic)
                return set(v);
            latestValue.current = v;
            latestSetter.current = set;
            frame.update(startAnimation);
            return value.get();
        }, stopAnimation);
    }, [JSON.stringify(config)]);
    useIsomorphicLayoutEffect(() => {
        if (isMotionValue(source)) {
            return source.on("change", (v) => value.set(toNumber(v)));
        }
    }, [value]);
    return value;
}

const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}

function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item = tree[name];
    if (item) {
      callback(name, internalGetIconData(data, name, item));
      names.push(name);
    }
  }
  return names;
}

const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
};

const optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item, defaults) {
  for (const prop in defaults) {
    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  return data;
}

const dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage.icons[name] = icon;
    } else {
      storage.missing.add(name);
    }
  });
}
function addIconToStorage(storage, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}

let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);
  }
}
function addIcon(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage, icon.name, data);
}
function addCollection(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (icon && addIcon(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    provider,
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage = getStorage(provider, prefix);
  return !!addIconSet(storage, data);
}

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}

const regex = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id) => {
    const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
    const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}

const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}

function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}

const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
let fetchModule = detectFetch();
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index) => {
    length += name.length + 1;
    if (length >= maxLength && index > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};

function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}

function removeCallback(storages, id) {
  storages.forEach((storage) => {
    const items = storage.loaderCallbacks;
    if (items) {
      storage.loaderCallbacks = items.filter((row) => row.id !== id);
    }
  });
}
function updateCallbacks(storage) {
  if (!storage.pendingCallbacksFlag) {
    storage.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage.pendingCallbacksFlag = false;
      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage.provider;
      const prefix = storage.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage) => {
    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);
  });
  return abort;
}

function listToIcons(list, validate = true, simpleNames = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}

// src/config.ts
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};

// src/query.ts
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index = config.resources.indexOf(item.resource);
      if (index !== -1 && index !== config.index) {
        config.index = index;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}

// src/index.ts
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find,
    setIndex: (index) => {
      config.index = index;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}

function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send = api.send;
      }
    }
  }
  if (!redundancy || !send) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send, callback)().abort;
}

const browserCacheVersion = "iconify2";
const browserCachePrefix = "iconify";
const browserCacheCountKey = browserCachePrefix + "-count";
const browserCacheVersionKey = browserCachePrefix + "-version";
const browserStorageHour = 36e5;
const browserStorageCacheExpiration = 168;
const browserStorageLimit = 50;

function getStoredItem(func, key) {
  try {
    return func.getItem(key);
  } catch (err) {
  }
}
function setStoredItem(func, key, value) {
  try {
    func.setItem(key, value);
    return true;
  } catch (err) {
  }
}
function removeStoredItem(func, key) {
  try {
    func.removeItem(key);
  } catch (err) {
  }
}

function setBrowserStorageItemsCount(storage, value) {
  return setStoredItem(storage, browserCacheCountKey, value.toString());
}
function getBrowserStorageItemsCount(storage) {
  return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;
}

const browserStorageConfig = {
  local: true,
  session: true
};
const browserStorageEmptyItems = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let browserStorageStatus = false;
function setBrowserStorageStatus(status) {
  browserStorageStatus = status;
}

let _window = typeof window === "undefined" ? {} : window;
function getBrowserStorage(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  browserStorageConfig[key] = false;
}

function iterateBrowserStorage(key, callback) {
  const func = getBrowserStorage(key);
  if (!func) {
    return;
  }
  const version = getStoredItem(func, browserCacheVersionKey);
  if (version !== browserCacheVersion) {
    if (version) {
      const total2 = getBrowserStorageItemsCount(func);
      for (let i = 0; i < total2; i++) {
        removeStoredItem(func, browserCachePrefix + i.toString());
      }
    }
    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
    setBrowserStorageItemsCount(func, 0);
    return;
  }
  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
  const parseItem = (index) => {
    const name = browserCachePrefix + index.toString();
    const item = getStoredItem(func, name);
    if (typeof item !== "string") {
      return;
    }
    try {
      const data = JSON.parse(item);
      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback
      callback(data, index)) {
        return true;
      }
    } catch (err) {
    }
    removeStoredItem(func, name);
  };
  let total = getBrowserStorageItemsCount(func);
  for (let i = total - 1; i >= 0; i--) {
    if (!parseItem(i)) {
      if (i === total - 1) {
        total--;
        setBrowserStorageItemsCount(func, total);
      } else {
        browserStorageEmptyItems[key].add(i);
      }
    }
  }
}

function initBrowserStorage() {
  if (browserStorageStatus) {
    return;
  }
  setBrowserStorageStatus(true);
  for (const key in browserStorageConfig) {
    iterateBrowserStorage(key, (item) => {
      const iconSet = item.data;
      const provider = item.provider;
      const prefix = iconSet.prefix;
      const storage = getStorage(
        provider,
        prefix
      );
      if (!addIconSet(storage, iconSet).length) {
        return false;
      }
      const lastModified = iconSet.lastModified || -1;
      storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;
      return true;
    });
  }
}

function updateLastModified(storage, lastModified) {
  const lastValue = storage.lastModifiedCached;
  if (
    // Matches or newer
    lastValue && lastValue >= lastModified
  ) {
    return lastValue === lastModified;
  }
  storage.lastModifiedCached = lastModified;
  if (lastValue) {
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item) => {
        const iconSet = item.data;
        return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;
      });
    }
  }
  return true;
}
function storeInBrowserStorage(storage, data) {
  if (!browserStorageStatus) {
    initBrowserStorage();
  }
  function store(key) {
    let func;
    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
      return;
    }
    const set = browserStorageEmptyItems[key];
    let index;
    if (set.size) {
      set.delete(index = Array.from(set).shift());
    } else {
      index = getBrowserStorageItemsCount(func);
      if (index >= browserStorageLimit || !setBrowserStorageItemsCount(func, index + 1)) {
        return;
      }
    }
    const item = {
      cached: Math.floor(Date.now() / browserStorageHour),
      provider: storage.provider,
      data
    };
    return setStoredItem(
      func,
      browserCachePrefix + index.toString(),
      JSON.stringify(item)
    );
  }
  if (data.lastModified && !updateLastModified(storage, data.lastModified)) {
    return;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
}

function emptyCallback() {
}
function loadedNewIcons(storage) {
  if (!storage.iconsLoaderFlag) {
    storage.iconsLoaderFlag = true;
    setTimeout(() => {
      storage.iconsLoaderFlag = false;
      updateCallbacks(storage);
    });
  }
}
function loadNewIcons(storage, icons) {
  if (!storage.iconsToLoad) {
    storage.iconsToLoad = icons;
  } else {
    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();
  }
  if (!storage.iconsQueueFlag) {
    storage.iconsQueueFlag = true;
    setTimeout(() => {
      storage.iconsQueueFlag = false;
      const { provider, prefix } = storage;
      const icons2 = storage.iconsToLoad;
      delete storage.iconsToLoad;
      let api;
      if (!icons2 || !(api = getAPIModule(provider))) {
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          if (typeof data !== "object") {
            item.icons.forEach((name) => {
              storage.missing.add(name);
            });
          } else {
            try {
              const parsed = addIconSet(
                storage,
                data
              );
              if (!parsed.length) {
                return;
              }
              const pending = storage.pendingIcons;
              if (pending) {
                parsed.forEach((name) => {
                  pending.delete(name);
                });
              }
              storeInBrowserStorage(storage, data);
            } catch (err) {
              console.error(err);
            }
          }
          loadedNewIcons(storage);
        });
      });
    });
  }
}
const loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage = getStorage(provider, prefix);
    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage) => {
    const { provider, prefix } = storage;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(storage, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};

function mergeCustomisations(defaults, item) {
  const result = {
    ...defaults
  };
  for (const key in item) {
    const value = item[key];
    const valueType = typeof value;
    if (key in defaultIconSizeCustomisations) {
      if (value === null || value && (valueType === "string" || valueType === "number")) {
        result[key] = value;
      }
    } else if (valueType === typeof result[key]) {
      result[key] = key === "rotate" ? value % 4 : value;
    }
  }
  return result;
}

const separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}

function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}

function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}

function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}

let policy;
function createPolicy() {
  try {
    policy = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (s) => s
    });
  } catch (err) {
    policy = null;
  }
}
function cleanUpInnerHTML(html) {
  if (policy === void 0) {
    createPolicy();
  }
  return policy ? policy.createHTML(html) : html;
}

const defaultExtendedIconCustomisations = {
    ...defaultIconCustomisations,
    inline: false,
};

/**
 * Default SVG attributes
 */
const svgDefaults = {
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlnsXlink': 'http://www.w3.org/1999/xlink',
    'aria-hidden': true,
    'role': 'img',
};
/**
 * Style modes
 */
const commonProps = {
    display: 'inline-block',
};
const monotoneProps = {
    backgroundColor: 'currentColor',
};
const coloredProps = {
    backgroundColor: 'transparent',
};
// Dynamically add common props to variables above
const propsToAdd = {
    Image: 'var(--svg)',
    Repeat: 'no-repeat',
    Size: '100% 100%',
};
const propsToAddTo = {
    WebkitMask: monotoneProps,
    mask: monotoneProps,
    background: coloredProps,
};
for (const prefix in propsToAddTo) {
    const list = propsToAddTo[prefix];
    for (const prop in propsToAdd) {
        list[prefix + prop] = propsToAdd[prop];
    }
}
/**
 * Default values for customisations for inline icon
 */
const inlineDefaults = {
    ...defaultExtendedIconCustomisations,
    inline: true,
};
/**
 * Fix size: add 'px' to numbers
 */
function fixSize(value) {
    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');
}
/**
 * Render icon
 */
const render = (
// Icon must be validated before calling this function
icon, 
// Partial properties
props, 
// Icon name
name) => {
    // Get default properties
    const defaultProps = props.inline
        ? inlineDefaults
        : defaultExtendedIconCustomisations;
    // Get all customisations
    const customisations = mergeCustomisations(defaultProps, props);
    // Check mode
    const mode = props.mode || 'svg';
    // Create style
    const style = {};
    const customStyle = props.style || {};
    // Create SVG component properties
    const componentProps = {
        ...(mode === 'svg' ? svgDefaults : {}),
    };
    if (name) {
        const iconName = stringToIcon(name, false, true);
        if (iconName) {
            const classNames = ['iconify'];
            const props = [
                'provider',
                'prefix',
            ];
            for (const prop of props) {
                if (iconName[prop]) {
                    classNames.push('iconify--' + iconName[prop]);
                }
            }
            componentProps.className = classNames.join(' ');
        }
    }
    // Get element properties
    for (let key in props) {
        const value = props[key];
        if (value === void 0) {
            continue;
        }
        switch (key) {
            // Properties to ignore
            case 'icon':
            case 'style':
            case 'children':
            case 'onLoad':
            case 'mode':
            case 'ssr':
                break;
            // Forward ref
            case '_ref':
                componentProps.ref = value;
                break;
            // Merge class names
            case 'className':
                componentProps[key] =
                    (componentProps[key] ? componentProps[key] + ' ' : '') +
                        value;
                break;
            // Boolean attributes
            case 'inline':
            case 'hFlip':
            case 'vFlip':
                customisations[key] =
                    value === true || value === 'true' || value === 1;
                break;
            // Flip as string: 'horizontal,vertical'
            case 'flip':
                if (typeof value === 'string') {
                    flipFromString(customisations, value);
                }
                break;
            // Color: copy to style
            case 'color':
                style.color = value;
                break;
            // Rotation as string
            case 'rotate':
                if (typeof value === 'string') {
                    customisations[key] = rotateFromString(value);
                }
                else if (typeof value === 'number') {
                    customisations[key] = value;
                }
                break;
            // Remove aria-hidden
            case 'ariaHidden':
            case 'aria-hidden':
                if (value !== true && value !== 'true') {
                    delete componentProps['aria-hidden'];
                }
                break;
            // Copy missing property if it does not exist in customisations
            default:
                if (defaultProps[key] === void 0) {
                    componentProps[key] = value;
                }
        }
    }
    // Generate icon
    const item = iconToSVG(icon, customisations);
    const renderAttribs = item.attributes;
    // Inline display
    if (customisations.inline) {
        style.verticalAlign = '-0.125em';
    }
    if (mode === 'svg') {
        // Add style
        componentProps.style = {
            ...style,
            ...customStyle,
        };
        // Add icon stuff
        Object.assign(componentProps, renderAttribs);
        // Counter for ids based on "id" property to render icons consistently on server and client
        let localCounter = 0;
        let id = props.id;
        if (typeof id === 'string') {
            // Convert '-' to '_' to avoid errors in animations
            id = id.replace(/-/g, '_');
        }
        // Add icon stuff
        componentProps.dangerouslySetInnerHTML = {
            __html: cleanUpInnerHTML(replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifyReact')),
        };
        return reactExports.createElement('svg', componentProps);
    }
    // Render <span> with style
    const { body, width, height } = icon;
    const useMask = mode === 'mask' ||
        (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);
    // Generate SVG
    const html = iconToHTML(body, {
        ...renderAttribs,
        width: width + '',
        height: height + '',
    });
    // Generate style
    componentProps.style = {
        ...style,
        '--svg': svgToURL(html),
        'width': fixSize(renderAttribs.width),
        'height': fixSize(renderAttribs.height),
        ...commonProps,
        ...(useMask ? monotoneProps : coloredProps),
        ...customStyle,
    };
    return reactExports.createElement('span', componentProps);
};
/**
 * Initialise stuff
 */
// Enable short names
allowSimpleNames(true);
// Set API module
setAPIModule('', fetchAPIModule);
/**
 * Browser stuff
 */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // Set cache and load existing cache
    initBrowserStorage();
    const _window = window;
    // Load icons from global "IconifyPreload"
    if (_window.IconifyPreload !== void 0) {
        const preload = _window.IconifyPreload;
        const err = 'Invalid IconifyPreload syntax.';
        if (typeof preload === 'object' && preload !== null) {
            (preload instanceof Array ? preload : [preload]).forEach((item) => {
                try {
                    if (
                    // Check if item is an object and not null/array
                    typeof item !== 'object' ||
                        item === null ||
                        item instanceof Array ||
                        // Check for 'icons' and 'prefix'
                        typeof item.icons !== 'object' ||
                        typeof item.prefix !== 'string' ||
                        // Add icon set
                        !addCollection(item)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            });
        }
    }
    // Set API from global "IconifyProviders"
    if (_window.IconifyProviders !== void 0) {
        const providers = _window.IconifyProviders;
        if (typeof providers === 'object' && providers !== null) {
            for (let key in providers) {
                const err = 'IconifyProviders[' + key + '] is invalid.';
                try {
                    const value = providers[key];
                    if (typeof value !== 'object' ||
                        !value ||
                        value.resources === void 0) {
                        continue;
                    }
                    if (!addAPIProvider(key, value)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            }
        }
    }
}
function IconComponent(props) {
    const [mounted, setMounted] = reactExports.useState(!!props.ssr);
    const [abort, setAbort] = reactExports.useState({});
    // Get initial state
    function getInitialState(mounted) {
        if (mounted) {
            const name = props.icon;
            if (typeof name === 'object') {
                // Icon as object
                return {
                    name: '',
                    data: name,
                };
            }
            const data = getIconData(name);
            if (data) {
                return {
                    name,
                    data,
                };
            }
        }
        return {
            name: '',
        };
    }
    const [state, setState] = reactExports.useState(getInitialState(!!props.ssr));
    // Cancel loading
    function cleanup() {
        const callback = abort.callback;
        if (callback) {
            callback();
            setAbort({});
        }
    }
    // Change state if it is different
    function changeState(newState) {
        if (JSON.stringify(state) !== JSON.stringify(newState)) {
            cleanup();
            setState(newState);
            return true;
        }
    }
    // Update state
    function updateState() {
        var _a;
        const name = props.icon;
        if (typeof name === 'object') {
            // Icon as object
            changeState({
                name: '',
                data: name,
            });
            return;
        }
        // New icon or got icon data
        const data = getIconData(name);
        if (changeState({
            name,
            data,
        })) {
            if (data === undefined) {
                // Load icon, update state when done
                const callback = loadIcons([name], updateState);
                setAbort({
                    callback,
                });
            }
            else if (data) {
                // Icon data is available: trigger onLoad callback if present
                (_a = props.onLoad) === null || _a === void 0 ? void 0 : _a.call(props, name);
            }
        }
    }
    // Mounted state, cleanup for loader
    reactExports.useEffect(() => {
        setMounted(true);
        return cleanup;
    }, []);
    // Icon changed or component mounted
    reactExports.useEffect(() => {
        if (mounted) {
            updateState();
        }
    }, [props.icon, mounted]);
    // Render icon
    const { name, data } = state;
    if (!data) {
        return props.children
            ? props.children
            : reactExports.createElement('span', {});
    }
    return render({
        ...defaultIconProps,
        ...data,
    }, props, name);
}
/**
 * Block icon
 *
 * @param props - Component properties
 */
const Icon$1 = reactExports.forwardRef((props, ref) => IconComponent({
    ...props,
    _ref: ref,
}));
/**
 * Inline icon (has negative verticalAlign that makes it behave like icon font)
 *
 * @param props - Component properties
 */
reactExports.forwardRef((props, ref) => IconComponent({
    inline: true,
    ...props,
    _ref: ref,
}));

const NotificationTypeValues = {
  DEFAULT: "default",
  SUCCESS: "success",
  ERROR: "error",
  WARNING: "warning",
  INFO: "info"
};
const NotificationVariants = {
  BASIC: "basic",
  TITLE: "title",
  ICON_ONLY: "icon-only",
  TEXT_ONLY: "text-only",
  ICON_NO_CLOSE: "icon-no-close",
  LONG_TEXT: "long-text"
};
const NotificationAnimations = {
  SLIDE: "slide",
  FADE: "fade",
  BOUNCE: "bounce",
  SCALE: "scale",
  ELASTIC: "elastic"
};
const NotificationPositions = {
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right",
  TOP_CENTER: "top-center",
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  BOTTOM_CENTER: "bottom-center"
};

const StatusBarVariant = {
  DEFAULT: "default",
  SQUARE: "square",
  HEXAGON: "hexagon",
  RHOMBUS: "rhombus",
  ENVI: "envi"
};
const ServerInfoVariant = {
  DEFAULT: "default",
  SQUARE: "square",
  HEXAGON: "hexagon",
  RHOMBUS: "rhombus",
  ENVI: "envi"
};
const AccountVariant = {
  DEFAULT: "default",
  SQUARE: "square",
  HEXAGON: "hexagon",
  RHOMBUS: "rhombus",
  ENVI: "envi"
};
const ProgressBarStyle = {
  BORDER: "border",
  FILL: "fill"
};
const HudAnimation = {
  DEFAULT: "default",
  FADE: "fade",
  BOUNCE: "bounce",
  SLIDE: "slide",
  SCALE: "scale",
  ELASTIC: "elastic"
};
const MinimapType = {
  SQUARE: "square",
  CIRCLE: "circle"
};
const MinimapSize = {
  SMALL: "small",
  MEDIUM: "medium",
  LARGE: "large"
};
const VehicleType = {
  CAR: "car",
  BOAT: "boat",
  AIR: "air"
};
const MinimapSizePixels = {
  "square": {
    "small": { width: 200, height: 120 },
    "medium": { width: 230, height: 140 },
    "large": { width: 270, height: 170 }
  },
  "circle": {
    "small": { width: 120, height: 120 },
    "medium": { width: 140, height: 140 },
    "large": { width: 200, height: 200 }
  }
};
const MinimapBufferSize = {
  "square": {
    "small": { x: 0.0313, y: -0.0838 },
    "medium": { x: 0.0287, y: -0.07401 },
    "large": { x: 0.02426, y: -0.073 }
  },
  "circle": {
    "small": { x: 0.0313, y: -0.0838 },
    "medium": { x: 0.0287, y: -0.07401 },
    "large": { x: 0.02426, y: -0.073 }
  }
};
const ShadowStyle = {
  textShadow: "0 0.3vh 0.4vh rgba(0, 0, 0, 0.3), 0 0 .6vh rgba(255, 255, 255, 0.8)",
  filter: "drop-shadow(0 0.3vh 0.3vh rgba(0, 0, 0, 0.2))"
};
const TimeDisplayLocation = {
  [HudThemes.LIGHT]: "serverInfoItems",
  [HudThemes.DARK]: "serverInfoItems",
  [HudThemes.CLEAN_SIMPLE]: "serverInfoItems",
  [HudThemes.ENVI]: "serverInfoItems",
  [HudThemes.MIDNIGHT]: "serverInfoItems",
  [HudThemes.CYBERPUNK]: "serverInfoItems",
  [HudThemes.CYBERPUNK_2]: "serverInfoItems",
  [HudThemes.PIXEL]: "accountItems",
  [HudThemes.RETRO]: "accountItems"
};
const TimeMode = {
  IN_GAME: "in-game",
  REAL_TIME: "real-time"
};
const CurrencySymbol = {
  USD: {
    code: "usd",
    symbol: "$"
  },
  EUR: {
    code: "eur",
    symbol: "€"
  },
  GBP: {
    code: "gbp",
    symbol: "£"
  }
};

const ProgressbarVariant = {
  INCLUDE_TITLE_VALUE: "include-title-value",
  INCLUDE_TITLE: "include-title",
  INCLUDE_VALUE: "include-value",
  ONLY_BAR: "only-bar"
};
const ProgressbarTextPosition = {
  ABOVE_BAR: "above-bar",
  BELOW_BAR: "below-bar"
};
const ProgressbarAnimation = {
  DEFAULT: "default",
  FADE: "fade",
  SLIDE: "slide",
  BOUNCE: "bounce"
};
const ProgressbarAnimationDirection = {
  DEFAULT: "default",
  TOP: "top",
  RIGHT: "right",
  BOTTOM: "bottom",
  LEFT: "left"
};

const createStoreImpl$1 = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore$1 = (createState) => createState ? createStoreImpl$1(createState) : createStoreImpl$1;

const identity$1 = (arg) => arg;
function useStore$1(api, selector = identity$1) {
  const slice = React.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  React.useDebugValue(slice);
  return slice;
}
const createImpl$1 = (createState) => {
  const api = createStore$1(createState);
  const useBoundStore = (selector) => useStore$1(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create$1 = (createState) => createState ? createImpl$1(createState) : createImpl$1;

const generateId = () => `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

const useNotificationStore = create$1((set) => ({
  notifications: [],
  addNotification: (notification) => set((state) => ({
    notifications: [
      ...state.notifications,
      {
        ...notification,
        id: generateId()
      }
    ]
  })),
  removeNotification: (id) => set((state) => ({
    notifications: state.notifications.filter((notification) => notification.id !== id)
  })),
  clearAllNotifications: () => set({ notifications: [] })
}));

const useConfigStore = create$1()(
  (set) => ({
    config: {},
    hudConfig: {},
    disabledHudElements: {},
    setConfig: (value) => set({ config: value }),
    setHudConfig: (value) => set({ hudConfig: value }),
    setDisabledHudElements: (value) => set({ disabledHudElements: value })
  })
);

const defaultState = {
  theme: HudThemes.LIGHT,
  serverInfoVariant: ServerInfoVariant.DEFAULT,
  accountVariant: AccountVariant.DEFAULT,
  statusBarVariant: StatusBarVariant.DEFAULT,
  speedometerVariant: SpeedometerThemes.DEFAULT,
  progressBarStyle: ProgressBarStyle.BORDER,
  progressBarSettings: {
    theme: ProgressBarThemes.LIGHT,
    variant: ProgressbarVariant.INCLUDE_TITLE_VALUE,
    animation: ProgressbarAnimation.DEFAULT,
    animationDirection: ProgressbarAnimationDirection.DEFAULT,
    isRounded: true,
    animationDelay: 0.3,
    textPosition: ProgressbarTextPosition.ABOVE_BAR
  }
};
const useHudStore = create$1((set) => ({
  theme: defaultState.theme,
  serverInfoVariant: defaultState.serverInfoVariant,
  accountVariant: defaultState.accountVariant,
  statusBarVariant: defaultState.statusBarVariant,
  speedometerVariant: defaultState.speedometerVariant,
  progressBarStyle: defaultState.progressBarStyle,
  progressBarSettings: defaultState.progressBarSettings,
  setTheme: (theme) => set({ theme }),
  setStatusBarVariant: (variant) => set({ statusBarVariant: variant }),
  setServerInfoVariant: (variant) => set({ serverInfoVariant: variant }),
  setAccountVariant: (variant) => set({ accountVariant: variant }),
  setSpeedometerVariant: (variant) => set({ speedometerVariant: variant }),
  setProgressBarStyle: (style) => set({ progressBarStyle: style }),
  setProgressBarSettings: (settings) => set({ progressBarSettings: settings }),
  isHudVisible: false,
  setHudVisible: (isVisible) => set({ isHudVisible: isVisible }),
  config: {},
  setConfig: (config) => set({ config }),
  playerStatus: {},
  setPlayerStatus: (data) => set((state) => ({
    playerStatus: { ...state.playerStatus, ...data }
  })),
  account: {},
  setAccount: (data) => set((state) => ({
    account: { ...state.account, ...data }
  })),
  location: {},
  setLocation: (data) => set((state) => ({
    location: { ...state.location, ...data }
  })),
  serverInfo: {},
  setServerInfo: (data) => set((state) => ({
    serverInfo: { ...state.serverInfo, ...data }
  })),
  weapon: {},
  setWeapon: (data) => set((state) => ({
    weapon: { ...state.weapon, ...data }
  })),
  vehicle: {},
  setVehicle: (data) => set((state) => ({
    vehicle: { ...state.vehicle, ...data }
  })),
  progressBar: {},
  setProgressBar: (data) => set((state) => {
    if (data.duration && data.isVisible !== false) {
      data.isVisible = true;
    }
    return { progressBar: { ...state.progressBar, ...data } };
  })
}));

const isEnvBrowser = () => !window.invokeNative;
const noop = () => {
};

async function fetchNui(eventName, data, mockData) {
  const options = {
    method: "post",
    headers: {
      "Content-Type": "application/json; charset=UTF-8"
    },
    body: JSON.stringify(data)
  };
  if (isEnvBrowser() && mockData) return mockData;
  const resourceName = window.GetParentResourceName ? window.GetParentResourceName() : "envi-hud";
  const resp = await fetch(`https://${resourceName}/${eventName}`, options);
  const respFormatted = await resp.json();
  return respFormatted;
}

const useSettingsStore = create$1((set, get) => ({
  isVisible: false,
  isAdminVisible: false,
  wasAdminMode: false,
  notifySettings: {},
  prevNotifySettings: {},
  unsavedNotifySettings: null,
  hasUnsavedChanges: false,
  showUnsavedDialog: false,
  elementPositions: {},
  draggingElementId: null,
  hudSettings: {},
  prevHudSettings: null,
  disabledElementsState: {},
  setDraggingElementId: (elementId) => {
    set({ draggingElementId: elementId });
  },
  setSettingsVisible: (visible) => {
    if (visible) {
      const { hudSettings } = get();
      if (hudSettings && Object.keys(hudSettings).length > 0) {
        if (Object.keys(hudSettings.notification).length === 0) {
          set({
            hudSettings: {
              ...hudSettings,
              notification: {
                ...hudSettings.notification
              }
            }
          });
        }
      } else {
        const config = useConfigStore.getState().hudConfig;
        if (config?.notification?.sound) {
          config.notification.sound.path = formatSoundPath(config.notification.sound.path);
        }
        set({
          hudSettings: config,
          prevHudSettings: config
        });
      }
      set({ isVisible: true, wasAdminMode: false });
    } else {
      set({
        isVisible: false,
        unsavedNotifySettings: null,
        showUnsavedDialog: false
      });
    }
  },
  setAdminSettingsVisible: (visible) => {
    if (visible) {
      const { hudSettings } = get();
      if (hudSettings && Object.keys(hudSettings).length > 0) {
        if (Object.keys(hudSettings.notification).length === 0) {
          set({
            hudSettings: {
              ...hudSettings,
              notification: {
                ...hudSettings.notification
              }
            }
          });
        }
      } else {
        const config = useConfigStore.getState().hudConfig;
        if (config?.notification?.sound) {
          config.notification.sound.path = formatSoundPath(config.notification.sound.path);
        }
        set({
          hudSettings: config,
          prevHudSettings: config
        });
      }
      set({ isAdminVisible: true, wasAdminMode: true });
    } else {
      set({
        isAdminVisible: false,
        unsavedNotifySettings: null,
        showUnsavedDialog: false
      });
    }
  },
  closeHudSettings: () => {
    const { hasUnsavedChanges, isAdminVisible, isVisible } = get();
    if (hasUnsavedChanges) {
      set({
        isVisible: isVisible && !isAdminVisible,
        isAdminVisible: isAdminVisible && !isVisible,
        showUnsavedDialog: true
      });
    } else {
      set({
        isVisible: false,
        isAdminVisible: false,
        unsavedNotifySettings: null,
        showUnsavedDialog: false
      });
    }
  },
  setNotifySettings: (settings) => {
    const { hudSettings } = get();
    set({
      hudSettings: {
        ...hudSettings,
        notification: {
          ...hudSettings.notification,
          ...settings
        }
      },
      prevHudSettings: {
        ...hudSettings,
        notification: {
          ...hudSettings.notification,
          ...settings
        }
      }
    });
  },
  updateNotifySettings: (newSettings) => {
    const { hudSettings, hasUnsavedChanges } = get();
    if (!hasUnsavedChanges) {
      set({
        prevHudSettings: {
          ...hudSettings
        }
      });
    }
    set({
      hudSettings: {
        ...hudSettings,
        notification: {
          ...hudSettings.notification,
          ...newSettings
        }
      },
      hasUnsavedChanges: true
    });
  },
  saveChanges: () => {
    const { hudSettings } = get();
    set({
      prevHudSettings: { ...hudSettings },
      hasUnsavedChanges: false,
      showUnsavedDialog: false
    });
  },
  discardChanges: () => {
    const { prevHudSettings } = get();
    if (prevHudSettings) {
      set({
        hudSettings: { ...prevHudSettings },
        hasUnsavedChanges: false,
        showUnsavedDialog: false
      });
    }
  },
  discardHudChanges: () => {
    const { prevHudSettings, wasAdminMode } = get();
    if (prevHudSettings) {
      set({
        hudSettings: prevHudSettings,
        hasUnsavedChanges: false,
        showUnsavedDialog: false,
        isVisible: !wasAdminMode,
        isAdminVisible: wasAdminMode
      });
      const hudStore = useHudStore.getState();
      hudStore.setTheme(prevHudSettings.theme);
      if (prevHudSettings.serverInfoVariant) hudStore.setServerInfoVariant(prevHudSettings.serverInfoVariant);
      if (prevHudSettings.accountVariant) hudStore.setAccountVariant(prevHudSettings.accountVariant);
      if (prevHudSettings.statusBarVariant) hudStore.setStatusBarVariant(prevHudSettings.statusBarVariant);
      if (prevHudSettings.speedometerVariant) hudStore.setSpeedometerVariant(prevHudSettings.speedometerVariant);
      if (prevHudSettings.progressBarStyle) hudStore.setProgressBarStyle(prevHudSettings.progressBarStyle);
      if (prevHudSettings.progressBarSettings) hudStore.setProgressBarSettings(prevHudSettings.progressBarSettings);
    }
  },
  keepChanges: () => {
    set({ showUnsavedDialog: false });
  },
  resetNotifySettings: () => {
    const { prevHudSettings } = get();
    set({
      hudSettings: prevHudSettings ?? {},
      unsavedNotifySettings: null,
      hasUnsavedChanges: false,
      showUnsavedDialog: false
    });
  },
  setHudSettings: (settings) => {
    const currentSettings = get().hudSettings;
    if (!currentSettings || Object.keys(currentSettings).length === 0) {
      set({
        hudSettings: { ...currentSettings, ...settings },
        prevHudSettings: { ...currentSettings, ...settings }
      });
    }
  },
  updateHudSettings: (newSettings) => {
    const { hudSettings, prevHudSettings } = get();
    if (!prevHudSettings) {
      set({ prevHudSettings: { ...hudSettings } });
    }
    const updatedSettings = { ...hudSettings, ...newSettings };
    set({
      hudSettings: updatedSettings,
      hasUnsavedChanges: true
    });
    const hudStore = useHudStore.getState();
    if (newSettings.theme) hudStore.setTheme(newSettings.theme);
    if (newSettings.serverInfoVariant) hudStore.setServerInfoVariant(newSettings.serverInfoVariant);
    if (newSettings.accountVariant) hudStore.setAccountVariant(newSettings.accountVariant);
    if (newSettings.statusBarVariant) hudStore.setStatusBarVariant(newSettings.statusBarVariant);
    if (newSettings.speedometerVariant) hudStore.setSpeedometerVariant(newSettings.speedometerVariant);
    if (newSettings.progressBarStyle) hudStore.setProgressBarStyle(newSettings.progressBarStyle);
    if (newSettings.progressBarSettings) hudStore.setProgressBarSettings(newSettings.progressBarSettings);
  },
  saveHudChanges: async () => {
    const { hudSettings, elementPositions } = get();
    try {
      const success = await fetchNui("saveHudSettings", {
        ...hudSettings,
        elementPositions
      });
      if (success) {
        set({
          prevHudSettings: { ...hudSettings, elementPositions },
          hasUnsavedChanges: false,
          showUnsavedDialog: false
        });
        return true;
      } else {
        console.error("Failed to save HUD settings");
        return false;
      }
    } catch (error) {
      console.error("Error saving HUD settings:", error);
      return false;
    }
  },
  saveGlobalHudSettings: async () => {
    const { hudSettings, elementPositions } = get();
    const disabledElements = useConfigStore.getState().disabledHudElements;
    try {
      const success = await fetchNui("saveGlobalHudSettings", {
        settings: {
          ...hudSettings,
          elementPositions
        },
        disabledElements
      });
      if (success) {
        set({
          prevHudSettings: { ...hudSettings, elementPositions },
          hasUnsavedChanges: false,
          showUnsavedDialog: false
        });
        return true;
      } else {
        console.error("Failed to save global HUD settings");
        return false;
      }
    } catch (error) {
      console.error("Error saving global HUD settings:", error);
      return false;
    }
  },
  resetHudSettings: async () => {
    const { prevHudSettings, elementPositions } = get();
    if (prevHudSettings && Object.keys(prevHudSettings).length > 0) {
      const useOriginalVisibility = prevHudSettings.cinematicMode === false && prevHudSettings.previousElementsVisibility !== void 0;
      set({
        hudSettings: {
          ...prevHudSettings,
          minimap: {
            ...prevHudSettings.minimap,
            buffer: MinimapBufferSize[prevHudSettings.minimap.type][prevHudSettings.minimap.size]
          },
          elementsVisibility: useOriginalVisibility && prevHudSettings.previousElementsVisibility ? prevHudSettings.previousElementsVisibility : prevHudSettings.elementsVisibility,
          elementPositions: prevHudSettings.elementPositions || elementPositions
        },
        hasUnsavedChanges: false
        // elementPositions: {}
      });
      const hudStore = useHudStore.getState();
      hudStore.setTheme(prevHudSettings.theme);
      if (prevHudSettings.serverInfoVariant) hudStore.setServerInfoVariant(prevHudSettings.serverInfoVariant);
      if (prevHudSettings.accountVariant) hudStore.setAccountVariant(prevHudSettings.accountVariant);
      if (prevHudSettings.statusBarVariant) hudStore.setStatusBarVariant(prevHudSettings.statusBarVariant);
      if (prevHudSettings.speedometerVariant) hudStore.setSpeedometerVariant(prevHudSettings.speedometerVariant);
      if (prevHudSettings.progressBarStyle) hudStore.setProgressBarStyle(prevHudSettings.progressBarStyle);
      if (prevHudSettings.progressBarSettings) hudStore.setProgressBarSettings(prevHudSettings.progressBarSettings);
      await fetchNui("updateMinimap", {
        position: get().elementPositions["minimap"] || { x: 0, y: 0 },
        type: prevHudSettings.minimap.type,
        size: MinimapSizePixels[prevHudSettings.minimap.type][prevHudSettings.minimap.size],
        buffer: MinimapBufferSize[prevHudSettings.minimap.type][prevHudSettings.minimap.size]
      });
    } else {
      try {
        const config = await fetchNui("getHudConfig");
        if (config && config.theme) {
          set({
            hudSettings: config,
            hasUnsavedChanges: false,
            elementPositions: {}
          });
          const hudStore = useHudStore.getState();
          hudStore.setTheme(config.theme);
          if (config.serverInfoVariant) hudStore.setServerInfoVariant(config.serverInfoVariant);
          if (config.accountVariant) hudStore.setAccountVariant(config.accountVariant);
          if (config.statusBarVariant) hudStore.setStatusBarVariant(config.statusBarVariant);
          if (config.speedometerVariant) hudStore.setSpeedometerVariant(config.speedometerVariant);
          if (config.progressBarStyle) hudStore.setProgressBarStyle(config.progressBarStyle);
          if (config.progressBarSettings) hudStore.setProgressBarSettings(config.progressBarSettings);
          if (config.minimap) {
            await fetchNui("updateMinimap", {
              position: get().elementPositions["minimap"] || { x: 0, y: 0 },
              type: config.minimap.type,
              size: MinimapSizePixels[config.minimap.type][config.minimap.size],
              buffer: get().hudSettings.minimap.buffer || MinimapBufferSize[config.minimap.type][config.minimap.size]
            });
          }
        }
      } catch (error) {
        console.error("Error fetching config:", error);
      }
    }
  },
  updateElementPosition: (elementId, position) => {
    const { elementPositions } = get();
    set({
      elementPositions: {
        ...elementPositions,
        [elementId]: position
      }
    });
  },
  resetElementPositions: () => {
    const { elementPositions } = get();
    const currentMinimapPosition = elementPositions["minimap"];
    if (currentMinimapPosition) {
      set({
        elementPositions: {
          minimap: { x: 0, y: 0 }
        }
      });
    } else {
      set({ elementPositions: {} });
    }
  },
  toggleDraggable: () => {
    const { hudSettings, wasAdminMode } = get();
    set({
      hudSettings: {
        ...hudSettings,
        isDraggable: !hudSettings.isDraggable
      },
      wasAdminMode
    });
  },
  setDisabledElementsState: (state) => {
    set({ disabledElementsState: state });
    useConfigStore.getState().setDisabledHudElements(state);
  },
  updateDisabledElement: (element, value) => {
    const currentState = get().disabledElementsState;
    set({
      disabledElementsState: {
        ...currentState,
        [element]: value
      }
    });
    useConfigStore.getState().setDisabledHudElements({
      ...currentState,
      [element]: value
    });
  },
  updateNestedDisabledElement: (parent, child, value) => {
    const currentState = get().disabledElementsState;
    const currentParent = currentState[parent] || {};
    const updatedParent = {
      ...currentParent,
      [child]: value
    };
    const updatedState = {
      ...currentState,
      [parent]: updatedParent
    };
    set({ disabledElementsState: updatedState });
    useConfigStore.getState().setDisabledHudElements(updatedState);
  },
  toggleCinematicMode: (enabled) => {
    const { hudSettings } = get();
    const currentCinematicMode = hudSettings?.cinematicMode || false;
    const newCinematicMode = enabled !== void 0 ? enabled : !currentCinematicMode;
    const currentElementsVisibility = hudSettings?.elementsVisibility;
    if (newCinematicMode) {
      set({
        hudSettings: {
          ...hudSettings,
          cinematicMode: true,
          previousElementsVisibility: { ...currentElementsVisibility },
          elementsVisibility: {
            ...currentElementsVisibility,
            showAllElements: false,
            serverInfo: false,
            location: false,
            weapon: false,
            voice: false,
            playerStatus: false,
            account: false,
            vehicle: false
          }
        }
      });
    } else {
      const previousVisibility = hudSettings?.previousElementsVisibility || currentElementsVisibility;
      set({
        hudSettings: {
          ...hudSettings,
          cinematicMode: false,
          elementsVisibility: {
            ...previousVisibility
          }
        }
      });
    }
  }
}));

function createJSONStorage$1(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0 );
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, void 0 )
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable$1 = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable$1(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable$1(onRejected)(e);
      }
    };
  }
};
const persistImpl$1 = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage$1(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable$1(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persist$1 = persistImpl$1;

const useTutorialStore = create$1()(
  persist$1(
    (set) => ({
      hasSeenTutorial: false,
      currentStep: 0,
      isVisible: false,
      setHasSeenTutorial: (value) => set({ hasSeenTutorial: value }),
      setCurrentStep: (step) => set({ currentStep: step }),
      setTutorialVisible: (visible) => set({ isVisible: visible })
    }),
    {
      name: "envi-hud-tutorial",
      storage: createJSONStorage$1(() => localStorage)
    }
  )
);

const normalizeValue = (type, value) => {
  if (type === "health" && value > 100) {
    return value / 200 * 100;
  }
  return Math.floor(value);
};
const getStatusColor = (type, value, themeStyle) => {
  if (type === "health" && value <= 0) {
    return "#ff2d2d";
  }
  const thresholds = {
    health: { danger: 25, warning: 50 },
    armor: { danger: 25, warning: 50 },
    hunger: { danger: 25, warning: 50 },
    thirst: { danger: 25, warning: 50 },
    stamina: { danger: 25, warning: 50 },
    stress: { danger: 75, warning: 50 },
    oxygen: { danger: 25, warning: 50 }
  }[type] || { danger: 25, warning: 50 };
  if (type === "stress") {
    if (value >= thresholds.danger) return "#ff2d2d";
    if (value >= thresholds.warning) return "#fbbf24";
    return themeStyle?.progress || "#000000";
  }
  if (value <= thresholds.danger) return "#ff2d2d";
  if (value <= thresholds.warning) return "#fbbf24";
  return themeStyle?.progress || "#000000";
};
const getIconColor = (theme, progressBarStyle, isDying, type, value, themeStyle) => {
  if (!themeStyle) return "#ffffff";
  const isFillStyle = progressBarStyle === "fill";
  const isHealthType = type === "health";
  const isCleanTheme = theme === "clean_simple";
  if (isDying && isHealthType && !isFillStyle) {
    return "#ff2d2d";
  }
  if (isDying && isFillStyle) {
    return value >= 50 ? themeStyle.icon || "#ffffff" : "#ff2d2d";
  }
  if (isCleanTheme && isFillStyle) {
    return "#000000";
  }
  return themeStyle?.icon || "#ffffff";
};
const createHexagonPath = (centerX, centerY, radius) => {
  const points = [];
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 3 * i - Math.PI / 2;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    points.push(`${x},${y}`);
  }
  return `M ${points.join(" L ")} Z`;
};
const calculateHexagonPerimeter = (radius) => {
  return 6 * radius;
};
const shouldShowHudElement = (category, key, checkCurrentVisibility = false) => {
  const elementsVisibility = useSettingsStore.getState().hudSettings?.elementsVisibility;
  const disabledElements = useConfigStore.getState().disabledHudElements;
  if (!disabledElements) return true;
  const isDisabled = key ? disabledElements?.[category]?.[key] === true : disabledElements?.[category] === true;
  if (isDisabled) return false;
  if (!checkCurrentVisibility) return true;
  if (!elementsVisibility) return true;
  if (key) {
    const categoryVisibility = elementsVisibility[category];
    if (typeof categoryVisibility === "object") {
      const keyVisibility = categoryVisibility[key];
      return keyVisibility !== false;
    }
    return true;
  }
  return elementsVisibility[category] !== false;
};
const getCurrencySymbol = (code) => {
  for (const key in CurrencySymbol) {
    if (CurrencySymbol[key].code === code) {
      return CurrencySymbol[key].symbol;
    }
  }
  return "$";
};
const getCurrencyCodeMap = () => {
  const result = {};
  Object.entries(CurrencySymbol).forEach(([key, value]) => {
    result[key] = value.code;
  });
  return result;
};

const formatOptionsFromEntries = (entries, format = "snake_case", customLabels) => {
  return Object.entries(entries).map(([key, value]) => ({
    value,
    label: customLabels?.[value] ?? (format === "snake_case" ? key.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ") : key.charAt(0).toUpperCase() + key.slice(1).toLowerCase())
  }));
};
const formatSoundOptions = (sounds) => {
  const options = Object.entries(sounds).map(([key, value]) => ({
    value: key,
    label: value.name
  }));
  return options;
};
const formatSoundPath = (path) => {
  if (path.startsWith("nui://")) {
    return path;
  }
  if (path.includes("/sounds/")) {
    return `nui://envi-hud/web/build${path}`;
  }
  return `nui://envi-hud/web/build/sounds/${path}`;
};
const getFontFamily = (fonts, fontKey, defaultFont = "default") => {
  if (fontKey && fontKey.includes(",")) {
    return fontKey;
  }
  if (fontKey && fonts[fontKey]) {
    return fonts[fontKey];
  }
  return fonts[defaultFont] || "Roboto, sans-serif";
};
const formatTime = (date) => {
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  return `${hours}:${minutes}`;
};
const formatWeaponImage = (weaponName) => {
  if (typeof HudImages === "undefined") return "";
  const config = {
    enableUrl: Boolean(HudImages?.["enableUrl"]),
    baseUrl: String(HudImages?.["baseUrl"]),
    localPath: String(HudImages?.["localPath"]),
    extension: String(HudImages?.["extension"])
  };
  const shouldUseUrl = Boolean(config?.enableUrl) && config.baseUrl !== "";
  if (shouldUseUrl) {
    return `${config.baseUrl}/${weaponName.toLowerCase()}${config.extension}`;
  }
  return `${config.localPath}/${weaponName.toLowerCase()}${config.extension}`;
};
const formatNumber = (value, step) => {
  if (step < 1) {
    const decimalPlaces = step.toString().split(".")[1]?.length || 0;
    return parseFloat(value.toFixed(Math.max(decimalPlaces, 2)));
  }
  return value;
};

const NotificationIcon = ({
  icon,
  className,
  style
}) => {
  const isImageUrl = /^(https?:\/\/|\/|nui:\/\/)/i.test(icon);
  if (isImageUrl) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: icon,
        alt: "notification icon",
        loading: "lazy",
        className,
        onError: (e) => {
          console.error("Failed to load notification icon:", icon);
          e.currentTarget.style.display = "none";
        }
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon$1,
    {
      icon,
      className,
      style
    }
  );
};

const NotificationItem = ({
  type = NotificationTypeValues.DEFAULT,
  variant,
  title,
  message,
  showCloseButton = true,
  textOptions,
  theme = NotificationThemes.LIGHT,
  onClose
}) => {
  const notificationBaseStyle = HudBaseStyles.notification;
  const font = getFontFamily(defaultBaseStyle.fonts, notificationBaseStyle.font);
  const themeStyle = reactExports.useMemo(
    () => NotificationThemeStyles[theme]?.[type] ?? NotificationThemeStyles["light"]?.[type],
    [theme, type]
  );
  const styles = reactExports.useMemo(() => {
    const baseStyle = theme in NotificationBaseStyles ? NotificationBaseStyles[theme] : NotificationBaseStyles["default"];
    return {
      container: baseStyle?.container,
      icon: baseStyle?.icon,
      title: baseStyle?.title,
      message: baseStyle?.message,
      closeButton: baseStyle?.closeButton
    };
  }, [theme]);
  const renderIcon = reactExports.useCallback((iconClassName) => {
    if (variant === NotificationVariants.TEXT_ONLY || variant === NotificationVariants.LONG_TEXT) {
      return null;
    }
    const iconStyles = {
      width: styles?.icon?.size,
      height: styles?.icon?.size,
      backgroundColor: themeStyle?.iconBackground,
      color: themeStyle?.iconColor
    };
    const iconProps = {
      icon: themeStyle?.icon || "",
      className: iconClassName,
      style: {
        fontSize: styles?.icon?.iconSize
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "flex-shrink-0 rounded-full flex items-center justify-center",
        style: iconStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationIcon, { ...iconProps })
      }
    );
  }, [variant, styles.icon, themeStyle]);
  const renderTitle = reactExports.useCallback(() => {
    const isUnsupportedVariant = [
      NotificationVariants.TEXT_ONLY,
      NotificationVariants.LONG_TEXT,
      NotificationVariants.ICON_ONLY
    ].includes(variant);
    if (isUnsupportedVariant || !title) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "h1",
      {
        style: {
          fontSize: styles?.title?.fontSize,
          fontWeight: styles?.title?.fontWeight,
          color: themeStyle?.titleColor,
          fontFamily: font
        },
        children: title
      }
    );
  }, [variant, title, styles.title, themeStyle]);
  const getHeaderTitle = () => {
    switch (type) {
      case NotificationTypeValues.ERROR:
        return "Error";
      case NotificationTypeValues.WARNING:
        return "Warning";
      case NotificationTypeValues.SUCCESS:
        return "Success";
      case NotificationTypeValues.INFO:
        return "Information";
      default:
        return "Message";
    }
  };
  const getMessageStyles = reactExports.useCallback((additionalStyles = {}) => {
    const baseStyles = {
      fontSize: styles?.message?.fontSize,
      fontWeight: styles?.message?.fontWeight,
      lineHeight: styles?.message?.lineHeight,
      ...additionalStyles
    };
    if (textOptions?.enabled) {
      if (textOptions.isTruncated) {
        baseStyles.overflow = "hidden";
        baseStyles.textOverflow = "ellipsis";
        baseStyles.whiteSpace = "nowrap";
      } else if (textOptions.maxLines > 1) {
        baseStyles.display = "-webkit-box";
        baseStyles.overflow = "hidden";
        baseStyles.WebkitBoxOrient = "vertical";
        baseStyles.WebkitLineClamp = textOptions.maxLines;
      }
    }
    switch (theme) {
      case NotificationThemes.CLEAN_SIMPLE:
        baseStyles.width = "100%";
        if (!title) baseStyles.marginTop = ".65vh";
        break;
      case NotificationThemes.RETRO:
        baseStyles.flexGrow = "1";
        break;
      default:
        if (variant === NotificationVariants.TITLE) {
          baseStyles.width = "100%";
        } else if ([
          NotificationVariants.ICON_ONLY,
          NotificationVariants.ICON_NO_CLOSE
        ].includes(variant)) {
          baseStyles.flexGrow = "1";
        } else if (variant === NotificationVariants.TEXT_ONLY || variant === NotificationVariants.LONG_TEXT) ; else {
          baseStyles.flexGrow = "1";
        }
        break;
    }
    return {
      style: {
        ...baseStyles,
        color: themeStyle?.messageColor,
        fontFamily: font
      }
    };
  }, [theme, variant, styles.message, themeStyle?.messageColor, textOptions, title]);
  const themeRenderers = reactExports.useMemo(() => ({
    default: () => defaultRenderer(),
    [NotificationThemes.CLEAN_SIMPLE]: () => {
      const titleElement = renderTitle();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col items-center gap-[.65vh] text-center", children: [
        renderIcon(""),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow flex flex-col items-center gap-[.45vh]", children: [
          titleElement,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              ...getMessageStyles(),
              children: message
            }
          )
        ] })
      ] });
    },
    [NotificationThemes.RETRO]: () => {
      const titleElement = renderTitle();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col rounded-[1.25vh] border border-[#000] overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "w-full h-[3vh] border-b border-[#000] flex items-center px-[1.5vh]",
            style: { backgroundColor: themeStyle?.headerBackground },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[1.45vh] text-[#2C2C2C]",
                style: {
                  fontFamily: font
                },
                children: getHeaderTitle()
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full flex items-${titleElement ? "start" : "center"} gap-[1vh] p-[1.5vh]`, children: [
          renderIcon(""),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow flex flex-col gap-[.25vh]", children: [
            titleElement,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                ...getMessageStyles(),
                children: message
              }
            )
          ] })
        ] })
      ] });
    },
    [NotificationThemes.CYBERPUNK_2]: () => {
      const titleElement = renderTitle();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col items-center gap-[.65vh] overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-[.3vh] left-0 px-[.85vw] w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-[5vh] flex items-center gap-[.85vh]", children: [
          renderIcon(""),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "text-[1.45vh] text-[white]",
              style: {
                fontFamily: font
              },
              children: getHeaderTitle()
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[80%] mt-[2vh] flex flex-col items-center gap-[.45vh]", children: [
          titleElement,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              ...getMessageStyles(),
              children: message
            }
          )
        ] })
      ] });
    },
    [NotificationThemes.DARK]: () => defaultRenderer(),
    [NotificationThemes.LIGHT]: () => defaultRenderer(),
    [NotificationThemes.ENVI]: () => defaultRenderer(),
    [NotificationThemes.MIDNIGHT]: () => defaultRenderer(),
    [NotificationThemes.CYBERPUNK]: () => defaultRenderer()
  }), [styles, themeStyle, message, title, variant]);
  const defaultRenderer = reactExports.useCallback(() => {
    const shouldShowTitle = variant === NotificationVariants.TITLE && title;
    switch (variant) {
      case NotificationVariants.TITLE:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex items-start gap-[1vh] pr-[2.5vh]", children: [
          renderIcon("text-white"),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow flex flex-col gap-[.25vh]", children: [
            shouldShowTitle && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h1",
              {
                style: {
                  fontSize: styles?.title?.fontSize,
                  fontWeight: styles?.title?.fontWeight,
                  color: themeStyle?.titleColor,
                  fontFamily: font
                },
                children: title
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                ...getMessageStyles(),
                children: message
              }
            )
          ] })
        ] });
      case NotificationVariants.ICON_ONLY:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex items-center gap-[1vh] pr-[2.5vh]", children: [
          renderIcon("text-white"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              ...getMessageStyles(),
              children: message
            }
          )
        ] });
      case NotificationVariants.TEXT_ONLY:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ...getMessageStyles(),
            children: message
          }
        );
      case NotificationVariants.ICON_NO_CLOSE:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex items-center gap-[1vh]", children: [
          renderIcon("text-white"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              ...getMessageStyles(),
              children: message
            }
          )
        ] });
      case NotificationVariants.LONG_TEXT:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ...getMessageStyles(),
            children: message
          }
        );
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex items-start gap-[1vh] pr-[2.5vh]", children: [
          renderIcon("text-white"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              ...getMessageStyles(),
              children: message
            }
          )
        ] });
    }
  }, [variant, title, styles, themeStyle, message, renderIcon]);
  const renderContent = reactExports.useCallback(() => {
    const renderer = themeRenderers[theme] || themeRenderers["default"];
    return renderer ? renderer() : themeRenderers["default"]();
  }, [theme, themeRenderers]);
  const shouldShowCloseButton = reactExports.useCallback(() => {
    if (variant === NotificationVariants.TEXT_ONLY || variant === NotificationVariants.LONG_TEXT || variant === NotificationVariants.ICON_NO_CLOSE) {
      return false;
    }
    return showCloseButton;
  }, [variant, showCloseButton]);
  const renderCloseButton = reactExports.useCallback(() => {
    if (!shouldShowCloseButton()) return null;
    const themeToApply = [
      NotificationThemes.CLEAN_SIMPLE
    ];
    const closeButtonClasses = [
      "absolute z-[100]",
      "rounded-full flex items-center justify-center cursor-pointer transition-opacity duration-250 hover:opacity-70",
      themeToApply.includes(theme) ? themeStyle?.closeButtonBackground : ""
    ].filter(Boolean).join(" ");
    const closeButtonStyles = {
      top: styles?.closeButton?.position.top,
      right: styles?.closeButton?.position.right,
      width: themeToApply.includes(theme) ? styles?.closeButton?.containerSize : "",
      height: themeToApply.includes(theme) ? styles?.closeButton?.containerSize : "",
      backgroundColor: themeStyle?.closeButtonBackground,
      color: themeStyle?.closeButtonColor
    };
    if (theme === NotificationThemes.RETRO) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "absolute right-[1.5vh] top-[.35vh] flex items-center cursor-pointer gap-[.2vh]",
          onClick: onClose,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[1.45vh] text-[#2C2C2C]", children: "○" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[1.45vh] text-[#2C2C2C]", children: "_" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[1.45vh] text-[#2C2C2C]", children: "×" })
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        onClick: onClose,
        className: closeButtonClasses,
        style: closeButtonStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: "mdi:close",
            style: {
              width: styles?.closeButton?.size,
              height: styles?.closeButton?.size,
              color: themeStyle?.closeButtonColor
            }
          }
        )
      }
    );
  }, [shouldShowCloseButton, theme, styles, themeStyle, onClose]);
  const containerClasses = reactExports.useMemo(() => [
    themeStyle?.backgroundUrl ? "bg-fullSize bg-fullCenter bg-no-repeat" : "",
    "overflow-hidden shadow-lg"
  ].filter(Boolean).join(" "), [themeStyle]);
  const containerStyles = reactExports.useMemo(() => ({
    borderRadius: styles?.container?.borderRadius,
    borderWidth: styles?.container?.borderWidth,
    backgroundColor: themeStyle?.background,
    backgroundImage: themeStyle?.backgroundUrl ? `url(${themeStyle?.backgroundUrl})` : void 0,
    boxShadow: themeStyle?.shadow,
    borderColor: themeStyle?.borderColor
  }), [themeStyle, styles?.container]);
  const innerContainerStyles = reactExports.useMemo(() => ({
    padding: styles?.container?.padding,
    minWidth: styles?.container?.minWidth,
    maxWidth: styles?.container?.maxWidth,
    minHeight: styles?.container?.minHeight,
    ...styles?.container?.options
  }), [styles.container]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: containerClasses,
      style: containerStyles,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative",
          style: innerContainerStyles,
          children: [
            renderCloseButton(),
            renderContent()
          ]
        }
      )
    }
  );
};
NotificationItem.displayName = "NotificationItem";

const SoundContext = reactExports.createContext(void 0);
const DEFAULT_VOLUME = 0.5;
const SoundProvider = ({
  children
}) => {
  const { hudSettings } = useSettingsStore();
  const [notificationSound, setNotificationSound] = reactExports.useState(null);
  const [isEnabled, setIsEnabled] = reactExports.useState(hudSettings?.notification?.sound?.enabled ?? false);
  const audioRef = reactExports.useRef(null);
  const loadSound = reactExports.useCallback((soundConfig) => {
    if (audioRef.current) {
      audioRef.current.pause();
      audioRef.current.src = "";
    }
    const audio = new Audio();
    audio.src = formatSoundPath(soundConfig.path);
    const volume = Number(soundConfig.volume);
    if (!isNaN(volume) && isFinite(volume)) {
      audio.volume = Math.min(Math.max(volume, 0), 1);
    } else {
      audio.volume = DEFAULT_VOLUME;
      console.warn("Invalid volume value, using default:", DEFAULT_VOLUME);
    }
    audio.addEventListener("loadeddata", () => {
      setNotificationSound({
        audio,
        volume: audio.volume
      });
    });
    audioRef.current = audio;
    return audio;
  }, []);
  reactExports.useEffect(() => {
    const soundConfig = hudSettings?.notification?.sound;
    if (!soundConfig) return () => {
    };
    const audio = loadSound(soundConfig);
    setIsEnabled(soundConfig.enabled);
    return () => {
      if (audio) {
        audio.pause();
        audio.src = "";
      }
    };
  }, [hudSettings?.notification?.sound, loadSound]);
  const playNotificationSound = reactExports.useCallback(() => {
    if (audioRef.current && isEnabled) {
      audioRef.current.currentTime = 0;
      audioRef.current.play().catch((error) => {
        console.error("Error playing notification sound:", error);
      });
    }
  }, [isEnabled]);
  const setVolume = reactExports.useCallback((volume) => {
    if (notificationSound) {
      const numVolume = Number(volume);
      if (isNaN(numVolume) || !isFinite(numVolume)) {
        console.warn("Invalid volume value:", volume);
        return;
      }
      const normalizedVolume = Math.min(Math.max(numVolume, 0), 1);
      notificationSound.audio.volume = normalizedVolume;
      setNotificationSound((prev) => prev ? {
        ...prev,
        volume: normalizedVolume
      } : null);
    }
  }, [notificationSound]);
  const setSound = reactExports.useCallback((soundConfig) => {
    if (notificationSound) {
      notificationSound.audio.pause();
      notificationSound.audio.src = "";
    }
    setIsEnabled(soundConfig.enabled);
    loadSound(soundConfig);
  }, [loadSound, notificationSound]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SoundContext.Provider, { value: {
    playNotificationSound,
    setVolume,
    setSound
  }, children });
};
const useSound = () => {
  const context = reactExports.useContext(SoundContext);
  if (!context) {
    throw new Error("useSound must be used within a SoundProvider");
  }
  return context;
};

const useNotification = (config, useCustomNotifications) => {
  const { notifications, addNotification, removeNotification } = useNotificationStore();
  const { playNotificationSound } = useSound();
  const {
    position,
    maxNotifications,
    duration,
    animation,
    defaultVariant,
    sound,
    textOptions
  } = config;
  const getAnimationProps = reactExports.useCallback((position2) => {
    const { type = NotificationAnimations.SLIDE, distance = 250 } = animation;
    const transitions = {
      default: {
        type: "spring",
        stiffness: 200,
        damping: 20,
        mass: 0.8,
        duration: animation.duration
      },
      bounce: {
        type: "spring",
        stiffness: 400,
        damping: 15,
        mass: 0.8,
        duration: animation.duration,
        bounce: 0.5
      },
      elastic: {
        type: "spring",
        stiffness: 500,
        damping: 10,
        mass: 1,
        duration: animation.duration,
        bounce: 0.7
      },
      smooth: {
        type: "tween",
        duration: 0.2,
        ease: "easeOut"
      }
    };
    const getDirectionalOffset = (isNegative = false) => ({
      x: type === NotificationAnimations.BOUNCE ? isNegative ? -50 : 50 : isNegative ? -distance : distance
    });
    const getVerticalOffset = (isNegative = false) => ({
      y: type === NotificationAnimations.BOUNCE ? isNegative ? -50 : 50 : isNegative ? -distance : distance
    });
    const getPositionOffset = (pos) => {
      switch (pos) {
        case NotificationPositions.TOP_LEFT:
        case NotificationPositions.BOTTOM_LEFT:
          return getDirectionalOffset(true);
        case NotificationPositions.TOP_RIGHT:
        case NotificationPositions.BOTTOM_RIGHT:
          return getDirectionalOffset(false);
        case NotificationPositions.TOP_CENTER:
          return getVerticalOffset(true);
        case NotificationPositions.BOTTOM_CENTER:
          return getVerticalOffset(false);
        default:
          return getDirectionalOffset(false);
      }
    };
    const initialStates = {
      [NotificationAnimations.FADE]: { opacity: 0 },
      [NotificationAnimations.BOUNCE]: {
        opacity: 0,
        scale: 0.5,
        ...getPositionOffset(position2)
      },
      [NotificationAnimations.SCALE]: {
        opacity: 0,
        scale: 0.2
      },
      [NotificationAnimations.ELASTIC]: {
        opacity: 0,
        scale: 0.5,
        ...getPositionOffset(position2)
      },
      [NotificationAnimations.SLIDE]: {
        opacity: 0,
        ...getPositionOffset(position2)
      }
    };
    const getTransition = () => {
      switch (type) {
        case NotificationAnimations.BOUNCE:
          return transitions.bounce;
        case NotificationAnimations.ELASTIC:
          return transitions.elastic;
        case NotificationAnimations.FADE:
        case NotificationAnimations.SCALE:
          return transitions.smooth;
        default:
          return transitions.default;
      }
    };
    return {
      initial: initialStates[type] || initialStates[NotificationAnimations.SLIDE],
      animate: {
        opacity: 1,
        x: 0,
        y: 0,
        scale: 1,
        rotateY: 0,
        transition: getTransition()
      },
      exit: {
        opacity: 0,
        scale: type === NotificationAnimations.SCALE ? 0.5 : 0.85,
        rotateY: type === NotificationAnimations.SCALE ? -90 : 0,
        transition: transitions.smooth
      },
      layout: true,
      transition: {
        layout: {
          type: "spring",
          bounce: 0.3,
          duration: 0.6
        }
      }
    };
  }, [animation]);
  const show = reactExports.useCallback((props) => {
    if (useCustomNotifications) {
      fetchNui("sendNotification", {
        message: props.message,
        type: props.type,
        duration: props.duration || duration,
        variant: props.variant || defaultVariant,
        textOptions: props.textOptions || textOptions
      }, {
        success: true
      }).catch((error2) => {
        console.error("Error sending custom notification, fallback to internal:", error2);
        addNotification({
          duration: props.duration || duration,
          variant: props.variant || defaultVariant,
          textOptions: props.textOptions || textOptions,
          sound: props.sound || sound,
          ...props
        });
      });
      return;
    }
    if (props.sound?.enabled || sound.enabled && !props.sound) {
      playNotificationSound();
    }
    addNotification({
      duration: props.duration || duration,
      variant: props.variant || defaultVariant,
      textOptions: props.textOptions || textOptions,
      sound: props.sound || sound,
      ...props
    });
  }, [addNotification, duration, defaultVariant, sound, playNotificationSound, useCustomNotifications]);
  const success = reactExports.useCallback((message, options) => {
    show({ type: NotificationTypeValues.SUCCESS, message, ...options });
  }, [show]);
  const error = reactExports.useCallback((message, options) => {
    show({ type: NotificationTypeValues.ERROR, message, ...options });
  }, [show]);
  const warning = reactExports.useCallback((message, options) => {
    show({ type: NotificationTypeValues.WARNING, message, ...options });
  }, [show]);
  const info = reactExports.useCallback((message, options) => {
    show({ type: NotificationTypeValues.INFO, message, ...options });
  }, [show]);
  return {
    notifications: notifications.slice(0, maxNotifications),
    position,
    getAnimationProps,
    removeNotification,
    show,
    success,
    error,
    warning,
    info
  };
};

const NotificationContainer = ({
  config
}) => {
  const { notifications, removeNotification } = useNotificationStore();
  const currentPosition = config?.position ?? NotificationPositions.TOP_LEFT;
  const { getAnimationProps } = useNotification({
    theme: config?.theme ?? NotificationThemes.LIGHT,
    baseStyle: config?.baseStyle ?? "default",
    duration: config?.duration ?? 5e3,
    position: currentPosition,
    maxNotifications: config?.maxNotifications ?? 5,
    spacing: config?.spacing ?? "1.5",
    defaultVariant: config?.defaultVariant ?? NotificationVariants.BASIC,
    textOptions: config?.textOptions ?? {
      enabled: false,
      isTruncated: false,
      maxLines: 2
    },
    scale: config?.scale ?? 100,
    sound: config?.sound ?? {
      name: "default",
      path: "",
      volume: 0.5,
      enabled: false
    },
    animation: config?.animation ?? {
      type: NotificationAnimations.SLIDE,
      duration: 0.5,
      distance: 250
    }
  });
  reactExports.useEffect(() => {
    const visibleNotifications = notifications.slice(-Math.abs(config?.maxNotifications ?? 5));
    const timers = visibleNotifications.map((notification) => {
      if (notification.duration && notification.duration > 0) {
        const timer = setTimeout(() => {
          removeNotification(notification.id);
        }, notification.duration);
        return { id: notification.id, timer };
      }
      return null;
    }).filter(Boolean);
    const visibleIds = new Set(visibleNotifications.map((n) => n.id));
    notifications.forEach((notification) => {
      if (!visibleIds.has(notification.id)) {
        removeNotification(notification.id);
      }
    });
    return () => {
      timers.forEach((timer) => {
        if (timer) {
          clearTimeout(timer.timer);
        }
      });
    };
  }, [notifications, removeNotification, config?.maxNotifications]);
  const containerClasses = {
    base: `fixed px-[1.85vw] flex flex-col-reverse z-50`,
    position: {
      [NotificationPositions.TOP_LEFT]: "top-0 left-0 items-start",
      [NotificationPositions.TOP_RIGHT]: "top-0 right-0 items-end",
      [NotificationPositions.TOP_CENTER]: "top-0 left-1/2 -translate-x-1/2 items-center",
      [NotificationPositions.BOTTOM_LEFT]: "bottom-0 left-0 items-start",
      [NotificationPositions.BOTTOM_RIGHT]: "bottom-0 right-0 items-end",
      [NotificationPositions.BOTTOM_CENTER]: "bottom-0 left-1/2 -translate-x-1/2 items-center"
    }[currentPosition]
  };
  const scale = (config?.scale ?? 100) / 100;
  const calculateGap = () => {
    const baseSpacing = Number(config?.spacing ?? 1.5);
    return baseSpacing;
  };
  const calculatePadding = (position) => {
    const basePadding = 1.85;
    const verticalPadding = basePadding * scale;
    let paddingTop = position.includes("top") ? verticalPadding : 0;
    let paddingBottom = position.includes("bottom") ? verticalPadding : 0;
    if (position.includes("bottom")) {
      paddingBottom = verticalPadding * Math.pow(scale, 0.5);
    }
    return {
      paddingTop: `${paddingTop}vw`,
      paddingBottom: `${paddingBottom}vw`
    };
  };
  const getTransformOrigin = (position) => {
    if (position.includes("top")) {
      if (position.includes("right")) return "top right";
      if (position.includes("left")) return "top left";
      return "top center";
    }
    if (position.includes("bottom")) {
      if (position.includes("right")) return "bottom right";
      if (position.includes("left")) return "bottom left";
      return "bottom center";
    }
    return "center";
  };
  const getPositionAdjustment = () => {
    const padding = 1.85;
    const scaleDiff = 1 - scale;
    return {
      top: currentPosition.includes("top") ? `${padding * scaleDiff}vw` : "auto",
      bottom: currentPosition.includes("bottom") ? `${padding * scaleDiff}vw` : "auto",
      left: currentPosition.includes("left") ? `${padding * scaleDiff}vw` : currentPosition.includes("center") ? "50%" : "auto",
      right: currentPosition.includes("right") ? `${padding * scaleDiff}vw` : "auto"
    };
  };
  const positionAdjustment = getPositionAdjustment();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `${containerClasses.base} ${containerClasses.position} z-[9999]`,
      style: {
        gap: `${calculateGap()}vh`,
        transform: `scale(${scale})`,
        transformOrigin: getTransformOrigin(currentPosition),
        position: "fixed",
        top: positionAdjustment.top,
        bottom: positionAdjustment.bottom,
        left: positionAdjustment.left,
        right: positionAdjustment.right,
        translate: currentPosition.includes("center") ? "-50%" : "none",
        paddingTop: calculatePadding(currentPosition).paddingTop,
        paddingBottom: calculatePadding(currentPosition).paddingBottom
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "popLayout", children: notifications.slice(-Math.abs(config?.maxNotifications ?? 5)).map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          layoutId: `notification-${notification.id}`,
          ...getAnimationProps(currentPosition),
          layout: "position",
          style: {
            width: currentPosition.includes("center") ? "fit-content" : "auto",
            position: "relative"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: "fit-content",
            position: "relative",
            transition: "all 0.2s ease-out"
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            NotificationItem,
            {
              ...notification,
              theme: config?.theme,
              onClose: () => removeNotification(notification.id)
            }
          ) })
        },
        notification.id
      )) })
    }
  );
};

const useHudAnimation = () => {
  const animation = useSettingsStore((state) => state.hudSettings.hudAnimation);
  switch (animation) {
    case HudAnimation.FADE:
      return {
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        transition: {
          duration: 0.3,
          ease: "easeInOut"
        }
      };
    case HudAnimation.BOUNCE:
      return {
        initial: { scale: 0.8, opacity: 0 },
        animate: { scale: 1, opacity: 1 },
        transition: {
          type: "spring",
          stiffness: 300,
          damping: 15,
          duration: 0.5
        }
      };
    case HudAnimation.SLIDE:
      return {
        initial: { x: -50, opacity: 0 },
        animate: { x: 0, opacity: 1 },
        transition: {
          type: "spring",
          stiffness: 500,
          damping: 30,
          duration: 0.4
        }
      };
    case HudAnimation.SCALE:
      return {
        initial: { scale: 0, opacity: 0 },
        animate: { scale: 1, opacity: 1 },
        transition: {
          type: "tween",
          duration: 0.4,
          ease: [0.43, 0.13, 0.23, 0.96]
        }
      };
    case HudAnimation.ELASTIC:
      return {
        initial: { scale: 0.5, opacity: 0 },
        animate: { scale: 1, opacity: 1 },
        transition: {
          type: "spring",
          stiffness: 400,
          damping: 10,
          mass: 1,
          duration: 0.6
        }
      };
    default:
      return {
        initial: { opacity: 1 },
        animate: { opacity: 1 },
        transition: {
          duration: 0
        }
      };
  }
};

function DraggableElement({ children, elementId, className, onPositionChange, onDragEnd, style }) {
  const { hudSettings, elementPositions, updateElementPosition, draggingElementId, setDraggingElementId } = useSettingsStore();
  const elementRef = reactExports.useRef(null);
  const lastThemeRef = reactExports.useRef(hudSettings.theme);
  const [isOnLeftSide, setIsOnLeftSide] = reactExports.useState(false);
  const positionRef = reactExports.useRef(elementPositions[elementId]);
  const savedPosition = elementPositions[elementId] || { x: 0, y: 0 };
  const isDraggable = hudSettings?.isDraggable;
  const springConfig = { stiffness: 400, damping: 40 };
  const motionX = useSpring(savedPosition.x, springConfig);
  const motionY = useSpring(savedPosition.y, springConfig);
  const checkAndUpdatePosition = () => {
    if (!elementRef.current) return;
    const rect = elementRef.current.getBoundingClientRect();
    const newIsOnLeftSide = rect.left + rect.width / 2 < window.innerWidth / 2;
    if (newIsOnLeftSide !== isOnLeftSide) {
      setIsOnLeftSide(newIsOnLeftSide);
      if (onPositionChange) {
        onPositionChange(newIsOnLeftSide);
      }
    }
  };
  reactExports.useEffect(() => {
    const currentPosition = elementPositions[elementId];
    const hasPositionChanged = !currentPosition || positionRef.current?.x !== currentPosition.x || positionRef.current?.y !== currentPosition.y;
    if (hasPositionChanged) {
      positionRef.current = currentPosition;
      motionX.set(savedPosition.x);
      motionY.set(savedPosition.y);
      setTimeout(() => {
        checkAndUpdatePosition();
      }, 0);
      setTimeout(() => {
        checkAndUpdatePosition();
      }, 100);
    }
  }, [elementPositions, elementId]);
  reactExports.useEffect(() => {
    if (lastThemeRef.current !== hudSettings.theme) {
      lastThemeRef.current = hudSettings.theme;
      if (draggingElementId === elementId) {
        setDraggingElementId(null);
      }
      motionX.set(savedPosition.x);
      motionY.set(savedPosition.y);
      checkAndUpdatePosition();
    }
  }, [hudSettings.theme]);
  const handleDragStart = () => {
    setDraggingElementId(elementId);
  };
  const handleDragEnd = (_event, info) => {
    if (!elementRef.current) return;
    setDraggingElementId(null);
    const newPosition = {
      x: savedPosition.x + info.offset.x,
      y: savedPosition.y + info.offset.y
    };
    if (onDragEnd) {
      onDragEnd(newPosition);
    }
    updateElementPosition(elementId, newPosition);
    motionX.set(newPosition.x);
    motionY.set(newPosition.y);
    checkAndUpdatePosition();
  };
  reactExports.useEffect(() => {
    const resizeObserver = new ResizeObserver(() => {
      checkAndUpdatePosition();
    });
    if (elementRef.current) {
      resizeObserver.observe(elementRef.current);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      ref: elementRef,
      drag: isDraggable,
      dragMomentum: false,
      onDragStart: handleDragStart,
      onDragEnd: handleDragEnd,
      initial: false,
      style: {
        x: motionX,
        y: motionY,
        ...style
      },
      animate: {
        opacity: draggingElementId ? draggingElementId === elementId ? 1 : 0.5 : 1
      },
      transition: {
        opacity: { duration: 0.2 }
      },
      className: `absolute ${className} ${isDraggable ? "cursor-move" : ""}`,
      onTransitionEnd: checkAndUpdatePosition,
      children
    }
  );
}

function DefaultStatusBar(props) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const progressBarStyle = useHudStore((state) => state.progressBarStyle);
  const baseStyle = HudBaseStyles.playerStatus;
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const size = 4.35;
  const strokeWidth = 0.25;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const normalizedValue = normalizeValue(props.type, props.value);
  const progress = (100 - normalizedValue) / 100 * circumference;
  const isDying = Boolean(playerStatus.dying && props.type === "health");
  const getProgressColor = () => {
    if (isDying) return "#ff2d2d";
    if (theme === HudThemes.LIGHT) {
      return themeStyle[props.type];
    }
    return themeStyle?.progress;
  };
  const progressColor = getProgressColor();
  const iconColor = getIconColor(theme, progressBarStyle, isDying, props.type, props.value, themeStyle);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "relative",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative rounded-full flex items-center justify-center",
          style: {
            width: baseStyle?.statusItem?.size,
            height: baseStyle?.statusItem?.size,
            background: themeStyle?.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: `
            absolute inset-0 size-full 
            ${progressBarStyle === ProgressBarStyle.BORDER ? "rotate-90 -scale-x-100" : ""}
          `,
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none",
                children: progressBarStyle === ProgressBarStyle.BORDER ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: "50",
                    cy: "50",
                    r: "46",
                    fill: "none",
                    stroke: progressColor,
                    strokeWidth: "8",
                    strokeDasharray: `${2 * Math.PI * 46}`,
                    strokeDashoffset: progress * (2 * Math.PI * 46 / circumference),
                    className: "transition-all duration-500 ease-in-out",
                    style: {
                      transformOrigin: "center",
                      willChange: "stroke-dashoffset"
                    }
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: "50",
                    cy: "50",
                    r: "46",
                    fill: progressColor,
                    style: {
                      clipPath: `inset(${100 - normalizedValue}% 0 0 0)`,
                      transition: "clip-path 500ms ease-in-out",
                      willChange: "clip-path"
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: isDying ? "majesticons:skull" : themeIcons?.playerStatus?.[props.type],
                className: "z-10",
                style: {
                  color: iconColor,
                  fontSize: baseStyle?.statusItem?.iconSize
                }
              }
            )
          ]
        }
      )
    }
  );
}

function SquareStatusBar(props) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const progressBarStyle = useHudStore((state) => state.progressBarStyle);
  const baseStyle = HudBaseStyles.playerStatus;
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const size = 4.35;
  const perimeter = size * 4;
  const normalizedValue = normalizeValue(props.type, props.value);
  const progress = (100 - normalizedValue) / 100 * perimeter;
  const isDying = Boolean(playerStatus.dying && props.type === "health");
  const getProgressColor = () => {
    if (isDying) return "#ff2d2d";
    if (theme === HudThemes.LIGHT) {
      return themeStyle[props.type];
    }
    return themeStyle?.progress;
  };
  const progressColor = getProgressColor();
  const iconColor = getIconColor(theme, progressBarStyle, isDying, props.type, props.value, themeStyle);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative flex items-center justify-center overflow-hidden",
      style: {
        width: baseStyle?.statusItem?.size,
        height: baseStyle?.statusItem?.size,
        background: themeStyle?.background
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "svg",
          {
            className: "absolute inset-0 size-full",
            viewBox: "0 0 100 100",
            preserveAspectRatio: "none",
            children: progressBarStyle === ProgressBarStyle.BORDER ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "rect",
              {
                x: "0",
                y: "0",
                width: "100",
                height: "100",
                fill: "none",
                stroke: progressColor,
                strokeWidth: "16",
                strokeDasharray: "400",
                strokeDashoffset: progress * (400 / perimeter),
                className: "transition-all duration-500 ease-in-out",
                style: {
                  transformOrigin: "center",
                  willChange: "stroke-dashoffset"
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "rect",
              {
                x: "0",
                y: "0",
                width: "100",
                height: "100",
                fill: progressColor,
                style: {
                  clipPath: `inset(${100 - normalizedValue}% 0 0 0)`,
                  transition: "clip-path 500ms ease-in-out",
                  willChange: "clip-path"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: isDying ? "majesticons:skull" : themeIcons?.playerStatus?.[props.type],
            className: "z-10",
            style: {
              color: iconColor,
              fontSize: baseStyle?.statusItem?.iconSize
            }
          }
        )
      ]
    }
  ) });
}

function HexagonStatusBar(props) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const progressBarStyle = useHudStore((state) => state.progressBarStyle);
  const baseStyle = HudBaseStyles.playerStatus;
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const size = 4.35;
  const strokeWidth = 0.35;
  const radius = (size - strokeWidth) / 2;
  const normalizedValue = normalizeValue(props.type, props.value);
  const perimeter = calculateHexagonPerimeter(radius);
  const progress = (100 - normalizedValue) / 100 * perimeter;
  const isDying = Boolean(playerStatus.dying && props.type === "health");
  const getProgressColor = () => {
    if (isDying) return "#ff2d2d";
    if (theme === HudThemes.LIGHT) {
      return themeStyle[props.type];
    }
    return themeStyle?.progress;
  };
  const progressColor = getProgressColor();
  const iconColor = getIconColor(theme, progressBarStyle, isDying, props.type, props.value, themeStyle);
  const hexagonPath = createHexagonPath(size / 2, size / 2, radius);
  const backgroundPath = createHexagonPath(size / 2, size / 2, radius - strokeWidth / 2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "relative",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center justify-center",
          style: {
            width: baseStyle?.statusItem?.size,
            height: baseStyle?.statusItem?.size
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "svg",
              {
                className: "absolute inset-0 scale-x-[-1]",
                width: `${size}vh`,
                height: `${size}vh`,
                viewBox: `0 0 ${size} ${size}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: backgroundPath,
                      fill: themeStyle?.background?.replace("bg-[", "").replace("]", ""),
                      className: "transition-colors duration-500"
                    }
                  ),
                  progressBarStyle === ProgressBarStyle.BORDER ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: hexagonPath,
                      fill: "none",
                      stroke: progressColor,
                      strokeWidth,
                      strokeDasharray: perimeter,
                      strokeDashoffset: progress,
                      strokeLinejoin: "miter",
                      strokeLinecap: "square",
                      className: "transition-all duration-500 ease-in-out",
                      style: {
                        transformOrigin: "center",
                        willChange: "stroke-dashoffset"
                      }
                    }
                  ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: backgroundPath,
                      fill: progressColor,
                      style: {
                        clipPath: `inset(${100 - normalizedValue}% 0 0 0)`,
                        transition: "clip-path 500ms ease-in-out"
                      }
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: isDying ? "majesticons:skull" : themeIcons?.playerStatus?.[props.type],
                className: "z-10",
                style: {
                  color: iconColor,
                  fontSize: baseStyle?.statusItem?.iconSize
                }
              }
            )
          ]
        }
      )
    }
  );
}

function RhombusStatusBar(props) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const progressBarStyle = useHudStore((state) => state.progressBarStyle);
  const baseStyle = HudBaseStyles.playerStatus;
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const perimeter = 400;
  const normalizedValue = normalizeValue(props.type, props.value);
  const progress = (100 - normalizedValue) / 100 * perimeter;
  const isDying = Boolean(playerStatus.dying && props.type === "health");
  const getProgressColor = () => {
    if (isDying) return "#ff2d2d";
    if (theme === HudThemes.LIGHT) {
      return themeStyle[props.type];
    }
    return themeStyle?.progress;
  };
  const progressColor = getProgressColor();
  const iconColor = getIconColor(theme, progressBarStyle, isDying, props.type, props.value, themeStyle);
  const rhombusPath = `
    M 50 5
    L 75 30
    C 80 35, 85 40, 95 50
    C 85 60, 80 65, 75 70
    L 50 95
    L 25 70
    C 20 65, 15 60, 5 50
    C 15 40, 20 35, 25 30
    L 50 5
    Z
  `.trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative flex items-center justify-center overflow-hidden",
      style: {
        width: baseStyle?.statusItem?.size,
        height: baseStyle?.statusItem?.size
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "absolute inset-0 size-full",
            viewBox: "0 0 100 100",
            preserveAspectRatio: "xMidYMid meet",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: rhombusPath,
                  fill: themeStyle?.background?.replace("bg-[", "").replace("]", ""),
                  className: "transition-colors duration-500"
                }
              ),
              progressBarStyle === ProgressBarStyle.BORDER ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: rhombusPath,
                  fill: "none",
                  stroke: progressColor,
                  strokeWidth: "6",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  strokeDasharray: perimeter,
                  strokeDashoffset: progress,
                  className: "transition-all duration-500 ease-in-out",
                  style: {
                    transformOrigin: "center",
                    willChange: "stroke-dashoffset"
                  }
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: rhombusPath,
                  fill: progressColor,
                  style: {
                    clipPath: `inset(${100 - normalizedValue}% 0 0 0)`,
                    transition: "clip-path 500ms ease-in-out",
                    willChange: "clip-path"
                  }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: isDying ? "majesticons:skull" : themeIcons?.playerStatus?.[props.type],
            className: "z-10",
            style: {
              color: iconColor,
              fontSize: baseStyle?.statusItem?.iconSize
            }
          }
        )
      ]
    }
  ) });
}

function EnviStatusBar(props) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const progressBarStyle = useHudStore((state) => state.progressBarStyle);
  const baseStyle = HudBaseStyles.playerStatus;
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const perimeter = 300;
  const normalizedValue = normalizeValue(props.type, props.value);
  const progress = (100 - normalizedValue) / 100 * perimeter;
  const isDying = Boolean(playerStatus.dying && props.type === "health");
  const getProgressColor = () => {
    if (isDying) return "#ff2d2d";
    if (theme === HudThemes.LIGHT) {
      return themeStyle[props.type];
    }
    return themeStyle?.progress;
  };
  const progressColor = getProgressColor();
  const iconColor = getIconColor(theme, progressBarStyle, isDying, props.type, props.value, themeStyle);
  const enviPath = `
    M 50 0
    Q 65 35, 100 50
    Q 65 65, 50 100
    Q 35 65, 0 50
    Q 35 35, 50 0
    Z
  `.trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative flex items-center justify-center overflow-hidden",
      style: {
        width: baseStyle?.statusItem?.size,
        height: baseStyle?.statusItem?.size
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "absolute inset-0 size-full",
            viewBox: "0 0 100 100",
            preserveAspectRatio: "xMidYMid meet",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: enviPath,
                  fill: themeStyle?.background?.replace("bg-[", "").replace("]", ""),
                  className: "transition-colors duration-500"
                }
              ),
              progressBarStyle === ProgressBarStyle.BORDER ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: enviPath,
                  fill: "none",
                  stroke: progressColor,
                  strokeWidth: "6",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  strokeDasharray: perimeter,
                  strokeDashoffset: progress,
                  className: "transition-all duration-500 ease-in-out",
                  style: {
                    transformOrigin: "center",
                    willChange: "stroke-dashoffset"
                  }
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: enviPath,
                  fill: progressColor,
                  style: {
                    clipPath: `inset(${100 - normalizedValue}% 0 0 0)`,
                    transition: "clip-path 500ms ease-in-out",
                    willChange: "clip-path"
                  }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: isDying ? "majesticons:skull" : themeIcons?.playerStatus?.[props.type],
            className: "z-10",
            style: {
              color: iconColor,
              fontSize: baseStyle?.statusItem?.iconSize
            }
          }
        )
      ]
    }
  ) });
}

function StatusBar$3(props) {
  const statusBarVariant = useHudStore((state) => state.statusBarVariant);
  const theme = useHudStore((state) => state.theme);
  const animationProps = useHudAnimation();
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const baseStyle = HudBaseStyles.playerStatus;
  const commonProps = reactExports.useMemo(() => ({
    ...props,
    themeStyle,
    themeIcons,
    baseStyle
  }), [props, themeStyle, themeIcons, baseStyle]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: `status-${props.type}`, className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { scale: 0 },
      animate: { scale: 1 },
      transition: {
        delay: 0.2,
        type: "spring",
        stiffness: 200
      },
      children: (() => {
        switch (statusBarVariant) {
          case StatusBarVariant.SQUARE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                transition: { duration: 0.2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(SquareStatusBar, { ...commonProps })
              },
              `square-${props.type}`
            );
          case StatusBarVariant.HEXAGON:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                transition: { duration: 0.2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(HexagonStatusBar, { ...commonProps })
              },
              `hexagon-${props.type}`
            );
          case StatusBarVariant.RHOMBUS:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                transition: { duration: 0.2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(RhombusStatusBar, { ...commonProps })
              },
              `rhombus-${props.type}`
            );
          case StatusBarVariant.ENVI:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                transition: { duration: 0.2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(EnviStatusBar, { ...commonProps })
              },
              `envi-${props.type}`
            );
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0 },
                animate: { opacity: 1 },
                exit: { opacity: 0 },
                transition: { duration: 0.2 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultStatusBar, { ...commonProps })
              },
              `default-${props.type}`
            );
        }
      })()
    },
    `status-${props.type}-${statusBarVariant}-initial`
  ) }) });
}
function PlayerStatus() {
  const playerStatus = useHudStore((state) => state.playerStatus);
  const { playerStatusItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.playerStatus) / 100;
  const baseStyle = HudBaseStyles.playerStatus;
  const getTransformOrigin = () => {
    const position = baseStyle.container.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${baseStyle?.container?.layout}`,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                shouldShowHudElement("playerStatusItems", "health") && playerStatusItems.health && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "health", value: playerStatus.health ?? 0 }),
                shouldShowHudElement("playerStatusItems", "armor") && playerStatusItems.armor && playerStatus.armor !== void 0 && playerStatus.armor > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "armor", value: playerStatus.armor }),
                shouldShowHudElement("playerStatusItems", "hunger") && playerStatusItems.hunger && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "hunger", value: playerStatus.hunger ?? 0 }),
                shouldShowHudElement("playerStatusItems", "thirst") && playerStatusItems.thirst && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "thirst", value: playerStatus.thirst ?? 0 }),
                shouldShowHudElement("playerStatusItems", "stamina") && playerStatusItems.stamina && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "stamina", value: playerStatus.stamina ?? 0 }),
                shouldShowHudElement("playerStatusItems", "stress") && playerStatusItems.stress && playerStatus.stress !== void 0 && playerStatus.stress > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "stress", value: playerStatus.stress }),
                shouldShowHudElement("playerStatusItems", "oxygen") && playerStatusItems.oxygen && (playerStatus.oxygen ?? 0) < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$3, { type: "oxygen", value: playerStatus.oxygen ?? 0 })
              ]
            }
          )
        }
      )
    }
  );
}

const useTimeValue = () => {
  const serverInfo = useHudStore((state) => state.serverInfo);
  const timeMode = useSettingsStore((state) => state.hudSettings.timeMode) || TimeMode.REAL_TIME;
  const [currentTime, setCurrentTime] = reactExports.useState(formatTime(/* @__PURE__ */ new Date()));
  reactExports.useEffect(() => {
    setCurrentTime(formatTime(/* @__PURE__ */ new Date()));
    const interval = setInterval(() => {
      setCurrentTime(formatTime(/* @__PURE__ */ new Date()));
    }, 1e4);
    return () => clearInterval(interval);
  }, []);
  const timeValue = () => {
    return timeMode === TimeMode.IN_GAME ? serverInfo?.inGameTime || currentTime : currentTime;
  };
  return {
    timeValue
  };
};

const mockLocales = {
  common: {
    defaultSelectTitle: "Select..."
  },
  hud: {
    admin: {
      title: "Admin HUD Settings",
      description: "Configure server-wide HUD settings. Press save when you're done.",
      disabledElements: {
        title: "Disabled Elements",
        description: "Manage which HUD elements are disabled globally for all players.",
        mainElements: "Main Elements",
        manageButton: "Manage Disabled Elements"
      }
    },
    player: {
      title: "HUD Settings",
      description: "Customize your HUD in here. Press save when you're done."
    },
    groups: {
      theme: {
        title: "Theme",
        hud: "HUD",
        speedometer: "Speedometer"
      },
      hudShapes: {
        title: "HUD Element Shapes",
        serverInfo: "Server Info",
        account: "Account",
        specialThemeMessage: "Shape settings are disabled for custom themes."
      },
      statusBar: {
        title: "Status Bar",
        variant: "Variant",
        progressStyle: "Progress Style",
        progressStyleOptions: {
          border: "Border",
          fill: "Fill"
        },
        specialThemeMessage: "Status bar settings are disabled for Pixel and Retro themes as they use their own unique styles.",
        cyberpunkThemeMessage: "Status bar variant is disabled for Cyberpunk theme as it uses its own unique style."
      },
      variantOptions: {
        default: "Default",
        square: "Square",
        hexagon: "Hexagon",
        rhombus: "Rhombus",
        envi: "Envi"
      },
      animation: {
        title: "Animation Settings",
        showAnimation: "Show Animation",
        options: {
          default: "Default",
          fade: "Fade",
          bounce: "Bounce",
          slide: "Slide",
          scale: "Scale",
          elastic: "Elastic"
        }
      },
      display: {
        title: "Display Mode",
        minimap: {
          type: "Minimap Type",
          size: "Minimap Size",
          typeOptions: {
            square: "Square",
            circle: "Circle"
          },
          sizeOptions: {
            small: "Small",
            medium: "Medium",
            large: "Large"
          },
          buffer: {
            x: "Buffer X",
            y: "Buffer Y"
          }
        },
        timeMode: "Time Mode",
        timeModeOptions: {
          inGame: "In Game",
          realTime: "Real Time"
        },
        currencySymbol: "Currency Symbol",
        currencySymbolOptions: {
          usd: "USD ($)",
          eur: "EUR (€)",
          gbp: "GBP (£)"
        },
        cinematicMode: "Cinematic Mode"
      },
      progressbar: {
        title: "Progress Bar",
        theme: "Theme",
        variant: "Variant",
        variantOptions: {
          includeTitleValue: "Include Title and Value",
          includeTitle: "Include Title",
          includeValue: "Include Value",
          onlyBar: "Only Progress Bar"
        },
        animation: "Animation",
        animationOptions: {
          default: "Default",
          fade: "Fade",
          slide: "Slide",
          bounce: "Bounce"
        },
        animationDirection: "Direction",
        animationDirectionOptions: {
          default: "Default",
          top: "Top",
          right: "Right",
          bottom: "Bottom",
          left: "Left"
        },
        rounded: "Rounded Corners",
        animationDelay: "Animation Delay (s)",
        textPosition: "Text Position",
        textPositionOptions: {
          aboveBar: "Above Progress Bar",
          belowBar: "Below Progress Bar"
        },
        previewTitle: "Previewing...",
        cancelTitle: "Cancelling..."
      },
      elements: {
        title: "HUD Elements Visibility",
        showAll: "Show/Hide All Elements",
        serverInfo: "Server Info",
        location: "Location",
        weapon: "Weapon",
        voice: "Voice",
        playerStatus: "Player Status",
        account: "Account",
        vehicleHud: "Vehicle HUD",
        map: "Minimap"
      },
      serverInfo: {
        title: "Server Info Items",
        logo: "Logo",
        serverInfo: "Information",
        id: "Player ID",
        players: "Players",
        job: "Job",
        job2: "Job Grade",
        gang: "Gang",
        gang2: "Gang Grade",
        time: "Time",
        divider: "Divider"
      },
      account: {
        title: "Account Items",
        cash: "Cash",
        bank: "Bank",
        blackMoney: "Black Money",
        time: "Time"
      },
      playerStatus: {
        title: "Player Status Items",
        health: "Health",
        armor: "Armor",
        hunger: "Hunger",
        thirst: "Thirst",
        stamina: "Stamina",
        stress: "Stress",
        oxygen: "Oxygen"
      },
      elementScales: {
        title: "Element Scales",
        serverInfo: "Server Info Scale (%)",
        location: "Location Scale (%)",
        weapon: "Weapon Scale (%)",
        voice: "Voice Scale (%)",
        playerStatus: "Player Status Scale (%)",
        account: "Account Scale (%)",
        vehicle: "Vehicle HUD Scale (%)"
      }
    },
    buttons: {
      dragMode: "Enable Drag Mode",
      notifySettings: "Notification Settings",
      reset: "Reset",
      save: "Save Changes",
      saveGlobal: "Save Global"
    },
    modals: {
      unsavedChanges: {
        title: "Unsaved Changes",
        message: "You have unsaved changes. Would you like to apply these unsaved changes?",
        keep: "Keep Changes",
        discard: "Discard Changes"
      },
      applyTheme: {
        title: "Apply Theme to Speedometer",
        message: "Do you want to apply the selected HUD theme to the speedometer as well?"
      }
    },
    dragMode: {
      title: "Drag Mode Enabled",
      buttons: {
        reset: "Reset",
        exit: "Exit Drag Mode"
      }
    },
    notifications: {
      success: {
        settingsSaved: "HUD settings saved successfully!",
        globalSettingsSaved: "Global settings saved successfully!",
        notifySettingsSaved: "Notification settings saved successfully!",
        disabledElementsSaved: "Global disabled elements saved successfully!"
      }
    },
    display: {
      serverInfo: {
        players: "Players",
        id: "ID",
        job: "Job",
        gang: "Gang"
      },
      account: {
        cash: "Cash",
        bank: "Bank",
        blackMoney: "Black Money"
      },
      time: "Time"
    }
    // admin: {
    //   title: 'Admin HUD Settings',
    //   description: 'This is the admin settings. You can customize the admin settings in here. Press save when you\'re done.',
    //   buttons: {
    //     save: 'Save Default'
    //   }
    // }
  },
  notify: {
    title: "Notification Settings",
    description: "Customize your notifications in here. Press save when you're done.",
    groups: {
      appearance: {
        title: "Appearance",
        theme: "Theme",
        spacing: "Spacing",
        scale: "Scale (%)",
        variant: "Variant",
        variantOptions: {
          basic: "Basic",
          title: "Title Only",
          icon_only: "Icon Only",
          text_only: "Text Only",
          icon_no_close: "Icon Without Close",
          long_text: "Long Text"
        }
      },
      layout: {
        title: "Layout",
        position: "Position",
        positionOptions: {
          top_left: "Top Left",
          top_right: "Top Right",
          top_center: "Top Center",
          bottom_left: "Bottom Left",
          bottom_right: "Bottom Right",
          bottom_center: "Bottom Center"
        },
        maxNotifications: "Max Notifications"
      },
      sound: {
        title: "Sound",
        enable: "Enable Sound",
        select: "Notification Sound",
        volume: "Sound Volume (%)"
      },
      text: {
        title: "Text",
        enableOptions: "Enable Options",
        truncate: "Truncate",
        maxLines: "Max Lines"
      },
      animation: {
        title: "Animation",
        type: "Animation Type",
        options: {
          slide: "Slide",
          fade: "Fade",
          bounce: "Bounce",
          scale: "Scale",
          elastic: "Elastic"
        },
        duration: "Animation Duration (s)",
        distance: "Animation Distance"
      },
      behavior: {
        title: "Behavior",
        duration: "Display Duration (ms)"
      }
    },
    buttons: {
      preview: "Preview",
      save: "Save Changes"
    },
    preview: {
      title: "Preview Notification",
      message: "Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos. Lorem ipsum dolor sit amet consectetur adipisicing elit. Quisquam, quos."
    }
  },
  toggleStates: {
    enabled: "Enabled",
    disabled: "Disabled",
    show: "Show all",
    hide: "Hide all"
  },
  tutorial: {
    title: "Envi HUD Tutorial",
    stepCounter: "Step {step} of {total}",
    steps: [
      {
        title: "Welcome to ENVI HUD!",
        description: "Thank you for joining our server! Take a moment to discover the essential features of our HUD system designed to enhance your gaming experience.",
        icon: "mdi:hand-wave"
      },
      {
        title: "Customize Your HUD",
        description: "Make the HUD your own! Press F7 to access Settings where you can choose themes, adjust positions, and customize various elements to match your preferences.",
        icon: "mdi:cog"
      },
      {
        title: "Smart Notifications",
        description: "Never miss important information with our notification system. Customize notification styles, sounds, and positions in the Notification Settings to stay informed your way.",
        icon: "mdi:bell"
      },
      {
        title: "Don't Forget to Save",
        description: "Remember to save your settings using the Save Changes button. This ensures your HUD stays exactly how you like it every time you return to the server.",
        icon: "mdi:content-save"
      }
    ],
    buttons: {
      back: "Back",
      next: "Next",
      skip: "Skip Tutorial",
      getStarted: "Get Started"
    }
  }
};

const ServerHeader$7 = ({ themeStyle, themeIcons, baseStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`,
      children: [
        shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...ShadowStyle,
              width: baseStyle?.logo?.size,
              height: baseStyle?.logo?.size
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/logo.png",
                alt: "logo",
                className: "size-full object-cover"
              }
            )
          }
        ),
        shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.text,
                fontSize: defaultBaseStyle?.text?.title,
                fontWeight: defaultBaseStyle?.text?.weight?.bold,
                fontFamily: font
              },
              children: serverInfos?.name ?? "Envi-Scripts Roleplay"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.serverInfo?.discord,
                className: "size-[1.75vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  ...ShadowStyle,
                  fontSize: defaultBaseStyle?.text?.value,
                  color: themeStyle?.subText,
                  fontFamily: font
                },
                children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const InfoItem$7 = ({ icon, label, value, value2, id, themeStyle, font }) => {
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center gap-[.85vh]",
      style: {
        ...ShadowStyle,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "rounded-full flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size,
              borderWidth: defaultBaseStyle?.icon?.borderSize,
              background: themeStyle?.icon?.background,
              borderColor: themeStyle?.icon?.border,
              color: themeStyle?.icon?.text
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon,
                style: {
                  fontSize: defaultBaseStyle?.icon?.iconSize
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: defaultBaseStyle?.text?.value,
                fontFamily: font
              },
              children: value
            }
          ),
          showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: `calc(${defaultBaseStyle?.text?.value} - 0.2vh)`,
                fontFamily: font
              },
              children: value2
            }
          )
        ] })
      ]
    }
  );
};
function DefaultServerInfo() {
  const theme = useHudStore((state) => state?.theme);
  const serverInfo = useHudStore((state) => state?.serverInfo);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const infoItems = [
    {
      id: "id",
      icon: themeIcons?.serverInfo?.id,
      label: locales?.hud?.display?.serverInfo?.id,
      value: serverInfo?.playerId
    },
    // {
    //   id: "players",
    //   icon: themeIcons?.serverInfo?.players,
    //   label: locales?.hud?.display?.serverInfo?.players,
    //   value: serverInfo?.totalPlayers
    // },
    {
      id: "job",
      icon: themeIcons?.serverInfo?.job,
      label: locales?.hud?.display?.serverInfo?.job,
      value: serverInfo?.playerJob,
      value2: serverInfo?.playerJobGrade
    },
    {
      id: "gang",
      icon: themeIcons?.serverInfo?.job,
      label: locales?.hud?.display?.serverInfo?.gang,
      value: serverInfo?.playerJob2,
      value2: serverInfo?.playerJob2Grade
    },
    {
      id: "time",
      icon: themeIcons?.serverInfo?.time,
      label: locales?.hud?.display?.time,
      value: timeValue()
    }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout?.default,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$7,
                      {
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[2.25vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$7, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      ) })
    }
  );
}

const ServerHeader$6 = ({ themeStyle, themeIcons, baseStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`,
      children: [
        shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...ShadowStyle,
              width: baseStyle?.logo?.size,
              height: baseStyle?.logo?.size
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/logo.png",
                alt: "logo",
                className: "size-full object-cover"
              }
            )
          }
        ),
        shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.text,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font,
                fontWeight: defaultBaseStyle?.text?.weight?.bold
              },
              children: serverInfos?.name ?? "Envi-Scripts Roleplay"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.serverInfo?.discord,
                className: "size-[1.75vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText,
                  fontSize: defaultBaseStyle?.text?.value,
                  fontFamily: font
                },
                children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const InfoItem$6 = ({ icon, label, value, value2, id, themeStyle, font }) => {
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center gap-[.85vh]",
      style: {
        ...ShadowStyle,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size,
              borderWidth: defaultBaseStyle?.icon?.borderSize,
              background: themeStyle?.icon?.background,
              borderColor: themeStyle?.icon?.border,
              color: themeStyle?.icon?.text
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon,
                style: {
                  fontSize: defaultBaseStyle?.icon?.iconSize
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: defaultBaseStyle?.text?.value,
                fontFamily: font
              },
              children: value
            }
          ),
          showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: `calc(${defaultBaseStyle?.text?.value} - 0.2vh)`,
                fontFamily: font
              },
              children: value2
            }
          )
        ] })
      ]
    }
  );
};
function SquareServerInfo() {
  const theme = useHudStore((state) => state.theme);
  const serverInfo = useHudStore((state) => state.serverInfo);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const infoItems = [
    { id: "id", icon: themeIcons?.serverInfo?.id, label: locales?.hud?.display?.serverInfo?.id, value: serverInfo?.playerId },
    // { id: "players", icon: themeIcons?.serverInfo?.players, label: locales?.hud?.display?.serverInfo?.players, value: serverInfo?.totalPlayers },
    { id: "job", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.job, value: serverInfo?.playerJob, value2: serverInfo?.playerJobGrade },
    { id: "gang", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.gang, value: serverInfo?.playerJob2, value2: serverInfo?.playerJob2Grade },
    { id: "time", icon: themeIcons?.serverInfo?.time, label: locales?.hud?.display?.time, value: timeValue() }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout?.default,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$6,
                      {
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[2.25vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$6, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      ) })
    }
  );
}

const ServerHeader$5 = ({ themeStyle, themeIcons, baseStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`,
      children: [
        shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...ShadowStyle,
              width: baseStyle?.logo?.size,
              height: baseStyle?.logo?.size
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/logo.png",
                alt: "logo",
                className: "size-full object-cover"
              }
            )
          }
        ),
        shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.text,
                fontWeight: defaultBaseStyle?.text?.weight?.bold,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: serverInfos?.name ?? "Envi-Scripts Roleplay"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.serverInfo?.discord,
                className: "size-[1.75vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  ...ShadowStyle,
                  fontSize: defaultBaseStyle?.text?.value,
                  color: themeStyle?.subText,
                  fontFamily: font
                },
                children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const InfoItem$5 = ({ icon, label, value, value2, id, themeStyle, font }) => {
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center gap-[.85vh]",
      style: {
        ...ShadowStyle,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "polygon",
                    {
                      points: "50 0, 93.3 25, 93.3 75, 50 100, 6.7 75, 6.7 25",
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.text,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: defaultBaseStyle?.text?.value,
                fontFamily: font
              },
              children: value
            }
          ),
          showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: `calc(${defaultBaseStyle?.text?.value} - 0.2vh)`,
                fontFamily: font
              },
              children: value2
            }
          )
        ] })
      ]
    }
  );
};
function HexagonServerInfo() {
  const theme = useHudStore((state) => state.theme);
  const serverInfo = useHudStore((state) => state.serverInfo);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const infoItems = [
    { id: "id", icon: themeIcons?.serverInfo?.id, label: locales?.hud?.display?.serverInfo?.id, value: serverInfo?.playerId },
    // { id: "players", icon: themeIcons?.serverInfo?.players, label: locales?.hud?.display?.serverInfo?.players, value: serverInfo?.totalPlayers },
    { id: "job", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.job, value: serverInfo?.playerJob, value2: serverInfo?.playerJobGrade },
    { id: "gang", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.gang, value: serverInfo?.playerJob2, value2: serverInfo?.playerJob2Grade },
    { id: "time", icon: themeIcons?.serverInfo?.time, label: locales?.hud?.display?.time, value: timeValue() }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout?.default,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$5,
                      {
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[2.25vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$5, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      ) })
    }
  );
}

const ServerHeader$4 = ({ themeStyle, themeIcons, baseStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`,
      children: [
        shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...ShadowStyle,
              width: baseStyle?.logo?.size,
              height: baseStyle?.logo?.size
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/logo.png",
                alt: "logo",
                className: "size-full object-cover"
              }
            )
          }
        ),
        shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.text,
                fontWeight: defaultBaseStyle?.text?.weight?.bold,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: serverInfos?.name ?? "Envi-Scripts Roleplay"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.serverInfo?.discord,
                className: "size-[1.75vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText,
                  fontSize: defaultBaseStyle?.text?.value,
                  fontFamily: font
                },
                children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const InfoItem$4 = ({ icon, label, value, value2, id, themeStyle, font }) => {
  const rhombusPath = `
    M 50 5
    L 75 30
    C 80 35, 85 40, 95 50
    C 85 60, 80 65, 75 70
    L 50 95
    L 25 70
    C 20 65, 15 60, 5 50
    C 15 40, 20 35, 25 30
    L 50 5
    Z
  `.trim();
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center gap-[.85vh]",
      style: {
        ...ShadowStyle,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: rhombusPath,
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.text,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: defaultBaseStyle?.text?.value,
                fontFamily: font
              },
              children: value
            }
          ),
          showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: `calc(${defaultBaseStyle?.text?.value} - 0.2vh)`,
                fontFamily: font
              },
              children: value2
            }
          )
        ] })
      ]
    }
  );
};
function RhombusServerInfo() {
  const theme = useHudStore((state) => state.theme);
  const serverInfo = useHudStore((state) => state.serverInfo);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const infoItems = [
    { id: "id", icon: themeIcons?.serverInfo?.id, label: locales?.hud?.display?.serverInfo?.id, value: serverInfo?.playerId },
    // { id: "players", icon: themeIcons?.serverInfo?.players, label: locales?.hud?.display?.serverInfo?.players, value: serverInfo?.totalPlayers },
    { id: "job", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.job, value: serverInfo?.playerJob, value2: serverInfo?.playerJobGrade },
    { id: "gang", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.gang, value: serverInfo?.playerJob2, value2: serverInfo?.playerJob2Grade },
    { id: "time", icon: themeIcons?.serverInfo?.time, label: locales?.hud?.display?.time, value: timeValue() }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout?.default,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$4,
                      {
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[2.25vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$4, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      ) })
    }
  );
}

const ServerHeader$3 = ({ themeStyle, themeIcons, baseStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`,
      children: [
        shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              ...ShadowStyle,
              width: baseStyle?.logo?.size,
              height: baseStyle?.logo?.size
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/logo.png",
                alt: "logo",
                className: "size-full object-cover"
              }
            )
          }
        ),
        shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.text,
                fontSize: defaultBaseStyle?.text?.title,
                fontWeight: defaultBaseStyle?.text?.weight?.bold,
                fontFamily: font
              },
              children: serverInfos?.name ?? "Envi-Scripts Roleplay"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.serverInfo?.discord,
                className: "size-[1.75vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.subText
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  ...ShadowStyle,
                  fontSize: defaultBaseStyle?.text?.value,
                  color: themeStyle?.subText,
                  fontFamily: font
                },
                children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
const InfoItem$3 = ({ icon, label, value, value2, id, themeStyle, font }) => {
  const enviPath = `
    M 50 0
    Q 65 35, 100 50
    Q 65 65, 50 100
    Q 35 65, 0 50
    Q 35 35, 50 0
    Z
  `.trim();
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "flex items-center gap-[.85vh]",
      style: {
        ...ShadowStyle,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: enviPath,
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.text,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.subText,
                fontFamily: font
              },
              children: value
            }
          ),
          showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize",
              style: {
                ...ShadowStyle,
                color: themeStyle?.subText,
                fontSize: `calc(${defaultBaseStyle?.text?.value} - 0.2vh)`,
                fontFamily: font
              },
              children: value2
            }
          )
        ] })
      ]
    }
  );
};
function EnviServerInfo() {
  const theme = useHudStore((state) => state.theme);
  const serverInfo = useHudStore((state) => state.serverInfo);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const infoItems = [
    { id: "id", icon: themeIcons?.serverInfo?.id, label: locales?.hud?.display?.serverInfo?.id, value: serverInfo?.playerId },
    // { id: "players", icon: themeIcons?.serverInfo?.players, label: locales?.hud?.display?.serverInfo?.players, value: serverInfo?.totalPlayers },
    { id: "job", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.job, value: serverInfo?.playerJob, value2: serverInfo?.playerJobGrade },
    { id: "gang", icon: themeIcons?.serverInfo?.job, label: locales?.hud?.display?.serverInfo?.gang, value: serverInfo?.playerJob2, value2: serverInfo?.playerJob2Grade },
    { id: "time", icon: themeIcons?.serverInfo?.time, label: locales?.hud?.display?.time, value: timeValue() }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout?.default,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$3,
                      {
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[2.25vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$3, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      ) })
    }
  );
}

function ServerInfo$3() {
  const serverInfoVariant = useHudStore((state) => state.serverInfoVariant);
  switch (serverInfoVariant) {
    case ServerInfoVariant.SQUARE:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SquareServerInfo, {});
    case ServerInfoVariant.HEXAGON:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HexagonServerInfo, {});
    case ServerInfoVariant.RHOMBUS:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RhombusServerInfo, {});
    case ServerInfoVariant.ENVI:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EnviServerInfo, {});
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultServerInfo, {});
  }
}

function Location$3() {
  const theme = useHudStore((state) => state.theme);
  const location = useHudStore((state) => state.location);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.location) / 100;
  const baseStyle = HudBaseStyles.location;
  const themeStyle = LocationStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) ;
    if (position.left) return "left center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "location",
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      onPositionChange: handlePositionChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default}`,
              style: {
                ...ShadowStyle,
                gap: baseStyle?.container?.gap
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: baseStyle?.icon?.size,
                      height: baseStyle?.icon?.size
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Icon$1,
                      {
                        icon: themeIcons?.location?.area,
                        className: "size-full",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.text
                        }
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: baseStyle?.divider?.size?.width,
                      height: baseStyle?.divider?.size?.height,
                      background: themeStyle?.divider
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontSize: baseStyle?.directionText?.size,
                      fontWeight: defaultBaseStyle?.text?.weight?.bold,
                      fontFamily: font
                    },
                    children: location.direction
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: baseStyle?.divider?.size?.width,
                      height: baseStyle?.divider?.size?.height,
                      background: themeStyle?.divider
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "-mb-[.2vh]",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.text,
                        fontSize: defaultBaseStyle?.text?.title,
                        fontWeight: defaultBaseStyle?.text?.weight?.medium,
                        fontFamily: font
                      },
                      children: location.zone
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      style: {
                        ...ShadowStyle,
                        fontSize: defaultBaseStyle?.text?.value,
                        color: themeStyle?.subText,
                        fontFamily: font
                      },
                      children: location.street
                    }
                  )
                ] })
              ]
            }
          )
        }
      ) })
    }
  );
}

function Weapon$3() {
  const theme = useHudStore((state) => state.theme);
  const weapon = useHudStore((state) => state.weapon);
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.weapon) / 100;
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const baseStyle = HudBaseStyles.weapon;
  const themeStyle = WeaponStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    return "right center";
  };
  if (!weapon.weaponName) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0 },
      animate: {
        opacity: weapon.toggle ? 1 : 0
      },
      exit: { opacity: 0 },
      transition: { duration: 0.3, ease: "easeInOut" },
      className: `absolute ${enableBlackMoney ? "top-[32vh]" : "top-[27.75vh]"}`,
      style: {
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            DraggableElement,
            {
              elementId: "weapon",
              className: `relative ${isFlipped ? baseStyle.container.layout.flipped : baseStyle.container.layout.default}`,
              style: {
                gap: baseStyle?.container?.gap
              },
              onPositionChange: handlePositionChange,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      ...ShadowStyle,
                      minWidth: baseStyle?.image?.size?.minWidth,
                      maxWidth: baseStyle?.image?.size?.maxWidth,
                      height: baseStyle?.image?.size?.height
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: formatWeaponImage(weapon.weaponName),
                        alt: weapon.weaponLabel,
                        className: `size-full object-cover ${isFlipped ? "scale-x-100" : "-scale-x-100"}`
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    className: "uppercase -mb-[1vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontSize: defaultBaseStyle?.text?.title,
                      fontWeight: defaultBaseStyle?.text?.weight?.bold,
                      fontFamily: font
                    },
                    children: weapon.weaponLabel
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "flex items-center gap-[.85vh]",
                    style: ShadowStyle,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Icon$1,
                        {
                          icon: themeIcons.weapon.ammo,
                          className: "size-[1.35vh]",
                          style: {
                            ...ShadowStyle,
                            color: themeStyle?.value
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-[.85vh]`, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "span",
                          {
                            className: "text-[1.85vh]",
                            style: {
                              ...ShadowStyle,
                              color: themeStyle?.value,
                              fontWeight: defaultBaseStyle?.text?.weight?.bold,
                              fontFamily: font
                            },
                            children: weapon.ammo
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              ...ShadowStyle,
                              width: baseStyle?.divider?.size?.width,
                              height: baseStyle?.divider?.size?.height,
                              background: themeStyle?.divider
                            }
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "span",
                          {
                            className: "mt-[.3vh]",
                            style: {
                              ...ShadowStyle,
                              color: themeStyle?.subValue,
                              fontSize: defaultBaseStyle?.text?.value,
                              fontFamily: font
                            },
                            children: weapon.maxAmmo
                          }
                        )
                      ] })
                    ]
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
}

function VoiceStatus$3({ voiceLevel = 1, isTalking = false, isRadio = false }) {
  const theme = useHudStore((state) => state.theme);
  const themeStyle = PlayerStatusStyles[theme];
  const themeIcons = HudIcons[theme];
  const baseStyle = HudBaseStyles.playerStatus;
  const size = 4.35;
  const strokeWidth = 0.25;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const getVoiceLevelPercentage = (level) => {
    switch (level) {
      case 1:
        return 25;
      case 2:
        return 50;
      case 3:
        return 100;
      default:
        return level / 3 * 100;
    }
  };
  const progress = (100 - getVoiceLevelPercentage(voiceLevel)) / 100 * circumference;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: `
        relative
        transition-opacity duration-250
        ${isTalking ? "opacity-100" : "opacity-50"}
      `,
      initial: { opacity: 0, scale: 0.8 },
      animate: { opacity: isTalking ? 1 : 0.5, scale: 1 },
      transition: { duration: 0.25 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "rounded-full flex items-center justify-center",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background,
            width: baseStyle?.statusItem?.size,
            height: baseStyle?.statusItem?.size
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "absolute inset-0 rotate-90 -scale-x-100 size-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "50%",
                cy: "50%",
                r: `${radius}vh`,
                fill: "none",
                stroke: themeStyle?.progress,
                strokeWidth: `${strokeWidth}vh`,
                strokeDasharray: `${circumference}vh`,
                strokeDashoffset: `${progress}vh`,
                className: "transition-all duration-250"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { scale: 0 },
                animate: { scale: 1 },
                transition: {
                  delay: 0.2,
                  type: "spring",
                  stiffness: 200
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: isRadio ? themeIcons?.voice?.radio : themeIcons?.voice?.microphone,
                    className: "z-10",
                    style: {
                      color: themeStyle?.icon,
                      fontSize: baseStyle?.statusItem?.iconSize
                    }
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
function Voice$3() {
  const voiceStatus = useHudStore((state) => state.playerStatus.voice);
  const weapon = useHudStore((state) => state.weapon);
  const baseStyle = HudBaseStyles.voice;
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.voice) / 100;
  const elementPositions = useSettingsStore((state) => state.elementPositions);
  const weaponVisible = useSettingsStore((state) => state.hudSettings.elementsVisibility.weapon);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const shouldAnimatePosition = !elementPositions["voice-radio"];
  const defaultTop = weaponVisible && weapon.toggle ? enableBlackMoney ? "43.5vh" : "40vh" : enableBlackMoney ? "32.5vh" : "27.75vh";
  const handleDragEnd = (position) => {
    useSettingsStore.getState().updateElementPosition("voice-radio", {
      ...position,
      y: parseFloat(defaultTop) * window.innerHeight / 100
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      animate: {
        opacity: 1,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 0.8,
        restSpeed: 1e-3
      },
      className: "absolute",
      style: {
        transform: `scale(${scale})`,
        transformOrigin: "right center",
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraggableElement,
        {
          elementId: "voice-radio",
          className: "relative",
          onDragEnd: handleDragEnd,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            VoiceStatus$3,
            {
              voiceLevel: voiceStatus?.voiceLevel ?? 1,
              isTalking: voiceStatus?.isTalking ?? false,
              isRadio: voiceStatus?.isRadio ?? false
            }
          )
        }
      )
    }
  );
}

const MoneyDisplay$7 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: { willChange: "contents", fontFamily: font },
      children: `${prefix}${formattedValue}`
    }
  );
};
const AccountItem$7 = ({
  icon,
  label,
  value,
  themeStyle,
  baseStyle,
  font,
  isFlipped,
  currencyType
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `${isFlipped ? baseStyle?.item?.layout?.flipped : baseStyle?.item?.layout?.default}`,
      style: {
        ...ShadowStyle,
        gap: baseStyle?.item?.gap,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "rounded-full flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size,
              borderWidth: defaultBaseStyle?.icon?.borderSize,
              background: themeStyle?.icon?.background,
              borderColor: themeStyle?.icon?.border,
              color: themeStyle?.icon?.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon,
                style: {
                  fontSize: defaultBaseStyle?.icon?.iconSize
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.value
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                MoneyDisplay$7,
                {
                  value: value ?? 0,
                  font,
                  currencyType
                },
                `${label?.toLowerCase()}-${value}`
              )
            }
          )
        ] })
      ]
    }
  );
};
function DefaultAccount() {
  const theme = useHudStore((state) => state.theme);
  const account = useHudStore((state) => state.account);
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const animationProps = useHudAnimation();
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.account;
  const themeStyle = AccountStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const accountItems = [
    {
      id: "cash",
      icon: themeIcons?.account?.cash,
      label: locales?.hud?.display?.account?.cash,
      value: account.cash ?? 0
    },
    {
      id: "bank",
      icon: themeIcons?.account?.bank,
      label: locales?.hud?.display?.account?.bank,
      value: account.bank ?? 0
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: themeIcons?.account?.blackMoney,
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney ?? 0
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$7,
                      {
                        ...item,
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        font,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

const MoneyDisplay$6 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: { willChange: "contents", fontFamily: font },
      children: `${prefix}${formattedValue}`
    }
  );
};
const AccountItem$6 = ({
  icon,
  label,
  value,
  themeStyle,
  baseStyle,
  isFlipped,
  font,
  currencyType
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `${isFlipped ? baseStyle?.item?.layout?.flipped : baseStyle?.item?.layout?.default} relative overflow-hidden`,
      style: {
        ...ShadowStyle,
        gap: baseStyle?.item?.gap,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex items-center justify-center overflow-hidden",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size,
              borderWidth: defaultBaseStyle?.icon?.borderSize,
              background: themeStyle?.icon?.background,
              borderColor: themeStyle?.icon?.border,
              color: themeStyle?.icon?.color
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon,
                style: {
                  fontSize: defaultBaseStyle?.icon?.iconSize
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.value
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                MoneyDisplay$6,
                {
                  value: value ?? 0,
                  font,
                  currencyType
                },
                `${label?.toLowerCase()}-${value}`
              )
            }
          )
        ] })
      ]
    }
  );
};
function SquareAccount() {
  const theme = useHudStore((state) => state.theme);
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.account;
  const themeStyle = AccountStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const accountItems = [
    {
      id: "cash",
      icon: themeIcons?.account?.cash,
      label: locales?.hud?.display?.account?.cash,
      value: account.cash ?? 0
    },
    {
      id: "bank",
      icon: themeIcons?.account?.bank,
      label: locales?.hud?.display?.account?.bank,
      value: account.bank ?? 0
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: themeIcons?.account?.blackMoney,
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney ?? 0
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$6,
                      {
                        ...item,
                        font,
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

const MoneyDisplay$5 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: { willChange: "contents", fontFamily: font },
      children: `${prefix}${formattedValue}`
    }
  );
};
const AccountItem$5 = ({
  icon,
  label,
  value,
  themeStyle,
  baseStyle,
  isFlipped,
  font,
  currencyType
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `${isFlipped ? baseStyle?.item?.layout?.flipped : baseStyle?.item?.layout?.default}`,
      style: {
        ...ShadowStyle,
        gap: baseStyle?.item?.gap,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "polygon",
                    {
                      points: "50 0, 93.3 25, 93.3 75, 50 100, 6.7 75, 6.7 25",
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.color,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.value
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                MoneyDisplay$5,
                {
                  value: value ?? 0,
                  font,
                  currencyType
                },
                `${label?.toLowerCase()}-${value}`
              )
            }
          )
        ] })
      ]
    }
  );
};
function HexagonAccount() {
  const theme = useHudStore((state) => state.theme);
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.account;
  const themeStyle = AccountStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const accountItems = [
    {
      id: "cash",
      icon: themeIcons?.account?.cash,
      label: locales?.hud?.display?.account?.cash,
      value: account.cash ?? 0
    },
    {
      id: "bank",
      icon: themeIcons?.account?.bank,
      label: locales?.hud?.display?.account?.bank,
      value: account.bank ?? 0
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: themeIcons?.account?.blackMoney,
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney ?? 0
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$5,
                      {
                        ...item,
                        font,
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

const MoneyDisplay$4 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: { willChange: "contents", fontFamily: font },
      children: `${prefix}${formattedValue}`
    }
  );
};
const AccountItem$4 = ({
  icon,
  label,
  value,
  themeStyle,
  baseStyle,
  isFlipped,
  font,
  currencyType
}) => {
  const rhombusPath = `
    M 50 5
    L 75 30
    C 80 35, 85 40, 95 50
    C 85 60, 80 65, 75 70
    L 50 95
    L 25 70
    C 20 65, 15 60, 5 50
    C 15 40, 20 35, 25 30
    L 50 5
    Z
  `.trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `${isFlipped ? baseStyle?.item?.layout?.flipped : baseStyle?.item?.layout?.default}`,
      style: {
        ...ShadowStyle,
        gap: baseStyle?.item?.gap,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: rhombusPath,
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.color,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.value
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                MoneyDisplay$4,
                {
                  value: value ?? 0,
                  font,
                  currencyType
                },
                `${label?.toLowerCase()}-${value}`
              )
            }
          )
        ] })
      ]
    }
  );
};
function RhombusAccount() {
  const theme = useHudStore((state) => state.theme);
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.account;
  const themeStyle = AccountStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const accountItems = [
    {
      id: "cash",
      icon: themeIcons?.account?.cash,
      label: locales?.hud?.display?.account?.cash,
      value: account.cash ?? 0
    },
    {
      id: "bank",
      icon: themeIcons?.account?.bank,
      label: locales?.hud?.display?.account?.bank,
      value: account.bank ?? 0
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: themeIcons?.account?.blackMoney,
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney ?? 0
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$4,
                      {
                        ...item,
                        font,
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

const MoneyDisplay$3 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: { willChange: "contents", fontFamily: font },
      children: `${prefix}${formattedValue}`
    }
  );
};
const AccountItem$3 = ({
  icon,
  label,
  value,
  themeStyle,
  baseStyle,
  isFlipped,
  font,
  currencyType
}) => {
  const enviPath = `
    M 50 0
    Q 65 35, 100 50
    Q 65 65, 50 100
    Q 35 65, 0 50
    Q 35 35, 50 0
    Z
  `.trim();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `${isFlipped ? baseStyle?.item?.layout?.flipped : baseStyle?.item?.layout?.default}`,
      style: {
        ...ShadowStyle,
        gap: baseStyle?.item?.gap,
        color: themeStyle?.text
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative flex items-center justify-center",
            style: {
              ...ShadowStyle,
              width: defaultBaseStyle?.icon?.size,
              height: defaultBaseStyle?.icon?.size
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  viewBox: "0 0 100 100",
                  className: "absolute inset-0 w-full h-full",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "path",
                    {
                      d: enviPath,
                      fill: themeStyle?.icon?.background,
                      stroke: themeStyle?.icon?.border,
                      strokeWidth: "5"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon$1,
                {
                  icon,
                  style: {
                    color: themeStyle?.icon?.color,
                    fontSize: defaultBaseStyle?.icon?.iconSize
                  }
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "capitalize -mb-[.15vh]",
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.title,
                fontFamily: font
              },
              children: label
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              style: {
                ...ShadowStyle,
                fontSize: defaultBaseStyle?.text?.value,
                color: themeStyle?.value
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                MoneyDisplay$3,
                {
                  value: value ?? 0,
                  font,
                  currencyType
                },
                `${label?.toLowerCase()}-${value}`
              )
            }
          )
        ] })
      ]
    }
  );
};
function EnviAccount() {
  const theme = useHudStore((state) => state.theme);
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.account;
  const themeStyle = AccountStyles[theme];
  const themeIcons = HudIcons[theme];
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font[theme] || "default");
  const accountItems = [
    {
      id: "cash",
      icon: themeIcons?.account?.cash,
      label: locales?.hud?.display?.account?.cash,
      value: account.cash ?? 0
    },
    {
      id: "bank",
      icon: themeIcons?.account?.bank,
      label: locales?.hud?.display?.account?.bank,
      value: account.bank ?? 0
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: themeIcons?.account?.blackMoney,
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney ?? 0
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$3,
                      {
                        ...item,
                        font,
                        themeStyle,
                        themeIcons,
                        baseStyle,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.label}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

function Account$3() {
  const accountVariant = useHudStore((state) => state.accountVariant);
  switch (accountVariant) {
    case AccountVariant.SQUARE:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SquareAccount, {});
    case AccountVariant.HEXAGON:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HexagonAccount, {});
    case AccountVariant.RHOMBUS:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RhombusAccount, {});
    case AccountVariant.ENVI:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(EnviAccount, {});
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultAccount, {});
  }
}

function DefaultTheme$1() {
  const { elementsVisibility } = useSettingsStore((state) => state.hudSettings);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    shouldShowHudElement("serverInfo") && elementsVisibility?.serverInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(ServerInfo$3, {}),
    shouldShowHudElement("location") && elementsVisibility?.location && /* @__PURE__ */ jsxRuntimeExports.jsx(Location$3, {}),
    shouldShowHudElement("weapon") && elementsVisibility?.weapon && /* @__PURE__ */ jsxRuntimeExports.jsx(Weapon$3, {}),
    shouldShowHudElement("voice") && elementsVisibility?.voice && /* @__PURE__ */ jsxRuntimeExports.jsx(Voice$3, {}),
    shouldShowHudElement("playerStatus") && elementsVisibility?.playerStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(PlayerStatus, {}),
    shouldShowHudElement("account") && elementsVisibility?.account && /* @__PURE__ */ jsxRuntimeExports.jsx(Account$3, {})
  ] });
}

const MoneyDisplay$2 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontFamily: font }, children: `${prefix}${formattedValue}` });
};
const AccountItem$2 = ({
  id,
  icon,
  label,
  value,
  bgImage,
  iconSize = "w-[2.25vh] h-[2.85vh]",
  isFlipped,
  font,
  currencyType
}) => {
  const themeStyle = AccountStyles.retro;
  const displayValue = id === "time" ? value : /* @__PURE__ */ jsxRuntimeExports.jsx(
    MoneyDisplay$2,
    {
      value: Number(value) || 0,
      font,
      currencyType
    },
    `${id}-${value}`
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${isFlipped ? "flex flex-row" : "flex flex-row-reverse"} items-center gap-[1.25vh]`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `w-[3.95vh] h-[4.05vh] ${bgImage} bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: `nui://envi-hud/web/build/images/${icon}`,
            alt: label,
            className: iconSize
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh] -mb-[.35vh] mt-[.35vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: displayValue
        }
      )
    ] })
  ] });
};
function Account$2() {
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const { timeValue } = useTimeValue();
  const baseStyle = HudBaseStyles.account;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.retro || "bebas");
  const [_prevValues, setPrevValues] = reactExports.useState({
    cash: 0,
    bank: 0,
    blackMoney: 0
  });
  reactExports.useEffect(() => {
    setPrevValues({
      cash: account.cash ?? 0,
      bank: account.bank ?? 0,
      blackMoney: account.blackMoney ?? 0
    });
  }, [account]);
  const accountItems = [
    {
      id: "time",
      bgImage: "bg-retro-bg-1",
      icon: "retro-time-icon.png",
      iconSize: "size-[2.25vh]",
      label: locales?.hud?.display?.time,
      value: timeValue()
    },
    {
      id: "cash",
      bgImage: "bg-retro-bg-2",
      icon: "retro-cash-icon.png",
      label: locales?.hud?.display?.account?.cash,
      value: account.cash
    },
    {
      id: "bank",
      bgImage: "bg-retro-bg-3",
      icon: "retro-bank-icon.png",
      iconSize: "w-[2.95vh] h-[2.75vh]",
      label: locales?.hud?.display?.account?.bank,
      value: account.bank
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      bgImage: "bg-retro-bg-3",
      icon: "black-money-icon.png",
      iconSize: "w-[2.95vh] h-[2.75vh]",
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle.container.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `${baseStyle?.container?.layout} gap-[.75vh]`,
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem$2,
                      {
                        ...item,
                        isFlipped: flippedStates[itemId] || false,
                        font,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

const InfoItem$2 = ({ bgImage, icon, iconSize = "w-[2.25vh] h-[2.85vh]", label, value, value2, id, themeStyle, font }) => {
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-[3.95vh] h-[4.05vh] ${bgImage} bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: `nui://envi-hud/web/build/images/${icon}`,
        alt: label,
        className: iconSize
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh] -mb-[.35vh] mt-[.35vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh] -mb-[.35vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value
        }
      ),
      showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value2
        }
      )
    ] })
  ] });
};
const ServerHeader$2 = ({ themeStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  const themeIcons = HudIcons.retro;
  const baseStyle = HudBaseStyles.serverInfo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`, children: [
    shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          ...ShadowStyle,
          width: baseStyle?.logo?.size,
          height: baseStyle?.logo?.size
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/logo.png", alt: "logo", className: "size-full object-cover" })
      }
    ),
    shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.5vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: serverInfos?.name ?? "Envi-Scripts Roleplay"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.serverInfo?.discord,
            className: "size-[1.75vh]",
            style: {
              color: themeStyle?.icon
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[1.5vh]",
            style: {
              ...ShadowStyle,
              color: themeStyle?.text,
              fontFamily: font
            },
            children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
          }
        )
      ] })
    ] })
  ] });
};
function ServerInfo$2() {
  const serverInfo = useHudStore((state) => state.serverInfo);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles.retro;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.retro || "bebas");
  const infoItems = [
    // {
    //   id: "players",
    //   bgImage: "bg-retro-bg-1",
    //   icon: "retro-players-icon.png",
    //   label: locales?.hud?.display?.serverInfo?.players,
    //   value: serverInfo.totalPlayers
    // },
    {
      id: "id",
      bgImage: "bg-retro-bg-2",
      icon: "retro-player-icon.png",
      label: locales?.hud?.display?.serverInfo?.id,
      value: serverInfo.playerId
    },
    {
      id: "job",
      bgImage: "bg-retro-bg-3",
      icon: "retro-job1-icon.png",
      label: locales?.hud?.display?.serverInfo?.job,
      value: serverInfo.playerJob,
      value2: serverInfo.playerJobGrade
    },
    {
      id: "gang",
      bgImage: "bg-retro-bg-4",
      icon: "retro-job2-icon.png",
      iconSize: "w-[1.75vh] h-[2.85vh]",
      label: locales?.hud?.display?.serverInfo?.gang,
      value: serverInfo.playerJob2,
      value2: serverInfo.playerJob2Grade
    }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle.container.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              ...animationProps,
              className: `${baseStyle?.container?.layout?.default} gap-[1.25vh]`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "min-w-[14.15vw] relative",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader$2,
                      {
                        themeStyle,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo,
                        font
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[1.75vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$2, { ...item, themeStyle, font })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            className: "w-[.15vh] h-[3.5vh]",
                            style: {
                              ...ShadowStyle,
                              background: themeStyle?.divider
                            }
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      )
    }
  );
}

function Location$2() {
  const location = useHudStore((state) => state.location);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.location) / 100;
  const baseStyle = HudBaseStyles.location;
  const themeStyle = LocationStyles.retro;
  const themeIcons = HudIcons.retro;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.retro);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    return "left center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "location",
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      onPositionChange: handlePositionChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              ...animationProps,
              className: `${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default} gap-[1.25vh]`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-retro-bg-4 bg-fullSize bg-fullCenter bg-no-repeat size-[4.05vh] ${baseStyle?.icon?.size} flex items-center justify-center`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: themeIcons?.location?.area,
                    className: "size-[3.25vh]",
                    style: {
                      color: themeStyle?.text
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-[.15vh] h-[3.5vh]",
                    style: {
                      ...ShadowStyle,
                      background: themeStyle?.divider
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: "text-[2.5vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontWeight: defaultBaseStyle?.text?.weight?.bold
                    },
                    children: location.direction
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-[.15vh] h-[3.5vh]",
                    style: {
                      ...ShadowStyle,
                      background: themeStyle?.divider
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.6vh] tracking-[.1vw] -mb-[.2vh] mt-[.45vh]",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.text,
                        fontWeight: defaultBaseStyle?.text?.weight?.medium,
                        fontFamily: font
                      },
                      children: location.zone
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.6vh] tracking-[.1vw]",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.subText,
                        fontFamily: font
                      },
                      children: location.street
                    }
                  )
                ] })
              ]
            }
          )
        }
      )
    }
  );
}

const StatusColors = {
  health: "#FF9494",
  armor: "#74B7D1",
  thirst: "#CBEBFF",
  hunger: "#FFD966",
  stamina: "#FF9494",
  stress: "#74B7D1",
  oxygen: "#CBEBFF"
};
const StatusIcons$2 = {
  health: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.5vh] h-[4vh]", viewBox: "0 0 79 70", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M78.5403 20.4094C78.5403 9.52241 69.7133 0.691406 58.8313 0.691406C49.0873 0.691406 40.9943 7.76641 39.4103 17.0684C37.8253 7.76641 29.7323 0.691406 19.9883 0.691406C9.1063 0.691406 0.279297 9.52241 0.279297 20.4094C0.279297 26.7114 3.2393 32.3314 7.8493 35.9344L39.6983 69.3954L71.7563 35.2924C75.9213 31.6764 78.5403 26.3444 78.5403 20.4094Z",
        fill: "#F5F3DC"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M78.5403 20.4094C78.5403 9.52241 69.7133 0.691406 58.8313 0.691406C49.0873 0.691406 40.9943 7.76641 39.4103 17.0684C37.8253 7.76641 29.7323 0.691406 19.9883 0.691406C9.1063 0.691406 0.279297 9.52241 0.279297 20.4094C0.279297 26.7114 3.2393 32.3314 7.8493 35.9344L39.6983 69.3954L71.7563 35.2924C75.9213 31.6764 78.5403 26.3444 78.5403 20.4094Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  armor: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.5vh] h-[4vh]", viewBox: "0 0 67 74", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M33.293 0.0625L0.292969 10.3325V39.8225C0.292969 65.3065 33.293 73.7635 33.293 73.7635C33.293 73.7635 66.293 65.3065 66.293 39.8225V10.3325L33.293 0.0625Z", fill: "#F5F3DC" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M33.293 0.0625L0.292969 10.3325V39.8225C0.292969 65.3065 33.293 73.7635 33.293 73.7635C33.293 73.7635 66.293 65.3065 66.293 39.8225V10.3325L33.293 0.0625Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  thirst: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.5vh] h-[4vh]", viewBox: "0 0 65 78", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M64.8522 51.2352C64.8522 65.9292 50.4322 77.8372 32.6502 77.8372C14.8692 77.8372 0.449219 65.9292 0.449219 51.2352C0.449219 36.5412 32.6502 -0.0078125 32.6502 -0.0078125C32.6502 -0.0078125 64.8522 36.5412 64.8522 51.2352Z", fill: "#F5F3DC" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M64.8522 51.2352C64.8522 65.9292 50.4322 77.8372 32.6502 77.8372C14.8692 77.8372 0.449219 65.9292 0.449219 51.2352C0.449219 36.5412 32.6502 -0.0078125 32.6502 -0.0078125C32.6502 -0.0078125 64.8522 36.5412 64.8522 51.2352Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  hunger: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[3.85vh] h-[3.35vh]", viewBox: "0 0 69 63", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M48.0137 28.4208C47.2087 28.5968 46.9047 29.3288 46.4887 29.9388C43.8287 33.8358 41.8497 38.7458 39.1617 42.6978C37.8907 45.0668 40.8727 47.1728 42.5737 44.9438L50.4647 31.1118C51.1447 29.5418 49.5947 28.0748 48.0137 28.4208ZM27.7017 16.5048C27.0807 16.5808 26.4647 17.0118 26.1597 17.5518C24.1567 21.9608 20.6227 26.2828 18.6767 30.6228C17.4247 33.4158 20.0787 35.1488 21.7857 33.2648C23.9877 28.8378 27.6227 24.2668 29.5947 19.8208C30.3237 18.1788 29.7737 16.2528 27.7017 16.5048ZM41.9427 15.3338C41.1177 15.5008 40.6097 16.4508 40.1817 17.0918C34.7087 25.2748 30.4437 34.9948 25.0667 43.3198C23.1327 46.2578 26.3517 48.6938 28.4187 45.7378L44.2097 18.3198C44.8297 16.6638 43.7967 14.9598 41.9427 15.3338ZM61.6747 21.8818L61.6207 57.2168C61.4037 59.6138 60.1547 61.4908 57.8857 62.3578C42.8987 63.1778 27.7337 62.4708 12.6827 62.7188C9.65472 62.4588 7.39872 60.2708 7.19372 57.2298L7.20572 21.9998C0.0177226 18.2298 -2.63828 11.9168 5.12072 6.79078C18.4567 -2.02122 50.2097 -2.09922 63.5657 6.69678C71.3557 11.8268 69.1377 18.1538 61.6747 21.8818Z", fill: "#F5F3DC" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M48.0137 28.4208C47.2087 28.5968 46.9047 29.3288 46.4887 29.9388C43.8287 33.8358 41.8497 38.7458 39.1617 42.6978C37.8907 45.0668 40.8727 47.1728 42.5737 44.9438L50.4647 31.1118C51.1447 29.5418 49.5947 28.0748 48.0137 28.4208ZM27.7017 16.5048C27.0807 16.5808 26.4647 17.0118 26.1597 17.5518C24.1567 21.9608 20.6227 26.2828 18.6767 30.6228C17.4247 33.4158 20.0787 35.1488 21.7857 33.2648C23.9877 28.8378 27.6227 24.2668 29.5947 19.8208C30.3237 18.1788 29.7737 16.2528 27.7017 16.5048ZM41.9427 15.3338C41.1177 15.5008 40.6097 16.4508 40.1817 17.0918C34.7087 25.2748 30.4437 34.9948 25.0667 43.3198C23.1327 46.2578 26.3517 48.6938 28.4187 45.7378L44.2097 18.3198C44.8297 16.6638 43.7967 14.9598 41.9427 15.3338ZM61.6747 21.8818L61.6207 57.2168C61.4037 59.6138 60.1547 61.4908 57.8857 62.3578C42.8987 63.1778 27.7337 62.4708 12.6827 62.7188C9.65472 62.4588 7.39872 60.2708 7.19372 57.2298L7.20572 21.9998C0.0177226 18.2298 -2.63828 11.9168 5.12072 6.79078C18.4567 -2.02122 50.2097 -2.09922 63.5657 6.69678C71.3557 11.8268 69.1377 18.1538 61.6747 21.8818Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  stamina: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.5vh] h-[4vh]", viewBox: "0 0 52 76", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.3462 0.163906L49.0482 0.128906C50.8072 0.371906 51.6172 1.89991 50.8302 3.50891L36.8622 31.7919C35.0912 36.9889 43.9102 34.1879 45.9002 35.3679C47.8912 36.5489 46.5482 38.5159 45.3912 39.6969C33.7722 51.4549 21.4012 62.5299 9.80522 74.3229C8.10322 76.0239 5.46522 74.7739 5.92822 72.3549L11.9112 49.2669C12.2122 47.7049 11.6102 46.4319 9.94422 46.2239C7.80322 45.9579 4.30822 46.6289 2.41022 46.1309C1.61122 45.9229 0.824219 44.9039 0.824219 44.0599L11.5172 2.00391C11.8302 1.05491 12.3282 0.418906 13.3342 0.175906L13.3462 0.163906Z", fill: "#F5F3DC" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M13.3462 0.163906L49.0482 0.128906C50.8072 0.371906 51.6172 1.89991 50.8302 3.50891L36.8622 31.7919C35.0912 36.9889 43.9102 34.1879 45.9002 35.3679C47.8912 36.5489 46.5482 38.5159 45.3912 39.6969C33.7722 51.4549 21.4012 62.5299 9.80522 74.3229C8.10322 76.0239 5.46522 74.7739 5.92822 72.3549L11.9112 49.2669C12.2122 47.7049 11.6102 46.4319 9.94422 46.2239C7.80322 45.9579 4.30822 46.6289 2.41022 46.1309C1.61122 45.9229 0.824219 44.9039 0.824219 44.0599L11.5172 2.00391C11.8302 1.05491 12.3282 0.418906 13.3342 0.175906L13.3462 0.163906Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  stress: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.15vh] h-[3.65vh]", viewBox: "0 0 74 67", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M39.5459 58.4144C42.9169 55.3054 38.0629 49.7694 34.5239 53.1514C31.1419 56.3824 36.0169 61.6694 39.5459 58.4144ZM34.5689 14.3984C33.1209 14.6444 31.9239 16.2094 31.8679 17.6524C32.7549 26.7294 32.5779 35.9604 33.4859 45.0264C33.9379 49.5364 39.9589 49.5624 40.5499 45.1714L42.1779 17.4984C42.0309 16.1244 40.9779 14.7514 39.6029 14.4394C38.7559 14.2464 35.4529 14.2484 34.5689 14.3984ZM36.1889 0.814366C39.7529 0.529366 42.9089 2.09837 44.9839 4.96237L72.5809 52.8684C75.3059 59.0794 71.3049 65.7724 64.6409 66.4544L9.41886 66.4454C2.81986 65.9064 -1.29914 58.8824 1.47086 52.8684C10.8659 37.5124 18.8959 21.2074 28.4659 5.97037C30.2799 3.08137 32.6369 1.09837 36.1889 0.814366Z", fill: "#F5F3DC" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M39.5459 58.4144C42.9169 55.3054 38.0629 49.7694 34.5239 53.1514C31.1419 56.3824 36.0169 61.6694 39.5459 58.4144ZM34.5689 14.3984C33.1209 14.6444 31.9239 16.2094 31.8679 17.6524C32.7549 26.7294 32.5779 35.9604 33.4859 45.0264C33.9379 49.5364 39.9589 49.5624 40.5499 45.1714L42.1779 17.4984C42.0309 16.1244 40.9779 14.7514 39.6029 14.4394C38.7559 14.2464 35.4529 14.2484 34.5689 14.3984ZM36.1889 0.814366C39.7529 0.529366 42.9089 2.09837 44.9839 4.96237L72.5809 52.8684C75.3059 59.0794 71.3049 65.7724 64.6409 66.4544L9.41886 66.4454C2.81986 65.9064 -1.29914 58.8824 1.47086 52.8684C10.8659 37.5124 18.8959 21.2074 28.4659 5.97037C30.2799 3.08137 32.6369 1.09837 36.1889 0.814366Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    )
  ] }),
  oxygen: (color, clipHeight) => {
    const normalizedValue = clipHeight || 0;
    const bgColor = "#F5F3DC";
    const warningColor = "#fbbf24";
    const dangerColor = "#ff2d2d";
    const segment1_visible = normalizedValue > 75;
    const segment2_visible = normalizedValue > 25 && normalizedValue <= 75;
    const segment3_visible = normalizedValue <= 25;
    const clipPercent1 = normalizedValue > 75 ? (normalizedValue - 75) * 4 : 0;
    const clipPercent2 = normalizedValue > 25 && normalizedValue <= 75 ? (normalizedValue - 25) * 2 : 0;
    const clipPercent3 = normalizedValue <= 25 ? normalizedValue * 4 : 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[4.5vh] h-[4vh] z-10", viewBox: "0 0 297 306", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M0.496094 62.7337C0.496094 28.1587 28.5241 0.130737 63.0991 0.130737C97.6741 0.130737 125.702 28.1587 125.702 62.7337C125.702 97.3087 97.6741 125.337 63.0991 125.337C28.5241 125.337 0.496094 97.3087 0.496094 62.7337Z",
          fill: bgColor
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M125.701 161.101C125.701 113.891 163.972 75.6199 211.182 75.6199C258.392 75.6199 296.663 113.891 296.663 161.101C296.663 208.311 258.392 246.582 211.182 246.582C163.972 246.582 125.701 208.311 125.701 161.101Z",
          fill: bgColor
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M10.0293 252.924C10.0293 223.615 33.7893 199.855 63.0983 199.855C92.4073 199.855 116.167 223.615 116.167 252.924C116.167 282.233 92.4073 305.993 63.0983 305.993C33.7893 305.993 10.0293 282.233 10.0293 252.924Z",
          fill: bgColor
        }
      ),
      segment1_visible && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M0.496094 62.7337C0.496094 28.1587 28.5241 0.130737 63.0991 0.130737C97.6741 0.130737 125.702 28.1587 125.702 62.7337C125.702 97.3087 97.6741 125.337 63.0991 125.337C28.5241 125.337 0.496094 97.3087 0.496094 62.7337Z",
          fill: color,
          style: {
            clipPath: clipPercent1 > 0 ? `inset(${100 - clipPercent1}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      segment2_visible && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M125.701 161.101C125.701 113.891 163.972 75.6199 211.182 75.6199C258.392 75.6199 296.663 113.891 296.663 161.101C296.663 208.311 258.392 246.582 211.182 246.582C163.972 246.582 125.701 208.311 125.701 161.101Z",
          fill: normalizedValue > 50 ? color : warningColor,
          style: {
            clipPath: clipPercent2 > 0 ? `inset(${100 - clipPercent2}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      segment3_visible && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M10.0293 252.924C10.0293 223.615 33.7893 199.855 63.0983 199.855C92.4073 199.855 116.167 223.615 116.167 252.924C116.167 282.233 92.4073 305.993 63.0983 305.993C33.7893 305.993 10.0293 282.233 10.0293 252.924Z",
          fill: dangerColor,
          style: {
            clipPath: clipPercent3 > 0 ? `inset(${100 - clipPercent3}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      normalizedValue > 25 && normalizedValue <= 50 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M10.0293 252.924C10.0293 223.615 33.7893 199.855 63.0983 199.855C92.4073 199.855 116.167 223.615 116.167 252.924C116.167 282.233 92.4073 305.993 63.0983 305.993C33.7893 305.993 10.0293 282.233 10.0293 252.924Z",
          fill: warningColor
        }
      )
    ] });
  }
};
const getStatusBackground$1 = (type) => {
  switch (type) {
    case "health":
    case "hunger":
      return "bg-retro-status-1";
    case "armor":
    case "stress":
      return "bg-retro-status-2";
    case "thirst":
      return "bg-retro-status-3";
    case "stamina":
      return "bg-retro-status-4";
    case "oxygen":
      return "bg-retro-status-4";
    default:
      return "bg-retro-status-1";
  }
};
const DyingIcon$1 = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", className: "w-[4.15vh] h-[3.65vh]", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#ff2d2d", d: "M10.5 15.75h3l-1.5-3zM8.5 13q.825 0 1.413-.587T10.5 11t-.587-1.412T8.5 9t-1.412.588T6.5 11t.588 1.413T8.5 13m7 0q.825 0 1.413-.587T17.5 11t-.587-1.412T15.5 9t-1.412.588T13.5 11t.588 1.413T15.5 13M6 22v-4.25q-.975-.425-1.713-1.137T3.037 15t-.775-1.925T2 11q0-3.95 2.8-6.475T12 2t7.2 2.525T22 11q0 1.05-.262 2.075T20.963 15t-1.25 1.613T18 17.75V22h-3v-2h-2v2h-2v-2H9v2z" }) });
};
const StatusBar$2 = ({ type, value }) => {
  const playerStatus = useHudStore((state) => state.playerStatus);
  const animationProps = useHudAnimation();
  const normalizedValue = normalizeValue(type, value);
  const isDying = type === "health" && playerStatus.dying;
  const statusColor = value === 0 ? "#F5F3DC" : isDying ? "#ff2d2d" : StatusColors[type];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      ...animationProps,
      className: "relative",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center w-[5.45vh] h-[5.65vh] pb-[.5vh] ${getStatusBackground$1(type)} bg-fullSize bg-fullCenter bg-no-repeat`, children: isDying ? /* @__PURE__ */ jsxRuntimeExports.jsx(DyingIcon$1, {}) : StatusIcons$2[type]?.(statusColor, normalizedValue) })
    }
  );
};
function Status$2() {
  const { playerStatusItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.playerStatus) / 100;
  const baseStyle = HudBaseStyles.playerStatus;
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position?.right) return "right center";
    if (position?.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                shouldShowHudElement("playerStatusItems", "health") && playerStatusItems?.health && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-health", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "health", value: playerStatus.health ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "armor") && playerStatusItems?.armor && playerStatus?.armor !== void 0 && playerStatus?.armor > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-armor", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "armor", value: playerStatus.armor }) }),
                shouldShowHudElement("playerStatusItems", "thirst") && playerStatusItems?.thirst && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-thirst", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "thirst", value: playerStatus.thirst ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "hunger") && playerStatusItems?.hunger && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-hunger", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "hunger", value: playerStatus.hunger ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "stamina") && playerStatusItems?.stamina && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stamina", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "stamina", value: playerStatus.stamina ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "stress") && playerStatusItems?.stress && playerStatus?.stress !== void 0 && playerStatus?.stress > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stress", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "stress", value: playerStatus.stress }) }),
                shouldShowHudElement("playerStatusItems", "oxygen") && playerStatusItems?.oxygen && (playerStatus.oxygen ?? 0) < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-oxygen", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$2, { type: "oxygen", value: playerStatus.oxygen ?? 0 }) })
              ]
            }
          )
        }
      )
    }
  );
}

const VoiceStatus$2 = ({ isTalking = false, voiceLevel = 1, isRadio = false, themeStyle }) => {
  const [progress, setProgress] = reactExports.useState(0);
  const getVoiceLevelPercentage = (level) => {
    switch (level) {
      case 1:
        return 25;
      case 2:
        return 50;
      case 3:
        return 100;
      default:
        return level / 3 * 100;
    }
  };
  reactExports.useEffect(() => {
    const percentage = getVoiceLevelPercentage(voiceLevel);
    setProgress(percentage);
  }, [voiceLevel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: `
        w-[3.95vh] h-[4.05vh] 
        bg-retro-bg-3 bg-fullSize bg-fullCenter bg-no-repeat 
        flex items-center justify-center
        transition-opacity duration-300
        ${isTalking ? "opacity-100" : "opacity-50"}
      `,
      initial: { opacity: 0, scale: 0.8 },
      animate: { opacity: isTalking ? 1 : 0.5, scale: 1 },
      transition: { duration: 0.25 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative size-[2.25vh]", children: isRadio ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", className: "size-full", viewBox: "0 0 48 48", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("mask", { id: "ipSRadioNanny0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "none", strokeLinecap: "round", strokeWidth: "4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: themeStyle?.voice?.layer1, stroke: themeStyle?.voice?.layer1, d: "M36 42.001V21.688C36 15.313 31.09 10 24 10s-12 5.313-12 11.688V42c0 1.105.895 1.999 2 1.999h20c1.105 0 2-.894 2-1.999Z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "24", cy: "23", r: "4", fill: themeStyle?.voice?.layer2, stroke: themeStyle?.voice?.layer2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: themeStyle?.voice?.layer2, d: "M18 34h2m6 4h4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: themeStyle?.voice?.layer1, d: "M12 20V4" })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: themeStyle?.voice?.layer2, d: "M0 0h48v48H0z", mask: "url(#ipSRadioNanny0)" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", className: "size-full", viewBox: "0 0 14 14", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("mask", { id: "progress-mask", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "100%", height: `${100 - progress}%`, fill: "black" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: themeStyle?.background,
            fillRule: "evenodd",
            d: "M6.75 0a2.946 2.946 0 0 0-2.946 2.946v3.425a2.946 2.946 0 1 0 5.892 0V2.946A2.946 2.946 0 0 0 6.75 0M6 12.008v1.212a.75.75 0 0 0 1.5 0v-1.213a5.25 5.25 0 0 0 5-5.244a.75.75 0 0 0-1.5 0a3.75 3.75 0 0 1-3.75 3.75h-1a3.75 3.75 0 0 1-3.75-3.75a.75.75 0 1 0-1.5 0a5.25 5.25 0 0 0 5 5.245",
            clipRule: "evenodd"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.path,
          {
            fill: themeStyle?.progress,
            fillRule: "evenodd",
            d: "M6.75 0a2.946 2.946 0 0 0-2.946 2.946v3.425a2.946 2.946 0 1 0 5.892 0V2.946A2.946 2.946 0 0 0 6.75 0M6 12.008v1.212a.75.75 0 0 0 1.5 0v-1.213a5.25 5.25 0 0 0 5-5.244a.75.75 0 0 0-1.5 0a3.75 3.75 0 0 1-3.75 3.75h-1a3.75 3.75 0 0 1-3.75-3.75a.75.75 0 1 0-1.5 0a5.25 5.25 0 0 0 5 5.245",
            clipRule: "evenodd",
            initial: { clipPath: `inset(100% 0 0 0)` },
            animate: {
              clipPath: `inset(${100 - progress}% 0 0 0)`
            },
            transition: {
              duration: 0.5,
              ease: "easeInOut"
            }
          }
        )
      ] }) })
    }
  );
};
function Voice$2() {
  const voiceStatus = useHudStore((state) => state.playerStatus.voice);
  const weapon = useHudStore((state) => state.weapon);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.voice) / 100;
  const themeStyle = PlayerStatusStyles.retro;
  const baseStyle = HudBaseStyles.voice;
  const elementPositions = useSettingsStore((state) => state.elementPositions);
  const weaponVisible = useSettingsStore((state) => state.hudSettings.elementsVisibility.weapon);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const shouldAnimatePosition = !elementPositions["voice-radio"];
  const defaultTop = weaponVisible && weapon.toggle ? enableBlackMoney ? "50.5vh" : "45.5vh" : enableBlackMoney ? "39.5vh" : "34.5vh";
  const handleDragEnd = (position) => {
    useSettingsStore.getState().updateElementPosition("voice-radio", {
      ...position,
      y: parseFloat(defaultTop) * window.innerHeight / 100
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      animate: {
        opacity: 1,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 0.8,
        restSpeed: 1e-3
      },
      className: "absolute",
      style: {
        transform: `scale(${scale})`,
        transformOrigin: "right center",
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraggableElement,
        {
          elementId: "voice-radio",
          className: "relative",
          onDragEnd: handleDragEnd,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            VoiceStatus$2,
            {
              isTalking: voiceStatus?.isTalking ?? false,
              voiceLevel: voiceStatus?.voiceLevel ?? 1,
              isRadio: voiceStatus?.isRadio ?? false,
              themeStyle
            }
          )
        }
      )
    }
  );
}

function Weapon$2() {
  const weapon = useHudStore((state) => state.weapon);
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.weapon) / 100;
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const baseStyle = HudBaseStyles.weapon;
  const themeIcons = HudIcons.retro;
  const themeStyle = WeaponStyles.retro;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.retro);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
  };
  if (!weapon.weaponName) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0 },
      animate: {
        opacity: weapon.toggle ? 1 : 0
      },
      exit: { opacity: 0 },
      transition: { duration: 0.3, ease: "easeInOut" },
      className: `absolute ${enableBlackMoney ? "top-[39vh]" : "top-[34vh]"}`,
      style: {
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            DraggableElement,
            {
              elementId: "weapon",
              className: `relative ${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default}`,
              style: {
                gap: baseStyle?.container?.gap
              },
              onPositionChange: handlePositionChange,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      ...ShadowStyle,
                      minWidth: baseStyle?.image?.size?.minWidth,
                      maxWidth: baseStyle?.image?.size?.maxWidth,
                      height: baseStyle?.image?.size?.height
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: formatWeaponImage(weapon.weaponName),
                        alt: weapon.weaponLabel,
                        className: `size-full object-cover ${isFlipped ? "scale-x-100" : "-scale-x-100"}`
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    className: "text-[1.35vh] uppercase tracking-[.15vw] -mb-[.85vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontFamily: font
                    },
                    children: weapon.weaponLabel
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-[.85vh]`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-bg-1 size-[2.25vh] bg-fullSize bg-fullCenter flex items-center justify-center pb-[.25vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Icon$1,
                    {
                      icon: themeIcons?.weapon?.ammo,
                      className: "size-[1.45vh]",
                      style: {
                        color: themeStyle?.value
                      }
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-[.85vh]`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.value,
                          fontFamily: font
                        },
                        children: weapon.ammo
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "mb-[.15vh]",
                        style: {
                          ...ShadowStyle,
                          width: baseStyle?.divider?.size?.width,
                          height: baseStyle?.divider?.size?.height,
                          background: themeStyle?.divider
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.subValue,
                          fontFamily: font
                        },
                        children: weapon.maxAmmo
                      }
                    )
                  ] })
                ] })
              ]
            }
          )
        }
      )
    }
  );
}

function RetroTheme$1() {
  const { elementsVisibility } = useSettingsStore((state) => state.hudSettings);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    shouldShowHudElement("serverInfo") && elementsVisibility?.serverInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(ServerInfo$2, {}),
    shouldShowHudElement("account") && elementsVisibility?.account && /* @__PURE__ */ jsxRuntimeExports.jsx(Account$2, {}),
    shouldShowHudElement("location") && elementsVisibility?.location && /* @__PURE__ */ jsxRuntimeExports.jsx(Location$2, {}),
    shouldShowHudElement("playerStatus") && elementsVisibility?.playerStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(Status$2, {}),
    shouldShowHudElement("weapon") && elementsVisibility?.weapon && /* @__PURE__ */ jsxRuntimeExports.jsx(Weapon$2, {}),
    shouldShowHudElement("voice") && elementsVisibility?.voice && /* @__PURE__ */ jsxRuntimeExports.jsx(Voice$2, {})
  ] });
}

const InfoItem$1 = ({ bgImage, icon, iconSize = "w-[3vh] h-[2.75vh]", label, value, value2, id, themeStyle, font }) => {
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-[4.661vh] h-[4.262vh] ${bgImage} bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: `nui://envi-hud/web/build/images/${icon}`,
        alt: label,
        className: iconSize
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh] -mb-[.35vh] mt-[.35vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh] -mb-[.35vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value
        }
      ),
      showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.6vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value2
        }
      )
    ] })
  ] });
};
const ServerHeader$1 = ({ themeStyle, isFlipped, showLogo, showServerInfo, font }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  const themeIcons = HudIcons.pixel;
  const baseStyle = HudBaseStyles.serverInfo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`, children: [
    shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          ...ShadowStyle,
          width: baseStyle?.logo?.size,
          height: baseStyle?.logo?.size
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/logo.png", alt: "logo", className: "size-full object-cover" })
      }
    ),
    shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.5vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: serverInfos?.name ?? "Envi-Scripts Roleplay"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.serverInfo?.discord,
            className: "size-[1.75vh]",
            style: {
              color: themeStyle?.icon
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[1.5vh]",
            style: {
              ...ShadowStyle,
              color: themeStyle?.text,
              fontFamily: font
            },
            children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
          }
        )
      ] })
    ] })
  ] });
};
function ServerInfo$1() {
  const serverInfo = useHudStore((state) => state.serverInfo);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles.pixel;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.pixel || "pixel");
  const infoItems = [
    // {
    //   id: "players",
    //   bgImage: "bg-pixel-bg-1",
    //   icon: "pixel-player-icon.png",
    //   iconSize: "w-[2.5vh] h-[2.75vh]",
    //   label: locales?.hud?.display?.serverInfo?.players,
    //   value: serverInfo.totalPlayers
    // },
    {
      id: "id",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-players-icon.png",
      label: locales?.hud?.display?.serverInfo?.id,
      value: serverInfo.playerId
    },
    {
      id: "job",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-job1-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.serverInfo?.job,
      value: serverInfo.playerJob,
      value2: serverInfo.playerJobGrade
    },
    {
      id: "gang",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-job2-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.serverInfo?.gang,
      value: serverInfo.playerJob2,
      value2: serverInfo.playerJob2Grade
    }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle.container.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${baseStyle?.container?.layout?.default} gap-[1.25vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DraggableElement,
              {
                elementId: "server-info-header",
                className: "relative min-w-[14.15vw]",
                onPositionChange: handlePositionChange,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ServerHeader$1,
                  {
                    themeStyle,
                    isFlipped,
                    showLogo: serverInfoItems.logo,
                    showServerInfo: serverInfoItems.serverInfo,
                    font
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[1.75vh]", children: (() => {
              const visibleItems = infoItems.filter(
                (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
              );
              return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: `server-info-item-${visibleIndex}`,
                    className: "relative",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem$1, { ...item, themeStyle, font })
                  }
                ),
                visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: `server-info-divider-${visibleIndex}`,
                    className: "relative",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "w-[.15vh] h-[5vh]",
                        style: {
                          ...ShadowStyle,
                          background: themeStyle?.divider
                        }
                      }
                    )
                  }
                )
              ] }, visibleIndex));
            })() })
          ] })
        }
      ) })
    }
  );
}

const MoneyDisplay$1 = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontFamily: font }, children: `${prefix}${formattedValue}` });
};
const AccountItem$1 = ({
  id,
  icon,
  label,
  value,
  bgImage,
  iconSize = "w-[3vh] h-[2.75vh]",
  isFlipped,
  font,
  currencyType
}) => {
  const displayValue = id === "time" ? value : /* @__PURE__ */ jsxRuntimeExports.jsx(
    MoneyDisplay$1,
    {
      value: Number(value) || 0,
      font,
      currencyType
    },
    `${id}-${value}`
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${isFlipped ? "flex flex-row" : "flex flex-row-reverse"} items-center gap-[1.25vh]`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `w-[4.661vh] h-[4.262vh] ${bgImage} bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: `nui://envi-hud/web/build/images/${icon}`,
            alt: label,
            className: iconSize
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[#FFFDE9] text-[1.6vh] -mb-[.35vh] mt-[.35vh]",
          style: {
            ...ShadowStyle,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[#FFFDE9] text-[1.6vh]",
          style: {
            ...ShadowStyle,
            fontFamily: font
          },
          children: displayValue
        }
      )
    ] })
  ] });
};
function Account$1() {
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const { timeValue } = useTimeValue();
  const baseStyle = HudBaseStyles.account;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.pixel || "pixel");
  const [_prevValues, setPrevValues] = reactExports.useState({
    cash: 0,
    bank: 0,
    blackMoney: 0
  });
  reactExports.useEffect(() => {
    setPrevValues({
      cash: account.cash ?? 0,
      bank: account.bank ?? 0,
      blackMoney: account.blackMoney ?? 0
    });
  }, [account]);
  const accountItems = [
    {
      id: "time",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-time-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.time,
      value: timeValue()
    },
    {
      id: "cash",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-cash-icon.png",
      label: locales?.hud?.display?.account?.cash,
      value: account.cash
    },
    {
      id: "bank",
      bgImage: "bg-pixel-bg-1",
      icon: "pixel-bank-icon.png",
      iconSize: "w-[2.95vh] h-[2.75vh]",
      label: locales?.hud?.display?.account?.bank,
      value: account.bank
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      bgImage: "bg-pixel-bg-1",
      icon: "black-money-icon.png",
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${baseStyle?.container?.layout} gap-[1.35vh]`, children: accountItems.map((item, index) => {
            const itemId = `account-item-${index}`;
            return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
              DraggableElement,
              {
                elementId: itemId,
                className: "relative",
                onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  AccountItem$1,
                  {
                    ...item,
                    isFlipped: flippedStates[itemId] || false,
                    font,
                    currencyType: currency
                  }
                )
              },
              `${item.id}-${item.value}`
            );
          }) })
        }
      ) })
    }
  );
}

const StatusIcons$1 = {
  health: "nui://envi-hud/web/build/images/pixel-health-icon.png",
  healthDying: "nui://envi-hud/web/build/images/pixel-skull-icon.png",
  armor: "nui://envi-hud/web/build/images/pixel-armor-icon.png",
  thirst: "nui://envi-hud/web/build/images/pixel-thirst-icon.png",
  hunger: "nui://envi-hud/web/build/images/pixel-hunger-icon.png",
  stamina: "nui://envi-hud/web/build/images/pixel-stamina-icon.png",
  stress: "nui://envi-hud/web/build/images/pixel-stress-icon.png",
  oxygen: "nui://envi-hud/web/build/images/pixel-oxygen-icon.png"
};
const StatusIconSizes = {
  health: "w-[2.752vh] h-[2.411vh]",
  healthDying: "w-[2.752vh] h-[2.411vh]",
  armor: "w-[2.752vh] h-[2.811vh]",
  thirst: "w-[2.158vh] h-[3.054vh]",
  hunger: "size-[2.452vh]",
  stamina: "w-[3.052vh] h-[2.654vh]",
  stress: "size-[2.531vh]",
  oxygen: "w-[2.6vh] h-[2.3vh]"
};
const getStatusBackground = (type, isDying = false) => {
  if (type === "health" && isDying) {
    return "bg-pixel-status-dead";
  }
  switch (type) {
    case "health":
      return "bg-pixel-status-1";
    case "armor":
      return "bg-pixel-status-2";
    case "hunger":
      return "bg-pixel-status-3";
    case "thirst":
      return "bg-pixel-status-4";
    case "stamina":
      return "bg-pixel-status-5";
    case "stress":
      return "bg-pixel-status-6";
    case "oxygen":
      return "bg-pixel-status-7";
    default:
      return "bg-pixel-status-1";
  }
};
function StatusBar$1({ type, value }) {
  const playerStatus = useHudStore((state) => state.playerStatus);
  const animationProps = useHudAnimation();
  const normalizedValue = normalizeValue(type, value);
  const isDying = type === "health" && playerStatus.dying;
  const baseStyle = HudBaseStyles.playerStatus;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.pixel || "pixel");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      ...animationProps,
      className: "flex flex-col items-center",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: `text-[1.4vh] ${isDying ? "text-[#ff2d2d]" : "text-[#FFFDE9]"}`,
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: [
              normalizedValue,
              "%"
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-[4.661vh] h-[4.262vh] flex items-center justify-center ${getStatusBackground(type, isDying)} bg-fullSize bg-fullCenter bg-no-repeat`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: isDying ? StatusIcons$1.healthDying : StatusIcons$1[type],
            alt: type.charAt(0).toUpperCase() + type.slice(1),
            className: isDying ? StatusIconSizes.healthDying : StatusIconSizes[type]
          }
        ) })
      ]
    }
  );
}
function Status$1() {
  const playerStatus = useHudStore((state) => state.playerStatus);
  const { playerStatusItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.playerStatus) / 100;
  const baseStyle = HudBaseStyles.playerStatus;
  const getTransformOrigin = () => {
    const position = baseStyle.container.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: [
                shouldShowHudElement("playerStatusItems", "health") && playerStatusItems?.health && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-health", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "health", value: playerStatus?.health ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "armor") && playerStatusItems?.armor && playerStatus?.armor !== void 0 && playerStatus?.armor > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-armor", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "armor", value: playerStatus?.armor }) }),
                shouldShowHudElement("playerStatusItems", "hunger") && playerStatusItems?.hunger && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-hunger", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "hunger", value: playerStatus?.hunger ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "thirst") && playerStatusItems?.thirst && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-thirst", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "thirst", value: playerStatus?.thirst ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "stamina") && playerStatusItems?.stamina && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stamina", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "stamina", value: playerStatus?.stamina ?? 0 }) }),
                shouldShowHudElement("playerStatusItems", "stress") && playerStatusItems?.stress && playerStatus?.stress !== void 0 && playerStatus?.stress > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stress", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "stress", value: playerStatus?.stress }) }),
                shouldShowHudElement("playerStatusItems", "oxygen") && playerStatusItems?.oxygen && (playerStatus.oxygen ?? 0) < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-oxygen", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar$1, { type: "oxygen", value: playerStatus?.oxygen ?? 0 }) })
              ]
            }
          )
        }
      )
    }
  );
}

function Location$1() {
  const location = useHudStore((state) => state.location);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.location) / 100;
  const baseStyle = HudBaseStyles.location;
  const themeStyle = LocationStyles.pixel;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.pixel);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    return "left center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "location",
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      onPositionChange: handlePositionChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default} gap-[1.65vh]`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bg-pixel-bg-1 bg-fullSize bg-fullCenter bg-no-repeat w-[4.661vh] h-[4.262vh] ${baseStyle?.icon?.size} flex items-center justify-center`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "nui://envi-hud/web/build/images/pixel-map-icon.png",
                alt: "Location",
                className: `size-[2.95vh]`
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-[.15vh] h-[4.5vh]",
                style: {
                  ...ShadowStyle,
                  background: themeStyle?.divider
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[3vh]",
                style: {
                  ...ShadowStyle,
                  color: themeStyle?.text,
                  fontWeight: defaultBaseStyle?.text?.weight?.bold,
                  fontFamily: font
                },
                children: location.direction
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-[.15vh] h-[4.5vh]",
                style: {
                  ...ShadowStyle,
                  background: themeStyle?.divider
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "text-[1.6vh] tracking-[.1vw] -mb-[.2vh] mt-[.45vh]",
                  style: {
                    ...ShadowStyle,
                    color: themeStyle?.text,
                    fontWeight: defaultBaseStyle?.text?.weight?.medium,
                    fontFamily: font
                  },
                  children: location.zone
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: "text-[1.6vh] tracking-[.1vw]",
                  style: {
                    ...ShadowStyle,
                    color: themeStyle?.subText,
                    fontFamily: font
                  },
                  children: location.street
                }
              )
            ] })
          ] })
        }
      ) })
    }
  );
}

function Weapon$1() {
  const weapon = useHudStore((state) => state.weapon);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.weapon) / 100;
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const baseStyle = HudBaseStyles.weapon;
  const themeIcons = HudIcons.pixel;
  const themeStyle = WeaponStyles.pixel;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.pixel);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
  };
  if (!weapon.weaponName) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0 },
      animate: {
        opacity: weapon.toggle ? 1 : 0
      },
      exit: { opacity: 0 },
      transition: { duration: 0.3, ease: "easeInOut" },
      className: `absolute ${enableBlackMoney ? "top-[40.5vh]" : "top-[35.5vh]"}`,
      style: {
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            DraggableElement,
            {
              elementId: "weapon",
              className: `relative ${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default}`,
              style: {
                gap: baseStyle?.container?.gap
              },
              onPositionChange: handlePositionChange,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      ...ShadowStyle,
                      minWidth: baseStyle?.image?.size?.minWidth,
                      maxWidth: baseStyle?.image?.size?.maxWidth,
                      height: baseStyle?.image?.size?.height
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: formatWeaponImage(weapon.weaponName),
                        alt: weapon.weaponLabel,
                        className: `size-full object-cover ${isFlipped ? "scale-x-100" : "-scale-x-100"}`
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    className: "text-[1.35vh] uppercase tracking-[.1vw] -mb-[.85vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontFamily: font
                    },
                    children: weapon.weaponLabel
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-[.85vh]`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-pixel-bg-1 size-[2vh] bg-fullSize bg-fullCenter flex items-center justify-center pb-[.25vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Icon$1,
                    {
                      icon: themeIcons?.weapon?.ammo,
                      className: "size-[1.25vh]",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.value
                      }
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-[.85vh]`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.value,
                          fontFamily: font
                        },
                        children: weapon.ammo
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "mb-[.15vh]",
                        style: {
                          ...ShadowStyle,
                          width: baseStyle?.divider?.size?.width,
                          height: baseStyle?.divider?.size?.height,
                          background: themeStyle?.divider
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.subValue,
                          fontFamily: font
                        },
                        children: weapon.maxAmmo
                      }
                    )
                  ] })
                ] })
              ]
            }
          )
        }
      )
    }
  );
}

const alienSvgPaths = {
  background: "M296.56 74.7155V259.293H259.492V296.21H222.426V333.128H111.223V296.21H74.1562V259.293H37.0895V74.7155H74.1562V37.7982H111.223V0.880845H222.426V37.7982H259.492V74.7155H296.56ZM296.56 333.128H333.627V296.21H296.56V333.128ZM259.492 370.045H296.56V333.128H259.492V370.045ZM259.492 406.962V370.045H74.1562V406.962H148.291V443.88H74.1562V480.797H259.492V443.88H185.359V406.962H259.492ZM37.0895 370.045H74.1562V333.128H37.0895V370.045ZM0.0214844 333.128H37.0895V296.21H0.0214844V333.128Z",
  progress: "M296.56 74.7155V259.293H259.492V296.21H222.426V333.128H111.223V296.21H74.1562V259.293H37.0895V74.7155H74.1562V37.7982H111.223V0.880845H222.426V37.7982H259.492V74.7155H296.56ZM296.56 333.128H333.627V296.21H296.56V333.128ZM259.492 370.045H296.56V333.128H259.492V370.045ZM259.492 406.962V370.045H74.1562V406.962H148.291V443.88H74.1562V480.797H259.492V443.88H185.359V406.962H259.492ZM37.0895 370.045H74.1562V333.128H37.0895V370.045ZM0.0214844 333.128H37.0895V296.21H0.0214844V333.128Z"
};
const radioIcons = {
  default: "nui://envi-hud/web/build/images/pixel-radio-icon.png",
  active: "nui://envi-hud/web/build/images/pixel-radio-active-icon.png"
};
const VoiceStatus$1 = ({
  isTalking = false,
  voiceLevel = 1,
  isRadio = false
}) => {
  const [progress, setProgress] = reactExports.useState(0);
  const getVoiceLevelPercentage = (level) => {
    switch (level) {
      case 1:
        return 25;
      case 2:
        return 50;
      case 3:
        return 100;
      default:
        return level / 3 * 100;
    }
  };
  reactExports.useEffect(() => {
    const percentage = getVoiceLevelPercentage(voiceLevel);
    setProgress(percentage);
  }, [voiceLevel]);
  const MicrophoneSVG = () => isTalking ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 334 481", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: alienSvgPaths.background,
        fill: "#D1FFBF4F"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.path,
      {
        id: "inner-progressbar",
        d: alienSvgPaths.progress,
        fill: "#D1FFBF",
        initial: { opacity: 0 },
        animate: { opacity: 1, transition: { duration: 0.3 } },
        style: {
          clipPath: `polygon(0 ${100 - progress}%, 0 100%, 100% 100%, 100% ${100 - progress}%)`
        }
      }
    )
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "size-full", viewBox: "0 0 352 552", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M312.464 393.938H351.483V354.641H312.464V393.938ZM78.3564 433.236V472.532H156.392V511.828H78.3564V551.125H234.428V511.828H195.41V472.532V452.884V433.236H78.3564ZM39.339 433.236H78.3564V393.938H39.339V433.236ZM0.320312 393.938H39.339V354.641H0.320312V393.938ZM117.375 393.938H156.394V354.641H117.375V393.938ZM78.3564 354.641H117.375V315.345H78.3564V354.641ZM39.339 315.345H78.3564V197.454H39.339V315.345ZM273.447 118.861V158.158H214.919V197.456H273.447V236.75H234.428V276.048H273.447V315.345H312.464V118.861H273.447ZM234.428 118.861H273.447V79.5637H234.428V118.861ZM156.392 79.565L234.428 79.5637V40.269H156.392V79.565ZM273.447 551.125H312.464V472.532H273.447V551.125ZM234.428 472.532H273.447V393.937H234.428V472.532ZM195.41 393.938H234.428V315.346H195.41V393.938ZM156.392 315.345L195.41 315.346V236.75H156.392V315.345ZM117.375 236.75H156.392L156.394 158.158H117.375V236.75ZM78.3564 79.565V118.861V158.158H117.375V118.861V79.565H78.3564ZM39.339 79.565H78.3564V0.971663H39.339V79.565Z", fill: "#D1FFBF" }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: `
        w-[4.661vh] h-[4.262vh]
        ${isTalking ? "bg-pixel-status-2 opacity-100" : "bg-pixel-bg-1 opacity-50"}
        bg-fullSize bg-fullCenter bg-no-repeat 
        flex items-center justify-center
        transition-all duration-300
      `,
      initial: { opacity: 0, scale: 0.8 },
      animate: { opacity: isTalking ? 1 : 0.5, scale: 1 },
      transition: { duration: 0.25 },
      children: isRadio ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: isTalking ? radioIcons.active : radioIcons.default,
          alt: "Radio",
          className: "w-[1.752vh] h-[2.65vh]"
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[1.752vh] h-[2.65vh] flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MicrophoneSVG, {}) })
    }
  );
};
function Voice$1() {
  const voiceStatus = useHudStore((state) => state.playerStatus.voice);
  const weapon = useHudStore((state) => state.weapon);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.voice) / 100;
  const baseStyle = HudBaseStyles.voice;
  const elementPositions = useSettingsStore((state) => state.elementPositions);
  const weaponVisible = useSettingsStore((state) => state.hudSettings.elementsVisibility.weapon);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const shouldAnimatePosition = !elementPositions["voice-radio"];
  const defaultTop = weaponVisible && weapon.toggle ? enableBlackMoney ? "52.25vh" : "47.25vh" : enableBlackMoney ? "41vh" : "36vh";
  const handleDragEnd = (position) => {
    useSettingsStore.getState().updateElementPosition("voice-radio", {
      ...position,
      y: parseFloat(defaultTop) * window.innerHeight / 100
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      animate: {
        opacity: 1,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 0.8,
        restSpeed: 1e-3
      },
      className: "absolute",
      style: {
        transform: `scale(${scale})`,
        transformOrigin: "right center",
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraggableElement,
        {
          elementId: "voice-radio",
          className: "relative",
          onDragEnd: handleDragEnd,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            VoiceStatus$1,
            {
              isTalking: voiceStatus?.isTalking ?? false,
              voiceLevel: voiceStatus?.voiceLevel ?? 1,
              isRadio: voiceStatus?.isRadio ?? false
            }
          )
        }
      )
    }
  );
}

function PixelTheme$1() {
  const { elementsVisibility } = useSettingsStore((state) => state.hudSettings);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    shouldShowHudElement("serverInfo") && elementsVisibility?.serverInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(ServerInfo$1, {}),
    shouldShowHudElement("account") && elementsVisibility?.account && /* @__PURE__ */ jsxRuntimeExports.jsx(Account$1, {}),
    shouldShowHudElement("playerStatus") && elementsVisibility?.playerStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(Status$1, {}),
    shouldShowHudElement("location") && elementsVisibility?.location && /* @__PURE__ */ jsxRuntimeExports.jsx(Location$1, {}),
    shouldShowHudElement("weapon") && elementsVisibility?.weapon && /* @__PURE__ */ jsxRuntimeExports.jsx(Weapon$1, {}),
    shouldShowHudElement("voice") && elementsVisibility?.voice && /* @__PURE__ */ jsxRuntimeExports.jsx(Voice$1, {})
  ] });
}

const InfoItem = ({ icon, iconSize = "w-[3vh] h-[2.75vh]", label, value, value2, id, themeStyle }) => {
  const font = getFontFamily(defaultBaseStyle.fonts, "bankgothic");
  const showValue2 = () => {
    if (id === "job" && value2) {
      return shouldShowHudElement("serverInfoItems", "job2", true);
    }
    if (id === "gang" && value2) {
      return shouldShowHudElement("serverInfoItems", "gang2", true);
    }
    return !!value2;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[4.889vh] h-[4.491vh] bg-cyberpunk2-bg bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center pr-[.15vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: `nui://envi-hud/web/build/images/${icon}`,
        alt: label,
        className: iconSize
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.4vh] -mb-[.385vh] mt-[.35vh] uppercase",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.4vh] -mb-[.385vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value
        }
      ),
      showValue2() && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.4vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: value2
        }
      )
    ] })
  ] });
};
const ServerHeader = ({ themeStyle, font, isFlipped, showLogo, showServerInfo }) => {
  const serverInfos = useConfigStore((state) => state.config.serverInfo);
  const themeIcons = HudIcons.cyberpunk_2;
  const baseStyle = HudBaseStyles.serverInfo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row" : "flex-row-reverse"} gap-[1.5vh]`, children: [
    shouldShowHudElement("serverInfoItems", "logo") && showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          ...ShadowStyle,
          width: baseStyle?.logo?.size,
          height: baseStyle?.logo?.size
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/logo.png", alt: "logo", className: "size-full object-cover" })
      }
    ),
    shouldShowHudElement("serverInfoItems", "serverInfo") && showServerInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.5vh] uppercase",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: serverInfos?.name ?? "Envi-Scripts Roleplay"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${isFlipped ? "flex-row-reverse" : "flex-row"} gap-[.85vh]`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.serverInfo?.discord,
            className: "size-[1.75vh]",
            style: {
              color: themeStyle?.text
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[1.5vh] uppercase",
            style: {
              ...ShadowStyle,
              color: themeStyle?.text,
              fontFamily: font
            },
            children: serverInfos?.discord ?? "https://discord.gg/envi-scripts"
          }
        )
      ] })
    ] })
  ] });
};
function ServerInfo() {
  const serverInfo = useHudStore((state) => state.serverInfo);
  const animationProps = useHudAnimation();
  const { timeValue } = useTimeValue();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.serverInfo) / 100;
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const { serverInfoItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const baseStyle = HudBaseStyles.serverInfo;
  const themeStyle = ServerInfoStyles.cyberpunk_2;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.cyberpunk_2 || "bankgothic");
  const infoItems = [
    // {
    //   id: "players",
    //   icon: "cyberpunk2-players-icon.png",
    //   iconSize: "w-[2.75vh]",
    //   label: locales?.hud?.display?.serverInfo?.players,
    //   value: serverInfo.totalPlayers
    // },
    {
      id: "id",
      icon: "cyberpunk2-player-icon.png",
      iconSize: "w-[1.5vh]",
      label: locales?.hud?.display?.serverInfo?.id,
      value: serverInfo.playerId
    },
    {
      id: "job",
      icon: "cyberpunk2-job-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.serverInfo?.job,
      value: serverInfo.playerJob,
      value2: serverInfo.playerJobGrade
    },
    {
      id: "gang",
      icon: "cyberpunk2-job-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.serverInfo?.gang,
      value: serverInfo.playerJob2,
      value2: serverInfo.playerJob2Grade
    },
    {
      id: "time",
      icon: "cyberpunk2-time-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.time,
      value: timeValue()
    }
  ].filter((item) => serverInfoItems[item.id]);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              ...animationProps,
              className: `${baseStyle?.container?.layout?.default} gap-[1.25vh]`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: "server-info-header",
                    className: "relative min-w-[14.15vw]",
                    onPositionChange: handlePositionChange,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ServerHeader,
                      {
                        themeStyle,
                        font,
                        isFlipped,
                        showLogo: serverInfoItems.logo,
                        showServerInfo: serverInfoItems.serverInfo
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-[1.75vh]", children: (() => {
                  const visibleItems = infoItems.filter(
                    (item) => shouldShowHudElement("serverInfoItems", item.id) && item.value
                  );
                  return visibleItems.map((item, visibleIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-item-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoItem, { ...item, themeStyle })
                      }
                    ),
                    visibleIndex === 1 && shouldShowHudElement("serverInfoItems", "divider", true) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DraggableElement,
                      {
                        elementId: `server-info-divider-${visibleIndex}`,
                        className: "relative",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            className: `w-[.75vh] h-[4.25vh] bg-cyberpunk2-divider-bg bg-fullSize bg-fullCenter bg-no-repeat`,
                            style: ShadowStyle
                          }
                        )
                      }
                    )
                  ] }, visibleIndex));
                })() })
              ]
            }
          )
        }
      )
    }
  );
}

const MoneyDisplay = ({ value, currencyType = "usd", font }) => {
  const [displayValue, setDisplayValue] = reactExports.useState(0);
  const animationRef = reactExports.useRef();
  const startTimeRef = reactExports.useRef();
  const startValueRef = reactExports.useRef(0);
  const prefix = getCurrencySymbol(currencyType);
  reactExports.useEffect(() => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
    const duration = 750;
    startValueRef.current = displayValue;
    startTimeRef.current = Date.now();
    const animate = () => {
      const now = Date.now();
      const elapsed = now - (startTimeRef.current || 0);
      if (elapsed < duration) {
        const progress = elapsed / duration;
        const easeOutQuad = 1 - Math.pow(1 - progress, 2);
        const current = startValueRef.current + (value - startValueRef.current) * easeOutQuad;
        setDisplayValue(Math.round(current));
        animationRef.current = requestAnimationFrame(animate);
      } else {
        setDisplayValue(value);
      }
    };
    animationRef.current = requestAnimationFrame(animate);
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [value]);
  const formattedValue = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(displayValue);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontFamily: font }, children: `${prefix}${formattedValue}` });
};
const AccountItem = ({
  icon,
  label,
  value,
  iconSize = "w-[3vh] h-[2.75vh]",
  font,
  isFlipped,
  currencyType
}) => {
  const themeStyle = AccountStyles.cyberpunk_2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${isFlipped ? "flex flex-row" : "flex flex-row-reverse"} items-center gap-[1.25vh]`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "w-[4.889vh] h-[4.491vh] bg-cyberpunk2-bg bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center pr-[.15vw]",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: `nui://envi-hud/web/build/images/${icon}`,
            alt: label,
            className: iconSize
          }
        )
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.4vh] -mb-[.385vh] mt-[.35vh] uppercase",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontFamily: font
          },
          children: label
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: "text-[1.4vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            MoneyDisplay,
            {
              value: Number(value) || 0,
              font,
              currencyType
            },
            `${label?.toLowerCase()}-${value}`
          )
        }
      )
    ] })
  ] });
};
function Account() {
  const account = useHudStore((state) => state.account);
  const animationProps = useHudAnimation();
  const [flippedStates, setFlippedStates] = reactExports.useState({});
  const { accountItems: accountItemsVisibility } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const currency = useSettingsStore((state) => state.hudSettings.currencySymbol) || "usd";
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.account) / 100;
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const locales = useConfigStore((state) => state.config.locales) || mockLocales;
  const baseStyle = HudBaseStyles.account;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.cyberpunk_2 || "bankgothic");
  const [_prevValues, setPrevValues] = reactExports.useState({
    cash: 0,
    bank: 0,
    blackMoney: 0
  });
  reactExports.useEffect(() => {
    setPrevValues({
      cash: account.cash ?? 0,
      bank: account.bank ?? 0,
      blackMoney: account.blackMoney ?? 0
    });
  }, [account]);
  const accountItems = [
    {
      id: "cash",
      icon: "cyberpunk2-cash-icon.png",
      iconSize: "w-[3vh] h-[2vh]",
      label: locales?.hud?.display?.account?.cash,
      value: account.cash
    },
    {
      id: "bank",
      icon: "cyberpunk2-bank-icon.png",
      iconSize: "size-[2.75vh]",
      label: locales?.hud?.display?.account?.bank,
      value: account.bank
    },
    ...enableBlackMoney ? [{
      id: "blackMoney",
      icon: "black-money-icon.png",
      label: locales?.hud?.display?.account?.blackMoney,
      value: account.blackMoney
    }] : []
  ].filter((item) => accountItemsVisibility && item.id && accountItemsVisibility?.[item.id]);
  const handlePositionChange = (itemId, isOnLeftSide) => {
    setFlippedStates((prev) => ({
      ...prev,
      [itemId]: isOnLeftSide
    }));
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        top: baseStyle?.container?.position?.top,
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: baseStyle?.container?.layout,
              style: {
                gap: baseStyle?.container?.gap
              },
              children: accountItems.map((item, index) => {
                const itemId = `account-item-${index}`;
                return shouldShowHudElement("accountItems", item.id) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DraggableElement,
                  {
                    elementId: itemId,
                    className: "relative",
                    onPositionChange: (isOnLeftSide) => handlePositionChange(itemId, isOnLeftSide),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      AccountItem,
                      {
                        ...item,
                        font,
                        isFlipped: flippedStates[itemId] || false,
                        currencyType: currency
                      }
                    )
                  },
                  `${item.id}-${item.value}`
                );
              })
            }
          )
        }
      ) })
    }
  );
}

function Location() {
  const location = useHudStore((state) => state.location);
  const animationProps = useHudAnimation();
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.location) / 100;
  const baseStyle = HudBaseStyles.location;
  const themeStyle = LocationStyles.cyberpunk_2;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.cyberpunk_2);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) ;
    if (position.left) return "left center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "location",
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      onPositionChange: handlePositionChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              ...animationProps,
              className: `${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default} gap-[1.25vh]`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: "nui://envi-hud/web/build/images/cyberpunk2-location-icon.png",
                    alt: "Location",
                    className: `size-[3vh]`,
                    style: ShadowStyle
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-[.95vh] h-[4.4vh] bg-cyberpunk2-divider-bg bg-fullSize bg-fullCenter bg-no-repeat",
                    style: ShadowStyle
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: "text-[2.4vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontWeight: defaultBaseStyle?.text?.weight?.bold,
                      fontFamily: font
                    },
                    children: location.direction
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-[.95vh] h-[4.4vh] bg-cyberpunk2-divider-bg bg-fullSize bg-fullCenter bg-no-repeat",
                    style: ShadowStyle
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col ${isFlipped ? "items-start" : "items-end"}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.4vh] tracking-[.1vw] -mb-[.25vh] mt-[.35vh] uppercase",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.text,
                        fontWeight: defaultBaseStyle?.text?.weight?.medium,
                        fontFamily: font
                      },
                      children: location.zone
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.4vh] tracking-[.1vw] uppercase",
                      style: {
                        ...ShadowStyle,
                        color: themeStyle?.subText,
                        fontFamily: font
                      },
                      children: location.street
                    }
                  )
                ] })
              ]
            }
          )
        }
      )
    }
  );
}

const StatusIcons = {
  health: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.4vh] h-[2.2vh] z-10", viewBox: "0 0 24 22", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M22.4804 10.2357C20.5434 13.9607 15.3614 19.0267 12.4314 21.7247C12.1164 22.0087 11.6374 22.0087 11.3224 21.7247C8.37542 19.0267 3.19442 13.9607 1.25742 10.2357C-2.99758 2.04069 7.73042 -3.42231 11.8684 4.77269C16.0074 -3.42231 26.7354 2.04069 22.4804 10.2357Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22.4804 10.2357C20.5434 13.9607 15.3614 19.0267 12.4314 21.7247C12.1164 22.0087 11.6374 22.0087 11.3224 21.7247C8.37542 19.0267 3.19442 13.9607 1.25742 10.2357C-2.99758 2.04069 7.73042 -3.42231 11.8684 4.77269C16.0074 -3.42231 26.7354 2.04069 22.4804 10.2357Z", fill: "#ececec4d" })
  ] }),
  armor: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.3vh] h-[2.5vh] z-10", viewBox: "0 0 21 23", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M17.0796 16.4317C15.6316 18.5977 13.3976 20.8307 11.1646 22.1977C11.0156 22.2797 10.7986 22.4687 10.6496 22.4147C7.27964 20.3167 4.50464 17.2847 2.82564 13.6707C1.26964 10.2727 0.646638 6.42865 1.01164 2.69265C2.35164 2.16465 3.74664 1.74465 5.15364 1.43365C10.2306 0.350654 15.6316 0.783653 20.4506 2.69265C20.9236 7.49765 19.7736 12.4387 17.0796 16.4317Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M17.0796 16.4317C15.6316 18.5977 13.3976 20.8307 11.1646 22.1977C11.0156 22.2797 10.7986 22.4687 10.6496 22.4147C7.27964 20.3167 4.50464 17.2847 2.82564 13.6707C1.26964 10.2727 0.646638 6.42865 1.01164 2.69265C2.35164 2.16465 3.74664 1.74465 5.15364 1.43365C10.2306 0.350654 15.6316 0.783653 20.4506 2.69265C20.9236 7.49765 19.7736 12.4387 17.0796 16.4317Z",
        fill: "#ececec4d"
      }
    )
  ] }),
  hunger: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.8vh] h-[2.5vh] z-10", viewBox: "0 0 24 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M3.77766 4.70962C3.77766 5.20062 4.17566 5.59863 4.66666 5.59863C5.15766 5.59863 5.55566 5.20062 5.55566 4.70962C5.55566 4.21862 5.15766 3.82063 4.66666 3.82063C4.17566 3.82063 3.77766 4.21862 3.77766 4.70962ZM7.33266 2.93162C7.33266 3.42262 7.73066 3.82063 8.22166 3.82063C8.71266 3.82063 9.11066 3.42262 9.11066 2.93162C9.11066 2.44062 8.71266 2.04362 8.22166 2.04362C7.73066 2.04362 7.33266 2.44062 7.33266 2.93162ZM10.8887 4.70962C10.8887 5.20062 11.2867 5.59863 11.7767 5.59863C12.2677 5.59863 12.6657 5.20062 12.6657 4.70962C12.6657 4.21862 12.2677 3.82063 11.7767 3.82063C11.2867 3.82063 10.8887 4.21862 10.8887 4.70962ZM14.4437 2.93162C14.4437 3.42262 14.8417 3.82063 15.3327 3.82063C15.8237 3.82063 16.2217 3.42262 16.2217 2.93162C16.2217 2.44062 15.8237 2.04362 15.3327 2.04362C14.8417 2.04362 14.4437 2.44062 14.4437 2.93162ZM17.9987 4.70962C17.9987 5.20062 18.3967 5.59863 18.8877 5.59863C19.3787 5.59863 19.7767 5.20062 19.7767 4.70962C19.7767 4.21862 19.3787 3.82063 18.8877 3.82063C18.3967 3.82063 17.9987 4.21862 17.9987 4.70962ZM3.77766 7.37663H1.99966V3.82063C1.99966 1.85763 3.59166 0.265625 5.55566 0.265625H17.9987C19.9627 0.265625 21.5547 1.85763 21.5547 3.82063V7.37663H3.77766ZM4.66666 14.4866H1.99966C1.99966 17.4316 4.38766 19.8196 7.33266 19.8196H16.2217C19.1667 19.8196 21.5547 17.4316 21.5547 14.4866H4.66666ZM23.3317 10.9316C23.3317 11.9136 22.5357 12.7086 21.5547 12.7086H1.99966C1.01866 12.7086 0.222656 11.9136 0.222656 10.9316C0.222656 9.94963 1.01866 9.15362 1.99966 9.15362H21.5547C22.5357 9.15362 23.3317 9.94963 23.3317 10.9316Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M3.77766 4.70962C3.77766 5.20062 4.17566 5.59863 4.66666 5.59863C5.15766 5.59863 5.55566 5.20062 5.55566 4.70962C5.55566 4.21862 5.15766 3.82063 4.66666 3.82063C4.17566 3.82063 3.77766 4.21862 3.77766 4.70962ZM7.33266 2.93162C7.33266 3.42262 7.73066 3.82063 8.22166 3.82063C8.71266 3.82063 9.11066 3.42262 9.11066 2.93162C9.11066 2.44062 8.71266 2.04362 8.22166 2.04362C7.73066 2.04362 7.33266 2.44062 7.33266 2.93162ZM10.8887 4.70962C10.8887 5.20062 11.2867 5.59863 11.7767 5.59863C12.2677 5.59863 12.6657 5.20062 12.6657 4.70962C12.6657 4.21862 12.2677 3.82063 11.7767 3.82063C11.2867 3.82063 10.8887 4.21862 10.8887 4.70962ZM14.4437 2.93162C14.4437 3.42262 14.8417 3.82063 15.3327 3.82063C15.8237 3.82063 16.2217 3.42262 16.2217 2.93162C16.2217 2.44062 15.8237 2.04362 15.3327 2.04362C14.8417 2.04362 14.4437 2.44062 14.4437 2.93162ZM17.9987 4.70962C17.9987 5.20062 18.3967 5.59863 18.8877 5.59863C19.3787 5.59863 19.7767 5.20062 19.7767 4.70962C19.7767 4.21862 19.3787 3.82063 18.8877 3.82063C18.3967 3.82063 17.9987 4.21862 17.9987 4.70962ZM3.77766 7.37663H1.99966V3.82063C1.99966 1.85763 3.59166 0.265625 5.55566 0.265625H17.9987C19.9627 0.265625 21.5547 1.85763 21.5547 3.82063V7.37663H3.77766ZM4.66666 14.4866H1.99966C1.99966 17.4316 4.38766 19.8196 7.33266 19.8196H16.2217C19.1667 19.8196 21.5547 17.4316 21.5547 14.4866H4.66666ZM23.3317 10.9316C23.3317 11.9136 22.5357 12.7086 21.5547 12.7086H1.99966C1.01866 12.7086 0.222656 11.9136 0.222656 10.9316C0.222656 9.94963 1.01866 9.15362 1.99966 9.15362H21.5547C22.5357 9.15362 23.3317 9.94963 23.3317 10.9316Z",
        fill: "#ececec4d"
      }
    )
  ] }),
  thirst: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2vh] h-[2.6vh] z-10", viewBox: "0 0 16 23", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M8.29441 22.3501C11.7464 22.3501 15.7724 20.2101 15.7724 14.7591C15.7724 11.0611 10.0194 2.88609 8.29441 0.746094C6.76041 2.88609 0.816406 10.8671 0.816406 14.7591C0.816406 20.2101 4.84241 22.3501 8.29441 22.3501Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M8.29441 22.3501C11.7464 22.3501 15.7724 20.2101 15.7724 14.7591C15.7724 11.0611 10.0194 2.88609 8.29441 0.746094C6.76041 2.88609 0.816406 10.8671 0.816406 14.7591C0.816406 20.2101 4.84241 22.3501 8.29441 22.3501Z",
        fill: "#ececec4d"
      }
    )
  ] }),
  stamina: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.6vh] h-[3vh] z-10", viewBox: "0 0 20 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M18.9716 16.2305H14.6076L12.8616 10.9935L11.1166 7.93853L12.8616 7.50253L16.8766 9.24753C17.3666 9.42053 17.9046 9.16253 18.0766 8.67253C18.2386 8.21153 18.0206 7.70253 17.5746 7.50253L12.8616 5.75653H9.37058L5.87958 7.50253L4.13358 9.24753H1.51558C1.03358 9.24753 0.642578 9.63853 0.642578 10.1205C0.642578 10.6025 1.03358 10.9935 1.51558 10.9935H5.87958L7.62458 9.24753L9.37058 12.7395L5.87958 16.2305V22.3405C5.87958 22.8225 6.27058 23.2135 6.75258 23.2135C7.23458 23.2135 7.62458 22.8225 7.62458 22.3405V16.9115L11.1166 14.4845L12.8616 17.9765H18.9716C19.4536 17.9765 19.8446 17.5855 19.8446 17.1035C19.8446 16.6215 19.4536 16.2305 18.9716 16.2305ZM5.87958 4.01153C4.91558 4.01153 4.13358 3.22953 4.13358 2.26553C4.13358 1.30153 4.91558 0.519531 5.87958 0.519531C6.84358 0.519531 7.62458 1.30153 7.62458 2.26553C7.62458 3.22953 6.84358 4.01153 5.87958 4.01153Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M18.9716 16.2305H14.6076L12.8616 10.9935L11.1166 7.93853L12.8616 7.50253L16.8766 9.24753C17.3666 9.42053 17.9046 9.16253 18.0766 8.67253C18.2386 8.21153 18.0206 7.70253 17.5746 7.50253L12.8616 5.75653H9.37058L5.87958 7.50253L4.13358 9.24753H1.51558C1.03358 9.24753 0.642578 9.63853 0.642578 10.1205C0.642578 10.6025 1.03358 10.9935 1.51558 10.9935H5.87958L7.62458 9.24753L9.37058 12.7395L5.87958 16.2305V22.3405C5.87958 22.8225 6.27058 23.2135 6.75258 23.2135C7.23458 23.2135 7.62458 22.8225 7.62458 22.3405V16.9115L11.1166 14.4845L12.8616 17.9765H18.9716C19.4536 17.9765 19.8446 17.5855 19.8446 17.1035C19.8446 16.6215 19.4536 16.2305 18.9716 16.2305ZM5.87958 4.01153C4.91558 4.01153 4.13358 3.22953 4.13358 2.26553C4.13358 1.30153 4.91558 0.519531 5.87958 0.519531C6.84358 0.519531 7.62458 1.30153 7.62458 2.26553C7.62458 3.22953 6.84358 4.01153 5.87958 4.01153Z",
        fill: "#ececec4d"
      }
    )
  ] }),
  stress: (color, clipHeight) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.7vh] h-[2.6vh] z-10", viewBox: "0 0 23 22", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M11.6047 15.2766H19.9437C19.9437 15.2766 19.9437 19.4466 15.7747 19.4466C11.6047 19.4466 11.6047 15.2766 11.6047 15.2766ZM19.1097 8.60563C20.0317 8.60563 20.7777 9.35163 20.7777 10.2726C20.7777 11.1946 20.0317 11.9406 19.1097 11.9406C18.1887 11.9406 17.4427 11.1946 17.4427 10.2726C17.4427 9.35163 18.1887 8.60563 19.1097 8.60563ZM12.4387 8.60563C13.3597 8.60563 14.1067 9.35163 14.1067 10.2726C14.1067 11.1946 13.3597 11.9406 12.4387 11.9406C11.5177 11.9406 10.7707 11.1946 10.7707 10.2726C10.7707 9.35163 11.5177 8.60563 12.4387 8.60563ZM10.7707 5.26963C10.7707 5.26963 9.10267 5.26962 9.10267 6.93762V15.2766C9.10267 18.6126 10.7707 21.9476 15.7747 21.9476C20.7777 21.9476 22.4457 18.6126 22.4457 15.2766V6.93762C22.4457 5.26962 20.7777 5.26963 20.7777 5.26963C19.5967 5.26963 17.4787 6.93762 15.7747 6.93762C14.0697 6.93762 12.0837 5.26963 10.7707 5.26963ZM4.09967 3.60162C5.02067 3.60162 5.76667 4.34863 5.76667 5.26963C5.76667 6.19063 5.02067 6.93762 4.09967 6.93762C3.17767 6.93762 2.43167 6.19063 2.43167 5.26963C2.43167 4.34863 3.17767 3.60162 4.09967 3.60162ZM2.43167 0.265625C2.43167 0.265625 0.763672 0.265625 0.763672 1.93362V10.5366C0.763672 13.4216 1.35367 16.9446 6.60067 16.9446H7.43467V11.9406L3.26567 13.6086C3.26567 13.6086 3.26567 9.43863 7.43467 9.43863V6.93762C7.43467 5.75663 7.57967 4.73562 8.26867 3.97662C8.90467 3.27662 9.94467 1.87863 12.6987 3.19163L14.1067 4.10663V1.93362C14.1067 1.93362 14.1067 0.265625 12.4387 0.265625C11.2577 0.265625 9.13967 1.93362 7.43467 1.93362C5.73067 1.93362 3.74367 0.265625 2.43167 0.265625Z",
        fill: color,
        style: {
          clipPath: clipHeight ? `inset(${100 - clipHeight}% 0 0 0)` : "none",
          transition: "clip-path 500ms ease-in-out, fill .25s ease"
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M11.6047 15.2766H19.9437C19.9437 15.2766 19.9437 19.4466 15.7747 19.4466C11.6047 19.4466 11.6047 15.2766 11.6047 15.2766ZM19.1097 8.60563C20.0317 8.60563 20.7777 9.35163 20.7777 10.2726C20.7777 11.1946 20.0317 11.9406 19.1097 11.9406C18.1887 11.9406 17.4427 11.1946 17.4427 10.2726C17.4427 9.35163 18.1887 8.60563 19.1097 8.60563ZM12.4387 8.60563C13.3597 8.60563 14.1067 9.35163 14.1067 10.2726C14.1067 11.1946 13.3597 11.9406 12.4387 11.9406C11.5177 11.9406 10.7707 11.1946 10.7707 10.2726C10.7707 9.35163 11.5177 8.60563 12.4387 8.60563ZM10.7707 5.26963C10.7707 5.26963 9.10267 5.26962 9.10267 6.93762V15.2766C9.10267 18.6126 10.7707 21.9476 15.7747 21.9476C20.7777 21.9476 22.4457 18.6126 22.4457 15.2766V6.93762C22.4457 5.26962 20.7777 5.26963 20.7777 5.26963C19.5967 5.26963 17.4787 6.93762 15.7747 6.93762C14.0697 6.93762 12.0837 5.26963 10.7707 5.26963ZM4.09967 3.60162C5.02067 3.60162 5.76667 4.34863 5.76667 5.26963C5.76667 6.19063 5.02067 6.93762 4.09967 6.93762C3.17767 6.93762 2.43167 6.19063 2.43167 5.26963C2.43167 4.34863 3.17767 3.60162 4.09967 3.60162ZM2.43167 0.265625C2.43167 0.265625 0.763672 0.265625 0.763672 1.93362V10.5366C0.763672 13.4216 1.35367 16.9446 6.60067 16.9446H7.43467V11.9406L3.26567 13.6086C3.26567 13.6086 3.26567 9.43863 7.43467 9.43863V6.93762C7.43467 5.75663 7.57967 4.73562 8.26867 3.97662C8.90467 3.27662 9.94467 1.87863 12.6987 3.19163L14.1067 4.10663V1.93362C14.1067 1.93362 14.1067 0.265625 12.4387 0.265625C11.2577 0.265625 9.13967 1.93362 7.43467 1.93362C5.73067 1.93362 3.74367 0.265625 2.43167 0.265625Z",
        fill: "#ececec4d"
      }
    )
  ] }),
  oxygen: (color, clipHeight) => {
    const normalizedValue = clipHeight || 0;
    const darkGray = "#ECECEC4D";
    const warningColor = "#fbbf24";
    const dangerColor = "#ff2d2d";
    const isWhite = color === "#ECECEC";
    const bgColor = darkGray;
    let segment1Color = darkGray;
    let segment2Color = darkGray;
    let segment3Color = darkGray;
    if (!isWhite) {
      if (normalizedValue > 75) {
        segment1Color = color;
      }
      if (normalizedValue > 50 && normalizedValue <= 75) {
        segment2Color = color;
      } else if (normalizedValue > 25 && normalizedValue <= 50) {
        segment2Color = warningColor;
        segment3Color = warningColor;
      }
      if (normalizedValue <= 25) {
        segment3Color = dangerColor;
      }
    } else {
      segment1Color = segment2Color = segment3Color = color;
    }
    const clipPercent3 = normalizedValue <= 25 ? normalizedValue * 4 : 100;
    const clipPercent2 = normalizedValue > 25 && normalizedValue <= 75 ? (normalizedValue - 25) * 2 : 0;
    const clipPercent1 = normalizedValue > 75 ? (normalizedValue - 75) * 4 : 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.4vh] h-[2.3vh] z-10", viewBox: "0 0 297 306", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-1",
          d: "M0.496094 62.7337C0.496094 28.1587 28.5241 0.130737 63.0991 0.130737C97.6741 0.130737 125.702 28.1587 125.702 62.7337C125.702 97.3087 97.6741 125.337 63.0991 125.337C28.5241 125.337 0.496094 97.3087 0.496094 62.7337Z",
          fill: segment1Color,
          style: {
            clipPath: clipPercent3 > 0 ? `inset(${100 - clipPercent3}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-1-bg",
          d: "M0.496094 62.7337C0.496094 28.1587 28.5241 0.130737 63.0991 0.130737C97.6741 0.130737 125.702 28.1587 125.702 62.7337C125.702 97.3087 97.6741 125.337 63.0991 125.337C28.5241 125.337 0.496094 97.3087 0.496094 62.7337Z",
          fill: bgColor
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-2",
          d: "M125.701 161.101C125.701 113.891 163.972 75.6199 211.182 75.6199C258.392 75.6199 296.663 113.891 296.663 161.101C296.663 208.311 258.392 246.582 211.182 246.582C163.972 246.582 125.701 208.311 125.701 161.101Z",
          fill: segment2Color,
          style: {
            clipPath: clipPercent2 > 0 ? `inset(${100 - clipPercent2}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-2-bg",
          d: "M125.701 161.101C125.701 113.891 163.972 75.6199 211.182 75.6199C258.392 75.6199 296.663 113.891 296.663 161.101C296.663 208.311 258.392 246.582 211.182 246.582C163.972 246.582 125.701 208.311 125.701 161.101Z",
          fill: bgColor
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-3",
          d: "M10.0293 252.924C10.0293 223.615 33.7893 199.855 63.0983 199.855C92.4073 199.855 116.167 223.615 116.167 252.924C116.167 282.233 92.4073 305.993 63.0983 305.993C33.7893 305.993 10.0293 282.233 10.0293 252.924Z",
          fill: segment3Color,
          style: {
            clipPath: clipPercent1 > 0 ? `inset(${100 - clipPercent1}% 0 0 0)` : "none",
            transition: "clip-path 500ms ease-in-out, fill .25s ease"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "percent-3-bg",
          d: "M10.0293 252.924C10.0293 223.615 33.7893 199.855 63.0983 199.855C92.4073 199.855 116.167 223.615 116.167 252.924C116.167 282.233 92.4073 305.993 63.0983 305.993C33.7893 305.993 10.0293 282.233 10.0293 252.924Z",
          fill: bgColor
        }
      )
    ] });
  }
};
const DyingIcon = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-[3vh] h-[2.8vh] z-10", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#ff2d2d", d: "M10.5 15.75h3l-1.5-3zM8.5 13q.825 0 1.413-.587T10.5 11t-.587-1.412T8.5 9t-1.412.588T6.5 11t.588 1.413T8.5 13m7 0q.825 0 1.413-.587T17.5 11t-.587-1.412T15.5 9t-1.412.588T13.5 11t.588 1.413T15.5 13M6 22v-4.25q-.975-.425-1.713-1.137T3.037 15t-.775-1.925T2 11q0-3.95 2.8-6.475T12 2t7.2 2.525T22 11q0 1.05-.262 2.075T20.963 15t-1.25 1.613T18 17.75V22h-3v-2h-2v2h-2v-2H9v2z" }) });
};
function StatusBar({ type, value }) {
  const theme = useHudStore((state) => state.theme);
  const playerStatus = useHudStore((state) => state.playerStatus);
  const { progressBarStyle } = useSettingsStore((state) => state.hudSettings);
  const animationProps = useHudAnimation();
  const themeStyle = PlayerStatusStyles[theme];
  const normalizedValue = normalizeValue(type, value);
  const isDying = type === "health" && playerStatus.dying;
  const progressColor = isDying ? "#ff2d2d" : getStatusColor(type, normalizedValue, themeStyle);
  const clipStart = 100 - normalizedValue;
  const clipEnd = Math.max(0, 100 - normalizedValue * 2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[4.889vh] h-[4.491vh] flex items-center justify-center pr-[.1vw]", children: progressBarStyle === ProgressBarStyle.FILL ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute inset-0 size-full", viewBox: "0 0 35 33", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.899994", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M33.601 6.99816V9.08716L27.744 2.87516H0.708984V0.785156H27.744L33.601 6.99816Z", fill: "#191D22" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M33.601 9.08409V31.7831H5.70298L0.708984 26.7891V2.87109H27.744L33.601 9.08409Z", fill: "#121416" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "status-bar",
          d: "M33.6008 31.6622H5.70078L0.710781 26.6622V0.652188H27.7408L33.6008 6.87219V31.6622ZM28.1708 -0.0078125H0.0507812V27.1122L5.24078 32.3222H34.2608V6.47219L28.1708 -0.0078125Z",
          fill: isDying ? "#ff2d2d" : "white"
        }
      )
    ] }),
    isDying ? /* @__PURE__ */ jsxRuntimeExports.jsx(DyingIcon, {}) : StatusIcons[type]?.(progressColor, normalizedValue)
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute inset-0 size-full", viewBox: "0 0 35 33", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.899994", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M33.601 6.99816V9.08716L27.744 2.87516H0.708984V0.785156H27.744L33.601 6.99816Z", fill: "#191D22" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M33.601 9.08409V31.7831H5.70298L0.708984 26.7891V2.87109H27.744L33.601 9.08409Z", fill: "#121416" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          id: "status-bar",
          d: "M33.6008 31.6622H5.70078L0.710781 26.6622V0.652188H27.7408L33.6008 6.87219V31.6622ZM28.1708 -0.0078125H0.0507812V27.1122L5.24078 32.3222H34.2608V6.47219L28.1708 -0.0078125Z",
          fill: progressColor,
          style: {
            clipPath: `polygon(${clipEnd}% ${clipStart}%, 100% ${clipStart}%, 100% 100%, ${clipEnd}% 100%)`,
            transition: "clip-path 500ms ease-in-out",
            willChange: "clip-path"
          }
        }
      )
    ] }),
    isDying ? /* @__PURE__ */ jsxRuntimeExports.jsx(DyingIcon, {}) : StatusIcons[type]?.("#ECECEC")
  ] }) }) });
}
function Status() {
  const playerStatus = useHudStore((state) => state.playerStatus);
  const { playerStatusItems } = useSettingsStore((state) => state.hudSettings.elementsVisibility);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.playerStatus) / 100;
  const baseStyle = HudBaseStyles.playerStatus;
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "absolute",
      style: {
        bottom: baseStyle?.container?.position?.bottom,
        left: baseStyle?.container?.position?.left,
        right: baseStyle?.container?.position?.right
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${baseStyle?.container?.layout} gap-[.85vh]`, children: [
            shouldShowHudElement("playerStatusItems", "health") && playerStatusItems?.health && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-health", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "health", value: playerStatus?.health ?? 0 }) }),
            shouldShowHudElement("playerStatusItems", "armor") && playerStatusItems?.armor && playerStatus?.armor !== void 0 && playerStatus?.armor > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-armor", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "armor", value: playerStatus?.armor }) }),
            shouldShowHudElement("playerStatusItems", "hunger") && playerStatusItems?.hunger && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-hunger", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "hunger", value: playerStatus?.hunger ?? 0 }) }),
            shouldShowHudElement("playerStatusItems", "thirst") && playerStatusItems?.thirst && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-thirst", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "thirst", value: playerStatus?.thirst ?? 0 }) }),
            shouldShowHudElement("playerStatusItems", "stamina") && playerStatusItems?.stamina && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stamina", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "stamina", value: playerStatus?.stamina ?? 0 }) }),
            shouldShowHudElement("playerStatusItems", "stress") && playerStatusItems?.stress && playerStatus?.stress !== void 0 && playerStatus?.stress > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-stress", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "stress", value: playerStatus?.stress }) }),
            shouldShowHudElement("playerStatusItems", "oxygen") && playerStatusItems?.oxygen && (playerStatus.oxygen ?? 0) < 100 && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableElement, { elementId: "status-oxygen", className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StatusBar, { type: "oxygen", value: playerStatus?.oxygen ?? 0 }) })
          ] })
        }
      )
    }
  );
}

function Weapon() {
  const weapon = useHudStore((state) => state.weapon);
  const [isFlipped, setIsFlipped] = reactExports.useState(false);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.weapon) / 100;
  const baseStyle = HudBaseStyles.weapon;
  const themeIcons = HudIcons.cyberpunk_2;
  const themeStyle = WeaponStyles.cyberpunk_2;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font.cyberpunk_2);
  const handlePositionChange = (isOnLeftSide) => {
    setIsFlipped(isOnLeftSide);
  };
  const getTransformOrigin = () => {
    const position = baseStyle?.container?.position;
    if (position.right) return "right center";
  };
  if (!weapon.weaponName) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: { opacity: 0 },
      animate: {
        opacity: weapon.toggle ? 1 : 0
      },
      exit: { opacity: 0 },
      transition: { duration: 0.3, ease: "easeInOut" },
      className: `absolute ${enableBlackMoney ? "top-[34vh]" : "top-[29vh]"}`,
      style: {
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            DraggableElement,
            {
              elementId: "weapon",
              className: `relative ${isFlipped ? baseStyle?.container?.layout?.flipped : baseStyle?.container?.layout?.default} gap-[1.1vh]`,
              onPositionChange: handlePositionChange,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      ...ShadowStyle,
                      minWidth: baseStyle?.image?.size?.minWidth,
                      maxWidth: baseStyle?.image?.size?.maxWidth,
                      height: baseStyle?.image?.size?.height
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: formatWeaponImage(weapon.weaponName),
                        alt: weapon.weaponLabel,
                        className: `size-full object-cover ${isFlipped ? "scale-x-100" : "-scale-x-100"}`
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    className: "text-[1.35vh] uppercase tracking-[.15vw] -mb-[.85vh]",
                    style: {
                      ...ShadowStyle,
                      color: themeStyle?.text,
                      fontFamily: font
                    },
                    children: weapon.weaponLabel
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-cyberpunk2-bg size-[2.55vh] bg-fullSize bg-fullCenter flex items-center justify-center pr-[.1vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Icon$1,
                    {
                      icon: themeIcons.weapon.ammo,
                      className: "size-[1.55vh]",
                      style: {
                        color: themeStyle?.value
                      }
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh]", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          ...ShadowStyle,
                          color: themeStyle?.value,
                          fontFamily: font
                        },
                        children: weapon.ammo
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "mb-[.15vh]",
                        style: {
                          ...ShadowStyle,
                          width: baseStyle?.divider?.size?.width,
                          height: baseStyle?.divider?.size?.height,
                          background: themeStyle?.divider
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        className: "text-[1.85vh]",
                        style: {
                          color: themeStyle?.subValue,
                          fontFamily: font
                        },
                        children: weapon.maxAmmo
                      }
                    )
                  ] })
                ] })
              ]
            }
          )
        }
      )
    }
  );
}

const VoiceStatus = ({ isTalking = false, voiceLevel = 1, isRadio = false, themeStyle }) => {
  const [progress, setProgress] = reactExports.useState(0);
  const getVoiceLevelPercentage = (level) => {
    switch (level) {
      case 1:
        return 25;
      case 2:
        return 50;
      case 3:
        return 100;
      default:
        return level / 3 * 100;
    }
  };
  reactExports.useEffect(() => {
    const percentage = getVoiceLevelPercentage(voiceLevel);
    setProgress(percentage);
  }, [voiceLevel]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: `
        w-[4.889vh] h-[4.491vh]
        bg-cyberpunk2-bg bg-fullSize bg-fullCenter bg-no-repeat 
        flex items-center justify-center
        transition-opacity duration-300
        ${isTalking ? "opacity-100" : "opacity-50"}
      `,
      initial: { opacity: 0, scale: 0.8 },
      animate: { opacity: isTalking ? 1 : 0.5, scale: 1 },
      transition: { duration: 0.25 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative size-[2.25vh]", children: isRadio ? /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", className: "size-full", viewBox: "0 0 48 48", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("mask", { id: "ipSRadioNanny0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "none", strokeLinecap: "round", strokeWidth: "4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: themeStyle?.voice?.layer1, stroke: themeStyle?.voice?.layer1, d: "M36 42.001V21.688C36 15.313 31.09 10 24 10s-12 5.313-12 11.688V42c0 1.105.895 1.999 2 1.999h20c1.105 0 2-.894 2-1.999Z" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "24", cy: "23", r: "4", fill: themeStyle?.voice?.layer2, stroke: themeStyle?.voice?.layer2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: themeStyle?.voice?.layer2, d: "M18 34h2m6 4h4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { stroke: themeStyle?.voice?.layer1, d: "M12 20V4" })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: themeStyle?.voice?.layer1, d: "M0 0h48v48H0z", mask: "url(#ipSRadioNanny0)" })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", className: "size-full", viewBox: "0 0 14 14", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("mask", { id: "progress-mask", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "0", y: "0", width: "100%", height: `${100 - progress}%`, fill: "black" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            fill: themeStyle?.background,
            fillRule: "evenodd",
            d: "M6.75 0a2.946 2.946 0 0 0-2.946 2.946v3.425a2.946 2.946 0 1 0 5.892 0V2.946A2.946 2.946 0 0 0 6.75 0M6 12.008v1.212a.75.75 0 0 0 1.5 0v-1.213a5.25 5.25 0 0 0 5-5.244a.75.75 0 0 0-1.5 0a3.75 3.75 0 0 1-3.75 3.75h-1a3.75 3.75 0 0 1-3.75-3.75a.75.75 0 1 0-1.5 0a5.25 5.25 0 0 0 5 5.245",
            clipRule: "evenodd"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.path,
          {
            fill: themeStyle?.progress,
            fillRule: "evenodd",
            d: "M6.75 0a2.946 2.946 0 0 0-2.946 2.946v3.425a2.946 2.946 0 1 0 5.892 0V2.946A2.946 2.946 0 0 0 6.75 0M6 12.008v1.212a.75.75 0 0 0 1.5 0v-1.213a5.25 5.25 0 0 0 5-5.244a.75.75 0 0 0-1.5 0a3.75 3.75 0 0 1-3.75 3.75h-1a3.75 3.75 0 0 1-3.75-3.75a.75.75 0 1 0-1.5 0a5.25 5.25 0 0 0 5 5.245",
            clipRule: "evenodd",
            initial: { clipPath: `inset(100% 0 0 0)` },
            animate: {
              clipPath: `inset(${100 - progress}% 0 0 0)`
            },
            transition: {
              duration: 0.5,
              ease: "easeInOut"
            }
          }
        )
      ] }) })
    }
  );
};
function Voice() {
  const voiceStatus = useHudStore((state) => state.playerStatus.voice);
  const weapon = useHudStore((state) => state.weapon);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.voice) / 100;
  const baseStyle = HudBaseStyles.voice;
  const elementPositions = useSettingsStore((state) => state.elementPositions);
  const weaponVisible = useSettingsStore((state) => state.hudSettings.elementsVisibility.weapon);
  const enableBlackMoney = useConfigStore((state) => state.config.enableBlackMoney);
  const themeStyle = PlayerStatusStyles.cyberpunk_2;
  const shouldAnimatePosition = !elementPositions["voice-radio"];
  const defaultTop = weaponVisible && weapon.toggle ? enableBlackMoney ? "45.5vh" : "41vh" : enableBlackMoney ? "34vh" : "28.5vh";
  const handleDragEnd = (position) => {
    useSettingsStore.getState().updateElementPosition("voice-radio", {
      ...position,
      y: parseFloat(defaultTop) * window.innerHeight / 100
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      animate: {
        opacity: 1,
        top: shouldAnimatePosition ? defaultTop : void 0
      },
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 0.8,
        restSpeed: 1e-3
      },
      className: "absolute",
      style: {
        transform: `scale(${scale})`,
        transformOrigin: "right center",
        right: baseStyle?.container?.position?.right,
        left: baseStyle?.container?.position?.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraggableElement,
        {
          elementId: "voice-radio",
          className: "relative",
          onDragEnd: handleDragEnd,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            VoiceStatus,
            {
              isTalking: voiceStatus?.isTalking ?? false,
              voiceLevel: voiceStatus?.voiceLevel ?? 1,
              isRadio: voiceStatus?.isRadio ?? false,
              themeStyle
            }
          )
        }
      )
    }
  );
}

function Cyberpunk2Theme$1() {
  const { elementsVisibility } = useSettingsStore((state) => state.hudSettings);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    shouldShowHudElement("serverInfo") && elementsVisibility?.serverInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(ServerInfo, {}),
    shouldShowHudElement("account") && elementsVisibility?.account && /* @__PURE__ */ jsxRuntimeExports.jsx(Account, {}),
    shouldShowHudElement("location") && elementsVisibility?.location && /* @__PURE__ */ jsxRuntimeExports.jsx(Location, {}),
    shouldShowHudElement("playerStatus") && elementsVisibility?.playerStatus && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, {}),
    shouldShowHudElement("weapon") && elementsVisibility?.weapon && /* @__PURE__ */ jsxRuntimeExports.jsx(Weapon, {}),
    shouldShowHudElement("voice") && elementsVisibility?.voice && /* @__PURE__ */ jsxRuntimeExports.jsx(Voice, {})
  ] });
}

const getNosColor = (value, themeColor) => {
  if (value <= 25) {
    return "#ff2d2d";
  }
  if (value <= 50) {
    return "#fbbf24";
  }
  return themeColor;
};
function NosStatus({ value = 0 }) {
  const theme = useHudStore((state) => state.theme);
  const themeStyle = VehicleStyles[theme];
  const themeIcons = HudIcons[theme];
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const size = 4.35;
  const strokeWidth = 0.25;
  const radius = (size - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const progress = (100 - value) / 100 * circumference;
  const progressColor = getNosColor(value, themeStyle?.nosProgress);
  reactExports.useEffect(() => {
    let interval;
    if (value <= 25) {
      interval = setInterval(() => {
        setIsBlinking((prev) => !prev);
      }, 500);
    } else {
      setIsBlinking(false);
    }
    return () => clearInterval(interval);
  }, [value]);
  const getNosStyle = () => {
    const isLow = value <= 25;
    return {
      icon: `size-[2.15vh] z-10`,
      iconColor: isLow ? "#ff2d2d" : themeStyle?.icon,
      opacity: isLow ? isBlinking ? 1 : 0.5 : 1
    };
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: "relative",
      initial: { opacity: 0, scale: 0.8 },
      animate: { opacity: 1, scale: 1 },
      transition: { duration: 0.25 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "\r\n        size-[4.35vh]\r\n        rounded-full\r\n        flex \r\n        items-center \r\n        justify-center\r\n      ",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "absolute inset-0 rotate-90 -scale-x-100 size-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "50%",
                cy: "50%",
                r: `${radius}vh`,
                fill: "none",
                stroke: progressColor,
                strokeWidth: `${strokeWidth}vh`,
                strokeDasharray: `${circumference}vh`,
                strokeDashoffset: `${progress}vh`,
                className: `
              transition-all 
              duration-250
            `
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { scale: 0 },
                animate: { scale: 1 },
                transition: {
                  delay: 0.2,
                  type: "spring",
                  stiffness: 200
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: themeIcons?.vehicle?.nos,
                    className: getNosStyle().icon,
                    style: {
                      color: getNosStyle().iconColor
                    }
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
function AirSpeedometer({
  speed = 0,
  engineHealth = 0,
  fuelLevel = 0,
  altitude = 0,
  themeStyle,
  font
}) {
  const config = useConfigStore((state) => state.config);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (fuelLevel <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if (engineHealth <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  const getSpeedUnit = () => config.mph ? "mph" : "km/h";
  const getSpeedValue = () => {
    const value = Math.floor(speed);
    return value;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-mt-[24vh] -mr-[3.8vw] relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "relative w-[15vw] h-[12vh] flex items-center justify-center",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "relative rounded-[.85vh] p-[1.5vh] min-w-[15vw]",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: "text-[1.35vh] uppercase font-medium tracking-[.15vh] mb-[.25vh]",
                    style: {
                      color: themeStyle?.text,
                      fontFamily: font
                    },
                    children: "Speed"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-[.5vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[3.5vh] font-bold leading-none",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: getSpeedValue()
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.5vh] font-medium mb-[.5vh]",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: getSpeedUnit()
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-end", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: "text-[1.35vh] uppercase font-medium tracking-[.15vh] mb-[.25vh]",
                    style: {
                      color: themeStyle?.text,
                      fontFamily: font
                    },
                    children: "Altitude"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-[.5vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[3.5vh] font-bold leading-none",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: altitude
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.5vh] font-medium mb-[.5vh]",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: "ft"
                    }
                  )
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1.5vh] mt-[1.5vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-[.5vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.15vh] uppercase font-medium",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: "Engine"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      className: "text-[1.15vh] font-medium",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: [
                        engineHealth,
                        "%"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-full h-[.65vh] rounded-full",
                    style: {
                      background: themeStyle?.air?.airProgressTrack
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      motion.div,
                      {
                        className: "h-full rounded-full transition-all duration-300",
                        animate: {
                          width: `${engineHealth}%`,
                          opacity: engineHealth <= 20 ? isLowValue.engineHealth ? 1 : 0.5 : 1
                        },
                        transition: { duration: 0.3 },
                        style: {
                          background: engineHealth <= 35 ? "#ff2d2d" : themeStyle?.air?.airProgressBar
                        }
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-[.5vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      className: "text-[1.15vh] uppercase font-medium",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: "Fuel"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      className: "text-[1.15vh] font-medium",
                      style: {
                        color: themeStyle?.text,
                        fontFamily: font
                      },
                      children: [
                        fuelLevel,
                        "%"
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "w-full h-[.65vh] rounded-full",
                    style: {
                      background: themeStyle?.air?.airProgressTrack
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      motion.div,
                      {
                        className: "h-full rounded-full transition-all duration-300",
                        animate: {
                          width: `${fuelLevel}%`,
                          opacity: fuelLevel <= 20 ? isLowValue.fuelLevel ? 1 : 0.5 : 1
                        },
                        transition: { duration: 0.3 },
                        style: {
                          background: fuelLevel <= 35 ? "#ff2d2d" : themeStyle?.air?.airProgressBar
                        }
                      }
                    )
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  ) });
}
function BoatSpeedometer({
  speed = 0,
  engineHealth = 0,
  fuelLevel = 0,
  themeStyle,
  themeIcons
}) {
  const config = useConfigStore((state) => state.config);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (fuelLevel <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if (engineHealth <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  const getSpeedUnit = () => config.mph ? "mph" : "km/h";
  const getSpeedValue = () => {
    const value = Math.floor(speed);
    return value;
  };
  const baseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(
    defaultBaseStyle.fonts,
    baseStyle.font?.[SpeedometerThemes.DEFAULT]?.type?.boat
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "-mt-[26.5vh] -mr-[7.5vw] relative w-[18vw] h-[15vh] flex items-center justify-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative size-[12vh] rounded-full flex items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          className: "absolute inset-0 w-full h-full -rotate-90",
          viewBox: "0 0 100 100",
          style: {
            ...ShadowStyle
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "50",
                cy: "50",
                r: "45",
                fill: "none",
                stroke: themeStyle?.speedometerTrack,
                strokeWidth: "2.5"
              }
            ),
            [...Array(8)].map((_, i) => {
              const angle = i * 45 * Math.PI / 180;
              const x1 = 50 + 38 * Math.cos(angle);
              const y1 = 50 + 38 * Math.sin(angle);
              const x2 = 50 + 42 * Math.cos(angle);
              const y2 = 50 + 42 * Math.sin(angle);
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "line",
                {
                  x1,
                  y1,
                  x2,
                  y2,
                  stroke: themeStyle?.speedometerTick,
                  strokeWidth: "2"
                },
                i
              );
            })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[4.5vh] -mb-[.45vh] leading-none",
            style: {
              ...ShadowStyle,
              color: themeStyle?.text,
              textShadow: "0 0 10px rgba(255, 255, 255, 0.5)",
              fontFamily: font
            },
            children: getSpeedValue()
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[1.5vh] uppercase",
            style: {
              ...ShadowStyle,
              color: themeStyle?.subText,
              fontFamily: font
            },
            children: getSpeedUnit()
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-0 left-1/2 -translate-x-1/2 flex items-center gap-[1.5vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          className: "flex flex-col items-center gap-[0.5vh]",
          style: ShadowStyle,
          animate: {
            opacity: engineHealth <= 20 ? isLowValue.engineHealth ? 1 : 0.5 : 1
          },
          transition: { duration: 0.3 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.engine,
                className: "size-[2vh]",
                style: {
                  color: engineHealth <= 20 ? "#ff3333" : themeStyle?.icon
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[6.5vh] h-[0.4vh] rounded-full overflow-hidden bg-black/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-full rounded-full transition-all duration-300",
                style: {
                  width: `${engineHealth}%`,
                  background: engineHealth <= 20 ? "#ff3333" : themeStyle?.progressBar
                }
              }
            ) })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "size-[3.5vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background,
            borderStyle: themeStyle?.border?.style,
            borderColor: themeStyle?.border?.color
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: themeIcons?.vehicle?.boatWheel,
              className: "size-[2vh] animate-spin-slow",
              style: {
                color: themeStyle?.icon
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          className: "flex flex-col items-center gap-[0.5vh]",
          style: ShadowStyle,
          animate: {
            opacity: fuelLevel <= 20 ? isLowValue.fuelLevel ? 1 : 0.5 : 1
          },
          transition: { duration: 0.3 },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.fuel,
                className: "size-[2vh]",
                style: {
                  color: fuelLevel <= 20 ? "#ff3333" : themeStyle?.icon
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[6.5vh] h-[0.4vh] rounded-full overflow-hidden bg-black/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "h-full rounded-full transition-all duration-300",
                style: {
                  width: `${fuelLevel}%`,
                  background: fuelLevel <= 20 ? "#ff3333" : themeStyle?.progressBar
                }
              }
            ) })
          ]
        }
      )
    ] })
  ] });
}
function DefaultSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    speed = 0,
    currentGear = 0,
    rpm = 0,
    maxSpeedForCruise = 0,
    handBrake = false,
    nos = {
      toggle: false,
      value: 0
    },
    altitude = 0,
    themeStyle,
    themeIcons,
    defaultBaseStyle: defaultBaseStyle2
  } = props;
  const config = useConfigStore((state) => state.config);
  const theme = useHudStore((state) => state.theme);
  const baseStyle = HudBaseStyles.vehicle;
  const [shakeOffset, setShakeOffset] = reactExports.useState(0);
  const [prevGear, setPrevGear] = reactExports.useState(currentGear);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear);
      }, 300);
    }
  }, [currentGear, prevGear]);
  reactExports.useEffect(() => {
    let interval;
    if (speed && speed > 160) {
      interval = setInterval(() => {
        setShakeOffset(Math.random() * 15 - 5);
      }, 100);
      return () => clearInterval(interval);
    } else {
      setShakeOffset(0);
    }
    return () => clearInterval(interval);
  }, [speed]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (fuelLevel <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if (engineHealth <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  reactExports.useEffect(() => {
    let interval;
    if (indicators > 0) {
      interval = setInterval(() => {
        setIsBlinking((prev) => !prev);
      }, 500);
    } else {
      setIsBlinking(false);
    }
    return () => clearInterval(interval);
  }, [indicators]);
  const limitedSpeed = Math.min(speed, 160);
  const angle = limitedSpeed / 160 * 180;
  const needleLength = 120;
  const ticks = Array.from({ length: 17 }, (_, i) => {
    const tickAngle = 180 - i * 180 / 16;
    const isMajor = i % 2 === 0;
    const tickLength = isMajor ? 15 : 8;
    const textRadius = 145;
    return {
      x1: 200 + 120 * Math.cos(tickAngle * Math.PI / 180),
      y1: 200 - 120 * Math.sin(tickAngle * Math.PI / 180),
      x2: 200 + (120 - tickLength) * Math.cos(tickAngle * Math.PI / 180),
      y2: 200 - (120 - tickLength) * Math.sin(tickAngle * Math.PI / 180),
      textX: 200 + textRadius * Math.cos(tickAngle * Math.PI / 180),
      textY: 200 - textRadius * Math.sin(tickAngle * Math.PI / 180),
      value: isMajor ? Math.round(i / 16 * 160) : null
    };
  });
  const getFuelEngineStyle = ({ type: type2, value }) => {
    const isLow = value <= 20;
    const isBlinking2 = isLowValue[type2];
    const isLightTheme = theme === HudThemes.LIGHT;
    return {
      icon: "size-[2vh] transition-colors duration-250",
      iconColor: isLow ? "#ff2d2d" : isLightTheme ? "#FFFFFF" : themeStyle?.icon,
      progress: "absolute inset-0 rounded-full origin-left transition-colors duration-250",
      progressColor: isLow ? "#ff2d2d" : themeStyle?.progressBar,
      opacity: isLow ? isBlinking2 ? 1 : 0.5 : 1
    };
  };
  const getIndicatorsStyle = ({ type: type2, value }) => {
    const isLeft = value === 1;
    const isRight = value === 2;
    const isHazards = value === 3;
    const shouldBlink = isBlinking && (isHazards || type2 === "left" && isLeft || type2 === "right" && isRight);
    if (type2 === "hazards") {
      return {
        icon: "size-[1.75vh] transition-colors duration-250",
        iconColor: isHazards ? "#ff2d2d" : themeStyle?.icon,
        borderStyle: themeStyle?.border?.style,
        borderColor: isHazards ? "#ff2d2d" : themeStyle?.border?.color,
        opacity: isHazards ? isBlinking ? 1 : 0.5 : 0.5
      };
    }
    if (type2 === "left" || type2 === "right") {
      return {
        icon: "size-[1.35vh] transition-colors duration-250",
        iconColor: isHazards || isLeft && type2 === "left" || isRight && type2 === "right" ? "#F9C82D" : themeStyle?.icon,
        borderStyle: themeStyle?.border?.style,
        borderColor: isHazards || isLeft && type2 === "left" || isRight && type2 === "right" ? "#F9C82D" : themeStyle?.border?.color,
        opacity: shouldBlink ? 1 : 0.5
      };
    }
    return {
      icon: "size-[1.35vh] transition-colors duration-250",
      iconColor: themeStyle?.icon,
      borderStyle: themeStyle?.border?.style,
      borderColor: themeStyle?.border?.color,
      opacity: shouldBlink ? 1 : 0.5
    };
  };
  const getSpeedUnit = () => config.mph ? "mph" : "km/h";
  const getSpeedValue = () => {
    const value = Math.floor(speed);
    return value;
  };
  const rpmRadius = 90;
  const rpmAngle = rpm / 100 * 180;
  const font = getFontFamily(
    defaultBaseStyle2.fonts,
    baseStyle.font?.[SpeedometerThemes.DEFAULT]?.type?.[type] || "default"
  );
  if (type === VehicleType.AIR) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AirSpeedometer,
      {
        speed,
        engineHealth,
        fuelLevel,
        altitude,
        themeStyle,
        font
      }
    );
  }
  if (type === VehicleType.BOAT) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      BoatSpeedometer,
      {
        speed,
        engineHealth,
        fuelLevel,
        themeStyle,
        themeIcons
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative size-[32vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full h-full", viewBox: "0 0 400 400", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: `M ${200 + rpmRadius * Math.cos(180 * Math.PI / 180)} ${200 - rpmRadius * Math.sin(180 * Math.PI / 180)} 
               A ${rpmRadius} ${rpmRadius} 0 0 1 ${200 + rpmRadius * Math.cos(0 * Math.PI / 180)} ${200 - rpmRadius * Math.sin(0 * Math.PI / 180)}`,
          fill: "none",
          stroke: themeStyle?.rpmTrack || "#1a1a1a",
          strokeWidth: "4",
          style: ShadowStyle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.path,
        {
          d: `M ${200 + rpmRadius * Math.cos(180 * Math.PI / 180)} ${200 - rpmRadius * Math.sin(180 * Math.PI / 180)} 
               A ${rpmRadius} ${rpmRadius} 0 0 1 ${200 + rpmRadius * Math.cos((180 - rpmAngle) * Math.PI / 180)} ${200 - rpmRadius * Math.sin((180 - rpmAngle) * Math.PI / 180)}`,
          fill: "none",
          stroke: themeStyle?.rpmProgress || "#ff3333",
          strokeWidth: "4",
          strokeLinecap: "round",
          initial: { pathLength: 0 },
          animate: {
            pathLength: rpm / 100,
            stroke: themeStyle?.rpmProgress
          },
          transition: {
            pathLength: {
              type: "spring",
              bounce: 0.1,
              duration: 0.6,
              stiffness: 60,
              damping: 9,
              mass: 0.6,
              restSpeed: 1e-4
            },
            stroke: {
              duration: 0.3
            }
          },
          style: ShadowStyle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: `M ${200 + 120 * Math.cos(180 * Math.PI / 180)} ${200 - 120 * Math.sin(180 * Math.PI / 180)} 
               A 120 120 0 0 1 ${200 + 120 * Math.cos(0 * Math.PI / 180)} ${200 - 120 * Math.sin(0 * Math.PI / 180)}`,
          fill: "none",
          stroke: themeStyle?.speedometerTrack,
          strokeWidth: "4",
          style: ShadowStyle
        }
      ),
      ticks.map((tick, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "line",
          {
            x1: tick.x1,
            y1: tick.y1,
            x2: tick.x2,
            y2: tick.y2,
            stroke: themeStyle?.speedometerTick,
            strokeWidth: tick.value !== null ? "3" : "1"
          }
        ),
        tick.value !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "text",
          {
            x: tick.textX,
            y: tick.textY,
            fill: themeStyle?.speedometerTick,
            fontSize: "20",
            textAnchor: "middle",
            dominantBaseline: "middle",
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: tick.value
          }
        )
      ] }, i)),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "text",
        {
          x: "200",
          y: "145",
          textAnchor: "middle",
          dominantBaseline: "middle",
          className: "font-bold text-[3vh]",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "tspan",
              {
                style: {
                  ...ShadowStyle,
                  fill: themeStyle?.textMuted,
                  fontFamily: font
                },
                children: "0".repeat(3 - Math.floor(speed).toString().length)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "tspan",
              {
                style: {
                  ...ShadowStyle,
                  fill: themeStyle?.textPrimary,
                  fontFamily: font
                },
                children: getSpeedValue()
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "text",
        {
          x: "200",
          y: "170",
          textAnchor: "middle",
          dominantBaseline: "middle",
          className: "font-bold text-[1.75vh] uppercase",
          style: {
            ...ShadowStyle,
            fill: themeStyle?.textSecondary,
            fontFamily: font
          },
          children: getSpeedUnit()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.g,
        {
          initial: false,
          animate: {
            rotate: -90 + angle + shakeOffset
          },
          style: {
            originX: "200px",
            originY: "200px"
          },
          transition: {
            type: "spring",
            bounce: 0.1,
            duration: 0.6,
            stiffness: 60,
            damping: 9,
            mass: 0.6,
            restSpeed: 1e-4
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "line",
            {
              x1: "200",
              y1: "200",
              x2: "200",
              y2: 200 - needleLength,
              stroke: themeStyle?.speedometerNeedle,
              strokeWidth: "4",
              style: ShadowStyle
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "200", cy: "200", r: "8", fill: "#000", stroke: themeStyle?.speedometerNeedle, strokeWidth: "3", style: ShadowStyle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-[12.65vh] left-1/2 -translate-x-1/2 flex items-center gap-[5.5vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "\r\n              size-[1.85vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden\r\n            ",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background,
            borderStyle: getIndicatorsStyle({ type: "left", value: indicators }).borderStyle,
            borderColor: getIndicatorsStyle({ type: "left", value: indicators }).borderColor
          },
          animate: { opacity: getIndicatorsStyle({ type: "left", value: indicators }).opacity },
          transition: { duration: 0.3 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: themeIcons?.vehicle?.indicators?.left,
              className: getIndicatorsStyle({ type: "left", value: indicators }).icon,
              style: {
                color: getIndicatorsStyle({ type: "left", value: indicators }).iconColor
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "\r\n              size-[1.85vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden\r\n            ",
          style: {
            ...ShadowStyle,
            background: themeStyle?.background,
            borderStyle: getIndicatorsStyle({ type: "right", value: indicators }).borderStyle,
            borderColor: getIndicatorsStyle({ type: "right", value: indicators }).borderColor
          },
          animate: { opacity: getIndicatorsStyle({ type: "right", value: indicators }).opacity },
          transition: { duration: 0.3 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: themeIcons?.vehicle?.indicators?.right,
              className: getIndicatorsStyle({ type: "right", value: indicators }).icon,
              style: {
                color: getIndicatorsStyle({ type: "right", value: indicators }).iconColor
              }
            }
          )
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-[10.35vh] left-1/2 -translate-x-1/2 flex items-center gap-[1.85vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            animate: { opacity: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).opacity },
            transition: { duration: 0.3 },
            style: ShadowStyle,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.fuel,
                className: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).icon,
                style: {
                  color: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).iconColor
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[4vw] h-[.4vh] overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "absolute inset-0 rounded-full",
              style: {
                ...ShadowStyle,
                background: themeStyle?.progressTrack
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).progress,
              style: {
                background: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).progressColor
              },
              initial: { scaleX: 0 },
              animate: {
                scaleX: fuelLevel / 100,
                opacity: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel }).opacity
              },
              transition: { duration: 0.5 }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `relative size-[3.35vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden`,
          style: {
            ...ShadowStyle,
            background: themeStyle?.background,
            border: themeStyle?.border
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              initial: {
                y: isAnimating ? currentGear > prevGear ? -60 : 60 : 0,
                opacity: 0
              },
              animate: {
                y: 0,
                opacity: 1
              },
              exit: {
                y: isAnimating ? currentGear > prevGear ? 60 : -60 : 0,
                opacity: 0
              },
              transition: {
                y: { type: "spring", stiffness: 300, damping: 20 },
                opacity: { duration: 0.05 }
              },
              className: "text-[1.55vh] font-bold absolute",
              style: {
                color: themeStyle?.text,
                fontFamily: font
              },
              children: currentGear === 0 ? "R" : currentGear
            },
            currentGear
          ) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            animate: { opacity: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).opacity },
            transition: { duration: 0.3 },
            style: ShadowStyle,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.engine,
                className: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).icon,
                style: {
                  color: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).iconColor
                }
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[4vw] h-[.4vh] overflow-hidden", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "absolute inset-0 rounded-full",
              style: {
                ...ShadowStyle,
                background: themeStyle?.progressTrack
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).progress,
              style: {
                background: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).progressColor
              },
              initial: { scaleX: 0 },
              animate: {
                scaleX: engineHealth / 100,
                opacity: getFuelEngineStyle({ type: "engineHealth", value: engineHealth }).opacity
              },
              transition: { duration: 0.5 }
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[16.75vh] -right-[1.3vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `
            size-[3.5vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden
            ${seatbelt ? "opacity-100" : "opacity-50"}
          `,
        style: {
          ...ShadowStyle,
          background: themeStyle?.background,
          borderStyle: themeStyle?.border?.style,
          borderColor: themeStyle?.border?.color
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: isHarness ? themeIcons?.vehicle?.seatbelt?.harness : seatbelt ? themeIcons?.vehicle?.seatbelt?.on : themeIcons?.vehicle?.seatbelt?.off,
            className: "size-[1.75vh]",
            style: {
              color: themeStyle?.icon
            }
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[22.5vh] -right-[.1vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `
            size-[3.5vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden
            ${headlights === 2 ? "opacity-100" : headlights === 1 ? "opacity-75" : "opacity-50"}
          `,
        style: {
          ...ShadowStyle,
          background: themeStyle?.background,
          borderStyle: themeStyle?.border?.style,
          borderColor: themeStyle?.border?.color
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: headlights === 2 ? themeIcons?.vehicle?.headlight?.high : headlights === 1 ? themeIcons?.vehicle?.headlight?.low : themeIcons?.vehicle?.headlight?.off,
            className: "size-[1.75vh]",
            style: {
              color: themeStyle?.icon
            }
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-[10.6vh] -right-[5.95vw] min-w-[6vw] min-h-[2.65vh] flex flex-col items-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center gap-[.6vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontWeight: defaultBaseStyle2?.text?.weight?.medium
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.cruiseControl,
                className: "size-[1.5vh]",
                style: {
                  color: theme === HudThemes.LIGHT ? "#FFFFFF" : themeStyle?.icon
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[1.45vh]",
                style: {
                  ...ShadowStyle,
                  color: theme === HudThemes.LIGHT ? "#FFFFFF" : themeStyle?.text,
                  fontFamily: font
                },
                children: cruiseControl ? "On" : "Off"
              }
            )
          ]
        }
      ),
      cruiseControl && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center gap-[.6vh]",
          style: {
            ...ShadowStyle,
            color: themeStyle?.text,
            fontWeight: defaultBaseStyle2?.text?.weight?.medium
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.maxSpeedForCruise,
                className: "size-[1.5vh]",
                style: {
                  color: theme === HudThemes.LIGHT ? "#FFFFFF" : themeStyle?.icon
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: "text-[1.45vh]",
                style: {
                  ...ShadowStyle,
                  color: theme === HudThemes.LIGHT ? "#FFFFFF" : themeStyle?.text,
                  fontFamily: font
                },
                children: [
                  maxSpeedForCruise ?? 0,
                  " ",
                  getSpeedUnit()
                ]
              }
            )
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[27.25vh] right-[2.25vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "\r\n              size-[3.5vh] \r\n              border-[.25vh]\r\n              rounded-full \r\n              flex \r\n              items-center \r\n              justify-center \r\n              overflow-hidden\r\n            ",
        style: {
          ...ShadowStyle,
          background: themeStyle?.background,
          borderStyle: getIndicatorsStyle({ type: "hazards", value: indicators }).borderStyle,
          borderColor: getIndicatorsStyle({ type: "hazards", value: indicators }).borderColor
        },
        animate: { opacity: getIndicatorsStyle({ type: "hazards", value: indicators }).opacity },
        transition: { duration: 0.3 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.vehicle?.indicators?.hazards,
            className: getIndicatorsStyle({ type: "hazards", value: indicators }).icon,
            style: {
              color: getIndicatorsStyle({ type: "hazards", value: indicators }).iconColor
            }
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[29.5vh] right-[5.55vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `
            size-[3.5vh] border-[.25vh] rounded-full flex items-center justify-center overflow-hidden
            `,
        style: {
          ...ShadowStyle,
          background: themeStyle?.background,
          borderStyle: themeStyle?.border?.style,
          borderColor: themeStyle?.border?.color
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.vehicle?.handBreak,
            className: "size-[1.75vh]",
            style: {
              color: handBrake ? "#ff2d2d" : themeStyle?.icon
            }
          }
        )
      }
    ) }),
    nos.toggle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[15.25vh] -left-[1.5vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(NosStatus, { value: nos.value ?? 0 }) })
  ] }) });
}

const getFuelEngineStyle = ({
  type: _type,
  value,
  isBlinking
}) => {
  const isLow = value <= 20;
  const shouldBlink = isLow && isBlinking;
  return {
    icon: `size-[4vh] transition-colors duration-250 ${isLow ? "text-[#eb242b]" : "text-[#ffffff]"}`,
    progress: `absolute inset-0  origin-left transition-colors duration-250 ${isLow ? "bg-[#eb242b]" : "bg-[#ffffff]"}`,
    opacity: shouldBlink ? 0.5 : 1
  };
};
const EngineBar = ({
  engineHealth,
  themeIcons
}) => {
  const [isBlinking, setIsBlinking] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setIsBlinking((prev) => !prev);
    }, 500);
    return () => clearInterval(interval);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[18px] w-[250px] h-[28px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "size-[45px] -mt-[8px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Icon$1,
      {
        icon: themeIcons?.vehicle?.engine,
        className: "w-full h-full transition-colors duration-250 text-[#ffffff]"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-full overflow-hidden", style: { transform: "skew(-20deg)" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[#ffffff1a]" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: getFuelEngineStyle({ type: "engineHealth", value: engineHealth, isBlinking }).progress,
          initial: false,
          animate: {
            scaleX: engineHealth / 100,
            opacity: getFuelEngineStyle({ type: "engineHealth", value: engineHealth, isBlinking }).opacity
          },
          transition: { duration: 0.3 }
        }
      )
    ] })
  ] });
};
const FuelBar = ({ fuelLevel }) => {
  const [isBlinking, setIsBlinking] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setIsBlinking((prev) => !prev);
    }, 500);
    return () => clearInterval(interval);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[230px] h-[24px] overflow-hidden", style: { transform: "skew(-20deg)" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[#ffffff1a]" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel, isBlinking }).progress,
        initial: { scaleX: fuelLevel / 100 },
        animate: {
          scaleX: fuelLevel / 100,
          opacity: getFuelEngineStyle({ type: "fuelLevel", value: fuelLevel, isBlinking }).opacity
        },
        transition: { duration: 0.5 }
      }
    )
  ] });
};
const SeatbeltIndicator = ({ seatbelt, isHarness, themeIcons }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
      ${seatbelt ? "opacity-100" : "opacity-50"}
    `, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon$1,
    {
      icon: isHarness ? themeIcons?.vehicle?.seatbelt?.harness : seatbelt ? themeIcons?.vehicle?.seatbelt?.on : themeIcons?.vehicle?.seatbelt?.off,
      className: `size-[73px] text-[#ffffff]`
    }
  ) });
};
const HeadlightIndicator = ({ headlights, themeIcons }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
      ${headlights === 2 ? "opacity-100" : headlights === 1 ? "opacity-75" : "opacity-50"}
    `, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon$1,
    {
      icon: headlights === 2 ? themeIcons?.vehicle?.headlight?.high : headlights === 1 ? themeIcons?.vehicle?.headlight?.low : themeIcons?.vehicle?.headlight?.off,
      className: `size-[73px] text-[#ffffff]`
    }
  ) });
};
const HandBrakeIndicator = ({ handBrake, themeIcons }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${handBrake ? "opacity-100" : "opacity-50"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon$1,
    {
      icon: themeIcons?.vehicle?.handBreak,
      className: `
          size-[73px]
          ${handBrake ? "text-[#eb242b]" : "text-[#ffffff]"}
        `
    }
  ) });
};
const HazardsIndicator = ({ indicatorsStyle, themeIcons }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      animate: { opacity: indicatorsStyle?.opacity },
      transition: { duration: 0.3 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon: themeIcons?.vehicle?.indicators?.hazards,
          className: indicatorsStyle?.icon
        }
      )
    }
  );
};
const NOSDisplay = ({
  value = 0,
  themeIcons
}) => {
  const [isBlinking, setIsBlinking] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setIsBlinking((prev) => !prev);
    }, 500);
    return () => clearInterval(interval);
  }, []);
  const barOpacity = value <= 25 ? isBlinking ? 0.5 : 1 : 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center gap-[.75vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Icon$1,
      {
        icon: themeIcons?.vehicle?.nos,
        className: `size-[3vh] text-[#ffffff]`,
        style: ShadowStyle
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-[12vh] w-[1vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-[#ffffff1a]" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `absolute bottom-0 w-full ${value <= 25 ? "bg-[#eb242b]" : "bg-[#ffffff]"}`,
          initial: false,
          animate: {
            height: `${value}%`,
            opacity: barOpacity
          },
          transition: { duration: 0.3 }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        className: `
        text-[1.2vh] font-medium
        ${value <= 25 ? "text-[#eb242b]" : "text-[#ffffff]"}
      `,
        style: ShadowStyle,
        children: [
          value,
          "%"
        ]
      }
    )
  ] });
};
function ModernSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = Hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeIcons,
    defaultBaseStyle
  } = props;
  const config = useConfigStore((state) => state.config);
  const [isBlinking, setIsBlinking] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setIsBlinking((prev) => !prev);
    }, 500);
    return () => clearInterval(interval);
  }, []);
  const activeSegments = Math.floor(rpm / 100 * 64);
  const getIndicatorsStyle = ({ type: type2, value }) => {
    const isLeft = value === 1;
    const isRight = value === 2;
    const isHazards = value === 3;
    const shouldBlink = isBlinking && (isHazards || type2 === "left" && isLeft || type2 === "right" && isRight);
    if (type2 === "hazards") {
      return {
        fill: isHazards ? "#eb242b" : "#ffffff33",
        icon: `size-[55px] transition-colors duration-250 ${isHazards ? "text-[#eb242b]" : "text-[#ffffff]"}`,
        opacity: isHazards ? shouldBlink ? 1 : 0.5 : 0.5
      };
    }
    if (type2 === "left" || type2 === "right") {
      const isActive = isHazards || type2 === "left" && isLeft || type2 === "right" && isRight;
      return {
        fill: isActive ? "#FFE082" : "#ffffff33",
        opacity: shouldBlink ? 1 : 0.5
      };
    }
    return {
      fill: "#ffffff33",
      opacity: 0.5
    };
  };
  const getSpeedUnit = () => config.mph ? "mph" : "km/h";
  const getSpeedValue = () => {
    const value = Math.floor(speed);
    return value;
  };
  const modernBaseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, modernBaseStyle.font?.[SpeedometerThemes.MODERN]?.type);
  const cruiseControlDisplay = (cruiseControl2, maxSpeedForCruise2, themeIcons2, defaultBaseStyle2) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1.25vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center gap-[.6vh] text-white",
          style: {
            fontWeight: defaultBaseStyle2?.text?.weight?.medium
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons2?.vehicle?.cruiseControl,
                className: "text-white size-[1.5vh]"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: `
              ${cruiseControl2 ? "text-[#ffffff]" : "text-[#bababa]"}
              text-[1.45vh]
            `,
                children: cruiseControl2 ? "On" : "Off"
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "bg-[#ffffff]",
          style: {
            width: modernBaseStyle?.cruiseControl?.divider?.size?.width,
            height: modernBaseStyle?.cruiseControl?.divider?.size?.height
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center gap-[.6vh] text-white",
          style: {
            fontWeight: defaultBaseStyle2?.text?.weight?.medium
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons2?.vehicle?.maxSpeedForCruise,
                className: `
              ${cruiseControl2 ? "text-[#ffffff]" : "text-[#bababa]"} 
              size-[1.5vh]
            `
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: `
              ${cruiseControl2 ? "text-[#ffffff]" : "text-[#bababa]"}
              text-[1.45vh]
            `,
                children: [
                  cruiseControl2 ? maxSpeedForCruise2 : 0,
                  " ",
                  getSpeedUnit()
                ]
              }
            )
          ]
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: "mb-[1.5vh]",
      initial: {
        marginRight: "-3.85vw"
      },
      animate: {
        marginRight: nos.toggle && type === VehicleType.CAR ? "-2.5vw" : "-3.85vw"
      },
      transition: {
        duration: 0.3,
        ease: "easeInOut"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative size-[32vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: "w-full h-full",
            viewBox: "0 0 1169 503",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  fill: "none",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M0.299927 502.4H277H632.9H891.4H1168.1V230.4C1168.1 103.7 1064.4 0 937.7 0H891.3H632.9H535.5H277H230.6C104 0 0.299927 103.7 0.299927 230.4V502.4Z",
                  className: "fill-[#1d1d1dfa]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-1", d: "M66.3 413.8H26.7V419.6H66.3V413.8Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-2", d: "M66.3 405.3H26.7V411.1H66.3V405.3Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-3", d: "M66.3 396.9H26.7V402.7H66.3V396.9Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-4", d: "M66.3 388.4H26.7V394.2H66.3V388.4Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-5", d: "M66.3 380H26.7V385.8H66.3V380Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-6", d: "M66.3 371.5H26.7V377.3H66.3V371.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-7", d: "M66.3 363.1H26.7V368.9H66.3V363.1Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-8", d: "M66.3 335.2H26.7V341H66.3V335.2Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-9", d: "M66.3 326.8H26.7V332.6H66.3V326.8Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-10", d: "M66.3 318.3H26.7V324.1H66.3V318.3Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-11", d: "M66.3 309.9H26.7V315.7H66.3V309.9Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-12", d: "M66.3 301.4H26.7V307.2H66.3V301.4Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-13", d: "M66.3 293H26.7V298.8H66.3V293Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-14", d: "M66.3 284.5H26.7V290.3H66.3V284.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-15", d: "M66.3 258.9H26.7V264.7H66.3V258.9Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-16", d: "M66.3 250.5H26.7V256.3H66.3V250.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-17", d: "M66.3 242H26.7V247.8H66.3V242Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-18", d: "M66.3 233.6H26.7V239.4H66.3V233.6Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-19", fillRule: "evenodd", clipRule: "evenodd", d: "M26.8 224.7H66.3999C66.3999 226.3 66.3 227.9 66.3 229.5V230.5H26.7V229.5C26.7 227.8 26.8 226.2 26.8 224.7Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-20", fillRule: "evenodd", clipRule: "evenodd", d: "M27.2999 214.2L66.7999 216.3C66.5999 218.2 66.4999 220.2 66.3999 222.1L26.8999 220C27.0999 218 27.1999 216.1 27.2999 214.2Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-21", fillRule: "evenodd", clipRule: "evenodd", d: "M28.3999 203.7L67.8 207.8C67.5 209.7 67.3 211.6 67.1 213.6L27.7 209.5C27.9 207.5 28.0999 205.6 28.3999 203.7Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-22", fillRule: "evenodd", clipRule: "evenodd", d: "M34.8 172.9L73 183.1C72.5 185 71.8999 186.8 71.3999 188.7L33.2 178.5C33.7 176.6 34.2 174.7 34.8 172.9Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-23", fillRule: "evenodd", clipRule: "evenodd", d: "M37.9999 162.9L75.6999 175.1C75.0999 176.9 74.3999 178.7 73.8999 180.6L36.2999 168.4C36.6999 166.5 37.2999 164.7 37.9999 162.9Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-24", fillRule: "evenodd", clipRule: "evenodd", d: "M41.7 153.1L78.7 167.3C78 169.1 77.3 170.9 76.6 172.7L39.6 158.5C40.2 156.6 41 154.8 41.7 153.1Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-25", fillRule: "evenodd", clipRule: "evenodd", d: "M45.9 143.4L82.1 159.5C81.3 161.2 80.5 163 79.7 164.8L43.5 148.7C44.3 147 45.1 145.2 45.9 143.4Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-26", fillRule: "evenodd", clipRule: "evenodd", d: "M50.5999 134.1L85.8999 152.1C84.9999 153.8 84.0999 155.5 83.1999 157.3L47.8999 139.3C48.7999 137.5 49.6999 135.8 50.5999 134.1Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-27", fillRule: "evenodd", clipRule: "evenodd", d: "M55.7999 125L90.0999 144.8C89.0999 146.5 88.0999 148.1 87.1999 149.8L52.7999 130C53.7999 128.3 54.7999 126.6 55.7999 125Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-28", fillRule: "evenodd", clipRule: "evenodd", d: "M61.3999 116.1L94.6 137.7C93.5 139.3 92.4999 140.9 91.3999 142.6L58.2 121C59.3 119.3 60.2999 117.7 61.3999 116.1Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-29", fillRule: "evenodd", clipRule: "evenodd", d: "M80.9 91.5L110.3 118C109 119.4 107.7 120.9 106.4 122.3L77 95.8C78.3 94.3 79.6 92.9 80.9 91.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-30", fillRule: "evenodd", clipRule: "evenodd", d: "M87.8999 84.2002L115.9 112.2C114.5 113.6 113.2 114.9 111.8 116.3L83.7999 88.3002C85.1999 86.9002 86.5999 85.5002 87.8999 84.2002Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-31", fillRule: "evenodd", clipRule: "evenodd", d: "M95.4 77.2002L121.9 106.6C120.5 107.9 119 109.2 117.6 110.5L91.1 81.1002C92.5 79.8002 93.9 78.5002 95.4 77.2002Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-32", fillRule: "evenodd", clipRule: "evenodd", d: "M103.2 70.6001L128.1 101.4C126.6 102.6 125.1 103.8 123.6 105.1L98.7 74.3001C100.2 73.1001 101.7 71.8001 103.2 70.6001Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-33", fillRule: "evenodd", clipRule: "evenodd", d: "M111.3 64.3999L134.6 96.3999C133 97.4999 131.5 98.6999 130 99.8999L106.7 67.8999C108.1 66.6999 109.7 65.5999 111.3 64.3999Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-34", fillRule: "evenodd", clipRule: "evenodd", d: "M119.6 58.6001L141.2 91.8001C139.6 92.9001 138 93.9001 136.4 95.1001L114.8 61.9001C116.4 60.8001 118 59.7001 119.6 58.6001Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-35", fillRule: "evenodd", clipRule: "evenodd", d: "M128.3 53.2002L148.1 87.5002C146.4 88.5002 144.8 89.5002 143.1 90.5002L123.3 56.2002C125 55.2002 126.7 54.2002 128.3 53.2002Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-36", fillRule: "evenodd", clipRule: "evenodd", d: "M155.9 39.8003L170.1 76.8003C168.3 77.5003 166.5 78.3003 164.8 79.1003L150.6 42.1003C152.3 41.2003 154.1 40.5003 155.9 39.8003Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-37", fillRule: "evenodd", clipRule: "evenodd", d: "M165.6 36.2002L177.8 73.9002C176 74.5002 174.2 75.2002 172.3 75.9002L160.1 38.2002C161.9 37.5002 163.7 36.8002 165.6 36.2002Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-38", fillRule: "evenodd", clipRule: "evenodd", d: "M175.5 33.1001L185.7 71.3001C183.8 71.8001 182 72.4001 180.2 73.0001L170 34.8001C171.8 34.2001 173.7 33.7001 175.5 33.1001Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-39", fillRule: "evenodd", clipRule: "evenodd", d: "M185.7 30.5L193.9 69.2C192 69.6 190.1 70.1 188.3 70.6L180.1 31.8C181.9 31.4 183.8 31 185.7 30.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-40", fillRule: "evenodd", clipRule: "evenodd", d: "M196 28.5L202.2 67.6C200.3 67.9 198.4 68.3 196.5 68.7L190.3 29.6C192.2 29.2 194.1 28.8 196 28.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-41", fillRule: "evenodd", clipRule: "evenodd", d: "M206.5 26.8999L210.6 66.2999C208.7 66.4999 206.8 66.7999 204.9 67.0999L200.8 27.6999C202.7 27.3999 204.6 27.1999 206.5 26.8999Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-42", fillRule: "evenodd", clipRule: "evenodd", d: "M217.1 26L219.2 65.5C217.3 65.6 215.3 65.8 213.4 66L211.3 26.4C213.3 26.2 215.2 26.1 217.1 26Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-43", fillRule: "evenodd", clipRule: "evenodd", d: "M227.8 25.5V65.1C225.9 65.1 223.9 65.2 222 65.3V25.7C223.9 25.6 225.9 25.6 227.8 25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-44", d: "M256.7 25.5H250.9V65.1H256.7V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-45", d: "M265.2 25.5H259.4V65.1H265.2V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-46", d: "M273.6 25.5H267.8V65.1H273.6V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-47", d: "M282.1 25.5H276.3V65.1H282.1V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-48", d: "M290.5 25.5H284.7V65.1H290.5V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-49", d: "M299 25.5H293.2V65.1H299V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-50", d: "M307.4 25.5H301.6V65.1H307.4V25.5Z", fill: "#909092" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-51", d: "M337.9 25.5H332.1V65.1H337.9V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-52", d: "M346.3 25.5H340.5V65.1H346.3V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-53", d: "M354.8 25.5H349V65.1H354.8V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-54", d: "M363.2 25.5H357.4V65.1H363.2V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-55", d: "M371.7 25.5H365.9V65.1H371.7V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-56", d: "M380.1 25.5H374.3V65.1H380.1V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-57", d: "M388.6 25.5H382.8V65.1H388.6V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-58", d: "M418.5 25.5H412.7V65.1H418.5V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-59", d: "M426.9 25.5H421.1V65.1H426.9V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-60", d: "M435.4 25.5H429.6V65.1H435.4V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-61", d: "M443.8 25.5H438V65.1H443.8V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-62", d: "M452.3 25.5H446.5V65.1H452.3V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-63", d: "M460.7 25.5H454.9V65.1H460.7V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "speedometer-64", d: "M469.2 25.5H463.4V65.1H469.2V25.5Z", fill: "#93272B" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-1",
                  d: "M66.3 413.8H26.7V419.6H66.3V413.8Z",
                  fill: activeSegments >= 1 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-2",
                  d: "M66.3 405.3H26.7V411.1H66.3V405.3Z",
                  fill: activeSegments >= 2 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-3",
                  d: "M66.3 396.9H26.7V402.7H66.3V396.9Z",
                  fill: activeSegments >= 3 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-4",
                  d: "M66.3 388.4H26.7V394.2H66.3V388.4Z",
                  fill: activeSegments >= 4 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-5",
                  d: "M66.3 380H26.7V385.8H66.3V380Z",
                  fill: activeSegments >= 5 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-6",
                  d: "M66.3 371.5H26.7V377.3H66.3V371.5Z",
                  fill: activeSegments >= 6 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-7",
                  d: "M66.3 363.1H26.7V368.9H66.3V363.1Z",
                  fill: activeSegments >= 7 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-8",
                  d: "M66.3 335.2H26.7V341H66.3V335.2Z",
                  fill: activeSegments >= 8 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-9",
                  d: "M66.3 326.8H26.7V332.6H66.3V326.8Z",
                  fill: activeSegments >= 9 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-10",
                  d: "M66.3 318.3H26.7V324.1H66.3V318.3Z",
                  fill: activeSegments >= 10 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-11",
                  d: "M66.3 309.9H26.7V315.7H66.3V309.9Z",
                  fill: activeSegments >= 11 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-12",
                  d: "M66.3 301.4H26.7V307.2H66.3V301.4Z",
                  fill: activeSegments >= 12 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-13",
                  d: "M66.3 293H26.7V298.8H66.3V293Z",
                  fill: activeSegments >= 13 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-14",
                  d: "M66.3 284.5H26.7V290.3H66.3V284.5Z",
                  fill: activeSegments >= 14 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-15",
                  d: "M66.3 258.9H26.7V264.7H66.3V258.9Z",
                  fill: activeSegments >= 15 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-16",
                  d: "M66.3 250.5H26.7V256.3H66.3V250.5Z",
                  fill: activeSegments >= 16 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-17",
                  d: "M66.3 242H26.7V247.8H66.3V242Z",
                  fill: activeSegments >= 17 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-18",
                  d: "M66.3 233.6H26.7V239.4H66.3V233.6Z",
                  fill: activeSegments >= 18 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-19",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M26.8 224.7H66.3999C66.3999 226.3 66.3 227.9 66.3 229.5V230.5H26.7V229.5C26.7 227.8 26.8 226.2 26.8 224.7Z",
                  fill: activeSegments >= 19 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-20",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M27.2999 214.2L66.7999 216.3C66.5999 218.2 66.4999 220.2 66.3999 222.1L26.8999 220C27.0999 218 27.1999 216.1 27.2999 214.2Z",
                  fill: activeSegments >= 20 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-21",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M28.3999 203.7L67.8 207.8C67.5 209.7 67.3 211.6 67.1 213.6L27.7 209.5C27.9 207.5 28.0999 205.6 28.3999 203.7Z",
                  fill: activeSegments >= 21 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-22",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M34.8 172.9L73 183.1C72.5 185 71.8999 186.8 71.3999 188.7L33.2 178.5C33.7 176.6 34.2 174.7 34.8 172.9Z",
                  fill: activeSegments >= 22 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-23",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M37.9999 162.9L75.6999 175.1C75.0999 176.9 74.3999 178.7 73.8999 180.6L36.2999 168.4C36.6999 166.5 37.2999 164.7 37.9999 162.9Z",
                  fill: activeSegments >= 23 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-24",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M41.7 153.1L78.7 167.3C78 169.1 77.3 170.9 76.6 172.7L39.6 158.5C40.2 156.6 41 154.8 41.7 153.1Z",
                  fill: activeSegments >= 24 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-25",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M45.9 143.4L82.1 159.5C81.3 161.2 80.5 163 79.7 164.8L43.5 148.7C44.3 147 45.1 145.2 45.9 143.4Z",
                  fill: activeSegments >= 25 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-26",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M50.5999 134.1L85.8999 152.1C84.9999 153.8 84.0999 155.5 83.1999 157.3L47.8999 139.3C48.7999 137.5 49.6999 135.8 50.5999 134.1Z",
                  fill: activeSegments >= 26 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-27",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M55.7999 125L90.0999 144.8C89.0999 146.5 88.0999 148.1 87.1999 149.8L52.7999 130C53.7999 128.3 54.7999 126.6 55.7999 125Z",
                  fill: activeSegments >= 27 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-28",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M61.3999 116.1L94.6 137.7C93.5 139.3 92.4999 140.9 91.3999 142.6L58.2 121C59.3 119.3 60.2999 117.7 61.3999 116.1Z",
                  fill: activeSegments >= 28 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-29",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M80.9 91.5L110.3 118C109 119.4 107.7 120.9 106.4 122.3L77 95.8C78.3 94.3 79.6 92.9 80.9 91.5Z",
                  fill: activeSegments >= 29 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-30",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M87.8999 84.2002L115.9 112.2C114.5 113.6 113.2 114.9 111.8 116.3L83.7999 88.3002C85.1999 86.9002 86.5999 85.5002 87.8999 84.2002Z",
                  fill: activeSegments >= 30 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-31",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M95.4 77.2002L121.9 106.6C120.5 107.9 119 109.2 117.6 110.5L91.1 81.1002C92.5 79.8002 93.9 78.5002 95.4 77.2002Z",
                  fill: activeSegments >= 31 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-32",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M103.2 70.6001L128.1 101.4C126.6 102.6 125.1 103.8 123.6 105.1L98.7 74.3001C100.2 73.1001 101.7 71.8001 103.2 70.6001Z",
                  fill: activeSegments >= 32 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-33",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M111.3 64.3999L134.6 96.3999C133 97.4999 131.5 98.6999 130 99.8999L106.7 67.8999C108.1 66.6999 109.7 65.5999 111.3 64.3999Z",
                  fill: activeSegments >= 33 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-34",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M119.6 58.6001L141.2 91.8001C139.6 92.9001 138 93.9001 136.4 95.1001L114.8 61.9001C116.4 60.8001 118 59.7001 119.6 58.6001Z",
                  fill: activeSegments >= 34 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-35",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M128.3 53.2002L148.1 87.5002C146.4 88.5002 144.8 89.5002 143.1 90.5002L123.3 56.2002C125 55.2002 126.7 54.2002 128.3 53.2002Z",
                  fill: activeSegments >= 35 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-36",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M155.9 39.8003L170.1 76.8003C168.3 77.5003 166.5 78.3003 164.8 79.1003L150.6 42.1003C152.3 41.2003 154.1 40.5003 155.9 39.8003Z",
                  fill: activeSegments >= 36 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-37",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M165.6 36.2002L177.8 73.9002C176 74.5002 174.2 75.2002 172.3 75.9002L160.1 38.2002C161.9 37.5002 163.7 36.8002 165.6 36.2002Z",
                  fill: activeSegments >= 37 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-38",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M175.5 33.1001L185.7 71.3001C183.8 71.8001 182 72.4001 180.2 73.0001L170 34.8001C171.8 34.2001 173.7 33.7001 175.5 33.1001Z",
                  fill: activeSegments >= 38 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-39",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M185.7 30.5L193.9 69.2C192 69.6 190.1 70.1 188.3 70.6L180.1 31.8C181.9 31.4 183.8 31 185.7 30.5Z",
                  fill: activeSegments >= 39 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-40",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M196 28.5L202.2 67.6C200.3 67.9 198.4 68.3 196.5 68.7L190.3 29.6C192.2 29.2 194.1 28.8 196 28.5Z",
                  fill: activeSegments >= 40 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-41",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M206.5 26.8999L210.6 66.2999C208.7 66.4999 206.8 66.7999 204.9 67.0999L200.8 27.6999C202.7 27.3999 204.6 27.1999 206.5 26.8999Z",
                  fill: activeSegments >= 41 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-42",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M217.1 26L219.2 65.5C217.3 65.6 215.3 65.8 213.4 66L211.3 26.4C213.3 26.2 215.2 26.1 217.1 26Z",
                  fill: activeSegments >= 42 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-43",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M227.8 25.5V65.1C225.9 65.1 223.9 65.2 222 65.3V25.7C223.9 25.6 225.9 25.6 227.8 25.5Z",
                  fill: activeSegments >= 43 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-44",
                  d: "M256.7 25.5H250.9V65.1H256.7V25.5Z",
                  fill: activeSegments >= 44 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-45",
                  d: "M265.2 25.5H259.4V65.1H265.2V25.5Z",
                  fill: activeSegments >= 45 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-46",
                  d: "M273.6 25.5H267.8V65.1H273.6V25.5Z",
                  fill: activeSegments >= 46 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-47",
                  d: "M282.1 25.5H276.3V65.1H282.1V25.5Z",
                  fill: activeSegments >= 47 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-48",
                  d: "M290.5 25.5H284.7V65.1H290.5V25.5Z",
                  fill: activeSegments >= 48 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-49",
                  d: "M299 25.5H293.2V65.1H299V25.5Z",
                  fill: activeSegments >= 49 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-50",
                  d: "M307.4 25.5H301.6V65.1H307.4V25.5Z",
                  fill: activeSegments >= 50 ? "#FFFFFF" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-51",
                  d: "M337.9 25.5H332.1V65.1H337.9V25.5Z",
                  fill: activeSegments >= 51 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-52",
                  d: "M346.3 25.5H340.5V65.1H346.3V25.5Z",
                  fill: activeSegments >= 52 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-53",
                  d: "M354.8 25.5H349V65.1H354.8V25.5Z",
                  fill: activeSegments >= 53 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-54",
                  d: "M363.2 25.5H357.4V65.1H363.2V25.5Z",
                  fill: activeSegments >= 54 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-55",
                  d: "M371.7 25.5H365.9V65.1H371.7V25.5Z",
                  fill: activeSegments >= 55 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-56",
                  d: "M380.1 25.5H374.3V65.1H380.1V25.5Z",
                  fill: activeSegments >= 56 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-57",
                  d: "M388.6 25.5H382.8V65.1H388.6V25.5Z",
                  fill: activeSegments >= 57 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-58",
                  d: "M418.5 25.5H412.7V65.1H418.5V25.5Z",
                  fill: activeSegments >= 58 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-59",
                  d: "M426.9 25.5H421.1V65.1H426.9V25.5Z",
                  fill: activeSegments >= 59 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-60",
                  d: "M435.4 25.5H429.6V65.1H435.4V25.5Z",
                  fill: activeSegments >= 60 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-61",
                  d: "M443.8 25.5H438V65.1H443.8V25.5Z",
                  fill: activeSegments >= 61 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-62",
                  d: "M452.3 25.5H446.5V65.1H452.3V25.5Z",
                  fill: activeSegments >= 62 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-63",
                  d: "M460.7 25.5H454.9V65.1H460.7V25.5Z",
                  fill: activeSegments >= 63 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.path,
                {
                  id: "speedometer-progress-64",
                  d: "M469.2 25.5H463.4V65.1H469.2V25.5Z",
                  fill: activeSegments >= 64 ? "#eb242b" : "transparent",
                  transition: { duration: 0.2, ease: "easeInOut" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M82.6 408.7L93.2 402.7H98.2L91.9 430.2H86.2L91 409.5L84.2 413.2L82.6 408.7Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M94.1 337.5C95.2 336.3 95.7 335.2 95.7 334.3C95.7 333.4 95.4 332.6 94.8 332.2C94.2 331.8 93.3 331.6 92.1 331.6C90.3 331.6 88.2 331.8 86 332.1L85 332.2L85.7 328C88.4 327.1 91 326.6 93.6 326.6C96.2 326.6 98.2 327.1 99.5 328.1C100.8 329.1 101.5 330.8 101.5 333C101.5 335.2 100.9 337.1 99.8 338.7C98.7 340.3 96.9 342 94.4 343.9L86.8 349.6H98L96.8 354.5H79.1L80.2 349.8L88.5 342.6C91.2 340.4 93.1 338.7 94.1 337.5Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M85.5 256.2C88 255.1 90.5999 254.5 93.3999 254.5C96.1999 254.5 98.3 255 99.6 255.9C100.9 256.8 101.6 258.3 101.6 260.3C101.6 262.3 101.2 263.8 100.5 264.9C99.8 266 98.5 267 96.6 268C97.6 268.6 98.3 269.2 98.7 269.9C99.1 270.6 99.3 271.7 99.3 273.1C99.3 276 98.2 278.4 96.1 280.2C94 282 91.1 282.9 87.5 282.9C86.3 282.9 85 282.8 83.6 282.5C82.2 282.2 81.0999 282 80.3999 281.8L79.2 281.4L80.3999 277.5C83.5999 277.8 86 278 87.7 278C89.4 278 90.7999 277.6 91.8999 276.8C92.9999 276 93.5 274.9 93.5 273.4C93.5 272.6 93.2 272 92.7 271.7C92.2 271.4 91.2999 271.2 89.8999 271.1L84.7 271L85.7 266.8L91.1 266.5C92.2 266.4 93.2 266 94.3 265C95.4 264.1 95.8999 263 95.8999 261.9C95.8999 260.2 94.7 259.3 92.2 259.3C90.1 259.3 88.1 259.4 86.2 259.7L85.1 259.8L85.5 256.2Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M90.3999 208.3L91.4999 203.4H79.8999L80.8999 199.2L92.3999 180.6H98.5999L86.9999 198.6H92.5999L94.2999 191.2H99.9999L98.2999 198.6H100.8L99.6999 203.3H97.1999L96.0999 208.2H90.3999V208.3Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M125 133.6C129.8 133.6 132.2 135.8 132.2 140.3C132.2 143.6 131.2 146.3 129.1 148.4C127 150.5 124.4 151.6 121.3 151.6C119.9 151.6 118.3 151.5 116.7 151.2C115.1 150.9 113.8 150.6 112.9 150.3L111.6 149.8L112.9 145.5C116.1 146.3 118.6 146.7 120.5 146.7C122.3 146.7 123.8 146.2 124.9 145.2C126 144.2 126.5 143.1 126.5 141.9C126.5 140.7 126.2 139.8 125.8 139.4C125.4 139 124.6 138.7 123.7 138.7C122.1 138.7 120.7 138.9 119.6 139.4L119 139.6L114.8 138.6L119.4 123.7H135.7L134.6 128.6H122.8L120.3 135.1C122.2 134.1 123.8 133.6 125 133.6Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M181.8 89.5001C178.6 89.5001 176.2 91.8001 174.6 96.3001C176.8 95.3001 178.7 94.8001 180.2 94.8001C185.2 94.8001 187.7 97.2001 187.7 102C187.7 105.3 186.7 107.9 184.8 109.9C182.8 111.9 180.1 112.9 176.5 112.9C173.7 112.9 171.6 112.1 170 110.5C168.4 108.9 167.6 106.4 167.6 103.2C167.6 101.1 168 99.0001 168.7 96.8001C169.4 94.6001 170.4 92.6001 171.7 90.8001C173 89.0001 174.6 87.5001 176.6 86.3001C178.6 85.1001 180.8 84.6001 183.2 84.6001C185 84.6001 187 84.8001 189.1 85.3001L190.2 85.6001L188.4 90.2001C186.2 89.7001 184 89.5001 181.8 89.5001ZM178.5 99.8001C176.9 99.8001 175.6 100.1 174.4 100.5L173.8 100.8C173.6 101.9 173.4 102.9 173.4 103.9C173.4 104.9 173.7 105.9 174.2 106.8C174.7 107.7 175.6 108.2 176.8 108.2C178.4 108.2 179.7 107.7 180.5 106.8C181.4 105.9 181.8 104.5 181.8 102.7C181.9 100.7 180.7 99.8001 178.5 99.8001Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M247.2 79.2999L248.3 74.3999H265.4L263.7 81.5999L249 102.6L243.8 101.1L258.2 80.9999L258.5 79.2999H247.2Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M334.3 74.2002C336.9 74.2002 338.9 74.7002 340.4 75.8002C341.9 76.9002 342.5 78.2002 342.5 79.7002C342.5 81.8002 342.1 83.4002 341.3 84.6002C340.5 85.8002 339.3 86.9002 337.7 88.0002C339.1 89.1002 339.9 90.8002 339.9 93.1002C339.9 95.9002 338.7 98.2002 336.2 100C333.7 101.8 330.8 102.7 327.6 102.7C324.3 102.7 322 102.1 320.7 101C319.4 99.8002 318.7 98.1002 318.7 95.8002C318.7 93.1002 320.5 90.5002 324.1 88.1002C323.5 87.5002 323.1 86.9002 322.8 86.4002C322.5 85.8002 322.4 85.4002 322.4 85.2002C322.4 85.0002 322.4 84.6002 322.4 84.0002C322.4 81.4002 323.5 79.1002 325.7 77.2002C327.8 75.2002 330.7 74.2002 334.3 74.2002ZM324.9 94.9002C324.9 95.9002 325.2 96.7002 325.7 97.1002C326.2 97.6002 327.2 97.8002 328.6 97.8002C330 97.8002 331.2 97.3002 332.3 96.4002C333.4 95.5002 333.9 94.5002 333.9 93.3002C333.9 92.6002 333.8 92.1002 333.5 91.7002C333.3 91.3002 332.8 91.0002 332.1 90.7002H328.4C327.4 91.1002 326.6 91.6002 325.9 92.3002C325.2 93.0002 324.9 93.9002 324.9 94.9002ZM336.3 81.8002C336.3 81.0002 336 80.4002 335.5 79.9002C335 79.4002 334.1 79.1002 332.9 79.1002C331.7 79.1002 330.6 79.5002 329.6 80.4002C328.6 81.3002 328.1 82.2002 328.1 83.2002C328.1 83.9002 328.2 84.4002 328.4 84.7002C328.6 85.0002 328.9 85.5002 329.5 85.9002H333.2C334 85.4002 334.8 84.8002 335.4 84.0002C336 83.2002 336.3 82.6002 336.3 81.8002Z", fill: "#eb242b" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M403.6 96.8999C405.2 97.2999 407 97.4999 409 97.4999C411 97.4999 412.7 96.8999 414.2 95.7999C415.6 94.5999 416.6 93.0999 417.1 91.1999L416 91.4999C413.5 92.0999 411.8 92.2999 410.9 92.2999C408.5 92.2999 406.7 91.6999 405.6 90.5999C404.4 89.3999 403.8 87.5999 403.8 84.9999C403.8 82.4999 404.8 80.1999 406.7 77.9999C407.6 76.8999 408.9 75.9999 410.5 75.3999C412.1 74.6999 413.9 74.3999 416 74.3999C418.6 74.3999 420.6 75.2999 421.9 77.1999C423.2 78.9999 423.8 81.5999 423.8 84.8999C423.8 90.4999 422.3 94.8999 419.2 98.0999C416.1 101.3 412.4 102.9 408.1 102.9C406.3 102.9 404.5 102.7 402.8 102.2L401.9 102L403.6 96.8999ZM418.4 84.0999C418.4 80.9999 417.2 79.4999 414.7 79.4999C413.3 79.4999 412 79.9999 410.9 80.8999C409.8 81.7999 409.3 82.8999 409.3 84.1999C409.3 85.4999 409.5 86.2999 410 86.6999C410.5 87.0999 411.2 87.2999 412.2 87.2999C414 87.2999 415.7 87.0999 417.3 86.7999L418.2 86.5999C418.3 85.6999 418.4 84.7999 418.4 84.0999Z", fill: "#eb242b" }),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "text",
                {
                  x: "170",
                  y: "395",
                  textAnchor: "middle",
                  dominantBaseline: "middle",
                  fill: "none",
                  className: "fill-[#ffffff]",
                  fontSize: "90",
                  fontWeight: "bold",
                  fontStyle: "italic",
                  children: currentGear === 0 ? "R" : currentGear
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: "M1145.1 461.2H31.5V464.1H1145.1V461.2Z",
                  fill: "none",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "text",
                {
                  x: "550",
                  y: "270",
                  textAnchor: "middle",
                  dominantBaseline: "middle",
                  className: `text-[268px] font-medium tracking-[10.5px]`,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "tspan",
                      {
                        className: "fill-[#ffffff66]",
                        style: {
                          fontFamily: font
                        },
                        children: "0".repeat(3 - Math.floor(speed).toString().length)
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "tspan",
                      {
                        className: "fill-[#ffffff]",
                        style: {
                          fontFamily: font
                        },
                        children: getSpeedValue()
                      }
                    )
                  ]
                }
              ),
              type === VehicleType.AIR && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "490",
                    y: "90",
                    width: "1000",
                    height: "120",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[2vh]", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "material-symbols:altitude", className: "text-[#ffffff] text-[6vh]" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "span",
                        {
                          className: "text-[6vh] font-medium tracking-[4px] text-[#ffffff] mt-[.5vh]",
                          style: {
                            fontFamily: font
                          },
                          children: [
                            altitude,
                            " ft"
                          ]
                        }
                      )
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "905",
                    y: "100",
                    width: "220",
                    height: "305",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-full", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-[20%] top-0 w-[.2vh] h-full bg-white", children: [...Array(10)].map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "absolute left-0 w-[1vh] h-[.2vh] bg-white",
                          style: {
                            top: `${index * 11}%`,
                            transform: "translateX(-100%)"
                          }
                        },
                        `left-marker-${index}`
                      )) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-[20%] top-0 w-[.2vh] h-full bg-white", children: [...Array(10)].map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "absolute right-0 w-[1vh] h-[.2vh] bg-white",
                          style: {
                            top: `${index * 11}%`,
                            transform: "translateX(100%)"
                          }
                        },
                        `right-marker-${index}`
                      )) })
                    ] })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "968",
                    y: "320",
                    width: "220",
                    height: "220",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "ri:plane-fill", className: "text-[#ffffff] text-[10vh]" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "160",
                    y: "195",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar.png", className: "w-full h-full" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "160",
                    y: "325",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar2.png", className: "w-full h-full" })
                  }
                )
              ] }),
              type === VehicleType.BOAT && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "772",
                    y: "228",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Icon$1,
                      {
                        icon: themeIcons?.vehicle.boatWheel,
                        className: "text-[#ffffff] text-[8.5vh] animate-spin-slow"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "160",
                    y: "195",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar4.png", className: "w-full h-full" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "160",
                    y: "325",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar3.png", className: "w-full h-full" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "895",
                    y: "210",
                    width: "120",
                    height: "120",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar5.png", className: "w-full h-full" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "1008",
                    y: "310",
                    width: "95",
                    height: "95",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar6.png", className: "w-full h-full" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "1045",
                    y: "215",
                    width: "72",
                    height: "72",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar7.png", className: "w-full h-full" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "text",
                {
                  x: "815",
                  y: "340",
                  textAnchor: "middle",
                  dominantBaseline: "middle",
                  className: "text-[50px] font-medium tracking-[4px] fill-[#ffffff]",
                  style: {
                    fontFamily: font
                  },
                  children: getSpeedUnit()
                }
              ),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "left-indicator", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    d: "M291.2 247.4H263.2V269.6H291.2V247.4Z",
                    fill: getIndicatorsStyle({ type: "left", value: indicators }).fill,
                    animate: { opacity: getIndicatorsStyle({ type: "left", value: indicators }).opacity },
                    transition: { duration: 0.2 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    fillRule: "evenodd",
                    clipRule: "evenodd",
                    d: "M267.4 280.5L243.3 258.5L267.4 236.5V280.5Z",
                    fill: getIndicatorsStyle({ type: "left", value: indicators }).fill,
                    animate: { opacity: getIndicatorsStyle({ type: "left", value: indicators }).opacity },
                    transition: { duration: 0.2 }
                  }
                )
              ] }),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "514",
                  y: "100",
                  width: "100",
                  height: "100",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    HazardsIndicator,
                    {
                      indicatorsStyle: getIndicatorsStyle({ type: "hazards", value: indicators }),
                      themeIcons
                    }
                  )
                }
              ),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "right-indicator", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    d: "M822.3 247.4H794.3V269.6H822.3V247.4Z",
                    fill: getIndicatorsStyle({ type: "right", value: indicators }).fill,
                    animate: { opacity: getIndicatorsStyle({ type: "right", value: indicators }).opacity },
                    transition: { duration: 0.2 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    fillRule: "evenodd",
                    clipRule: "evenodd",
                    d: "M818.2 280.5L842.3 258.5L818.2 236.5V280.5Z",
                    fill: getIndicatorsStyle({ type: "right", value: indicators }).fill,
                    animate: { opacity: getIndicatorsStyle({ type: "right", value: indicators }).opacity },
                    transition: { duration: 0.2 }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "305",
                  y: "383",
                  width: "292",
                  height: "25",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    EngineBar,
                    {
                      engineHealth,
                      themeIcons
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  fill: "none",
                  fillRule: "evenodd",
                  clipRule: "evenodd",
                  d: "M602.3 379H610.2C611.2 379 611.9 379.8 611.9 380.7V386.7C611.9 387.7 611.1 388.4 610.2 388.4H602.3C601.3 388.4 600.6 387.6 600.6 386.7V380.7C600.6 379.8 601.4 379 602.3 379ZM613.9 389.5C618.8 390.6 614.2 399.3 617.3 402.6C619.5 405 623.6 404 624.6 401C625.2 399.4 624.9 397.7 624.5 396.1C624.1 394.5 623.7 393.1 623.5 391.4C623.3 390 623.3 387.2 623 386.2C623.8 385 624.6 385.5 623.6 383.5C622.4 381 620 377.7 617.2 377L616.6 378.4C617.2 378.7 617.7 379.1 618.2 379.5L617.5 381L620.2 386.3H621.4C621.7 388.7 621.7 391.2 622.2 393.5C622.5 395.1 623.4 397.7 623.3 399.3C623.3 401.3 621.8 402.9 619.6 402.4C617.5 401.9 617.7 399.7 617.7 397.5C617.7 392.6 618.6 388.9 613.8 388V379.8C613.8 378.2 612.5 377 611 377H601.6C600 377 598.8 378.3 598.8 379.8V404.7H597.8C597.3 404.7 596.8 405.1 596.8 405.7V406.4C596.8 406.9 597.2 407.4 597.8 407.4H614.8C615.3 407.4 615.8 407 615.8 406.4V405.7C615.8 405.2 615.4 404.7 614.8 404.7H613.8V389.5H613.9Z",
                  className: "fill-[#ffffff]"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "foreignObject",
                {
                  x: "643",
                  y: "383",
                  width: "25%",
                  height: "5%",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FuelBar,
                    {
                      fuelLevel
                    }
                  )
                }
              ),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "foreignObject",
                  {
                    x: "972",
                    y: "150",
                    width: "15%",
                    height: "15%",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SeatbeltIndicator,
                      {
                        seatbelt,
                        isHarness,
                        themeIcons
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("foreignObject", { x: "972", y: "250", width: "15%", height: "15%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HeadlightIndicator,
                  {
                    headlights,
                    themeIcons
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("foreignObject", { x: "972", y: "350", width: "15%", height: "15%", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HandBrakeIndicator,
                  {
                    handBrake,
                    themeIcons
                  }
                ) })
              ] })
            ]
          }
        ),
        type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `
              absolute 
              top-[5vh] 
              left-1/2 
              -translate-x-1/2 
              bg-[#1d1d1dfa]
              flex items-center justify-center
              w-[12vw]
              h-[4.25vh]
              rounded-[5vh_5vh_0_0]
              pt-[.5vh]
            `,
            children: cruiseControlDisplay(cruiseControl, maxSpeedForCruise, themeIcons, defaultBaseStyle)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: `
            absolute 
            top-[5vh] 
            -right-[3.15vw] 
            -translate-x-1/2
          `,
            initial: {
              opacity: 0
            },
            animate: {
              opacity: nos.toggle && type === VehicleType.CAR ? 1 : 0
            },
            exit: {
              opacity: 0
            },
            transition: { duration: 0.3 },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              NOSDisplay,
              {
                value: nos.value ?? 0,
                themeIcons
              }
            )
          }
        )
      ] })
    }
  );
}

function RetroSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = Hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    altitude = 0,
    handBrake = false,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const [prevGear, setPrevGear] = reactExports.useState(currentGear ?? 0);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const config = useConfigStore((state) => state.config);
  const retroBaseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, retroBaseStyle.font?.[SpeedometerThemes.RETRO]?.type);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear ?? 0);
      }, 300);
    }
  }, [currentGear, prevGear]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if ((fuelLevel ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if ((engineHealth ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (indicators > 0) {
        setIsBlinking((prev) => !prev);
      } else {
        setIsBlinking(false);
      }
    }, 500);
    return () => clearInterval(interval);
  }, [indicators]);
  const getIndicatorImage = (type2) => {
    const isLeft = indicators === 1 || indicators === 3;
    const isRight = indicators === 2 || indicators === 3;
    if (type2 === "left") {
      return isLeft ? "nui://envi-hud/web/build/images/retro-left-active-arrow-icon.png" : "nui://envi-hud/web/build/images/retro-left-arrow-icon.png";
    } else {
      return isRight ? "nui://envi-hud/web/build/images/retro-right-active-arrow-icon.png" : "nui://envi-hud/web/build/images/retro-right-arrow-icon.png";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    nos?.toggle && type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[1.3vh] h-[2.3vh]", viewBox: "0 0 16 26", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.3639 17.0041L11.5925 13.3444L3.63689 17.935H7.6361L4.49938 21.5318L12.3642 17.0041H8.3639ZM16 9V24.4192C16 24.481 15.7536 24.9227 15.6867 25.0113C15.2639 25.5797 14.4222 25.8948 13.5044 25.9411C9.87587 26.1265 5.90276 25.8032 2.23768 25.9319C1.34491 25.9226 0 25.072 0 24.481V9H16Z", fill: "#FFD966" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.45418 2.15383V5.83932H13.2255C13.3935 5.83932 14.2025 6.03546 14.3904 6.10506C15.3006 6.43828 16.0553 7.2745 15.9968 8H0.00243108C-0.0476721 7.25763 0.682999 6.44355 1.60886 6.10506C1.79779 6.03546 2.60675 5.83932 2.77481 5.83932H6.54611V2.15383H3.5013C3.10883 2.15383 2.47941 1.76788 2.3197 1.51902C1.94602 0.93693 2.37085 0.326371 3.19964 0.0996528C6.13172 0.143942 9.41243 -0.105975 12.3205 0.0543089C13.5251 0.120743 14.263 0.95591 13.5438 1.67825C13.3768 1.84591 12.7735 2.15383 12.499 2.15383H9.45418Z", fill: "#FFD966" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-[24.8vh] h-[.7vh] rounded-[.25vh] bg-[#F5F3DC]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "absolute left-0 w-1/2 h-full rounded-[.25vh] bg-[#74B7D1]",
          initial: { width: 0 },
          animate: { width: `${nos.value}%` },
          transition: { duration: 0.5 }
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center w-[35.5vh] h-[20.1vh] bg-retro-speedometer-bg bg-fullSize bg-fullCenter bg-no-repeat p-[1.185vh_.65vw_1.185vh_.65vw] -mb-[.75vh]", children: [
      type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-[4.05vh] flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-retro-cc-bg w-[7.156vh] h-full bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center gap-[.3vh] pb-[.35vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: cruiseControl ? "nui://envi-hud/web/build/images/retro-cc-on-icon.png" : "nui://envi-hud/web/build/images/retro-cc-off-icon.png",
              alt: "CC",
              className: "w-[2.3vh] h-[2.15vh]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-[1.3vh] mt-[.5vh] ${cruiseControl ? "text-[#FF6666]" : "text-[#F5F3DC]"}`, children: "·" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: `text-[1.9vh] mt-[.5vh] ${cruiseControl ? "text-[#FF6666]" : "text-[#F5F3DC]"}`,
              style: {
                fontFamily: font
              },
              children: cruiseControl ? "on" : "off"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center h-full gap-[.5vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-bg-4 w-[3.65vh] h-full bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: handBrake ? "nui://envi-hud/web/build/images/retro-hand-brake-on-icon.png" : "nui://envi-hud/web/build/images/retro-hand-brake-off-icon.png",
              alt: "Hand Brake",
              className: "size-[2.35vh]"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-bg-3 w-[3.95vh] h-full bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.img,
            {
              src: indicators === 3 ? "nui://envi-hud/web/build/images/retro-hazards-on-icon.png" : "nui://envi-hud/web/build/images/retro-hazards-off-icon.png",
              alt: "Hazards",
              className: "size-[2.35vh]",
              animate: {
                opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 1
              },
              transition: { duration: 0.3 }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-bg-2 w-[3.65vh] h-full bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: isHarness ? "nui://envi-hud/web/build/images/retro-seat-belt-harness-icon.png" : seatbelt ? "nui://envi-hud/web/build/images/retro-seat-belt-on-icon.png" : "nui://envi-hud/web/build/images/retro-seat-belt-off-icon.png",
              alt: "Seat Belt",
              className: "w-[1.95vh] h-[2.75vh]"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-bg-1 w-[3.65vh] h-full bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: headlights === 2 ? "nui://envi-hud/web/build/images/retro-head-light-high-icon.png" : headlights === 1 ? "nui://envi-hud/web/build/images/retro-head-light-low-icon.png" : "nui://envi-hud/web/build/images/retro-head-light-off-icon.png",
              alt: "Headlight",
              className: "w-[2.75vh] h-[1.95vh]"
            }
          ) })
        ] })
      ] }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-[4.05vh] flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.5vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: "material-symbols:altitude",
              className: "size-[2.1vh]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: "text-[2vh] mt-[.5vh]",
              style: {
                fontFamily: font
              },
              children: [
                altitude,
                " ft."
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.55vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: "nui://envi-hud/web/build/images/radar1.png",
              alt: "Radar",
              className: "size-[4vh]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: "nui://envi-hud/web/build/images/radar8.png",
              alt: "Radar",
              className: "size-[4vh]"
            }
          )
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-[4.05vh] flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar3.png", alt: "Radar", className: "size-[4vh]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar4.png", alt: "Radar", className: "size-[4vh]" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center size-[4vh] border-[.2vh] border-black rounded-full bg-[#74B7D1]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon: themeIcons?.vehicle?.boatWheel2,
            className: "size-[2.75vh] text-[#F5F3DC] animate-spin-slow"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar4.png", alt: "Radar", className: "size-[4vh]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar3.png", alt: "Radar", className: "size-[4vh]" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-[.25vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[9.5vh] -mt-[.75vh]",
            style: {
              fontFamily: font
            },
            children: Math.floor(speed ?? 0)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "text-[3vh] mb-[3.25vh]",
            style: {
              fontFamily: font
            },
            children: config.mph ? "mph" : "km/h"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-[2.237vh] flex items-center justify-between gap-[.75vh] -mt-[2vh]", children: [
        type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: getIndicatorImage("left"),
            alt: "Left Turn Signal",
            className: "w-[2.237vh] h-full",
            animate: {
              opacity: indicators === 1 || indicators === 3 ? isBlinking ? 1 : 0.5 : 1
            },
            transition: { duration: 0.3 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "relative w-full h-[.895vh] rounded-[.35vh] bg-[#74B7D1] overflow-hidden",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute left-0 h-full rounded-[.35vh] bg-[#FF6666]",
                initial: { width: 0 },
                animate: { width: `${rpm ?? 0}%` },
                transition: { duration: 0.5 }
              }
            )
          }
        ),
        type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: getIndicatorImage("right"),
            alt: "Right Turn Signal",
            className: "w-[2.237vh] h-full",
            animate: {
              opacity: indicators === 2 || indicators === 3 ? isBlinking ? 1 : 0.5 : 1
            },
            transition: { duration: 0.3 }
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1.2vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-[1.8vh] h-[1.6vh]", viewBox: "0 0 17 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.31637 1.59157C3.12384 1.67105 2.94763 1.81997 2.92099 2.02059C3.02585 3.04299 2.79034 4.26369 2.92271 5.26139C2.96654 5.59165 3.24589 5.72976 3.59056 5.75831C5.10332 5.88563 6.83011 5.65723 8.36608 5.75909C8.80787 5.74674 8.98923 5.46819 9.03135 5.10321C9.11042 4.40104 9.10355 2.93727 9.03393 2.22893C9.00814 1.96272 8.91359 1.71812 8.62737 1.6016L3.31637 1.59157ZM10.6601 3.82386H11.8532C13.0118 3.82386 13.8945 4.98284 13.9779 5.93733C14.173 8.16963 13.8232 10.6226 13.9831 12.8788C14.0879 13.7886 15.4004 13.6929 15.4305 12.7801L15.4211 5.06C14.9603 4.7853 14.5564 4.61323 14.2555 4.17341C13.9607 3.74284 13.867 3.28064 13.8318 2.77909C13.7372 2.60393 12.4187 2.00902 12.1721 1.7621C11.6254 1.21271 12.2391 0.35235 13.0479 0.610843L16.9914 2.97123L17 12.9359C16.7636 15.5455 12.6405 15.6266 12.4033 12.939C12.2064 10.7075 12.5606 8.25142 12.399 5.99675C12.356 5.82699 12.3096 5.59859 12.1738 5.46819C12.1136 5.41031 11.738 5.23439 11.6787 5.23439H10.6601V12.5709C10.6601 12.6219 10.8862 12.8441 10.9558 12.8804C11.2274 13.02 11.7088 12.902 11.8119 13.3132C11.8549 13.4853 11.8549 14.4236 11.8119 14.5964C11.7474 14.8549 11.493 14.983 11.2137 15L0.573626 14.9946C0.371638 14.9838 0.100028 14.8086 0.0415801 14.6366C-0.014289 14.4753 -0.0134295 13.4336 0.0415801 13.2731C0.211766 12.7731 1.09364 13.1659 1.18045 12.4675L1.21827 0.648651C1.32399 0.255126 1.64889 0.0961723 2.07779 0.0622206C4.53861 -0.135314 7.32261 0.214231 9.81695 0.0637646C10.1195 0.0498753 10.6601 0.397875 10.6601 0.664856V3.82386Z", fill: "#FFD966" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "relative overflow-hidden w-[14.3vh] h-[.5vh] rounded-[.25vh] bg-[#F5F3DC]",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute left-0 h-full rounded-[.25vh]",
                initial: { width: 0 },
                animate: {
                  width: `${fuelLevel ?? 0}%`,
                  backgroundColor: (fuelLevel ?? 0) <= 20 ? "#FF6666" : "#74B7D1",
                  opacity: (fuelLevel ?? 0) <= 20 ? isLowValue.fuelLevel ? 0.5 : 1 : 1
                },
                transition: { duration: 0.5 }
              }
            )
          }
        )
      ] }),
      type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-retro-gear-bg size-[2.7vh] bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center pt-[.35vh] pr-[.15vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: {
            y: isAnimating ? currentGear > prevGear ? -20 : 20 : 0,
            opacity: 0
          },
          animate: {
            y: 0,
            opacity: 1
          },
          exit: {
            y: isAnimating ? currentGear > prevGear ? 20 : -20 : 0,
            opacity: 0
          },
          transition: {
            y: {
              type: "spring",
              stiffness: 500,
              damping: 30,
              mass: 0.8
            },
            opacity: {
              duration: 0.15
            }
          },
          className: "text-[2vh] text-[#FF6666]",
          style: {
            fontFamily: font
          },
          children: currentGear === 0 ? "R" : currentGear
        },
        currentGear
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-[2.1vh] h-[1.6vh]", viewBox: "0 0 24 19", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.9598 7.74143H12.646L10.3313 12.3888C10.2982 12.633 10.3696 12.5173 10.4927 12.5493C11.0007 12.6813 11.5341 12.6684 12.0531 12.6614L10.7628 16.4865L11.1952 16.326L14.8519 11.5682H13.1836C13.1437 11.5682 13.0206 11.4258 12.9152 11.4578C12.9772 11.0263 15.1186 7.88208 14.9598 7.74143ZM0 8.50679C0.0721996 7.64738 1.97997 7.68535 2.39618 8.065C2.45988 8.12195 2.69092 8.53267 2.69092 8.56115V10.5837H3.65925V8.45243C3.65925 8.41015 3.8648 8.12109 3.92596 8.06759C4.38209 7.66723 5.18903 7.92177 5.76068 7.8536C6.72476 7.73712 8.04558 5.34441 9.10055 5.0148L19.5364 5.00617C19.8005 4.94146 20.3408 5.40223 20.3408 5.60931V10.5837H21.3099V8.56115C21.3099 8.49126 21.6964 8.00719 21.7881 7.95456C22.2188 7.70347 23.8522 7.74057 24 8.3972V15.6133C23.8191 16.6064 21.3099 16.4856 21.3099 15.4493V13.4268L20.3408 13.4259C20.2601 13.507 20.4699 14.5856 20.2397 14.7996C18.873 16.2449 17.5793 17.8179 15.9799 19L8.90179 18.9793C7.98358 18.5781 6.66954 16.3899 5.76238 16.2647C5.13976 16.1785 4.51205 16.4848 3.97692 16.0007C3.90557 15.9351 3.65925 15.6107 3.65925 15.5581V13.4268H2.69092V15.4493C2.69092 16.4856 0.180924 16.6064 0 15.6133V8.50679Z", fill: "#FFD966" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.9533 3.9675C14.851 4.07058 12.4485 3.88835 12.0595 3.9675C12.0285 3.71349 12.1573 3.11252 11.9518 2.96803C11.4048 2.58518 9.27359 3.53495 9.05901 2.15263C8.9403 1.39244 8.90469 0.0331316 9.91735 0L17.4963 0.0625818C18.0926 0.333156 18.0972 2.0201 17.8314 2.49591C17.3539 3.35273 15.5322 2.63856 15.061 2.96803C14.8291 3.13093 15.0172 3.90308 14.9533 3.9675Z", fill: "#FFD966" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "relative overflow-hidden w-[14.3vh] h-[.5vh] rounded-[.25vh] bg-[#F5F3DC]",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute left-0 h-full rounded-[.25vh]",
                initial: { width: 0 },
                animate: {
                  width: `${engineHealth ?? 0}%`,
                  backgroundColor: (engineHealth ?? 0) <= 20 ? "#FF6666" : "#74B7D1",
                  opacity: (engineHealth ?? 0) <= 20 ? isLowValue.engineHealth ? 0.5 : 1 : 1
                },
                transition: { duration: 0.5 }
              }
            )
          }
        )
      ] })
    ] })
  ] });
}

function PixelSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const config = useConfigStore((state) => state.config);
  const pixelBaseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, pixelBaseStyle.font?.[SpeedometerThemes.PIXEL]?.type);
  const [shakeOffset, setShakeOffset] = reactExports.useState(0);
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  const [prevGear, setPrevGear] = reactExports.useState(0);
  reactExports.useEffect(() => {
    let interval;
    if (speed > 308) {
      interval = setInterval(() => {
        setShakeOffset(Math.random() * 15 - 5);
      }, 100);
    } else {
      setShakeOffset(0);
    }
    return () => clearInterval(interval);
  }, [speed]);
  reactExports.useEffect(() => {
    let interval;
    if (indicators > 0) {
      interval = setInterval(() => {
        setIsBlinking((prev) => !prev);
      }, 500);
    } else {
      setIsBlinking(false);
    }
    return () => clearInterval(interval);
  }, [indicators]);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear);
      }, 300);
    }
  }, [currentGear, prevGear]);
  const maxSpeed = 308;
  const maxRotation = 180;
  const rotation = Math.min(speed / maxSpeed * maxRotation, maxRotation);
  const getSpeedValue = () => {
    return Math.floor(speed).toString();
  };
  const getSpeedUnit = () => {
    return config.mph ? "mph" : "km/h";
  };
  const getFuelProgress = () => {
    return Math.min(Math.max(fuelLevel, 0), 100);
  };
  const getEngineProgress = () => {
    return Math.min(Math.max(engineHealth, 0), 100);
  };
  const getNitroProgress = () => {
    return Math.min(Math.max(nos.value, 0), 100);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex flex-col items-center gap-[.45vh]", children: [
    type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
            absolute -top-[2.95vh] -right-[.75vh] w-[2.861vh] h-[2.462vh] 
            bg-pixel-status-5 bg-fullSize bg-fullCenter bg-no-repeat 
            flex items-center justify-center
            ${headlights === 2 ? "opacity-100" : headlights === 1 ? "opacity-75" : "opacity-50"}
          `, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-headlights-icon.png", alt: "", className: "w-[1.922vh] h-[1.545vh]" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
            absolute -top-[4.55vh] right-[3.35vh] w-[2.861vh] h-[2.462vh] 
            ${!seatbelt ? "bg-pixel-status-6" : "bg-pixel-status-2"} bg-fullSize bg-fullCenter bg-no-repeat 
            flex items-center justify-center
          `, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: isHarness ? "nui://envi-hud/web/build/images/pixel-harness-icon.png" : seatbelt ? "nui://envi-hud/web/build/images/pixel-seatbelt-on-icon.png" : "nui://envi-hud/web/build/images/pixel-seatbelt-off-icon.png",
          alt: "seatbelt-status",
          className: `w-[1.717vh] ${isHarness ? "h-[1.338vh]" : seatbelt ? "h-[1.138vh]" : "size-[1.25vh]"}`
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute -top-[8.75vh] left-1/2 -translate-x-1/2 flex flex-col items-center gap-[.1vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-[1.4vh] uppercase text-[#FFFDE9]", style: {
          ...ShadowStyle,
          fontFamily: font
        }, children: cruiseControl ? "on" : "off" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-cc-icon.png", alt: "", className: "w-[3.918vh] h-[2.604vh]" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-[1.53vh] uppercase text-[#FFFDE9]", style: {
          ...ShadowStyle,
          fontFamily: font
        }, children: [
          maxSpeedForCruise ?? 0,
          " ",
          getSpeedUnit()
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
            absolute -top-[2.95vh] -left-[.5vh] w-[2.861vh] h-[2.462vh] 
            bg-pixel-status-3 bg-fullSize bg-fullCenter bg-no-repeat 
            flex items-center justify-center
            ${handBrake ? "opacity-100" : "opacity-50"}
          `, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-handbrake-icon.png", alt: "", className: "w-[1.931vh] h-[1.707vh]" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: `
            absolute -top-[4.55vh] left-[3.5vh] w-[2.861vh] h-[2.462vh] 
            bg-pixel-status-6 bg-fullSize bg-fullCenter bg-no-repeat 
            flex items-center justify-center
          `,
          animate: {
            opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
          },
          transition: { duration: 0.3 },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-hazards-icon.png", alt: "", className: "w-[2.025vh] h-[1.79vh]" })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-[1.35vh] left-1/2 -translate-x-1/2 w-[24.25vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full -scale-x-100", viewBox: "0 0 485 228", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { opacity: "0.33", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-1", d: "M485 192H473V225H485V192Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-2", d: "M473 149H461V193H473V149Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-3", d: "M461 127H449V149H461V127Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-4", d: "M449 105V127H437V118H425V96H437V105H449Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-5", d: "M425 84H413V96H425V84Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-6", d: "M413 72H401V84H413V72Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-7", d: "M401 60H389V72H401V60Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-8", d: "M389 48V60H364V48H352V36H377V48H389Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-9", d: "M352 24H327V36H352V24Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-10", d: "M327 12H278V24H327V12Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-11", d: "M278 0H204V12H278V0Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-12", d: "M204 12H155V24H204V12Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-13", d: "M155 24H131V36H155V24Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-14", d: "M131 36V48H120V60H96V48H107V36H131Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-15", d: "M96 60H84V72H96V60Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-16", d: "M84 72H72V84H84V72Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-17", d: "M72 84H60V96H72V84Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-18", d: "M60 96V118H48V129H36V107H48V96H60Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-19", d: "M36 129H24V151H36V129Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-20", d: "M24 151H12V194H24V151Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-21", d: "M12 194H0V228H12V194Z", fill: "#FFFDE9" })
      ] }),
      Array.from({ length: Math.ceil(rpm / 100 * 21) }).map((_, i) => {
        const trackNumber = i + 1;
        const trackColor = trackNumber >= 19 ? "#F97878" : trackNumber >= 16 ? "#FFAC99" : trackNumber >= 13 ? "#FFCC99" : trackNumber >= 10 ? "#FFF599" : trackNumber >= 4 ? "#E1FF99" : "#97FF99";
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "path",
          {
            d: document.getElementById(`rpm-track-${trackNumber}`)?.getAttribute("d") || "",
            fill: trackColor
          },
          `rpm-fill-${trackNumber}`
        );
      })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[21.3vh] h-[19vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "w-full h-full", viewBox: "0 0 193 170", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M110.889 169.579H106.096V165.342H110.889V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M106.096 169.579H101.302V165.342H106.096V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M101.302 169.579H96.509V165.342H101.302V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M96.508 169.579H91.7141V165.342H96.508V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M91.714 169.579H86.921V165.342H91.714V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M86.921 169.579H82.1271V165.342H86.921V169.579Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 97.552H187.593V93.315H192.386V97.552Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 93.315H187.593V89.079H192.386V93.315Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 97.552H0.582031V93.315H5.37503V97.552Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 89.078H187.593V84.841H192.386V89.078Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 93.315H0.582031V89.079H5.37503V93.315Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 80.605H187.593V76.368H192.386V80.605Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 84.841H187.593V79.621H192.386V84.841Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 89.078H0.582031V84.841H5.37503V89.078Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 84.841H0.582031V80.605H5.37503V84.841Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M192.386 76.368H187.593V72.132H192.386V76.368Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 80.605H0.582031V76.368H5.37503V80.605Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.37503 76.368H0.582031V72.132H5.37503V76.368Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M110.889 4.34H106.096V0.104004H110.889V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M106.096 4.34H101.302V0.104004H106.096V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M101.302 4.34H96.509V0.104004H101.302V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M96.508 4.34H91.7141V0.104004H96.508V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M91.714 4.34H86.921V0.104004H91.714V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M86.921 4.34H82.1271V0.104004H86.921V4.34Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M182.798 55.183H178.005V50.947H182.798V55.183Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M182.798 50.947H178.005V46.71H182.798V50.947Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M178.005 42.473H173.211V38.236H178.005V42.473Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M178.005 46.709H173.211V42.473H178.005V46.709Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M173.211 42.473H168.417V38.236H173.211V42.473Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M173.211 38.236H168.417V33.999H173.211V38.236Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M168.417 33.999H163.624V29.763H168.417V33.999Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M163.623 29.762H158.829V25.525H163.623V29.762Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M158.829 25.525H154.036V21.289H158.829V25.525Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M154.035 21.288H149.241V17.051H154.035V21.288Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M149.241 21.288H144.447V17.051H149.241V21.288Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M149.241 17.051H144.447V12.814H149.241V17.051Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M144.447 17.051H139.654V12.814H144.447V17.051Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 67.894H182.799V63.657H187.593V67.894Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 63.657H182.799V59.421H187.593V63.657Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 59.42H182.799V55.183H187.593V59.42Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 72.131H182.799V67.894H187.593V72.131Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 114.499H182.799V110.263H187.593V114.499Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 106.026H182.799V101.79H187.593V106.026Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 101.789H182.799V97.552H187.593V101.789Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 110.263H182.799V106.026H187.593V110.263Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M182.798 122.973H178.005V118.737H182.798V122.973Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M182.798 118.737H178.005V114.5H182.798V118.737Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M178.005 131.447H173.211V127.21H178.005V131.447Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M178.005 127.21H173.211V122.973H178.005V127.21Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M173.211 131.447H168.417V127.21H173.211V131.447Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M173.211 135.684H168.417V131.448H173.211V135.684Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M168.417 139.921H163.624V135.684H168.417V139.921Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M163.623 144.158H158.829V139.922H163.623V144.158Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M158.829 148.395H154.036V144.158H158.829V148.395Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M154.035 152.631H149.241V148.395H154.035V152.631Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M149.241 152.631H144.447V148.395H149.241V152.631Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M149.241 156.868H144.447V152.631H149.241V156.868Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M144.447 156.868H139.654V152.631H144.447V156.868Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M139.653 161.106H134.859V156.869H139.653V161.106Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M134.859 161.106H130.066V156.869H134.859V161.106Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M130.066 165.342H125.272V161.106H130.066V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M125.271 165.342H120.478V161.106H125.271V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M120.478 165.342H115.684V161.106H120.478V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M115.684 165.342H110.89V161.106H115.684V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M82.126 165.342H77.332V161.106H82.126V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M77.332 165.342H72.5391V161.106H77.332V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M72.539 165.342H67.745V161.106H72.539V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M67.7441 165.342H62.951V161.106H67.7441V165.342Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M62.951 161.106H58.108V156.869H62.951V161.106Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58.108 161.106H53.3151V156.869H58.108V161.106Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M53.315 156.868H48.521V152.631H53.315V156.868Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M48.5211 156.868H43.7271V152.631H48.5211V156.868Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M48.5201 152.631H43.7271V148.395H48.5201V152.631Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M43.727 152.631H38.9331V148.395H43.727V152.631Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M38.933 148.395H34.14V144.158H38.933V148.395Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M34.139 144.158H29.3451V139.922H34.139V144.158Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M29.345 139.921H24.551V135.684H29.345V139.921Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.5511 135.684H19.7581V131.448H24.5511V135.684Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.5511 131.447H19.7581V127.21H24.5511V131.447Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.757 131.447H14.963V127.21H19.757V131.447Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.757 127.21H14.963V122.973H19.757V127.21Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.963 118.737H10.17V114.5H14.963V118.737Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.963 122.973H10.17V118.737H14.963V122.973Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 114.499H5.375V110.263H10.169V114.499Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 110.263H5.375V106.026H10.169V110.263Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 106.026H5.375V101.79H10.169V106.026Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 101.789H5.375V97.552H10.169V101.789Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M139.653 12.814H134.859V8.578H139.653V12.814Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M134.859 12.814H130.066V8.578H134.859V12.814Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M130.066 8.578H125.272V4.341H130.066V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M125.271 8.578H120.478V4.341H125.271V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M120.478 8.578H115.684V4.341H120.478V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M115.684 8.578H110.89V4.341H115.684V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M82.126 8.578H77.332V4.341H82.126V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M77.332 8.578H72.5391V4.341H77.332V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M72.539 8.578H67.745V4.341H72.539V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M67.7441 8.578H62.951V4.341H67.7441V8.578Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M62.951 12.814H58.108V8.578H62.951V12.814Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M58.108 12.814H53.3151V8.578H58.108V12.814Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M53.315 17.051H48.521V12.814H53.315V17.051Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M48.5201 21.288H43.7271V17.051H48.5201V21.288Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M48.5211 17.051H43.7271V12.814H48.5211V17.051Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M43.727 21.288H38.9331V17.051H43.727V21.288Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M38.933 25.525H34.14V21.289H38.933V25.525Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M34.139 29.762H29.3451V25.525H34.139V29.762Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M29.345 33.999H24.551V29.763H29.345V33.999Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.5511 42.473H19.7581V38.236H24.5511V42.473Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.5511 38.236H19.7581V33.999H24.5511V38.236Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.757 46.709H14.963V42.473H19.757V46.709Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.757 42.473H14.963V38.236H19.757V42.473Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.963 55.183H10.17V50.947H14.963V55.183Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.963 50.947H10.17V46.71H14.963V50.947Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 72.131H5.375V67.894H10.169V72.131Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 67.894H5.375V63.657H10.169V67.894Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 63.657H5.375V59.421H10.169V63.657Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.169 59.42H5.375V55.183H10.169V59.42Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.330002", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_133_3)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M187.593 72.1311V97.5521H182.799V114.499H178.005V122.973H173.211V127.21H168.417V135.684H163.623V139.921H158.829V144.157H154.036V148.395H144.447V152.631H139.654V156.868H130.066V161.106H110.89V165.342H82.1268V161.106H62.9508V156.868H53.3148V152.631H48.5198V148.395H38.9328V144.157H34.1388V139.921H29.3448V135.684H24.5508V127.21H19.7568V122.973H14.9628V114.499H10.1698V97.5521H5.37476V72.1311H10.1698V55.1831H14.9628V46.7091H19.7568V42.4731H24.5508V33.9981H29.3448V29.7621H34.1388V25.5251H38.9328V21.2881H48.5198V17.0511H53.3148V12.8141H62.9508V8.57709H82.1268V4.34009H110.89V8.57709H130.066V12.8141H139.654V17.0511H144.447V21.2881H154.036V25.5251H158.829V29.7621H163.623V33.9981H168.417V42.4731H173.211V46.7091H178.005V55.1831H182.799V72.1311H187.593Z", fill: "#FFFDE9" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.g,
          {
            initial: { rotate: 0 },
            animate: {
              rotate: rotation + shakeOffset
            },
            transition: {
              type: "spring",
              stiffness: 100,
              damping: 15,
              mass: 0.8
            },
            style: {
              originX: "96.5px",
              originY: "85px"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                d: "M67.7985 94.1757L71.4075 91.6167L68.8455 88.7937L65.2355 91.3517L67.7985 94.1757L64.1895 96.7347L66.7515 99.5577L70.3615 96.9997L67.7985 94.1757ZM80.6115 108.294L84.2205 105.736L86.7835 108.56L83.1745 111.118L80.6115 108.294L77.0025 110.853L74.4395 108.029L78.0485 105.471L80.6115 108.294ZM93.5325 89.8537L90.9705 87.0297L69.3145 102.382L66.7515 99.5577L63.1425 102.117L65.7055 104.941L62.0955 107.499L64.6585 110.323L68.2675 107.764L70.8305 110.588L74.4395 108.029L71.8775 105.206L93.5325 89.8537Z",
                fill: "#FFFDE9"
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-0", d: "M41.9454 133.845V130.649H38.714V114.243H41.9454V111.012H51.9592V114.243H55.2261V130.649H51.9592V133.845H41.9454ZM42.3005 130.294H51.6041V114.598H42.3005V130.294Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-1", d: "M25.8719 95.4667V76.3883H23.0559V79.5563H19.5007V76.0363H22.7039V72.8331H26.2239V76.0363H29.4623V95.4667H25.8719Z", fill: "#97FF99" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-2", d: "M46.4749 56.8327V53.1085H42.7094V45.1635H46.4749V41.4807H57.7303V34.4047H46.8887V38.1289H42.7094V33.9909H46.4749V30.2253H58.1441V33.9909H61.9511V41.8531H58.1441V45.5773H46.8887V52.6947H57.7303V48.9291H61.9511V53.1085H58.1441V56.8327H46.4749Z", fill: "#E1FF99" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-3", d: "M89.9128 35.9197V32.7238H86.6814V29.1372H90.2679V32.3687H99.5715V26.2609H89.9128V22.7454H99.5715V16.6732H90.2679V19.8691H86.6814V16.3181H89.9128V13.0867H99.9266V16.3181H103.194V23.065H99.9266V25.9058H103.194V32.7238H99.9266V35.9197H89.9128Z", fill: "#FFF599" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-4", d: "M142.678 56.8681V50.4408H129.788V43.6939H133.019V40.4625H136.215V37.2666H139.482V34.0352H146.3V56.8681H142.678ZM133.374 46.8543H142.678V37.6217H139.837V40.8176H136.57V44.0135H133.374V46.8543Z", fill: "#FFCC99" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-5", d: "M159.373 95.6759V92.48H156.142V88.8935H159.728V92.1249H169.032V89.2486H162.569V86.0172H159.373V82.8213H156.142V76.0744H159.373V72.843H169.387V76.0744H172.654V82.8213H169.032V76.4295H159.728V82.5017H162.924V85.6621H169.387V88.8935H172.654V92.48H169.387V95.6759H159.373Z", fill: "#FFAC99" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "number-6", d: "M140.25 133.383V130.187H137.019V113.782H140.25V110.55H150.264V113.782H153.531V117.333H149.909V114.137H140.606V120.209H150.264V123.369H153.531V130.187H150.264V133.383H140.25ZM140.606 129.832H149.909V123.724H140.606V129.832Z", fill: "#F97878" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M83.483 89.795H86.902V74.685H83.483V89.795ZM90.322 71.662H86.902V74.685H90.322V71.662ZM86.902 92.818H90.322V89.795H86.902V92.818ZM107.419 68.64H90.3219V71.662H107.419V68.64ZM90.322 95.84H107.419V92.818H90.322V95.84ZM110.839 71.662H107.419V74.685H110.839V71.662ZM107.419 92.818H110.839V89.795H107.419V92.818ZM110.839 89.795H114.258V74.685H110.839V89.795Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M110.839 74.6848V89.7948H107.419V92.8178H90.3221V89.7948H86.9021V74.6848H90.3221V71.6618H107.419V74.6848H110.839Z", fill: "#FFFDE9" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_133_3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "182.21", height: "161", fill: "white", transform: "translate(5.38 4.34003)" }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute bottom-[4.75vh] left-1/2 -translate-x-1/2 text-[#FFFDE9] text-[1.6vh]",
          style: {
            fontFamily: font
          },
          children: getSpeedUnit()
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
        absolute left-1/2 -translate-x-1/2 flex items-center gap-[1.35vh]
        ${type === VehicleType.CAR ? "bottom-[3.5vh]" : type === VehicleType.AIR ? "bottom-[3.25vh]" : "bottom-[2.95vh]"}
        `, children: type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: "nui://envi-hud/web/build/images/pixel-left-indicator-icon.png",
            className: "w-[1.947vh] h-[1.516vh]",
            animate: { opacity: (indicators === 1 || indicators === 3) && isBlinking ? 1 : 0.3 },
            transition: { duration: 0.2 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: "nui://envi-hud/web/build/images/pixel-right-indicator-icon.png",
            className: "w-[1.947vh] h-[1.516vh]",
            animate: { opacity: (indicators === 2 || indicators === 3) && isBlinking ? 1 : 0.3 },
            transition: { duration: 0.2 }
          }
        )
      ] }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "span",
        {
          className: "text-[#FFFDE9] text-[1.3vh]",
          style: {
            fontFamily: font
          },
          children: [
            altitude,
            " ft."
          ]
        }
      ) : type === VehicleType.BOAT ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "size-[2vh] border-[.1vh] border-[#FFFDE9] rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon: themeIcons?.vehicle?.boatWheel,
          className: "size-[1.3vh] text-[#FFFDE9] animate-spin-slow"
        }
      ) }) : null }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `
          absolute left-1/2 -translate-x-1/2 text-[1.6vh]
          ${type === VehicleType.CAR || type === VehicleType.AIR ? "bottom-[1.35vh]" : "bottom-[.75vh]"}
        `,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[#FFFDE980]",
                style: {
                  fontFamily: font
                },
                children: "0".repeat(3 - getSpeedValue().length)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[#FFFDE9]",
                style: {
                  fontFamily: font
                },
                children: getSpeedValue()
              }
            )
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          absolute -left-[3vh] w-[2.778vh] h-[9.5vh] flex flex-col items-center gap-[.32vh]
          ${type === VehicleType.CAR ? "bottom-[2.5vh]" : "-bottom-[1.35vh]"}
        `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 29 175", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.3009 174.75H4.46094V169.48H24.3009V174.75Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M28.2708 169.478H24.3008V6.07812H28.2708V169.478Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.330002", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.30273 164.299H20.3267V9.4375H8.30273V164.299Z", fill: "#FFFDE9" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                d: "M8.30273 164.299H20.3267V9.4375H8.30273V164.299Z",
                fill: "#F97878",
                initial: { clipPath: "inset(100% 0 0 0)" },
                animate: {
                  clipPath: `inset(${100 - getFuelProgress()}% 0 0 0)`
                },
                transition: { duration: 0.5 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.46023 169.478H0.490234V6.07812H4.46023V169.478Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.3009 6.07859H4.46094V0.808594H24.3009V6.07859Z", fill: "#FFFDE9" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-fuel-icon.png", alt: "", className: "w-[1.543vh] h-[1.037vh]" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          absolute -right-[3vh] w-[2.778vh] h-[9.5vh] flex flex-col items-center gap-[.32vh]
          ${type === VehicleType.CAR ? "bottom-[2.5vh]" : "-bottom-[1.35vh]"}
        `,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 29 175", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.3009 174.75H4.46094V169.48H24.3009V174.75Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M28.2708 169.478H24.3008V6.07812H28.2708V169.478Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.330002", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.30273 164.299H20.3267V9.4375H8.30273V164.299Z", fill: "#FFFDE9" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                d: "M8.30273 164.299H20.3267V9.4375H8.30273V164.299Z",
                fill: "#F97878",
                initial: { clipPath: "inset(100% 0 0 0)" },
                animate: {
                  clipPath: `inset(${100 - getEngineProgress()}% 0 0 0)`
                },
                transition: { duration: 0.5 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.46023 169.478H0.490234V6.07812H4.46023V169.478Z", fill: "#FFFDE9" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.3009 6.07859H4.46094V0.808594H24.3009V6.07859Z", fill: "#FFFDE9" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-engine-icon.png", alt: "", className: "w-[1.386vh] h-[1.065vh]" })
        ]
      }
    ),
    type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1.5vh]", children: [
      nos?.toggle && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.32vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/pixel-nitrous-icon.png", alt: "", className: "w-[1.547vh] h-[2.463vh]", style: ShadowStyle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[12vh] h-[3.1vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 254 31", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M253.971 26.5098H246.301V5.08984H253.971V26.5098Z", fill: "#FFFDE9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M246.3 30.7917H8.59961V26.5117H246.3V30.7917Z", fill: "#FFFDE9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.330002", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M241.415 9.23828H16.1348V22.2173H241.415V9.23828Z", fill: "#FFFDE9" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M246.3 5.09079H8.59961V0.800781H246.3V5.09079Z", fill: "#FFFDE9" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              d: "M241.415 9.23828H16.1348V22.2173H241.415V9.23828Z",
              fill: "#FFF599",
              initial: { clipPath: "inset(0 100% 0 0)" },
              animate: {
                clipPath: `inset(0 ${100 - getNitroProgress()}% 0 0)`
              },
              transition: { duration: 0.5 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.59945 26.5098H0.939453V5.08984H8.59945V26.5098Z", fill: "#FFFDE9" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-pixel-bg-1 bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center w-[2.661vh] h-[2.262vh] overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: {
            y: isAnimating ? currentGear > prevGear ? -60 : 60 : 0,
            opacity: 0
          },
          animate: {
            y: 0,
            opacity: 1
          },
          exit: {
            y: isAnimating ? currentGear > prevGear ? 60 : -60 : 0,
            opacity: 0
          },
          transition: {
            y: { type: "spring", stiffness: 300, damping: 20 },
            opacity: { duration: 0.05 }
          },
          className: "text-[#FFFDE9] text-[1.6vh]",
          style: {
            fontFamily: font
          },
          children: currentGear === 0 ? "R" : currentGear
        },
        currentGear
      ) }) })
    ] }) })
  ] });
}

function Cyberpunk2Speedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const config = useConfigStore((state) => state.config);
  const baseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font?.[SpeedometerThemes.CYBERPUNK_2]?.type_1);
  const font2 = getFontFamily(defaultBaseStyle.fonts, baseStyle.font?.[SpeedometerThemes.CYBERPUNK_2]?.type_2);
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  const [prevGear, setPrevGear] = reactExports.useState(0);
  reactExports.useEffect(() => {
    let interval;
    if (indicators > 0) {
      interval = setInterval(() => {
        setIsBlinking((prev) => !prev);
      }, 500);
    } else {
      setIsBlinking(false);
    }
    return () => clearInterval(interval);
  }, [indicators]);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear);
      }, 300);
    }
  }, [currentGear, prevGear]);
  const getSpeedValue = () => {
    return Math.floor(speed).toString();
  };
  const getSpeedUnit = () => {
    return config.mph ? "mph" : "km/h";
  };
  const getNitroProgress = () => {
    return Math.min(Math.max(nos.value, 0), 100);
  };
  const getFuelProgress = () => {
    return Math.min(Math.max(fuelLevel, 0), 100);
  };
  const getEngineProgress = () => {
    return Math.min(Math.max(engineHealth, 0), 100);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `h-[17.906vh] bg-cyberpunk2-speedometer-bg bg-fullSize bg-fullCenter bg-no-repeat relative -mr-[.25vh]
          ${type === VehicleType.CAR ? "w-[41.07vh]" : "w-[35.07vh] "}
          `, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-[.25vw] -translate-y-1/2 w-[7vh] h-[14.1vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 18 71", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.7507 0H0.220703V70.126H17.7507V0Z", fill: "#191D22" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-1", d: "M2.55078 69.5352H9.91578V67.3242H2.55078V69.5352Z", fill: "#2B5C13" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-2", d: "M2.55078 67.0899H9.91578V64.8789H2.55078V67.0899Z", fill: "#2B5C13" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-3", d: "M2.55078 64.6446H9.91578V62.4336H2.55078V64.6446Z", fill: "#2B5C13" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-4", d: "M2.55078 62.1993H9.91578V59.9883H2.55078V62.1993Z", fill: "#2B5C13" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-5", d: "M2.55078 59.754H9.91578V57.543H2.55078V59.754Z", fill: "#4F5E12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-6", d: "M2.55078 57.3087H9.91578V55.0977H2.55078V57.3087Z", fill: "#4F5E12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-7", d: "M2.55078 54.8633H9.91578V52.6523H2.55078V54.8633Z", fill: "#4F5E12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-8", d: "M2.55078 52.418H9.91578V50.207H2.55078V52.418Z", fill: "#4F5E12" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-9", d: "M2.50977 49.9727H9.87477V47.7617H2.50977V49.9727Z", fill: "#5F4B11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-10", d: "M2.50977 47.5235H9.87477V45.3125H2.50977V47.5235Z", fill: "#5F4B11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-11", d: "M2.50977 45.0782H9.87477V42.8672H2.50977V45.0782Z", fill: "#5F4B11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-12", d: "M2.50977 42.6329H9.87477V40.4219H2.50977V42.6329Z", fill: "#5F4B11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-13", d: "M2.50977 40.1876H9.87477V37.9766H2.50977V40.1876Z", fill: "#613A11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-14", d: "M2.50977 37.7422H9.87477V35.5312H2.50977V37.7422Z", fill: "#613A11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-15", d: "M2.50977 35.336H9.87477V33.125H2.50977V35.336Z", fill: "#613A11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-16", d: "M2.50977 32.9258H9.87477V30.7148H2.50977V32.9258Z", fill: "#613A11" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-17", d: "M2.50977 30.5196H9.87477V28.3086H2.50977V30.5196Z", fill: "#612D10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-18", d: "M2.50977 28.1094H9.87477V25.8984H2.50977V28.1094Z", fill: "#612D10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-19", d: "M2.50977 25.7032H9.87477V23.4922H2.50977V25.7032Z", fill: "#612D10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-20", d: "M2.50977 23.2969H9.87477V21.0859H2.50977V23.2969Z", fill: "#612D10" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-21", d: "M2.50977 20.8868H9.87477V18.6758H2.50977V20.8868Z", fill: "#61130F" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-22", d: "M2.50977 18.4844H9.87477V16.2734H2.50977V18.4844Z", fill: "#61130F" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-23", d: "M2.50977 16.0821H9.87477V13.8711H2.50977V16.0821Z", fill: "#61130F" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-24", d: "M2.50977 13.6212H9.87477V11.4102H2.50977V13.6212Z", fill: "#61130F" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-25", d: "M2.50977 11.1641H9.87477V8.95312H2.50977V11.1641Z", fill: "#400200" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-26", d: "M2.50977 8.76178H9.87477V6.55078H2.50977V8.76178Z", fill: "#400200" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-27", d: "M2.50977 6.30475H9.87477V4.09375H2.50977V6.30475Z", fill: "#400200" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track-28", d: "M2.50977 3.84772H9.87477V1.63672H2.50977V3.84772Z", fill: "#400200" }),
          Array.from({ length: Math.ceil(rpm / 100 * 28) }).map((_, i) => {
            const trackNumber = i + 1;
            const trackColor = trackNumber >= 28 ? "#9B0400" : trackNumber >= 24 ? "#ED2E24" : trackNumber >= 20 ? "#EA6B26" : trackNumber >= 16 ? "#E88C28" : trackNumber >= 12 ? "#E5B429" : trackNumber >= 5 ? "#BFE22B" : "#6AE02D";
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                id: `rpm-track-${trackNumber}`,
                d: document.getElementById(`rpm-track-${trackNumber}`)?.getAttribute("d") || "",
                fill: trackColor
              },
              `rpm-track-${trackNumber}`
            );
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.8926 17.2114V14.9727H14.9629V15.8682H12.916V16.3159H14.5151L14.9629 16.7637V18.1069L14.5151 18.5547H12.3403L11.8926 18.1069V17.6592H13.9395V17.2114H11.8926Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.7803 7.15942V7.63623H13.8701V7.15942H12.7803ZM11.6904 5.2522L12.1645 4.77539H14.96V5.729H12.7803V6.20581H14.4832L14.96 6.68262V8.11304L14.4832 8.58984H12.1672L11.6904 8.11304V5.2522Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.9941 25.8027V24.0117H15.0176V27.5912H13.9941V26.6982H11.9473V24.0117H12.9707V25.8027H13.9941Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9707 35.3638V34.4683L14.25 34.4657V34.0205H12.2031V33.125H14.8257L15.2734 33.5728V34.6602L15.0176 34.916L15.2734 35.1719V36.2567L14.8257 36.7045L12.2031 36.707V35.8115L14.25 35.809V35.3638H12.9707Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.1973 44.8589V44.4111H12.1504V43.9634L12.5981 43.5156H14.7729L15.2207 43.9634V45.3066L14.7729 45.7544H13.1738V46.2021H15.2207V47.0977H12.1504V45.3066L12.5981 44.8589H14.1973Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.3984 53.3086V56.8906H13.375V54.2041H12.8658V53.3086H14.3984Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.2734 65.4887H15.276L15.2734 66.4481L14.8257 66.8959L12.6509 66.8984L12.2031 66.4507V63.7642L12.6483 63.3164H14.8257L15.2734 63.7642V65.4887ZM14.25 64.2119H13.2266V66.0029L14.25 66.0004V64.2119Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.47255 69.5328H1.16355C1.10655 69.5328 1.06055 69.4868 1.06055 69.4298V1.73581C1.06055 1.67881 1.10655 1.63281 1.16355 1.63281H1.47255C1.52955 1.63281 1.57555 1.67881 1.57555 1.73581V69.4298C1.57555 69.4868 1.52955 69.5328 1.47255 69.5328Z", fill: "#121416" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: "rpm-track", d: "M1.47255 69.5328H1.16355C1.10655 69.5328 1.06055 69.4868 1.06055 69.4298V1.73581C1.06055 1.67881 1.10655 1.63281 1.16355 1.63281H1.47255C1.52955 1.63281 1.57555 1.67881 1.57555 1.73581V69.4298C1.57555 69.4868 1.52955 69.5328 1.47255 69.5328Z", fill: "#ECECEC" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `absolute -translate-x-1/2 -translate-y-1/2 flex items-center gap-[1.15vh]
            ${type === VehicleType.CAR ? "left-[47%]" : "left-[52%]"}
            ${type === VehicleType.BOAT ? "top-[47%]" : "top-1/2"}
            `, children: [
          type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.img,
            {
              src: "nui://envi-hud/web/build/images/cyberpunk2-left-indicator-icon.png",
              alt: "",
              className: "w-[2.5vh] h-[2vh]",
              animate: {
                opacity: (indicators === 1 || indicators === 3) && isBlinking ? 1 : 0.3
              },
              transition: { duration: 0.2 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-[7vh]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[#ecececb6]",
                style: {
                  fontFamily: font
                },
                children: "0".repeat(3 - getSpeedValue().length)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[#ECECEC]",
                style: {
                  fontFamily: font
                },
                children: getSpeedValue()
              }
            )
          ] }),
          type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.img,
            {
              src: "nui://envi-hud/web/build/images/cyberpunk2-right-indicator-icon.png",
              alt: "",
              className: "w-[2.5vh] h-[2vh]",
              animate: {
                opacity: (indicators === 2 || indicators === 3) && isBlinking ? 1 : 0.3
              },
              transition: { duration: 0.2 }
            }
          )
        ] }),
        type === VehicleType.AIR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-[2.95vh] left-[4.75vw] flex items-center gap-[.5vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: "material-symbols:altitude",
              className: "text-white text-[2vh]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: "text-[#ECECEC] text-[2vh] mt-[.5vh]",
              style: {
                fontFamily: font2
              },
              children: [
                altitude,
                " ft."
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `
            absolute bottom-[3.15vh] text-[2vh] text-[#ECECEC] uppercase
            ${type === VehicleType.CAR ? "right-[6.3vw]" : type === VehicleType.AIR ? "right-[3.5vw]" : "left-[6.3vw]"}
          `,
            style: {
              fontFamily: font2
            },
            children: getSpeedUnit()
          }
        ),
        type === VehicleType.BOAT && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "\r\n              absolute bottom-[3.55vh] right-[5.4vw]\r\n              size-[2.35vh] border-[.15vh] border-white rounded-full flex items-center justify-center\r\n            ",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: themeIcons?.vehicle?.boatWheel,
                className: "text-white text-[1.35vh] animate-spin-slow"
              }
            )
          }
        ),
        type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[3vh] right-[6vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[3.2vh] h-[3.1vh] bg-[#191D22] rounded-[0_.5vh_0_.5vh] flex items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 size-[2.7vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 11 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3585 9.27522H0.5625V3.44922", stroke: "#737373", strokeWidth: "0.25" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.5625 0.363281H10.6885V5.66928", stroke: "#737373", strokeWidth: "0.25" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.svg,
              {
                id: "handbrake",
                className: "size-[2vh]",
                viewBox: "0 0 8 7",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                animate: {
                  opacity: handBrake ? 1 : 0.3
                },
                transition: { duration: 0.2 },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.93035 1.11843C2.22735 1.21543 1.21435 3.12543 2.07635 4.60443C2.92435 6.05943 4.99035 6.16143 5.97435 4.79143C7.12435 3.19143 5.88335 1.00743 3.93035 1.11843ZM3.91535 0.57843C6.22535 0.45743 7.74835 2.96843 6.51935 4.94943C5.36735 6.80443 2.63635 6.73243 1.58035 4.82343C0.564346 2.98743 1.82835 0.68743 3.91535 0.57843Z", fill: "#ED2E24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.96636 4.69673C4.02736 4.68773 4.19336 4.68873 4.24736 4.71073C4.29936 4.73273 4.33936 4.78273 4.35836 4.83373C4.38736 4.91073 4.38836 5.18073 4.35836 5.25673C4.29836 5.41373 4.13936 5.40773 3.99336 5.39573C3.88936 5.38773 3.80436 5.30773 3.79336 5.20273C3.78536 5.13473 3.78436 4.94073 3.79436 4.87573C3.80736 4.79573 3.88436 4.70873 3.96636 4.69673Z", fill: "#ED2E24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.391 0.323067C6.55 0.301067 6.657 0.415067 6.765 0.514067C8.411 2.02907 8.412 4.84307 6.769 6.36007C6.717 6.40807 6.61 6.50707 6.549 6.53407C6.328 6.63007 6.11 6.42907 6.179 6.20107C6.21 6.09707 6.299 6.05907 6.371 5.99107C7.829 4.62807 7.826 2.25707 6.375 0.890067C6.3 0.820067 6.208 0.778067 6.177 0.671067C6.133 0.518067 6.228 0.345067 6.391 0.323067Z", fill: "#ED2E24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.97397 1.48511C4.03597 1.47711 4.19597 1.47711 4.25097 1.50411C4.31897 1.53711 4.36297 1.62511 4.36997 1.69911V4.22511C4.34397 4.44611 4.15297 4.45111 3.97197 4.43311C3.86797 4.42311 3.80697 4.32911 3.79297 4.23211V1.68411C3.80497 1.58711 3.87397 1.49811 3.97397 1.48511Z", fill: "#ED2E24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.68996 0.323615C1.89496 0.293615 2.05196 0.472615 1.99596 0.673615C1.96696 0.778615 1.85496 0.838615 1.77896 0.909615C0.357965 2.24361 0.356964 4.63661 1.77896 5.96961C1.85396 6.04062 1.96196 6.09661 1.99396 6.20061C2.05996 6.41161 1.87596 6.60661 1.66296 6.54661C1.51496 6.50461 1.20596 6.16161 1.10096 6.03561C-0.202035 4.47562 -0.127035 2.11061 1.27896 0.642615C1.36196 0.556615 1.57796 0.339615 1.68996 0.323615Z", fill: "#ED2E24" })
                ]
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[5.2vh] right-[4.5vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[3.2vh] h-[3.1vh] bg-[#191D22] rounded-[0_.5vh_0_.5vh] flex items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 size-[2.7vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 11 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3585 9.27522H0.5625V3.44922", stroke: "#737373", strokeWidth: "0.25" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.5625 0.363281H10.6885V5.66928", stroke: "#737373", strokeWidth: "0.25" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.svg,
              {
                id: "hazards",
                className: "w-[2.25vh] h-[2.75vh]",
                viewBox: "0 0 9 8",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                animate: {
                  opacity: indicators === 3 ? isBlinking ? 1 : 0.3 : 0.5
                },
                transition: { duration: 0.2 },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.81473 6.75875L4.68673 1.31875C4.58773 1.29475 4.24773 1.90775 4.18273 2.01375C3.39873 3.29875 2.61273 4.64675 1.87273 5.95775C1.78573 6.11275 1.49673 6.56675 1.48973 6.70575C1.48573 6.78075 1.49173 6.75075 1.54273 6.75875C1.63973 6.77275 1.79673 6.78975 1.89573 6.79575C3.72073 6.90075 5.64473 6.71275 7.48073 6.79575L7.81473 6.75875ZM0.677734 7.14775L4.61873 0.46875L4.70873 0.49275C6.04873 2.69075 7.29973 4.94275 8.62673 7.14775H0.677734Z", fill: "#ED2E24" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.08156 5.73507C5.72556 5.02807 5.32656 4.25207 4.88156 3.59707C4.79756 3.47407 4.71156 3.24007 4.56656 3.39107C4.40956 3.55507 4.13856 4.05407 4.00356 4.27607C3.71956 4.74607 3.44356 5.23307 3.21956 5.73507H6.08156ZM6.82356 6.19407L2.47656 6.17507C2.77756 5.55107 3.12556 4.94607 3.47456 4.34707C3.77656 3.82707 4.11356 3.23307 4.44156 2.73507C4.48056 2.67707 4.61656 2.43307 4.68556 2.45007L6.82356 6.19407Z", fill: "#ED2E24" })
                ]
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[3.5vh] left-[4.75vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[3.2vh] h-[3.1vh] bg-[#191D22] rounded-[0_.5vh_0_.5vh] flex items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 size-[2.7vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 11 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3585 9.27522H0.5625V3.44922", stroke: "#737373", strokeWidth: "0.25" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.5625 0.363281H10.6885V5.66928", stroke: "#737373", strokeWidth: "0.25" })
            ] }) }),
            isHarness ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { id: "harness", className: "size-[1.75vh]", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fill: "#ECECEC", fillRule: "evenodd", d: "M6 21.02v-6.353h4v3.566c0 .24.194.434.427.434h4.933c1.087 0 1.973-1.28 1.973-2.387c0-1.1-.906-2.267-2-2.267h-4.666V10h4.68c1.1 0 1.986-1.18 1.986-2.287c0-1.113-.886-2.38-1.986-2.38h-4.92a.434.434 0 0 0-.427.434v3.566H6V2.98c0-.54.433-.98.967-.98h8.64c3.166 0 5.726 3.253 5.726 6.447c-.046.733-.433 2.453-1.653 3.433c.553.58 1.653 2.2 1.653 3.987c0 3.02-2.42 6.133-5.413 6.133H6.967A.975.975 0 0 1 6 21.02m8.813-9.04a.487.487 0 0 1-.973 0c0-.267.22-.493.487-.493a.49.49 0 0 1 .486.493m-1.926 0a.484.484 0 1 1-.967 0c0-.267.22-.493.487-.493c.266 0 .48.22.48.493M5.333 14v-4h-.506c-.98 0-2.16.893-2.16 2s1.18 2 2.16 2zm.894-4C6.1 10 6 10.12 6 10.267v3.466c0 .147.1.267.227.267h3.546c.127 0 .227-.12.227-.267v-3.466c0-.147-.1-.267-.227-.267zm.613.667c-.093 0-.173.086-.173.2v2.266c0 .114.08.2.173.2h2.32c.093 0 .173-.086.173-.2v-.7h-1.06c-.206 0-.373-.2-.373-.44c0-.246.167-.44.373-.44h1.06v-.693c0-.107-.08-.193-.173-.193z", clipRule: "evenodd" }) }) : seatbelt ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { id: "seatbelt-on", className: "size-[1.75vh]", xmlns: "http://www.w3.org/2000/svg", width: "48", height: "48", viewBox: "0 0 48 48", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { fill: "none", stroke: "#ECECEC", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m10.565 30.364l-6.364 6.364l7.071 7.071l6.364-6.364m4.243-18.385l14.85-14.849l7.07 7.071l-14.849 14.85" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.859 29.657a2 2 0 0 1 0-2.829l8.485-8.485a2 2 0 0 1 2.828 0l8.485 8.485a2 2 0 0 1 0 2.829l-8.485 8.485a2 2 0 0 1-2.828 0zm15.556-7.071l-7.071 7.07M31.779 9.15l7.07 7.072M26.828 14.1l7.071 7.072m-18.384 0L26.83 32.485" })
            ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { id: "seatbelt-off", className: "size-[1.75vh]", viewBox: "0 0 8 8", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.20984 5.08203C2.20884 5.10403 2.20984 5.12703 2.20984 5.14903C2.20884 5.20403 2.20784 5.26103 2.20984 5.31603C2.21184 5.37103 2.22184 5.43003 2.22684 5.48303C2.22884 5.50603 2.22484 5.52903 2.22784 5.55303C2.24084 5.66703 2.26784 5.78003 2.28884 5.89203C2.29884 5.90803 2.35584 5.88203 2.37284 5.87603C2.41684 5.86003 2.46384 5.83103 2.50184 5.81703C2.50484 5.81603 2.50784 5.81803 2.51084 5.81703C2.51884 5.81403 2.52784 5.81203 2.53584 5.80903C2.57684 5.79403 2.61984 5.78003 2.66084 5.76703C2.71484 5.75003 2.77284 5.73203 2.82784 5.71703C2.93784 5.68703 3.05084 5.66403 3.16184 5.64203C3.21684 5.63103 3.27384 5.61703 3.32884 5.60803C3.38284 5.60003 3.44384 5.59003 3.49584 5.58303C3.55084 5.57703 3.60984 5.57103 3.66284 5.56703C3.71784 5.56203 3.77584 5.56103 3.83084 5.55803C3.88684 5.55503 3.94084 5.55103 3.99784 5.55003C4.05284 5.54803 4.10884 5.54903 4.16484 5.55003C4.21984 5.55003 4.27684 5.54703 4.33184 5.55003C4.38384 5.55203 4.44484 5.56203 4.49884 5.56703C4.55484 5.57103 4.60984 5.57703 4.66584 5.58303C4.72184 5.58903 4.77684 5.59203 4.83284 5.60003C4.88684 5.60803 4.94784 5.61503 4.99984 5.62503C5.10884 5.64503 5.22684 5.67203 5.33384 5.70003C5.38884 5.71503 5.44684 5.73403 5.50084 5.75003C5.55384 5.76603 5.61984 5.78403 5.66784 5.80003C5.67084 5.80103 5.67684 5.81003 5.68484 5.81303C5.76484 5.84103 5.84084 5.87703 5.92184 5.90103C5.93584 5.89903 5.94084 5.83103 5.94384 5.81703C5.95684 5.75703 5.95984 5.70703 5.96884 5.65003C5.97684 5.60403 5.99884 5.55003 5.99384 5.50003C6.00684 5.48603 6.28684 5.63003 6.32784 5.64203C6.33584 5.64403 6.33784 5.64803 6.35284 5.65003C6.34884 5.67003 6.36384 5.66703 6.37484 5.67403C6.41684 5.69603 6.46284 5.71703 6.50384 5.74203C6.60184 5.80203 6.74084 5.89503 6.82984 5.96703C6.89184 6.01903 6.98984 6.10903 7.04684 6.16803C7.08684 6.20903 7.12284 6.27403 7.17184 6.31003C7.17184 6.31303 7.17084 6.31603 7.17184 6.31803C7.18384 6.35703 7.21984 6.33503 7.16384 6.39403C7.13684 6.42103 7.09184 6.44603 7.07984 6.48503C7.05384 6.48903 7.03184 6.52203 7.01284 6.54003C7.00684 6.54603 7.00684 6.55903 7.00484 6.56103C7.00284 6.56203 6.99084 6.56203 6.98384 6.56903C6.97184 6.58003 6.92184 6.63803 6.90984 6.63503C6.89084 6.60603 6.85884 6.58503 6.83784 6.56103C6.82084 6.54103 6.80184 6.50903 6.77884 6.48503C6.74084 6.44503 6.70884 6.42003 6.67084 6.38503C6.63984 6.35803 6.62084 6.33703 6.58684 6.31003C6.56384 6.29103 6.55684 6.29303 6.54484 6.28503C6.54384 6.28403 6.54084 6.27803 6.52884 6.26803C6.52684 6.26703 6.52084 6.25603 6.50384 6.24303C6.38884 6.15703 6.29284 6.10203 6.16984 6.03403C6.16684 6.03303 6.16084 6.02203 6.15084 6.01603C6.07884 5.97803 6.00384 5.94503 5.93084 5.90903C5.91584 5.93103 5.91684 5.96003 5.91084 5.98403C5.89584 6.03803 5.88384 6.09903 5.86884 6.15103C5.83684 6.26203 5.79884 6.37703 5.75984 6.48503C5.74184 6.53803 5.72184 6.59203 5.70184 6.64403C5.65984 6.75203 5.61384 6.86403 5.56784 6.97003C5.51784 7.08603 5.46284 7.20803 5.40884 7.32103C5.35684 7.42903 5.29884 7.54003 5.24184 7.64703C5.18184 7.76103 5.10884 7.87003 5.05884 7.98903H4.42384C4.43384 7.94703 4.50384 7.86703 4.50684 7.83003C4.50684 7.82803 4.50684 7.82503 4.50684 7.82203C4.54984 7.78303 4.56484 7.71903 4.59084 7.67203C4.65284 7.55503 4.71684 7.44303 4.77484 7.32103C4.82784 7.20803 4.87084 7.10003 4.91684 6.98703C4.93884 6.93203 4.96284 6.88003 4.98284 6.82003C4.99084 6.79803 5.00084 6.77703 5.00784 6.75303C5.05284 6.61003 5.09384 6.47103 5.08384 6.31803C5.08084 6.28203 5.06684 6.18103 5.03284 6.16403C5.02084 6.15703 5.01084 6.16103 4.99984 6.16003C4.93384 6.14903 4.88684 6.16203 4.83284 6.16003C4.79284 6.15803 4.75584 6.13503 4.69884 6.14303C4.67884 6.13603 4.64784 6.13603 4.62384 6.13503C4.60484 6.13403 4.58484 6.13603 4.56584 6.13503C4.55584 6.13403 4.54984 6.13503 4.54884 6.13503C4.52984 6.13303 4.51284 6.12703 4.49884 6.12603C4.32884 6.11703 4.16784 6.11003 3.99784 6.11803C3.95284 6.12003 3.90784 6.12203 3.86384 6.12603L3.85984 6.11803L3.84684 6.12603C3.84184 6.12703 3.83584 6.12603 3.83084 6.12603C3.80484 6.12903 3.81684 6.14003 3.81384 6.14303C3.81184 6.14403 3.79384 6.12803 3.77684 6.12603C3.74584 6.12203 3.71884 6.13503 3.70084 6.13503H3.57584C3.56084 6.13503 3.51884 6.14103 3.49584 6.14303C3.44084 6.14703 3.38484 6.14703 3.32884 6.15103C3.29484 6.15403 3.24784 6.16003 3.21584 6.16803C3.18684 6.21603 3.18184 6.26403 3.17884 6.31803C3.17584 6.37703 3.18084 6.42803 3.18684 6.48503C3.19384 6.54703 3.20484 6.59403 3.22084 6.65203C3.23684 6.71403 3.25884 6.76903 3.27884 6.82803C3.29284 6.86803 3.30584 6.90503 3.32084 6.94503C3.32584 6.95903 3.33184 6.97303 3.33784 6.98703C3.38784 7.11303 3.43784 7.21603 3.49584 7.33703C3.52084 7.38903 3.54584 7.43703 3.57184 7.48803C3.64484 7.63203 3.71884 7.77403 3.79884 7.91703C3.81084 7.93903 3.82884 7.96403 3.83084 7.98903H3.16184C3.13984 7.92903 3.10084 7.87703 3.06984 7.82203C3.04584 7.77803 3.01684 7.73103 2.99484 7.68803C2.98984 7.67803 2.98384 7.66603 2.97884 7.65503C2.92284 7.54803 2.86384 7.43003 2.81084 7.32103C2.78484 7.26603 2.76184 7.20903 2.73584 7.15403C2.71484 7.10703 2.68984 7.05803 2.66884 7.01203C2.66684 7.00603 2.66584 6.99703 2.66084 6.98703C2.60784 6.86303 2.54884 6.72803 2.50184 6.60203C2.48784 6.56403 2.47384 6.52403 2.46084 6.48503C2.41484 6.35403 2.37384 6.21803 2.33484 6.08403C2.32584 6.05203 2.31884 6.01703 2.30984 5.98403C2.30384 5.96203 2.30084 5.93703 2.28884 5.91703C2.26384 5.91303 2.18684 5.95403 2.16784 5.97603C2.15084 5.97503 2.14984 5.98203 2.14284 5.98403C2.02384 6.02203 1.91784 6.10803 1.81684 6.17603C1.62284 6.30803 1.45284 6.43303 1.32484 6.63603C1.30484 6.64003 1.29884 6.62803 1.28684 6.61903C1.23784 6.58503 1.20284 6.56203 1.15684 6.51903C1.14584 6.50803 1.13484 6.49603 1.12384 6.48503C1.07884 6.44203 1.03684 6.39503 0.989844 6.35203C0.984844 6.34603 0.967844 6.31903 0.964844 6.31803C0.975844 6.30603 0.987844 6.28803 0.998844 6.27703C1.03484 6.24003 1.07084 6.20403 1.10684 6.16803C1.12384 6.15103 1.14084 6.13503 1.15684 6.11803C1.20184 6.07303 1.24684 6.02903 1.29084 5.98403C1.30184 5.97303 1.31284 5.96203 1.32484 5.95103C1.36584 5.90903 1.40784 5.86703 1.44984 5.82503C1.46384 5.81203 1.47784 5.79803 1.49184 5.78403C1.53284 5.74203 1.57484 5.70003 1.61684 5.65803C1.63084 5.64403 1.64484 5.63103 1.65884 5.61703C1.69984 5.57503 1.75784 5.53603 1.78384 5.48303C1.81384 5.47803 1.81584 5.45703 1.83384 5.44103C1.87884 5.40103 1.91684 5.35803 1.95884 5.31603C1.97084 5.30503 1.98184 5.29303 1.99284 5.28303C2.03184 5.24403 2.07084 5.20403 2.10984 5.16603C2.13084 5.14403 2.15584 5.11803 2.17684 5.09903C2.18284 5.09203 2.19384 5.08803 2.20184 5.08203H2.20984Z", fill: "#ECECEC" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.23901 0.472656C4.23401 0.498656 4.25201 0.486656 4.26701 0.490656C4.51101 0.546656 4.68701 0.688656 4.79701 0.912656C4.81401 0.946656 4.81101 0.946656 4.83201 0.973656C4.83301 0.974656 4.83201 0.979656 4.83201 0.982656C4.83501 1.00366 4.82101 1.02966 4.84901 1.02366C4.85001 1.04066 4.84801 1.05766 4.84901 1.07366C4.84901 1.08366 4.84601 1.09466 4.85701 1.09966C4.85601 1.11266 4.85701 1.12766 4.85701 1.14066C4.85901 1.19566 4.87101 1.24966 4.86501 1.30766C4.86301 1.33666 4.84101 1.44966 4.83201 1.47466C4.80701 1.54566 4.71101 1.69366 4.65701 1.75066C4.64401 1.76366 4.61901 1.79066 4.60701 1.80066C4.58601 1.81866 4.53901 1.83966 4.51901 1.85966C4.51201 1.86666 4.50301 1.87166 4.50001 1.88166L4.49801 2.22266C4.49801 2.23366 4.50401 2.23666 4.51101 2.24266C4.54901 2.27166 4.62401 2.28966 4.66501 2.31066C4.67101 2.31366 4.67601 2.31566 4.68201 2.31866C4.72901 2.34266 4.78501 2.36966 4.83201 2.39366C4.83901 2.39766 4.84701 2.40566 4.85701 2.41066C4.85101 2.43366 4.82501 2.45966 4.80701 2.47766C4.59801 2.69166 4.38201 2.91066 4.17201 3.12066C4.17101 3.12166 4.15901 3.12566 4.14701 3.13766C3.64801 3.63666 3.14901 4.13866 2.64901 4.63766C2.51101 4.77666 2.36201 4.92966 2.21701 5.05866C2.21901 5.03366 2.21601 5.00866 2.21701 4.98366C2.22001 4.93066 2.23001 4.86966 2.23401 4.81666C2.23801 4.76066 2.23801 4.70566 2.24301 4.64966C2.24701 4.59066 2.25401 4.53266 2.25901 4.47366C2.26401 4.42066 2.27001 4.36766 2.27601 4.31566C2.28201 4.25966 2.28601 4.20366 2.29301 4.14866C2.29701 4.11266 2.31301 4.05566 2.30901 4.02266C2.31701 4.02066 2.31701 4.01366 2.31801 4.00666C2.31801 3.99766 2.31701 3.98866 2.31801 3.98066C2.33301 3.87366 2.35301 3.76066 2.37601 3.65566C2.38801 3.60066 2.40401 3.53366 2.41801 3.47966C2.43201 3.42766 2.46201 3.36966 2.47601 3.31266C2.47901 3.30166 2.48201 3.29166 2.48501 3.27966C2.52001 3.24866 2.52501 3.18266 2.54301 3.14566C2.56401 3.10266 2.61501 3.02166 2.64301 2.97866C2.65201 2.96566 2.66201 2.94566 2.66901 2.93666C2.69101 2.90666 2.75001 2.83966 2.77701 2.81166C2.90801 2.67666 3.07401 2.58266 3.22801 2.47766C3.26401 2.47266 3.29801 2.44266 3.32801 2.42766C3.44101 2.37266 3.55301 2.31966 3.66301 2.26066C3.67701 2.25266 3.70401 2.25166 3.71701 2.23566C3.72601 2.21966 3.72001 2.16666 3.72101 2.14366C3.72301 2.08766 3.72201 2.03166 3.72101 1.97666C3.72101 1.94966 3.72701 1.89366 3.72001 1.87366C3.71301 1.85266 3.68701 1.85666 3.67901 1.85066C3.62501 1.80766 3.51601 1.69966 3.47901 1.64166C3.46001 1.61266 3.40601 1.50566 3.39501 1.47466C3.38401 1.44266 3.36501 1.34266 3.36201 1.30766C3.35801 1.26266 3.35801 1.18566 3.36201 1.14066C3.36601 1.08966 3.38701 1.02266 3.40401 0.973656C3.41901 0.928656 3.45301 0.845656 3.47901 0.806656C3.48101 0.803656 3.49001 0.797656 3.49501 0.789656C3.53101 0.741656 3.59101 0.677656 3.63801 0.639656C3.64701 0.631656 3.66101 0.621656 3.67101 0.614656C3.72201 0.579656 3.82101 0.522656 3.88001 0.505656C3.89701 0.500656 3.98401 0.492656 3.98801 0.489656C3.99001 0.487656 3.98801 0.477656 3.98801 0.472656H4.23901Z", fill: "#ECECEC" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M6.06129 1.30644C6.09229 1.33644 6.13429 1.38744 6.17029 1.42344C6.18929 1.44244 6.21029 1.46244 6.22829 1.48144C6.24829 1.50344 6.27329 1.52744 6.28729 1.55244C6.28729 1.56344 6.22429 1.62744 6.21129 1.64044C6.19829 1.65444 6.18329 1.66844 6.17029 1.68244C6.12929 1.72444 6.08629 1.76544 6.04429 1.80744C6.02829 1.82444 6.01129 1.84144 5.99429 1.85744C5.95529 1.89644 5.91629 1.93544 5.87729 1.97444C5.86329 1.98844 5.84929 2.00244 5.83529 2.01644C5.79429 2.05844 5.75229 2.10044 5.71029 2.14144C5.69629 2.15544 5.68229 2.16944 5.66829 2.18344C5.63029 2.22244 5.59029 2.26144 5.55129 2.30044C5.53529 2.31744 5.51829 2.33344 5.50129 2.35044C5.46029 2.39244 5.41829 2.43444 5.37629 2.47544C5.35929 2.49244 5.34229 2.50944 5.32629 2.52644C5.29429 2.55844 5.25529 2.58644 5.22629 2.62244C5.22129 2.63644 5.24929 2.64344 5.25929 2.65144C5.28029 2.66844 5.30729 2.68544 5.32629 2.70144C5.46029 2.81644 5.59929 2.98744 5.67729 3.14444C5.69729 3.18444 5.72729 3.26544 5.74429 3.31144C5.78229 3.41644 5.81829 3.53644 5.84429 3.64544C5.85629 3.69644 5.86729 3.76044 5.87729 3.81244C5.88829 3.86644 5.89429 3.92444 5.90229 3.97944C5.91129 4.03444 5.92029 4.09144 5.92729 4.14644C5.93529 4.20144 5.93829 4.25844 5.94429 4.31344C5.95029 4.36944 5.95529 4.42544 5.96129 4.48044C5.96629 4.53644 5.97329 4.59344 5.97829 4.64744C5.98729 4.75844 5.99629 4.87144 6.00329 4.98244C6.00629 5.03744 6.01029 5.09344 6.01129 5.14944C6.01229 5.20344 6.01329 5.26244 6.01129 5.31644C6.00829 5.37244 5.99929 5.43444 5.99429 5.49144C5.90029 5.45544 5.80529 5.41944 5.70829 5.38844C5.69329 5.38444 5.67829 5.38544 5.66829 5.38344C5.60829 5.36444 5.55029 5.33844 5.48529 5.32444C5.44829 5.31644 5.42429 5.30644 5.38429 5.30744C5.37329 5.28644 5.34929 5.29544 5.33429 5.29144C5.27029 5.27344 5.22829 5.26944 5.16729 5.25744C5.11329 5.24644 5.05829 5.23344 5.00029 5.22444C4.94429 5.21544 4.89029 5.20644 4.83329 5.19944C4.77729 5.19144 4.72229 5.18844 4.66629 5.18244C4.61229 5.17744 4.55629 5.16944 4.49929 5.16544C4.43929 5.16144 4.38329 5.15944 4.32329 5.15744C4.27329 5.15544 4.21929 5.14944 4.16529 5.14944C4.10929 5.14844 4.05329 5.14744 3.99829 5.14944C3.94129 5.15044 3.88729 5.15444 3.83129 5.15744C3.77629 5.16044 3.71729 5.16144 3.66429 5.16544C3.60829 5.17044 3.55229 5.17644 3.49629 5.18244C3.44129 5.18844 3.38529 5.19944 3.32929 5.20744C3.27329 5.21544 3.21929 5.22344 3.16229 5.23244C3.10629 5.24244 3.05129 5.25444 2.99529 5.26644C2.87529 5.29144 2.77829 5.31644 2.66129 5.34944C2.60229 5.36644 2.55329 5.38044 2.49429 5.39944C2.49229 5.40044 2.43929 5.41544 2.44829 5.39944L5.18829 2.65944C5.21629 2.63744 5.20429 2.61644 5.18129 2.59544C5.17729 2.59144 5.16929 2.59444 5.16729 2.59244C5.11129 2.54744 5.05929 2.52644 5.00029 2.49244C4.95829 2.46844 4.91829 2.44044 4.87529 2.41744C4.89229 2.38244 4.93029 2.34544 4.95829 2.31744C4.97229 2.30344 4.98629 2.28944 5.00029 2.27544C5.03929 2.23644 5.07829 2.19744 5.11729 2.15844C5.13429 2.14144 5.15129 2.12544 5.16729 2.10844C5.21229 2.06344 5.25629 2.01944 5.30129 1.97444C5.31229 1.96344 5.32329 1.95244 5.33429 1.94144C5.37629 1.89944 5.41829 1.85744 5.46029 1.81644C5.47329 1.80244 5.48829 1.78844 5.50129 1.77444C5.54329 1.73244 5.58529 1.69044 5.62729 1.64844C5.64029 1.63544 5.65529 1.62144 5.66829 1.60744C5.71329 1.56244 5.75829 1.51844 5.80229 1.47344C5.81329 1.46244 5.82429 1.45144 5.83529 1.44044C5.88029 1.39444 5.92729 1.35544 5.96929 1.30644C5.97729 1.29644 5.99829 1.29044 6.00329 1.27344C6.01329 1.27744 6.05629 1.30144 6.06129 1.30644Z", fill: "#ECECEC" })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[1.22vh] left-[6.25vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[3.2vh] h-[3.1vh] bg-[#191D22] rounded-[0_.5vh_0_.5vh] flex items-center justify-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 size-[2.7vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 11 10", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3585 9.27522H0.5625V3.44922", stroke: "#737373", strokeWidth: "0.25" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.5625 0.363281H10.6885V5.66928", stroke: "#737373", strokeWidth: "0.25" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.svg,
              {
                className: "size-[1.85vh]",
                viewBox: "0 0 8 5",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                animate: {
                  opacity: headlights === 2 ? 1 : headlights === 1 ? 0.75 : 0.5
                },
                transition: { duration: 0.2 },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.24414 4.33984L3.36814 4.76084H0.744141V4.33984H3.24414Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.04614 3.42188L3.09514 3.84288L0.829141 3.84387L0.744141 3.80588V3.42188H3.04614Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M4.31242 4.33236C4.99442 4.45136 5.76842 4.35736 6.39542 4.06136C7.74442 3.42536 7.89042 2.04136 6.53542 1.30436C5.86942 0.942355 5.08242 0.855355 4.33642 0.951355C3.87142 2.01136 3.87842 3.26336 4.31242 4.33236ZM3.94142 4.72736C3.41642 3.41336 3.45142 1.90936 3.99142 0.605355C5.14442 0.319355 6.64042 0.585355 7.43842 1.51536C8.25642 2.46736 7.91942 3.60436 6.94442 4.26336C6.08942 4.84136 4.93242 4.98536 3.94142 4.72736Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.99614 2.90147H0.744141V2.48047H2.99614V2.90147Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.12014 1.54297L3.04614 1.96397H0.744141V1.54297H3.12014Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.41714 0.601562L3.26914 1.02256H0.744141V0.601562H3.41714Z", fill: "#ECECEC" })
                ]
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-[1vh] right-[.85vw]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-[7.6vh] h-[7.7vh] bg-cyberpunk2-cc-bg bg-fullSize bg-fullCenter bg-no-repeat", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "absolute top-1/2 left-[.6vw] -translate-x-1/2 -translate-y-1/2 text-[#ECECEC] text-[.85vh] uppercase",
                style: {
                  fontFamily: font2
                },
                children: cruiseControl ? "on" : "off"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "absolute -bottom-[.35vh] left-[1vw] -translate-y-1/2 text-[#ECECEC] text-[.95vh] uppercase",
                style: {
                  fontFamily: font2
                },
                children: [
                  maxSpeedForCruise,
                  " ",
                  getSpeedUnit()
                ]
              }
            )
          ] }) })
        ] })
      ] }),
      nos?.toggle && type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[4.4vh] h-[18vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 14 87", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.7959 29.0939H11.5409V0.546875H4.08789V12.3929H4.83289V1.07987H10.7959V29.0939ZM4.83289 57.3739H4.08789V85.9219H11.5409V74.0759H10.7959V85.3879H4.83289V57.3739ZM11.5409 29.0939H10.7959V65.8589H11.5409V29.0939ZM4.08789 50.4379H4.83289V22.4779H4.08789V50.4379Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.path,
          {
            id: "nitro-bar",
            d: "M5.95117 1.75781H9.67827V84.5858H5.95117V1.75781Z",
            fill: "#EF9538",
            initial: { clipPath: "inset(100% 0 0 0)" },
            animate: {
              clipPath: `inset(${100 - getNitroProgress()}% 0 0 0)`
            },
            transition: { duration: 0.5 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { clipPath: "url(#clip0_351_330)", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.0309 81.0664V86.9894H9.37891V86.6694H12.5839V81.0664H13.0309Z", fill: "#ECECEC" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9587 59.9867H12.5117V38.4297H12.9587V59.9867Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.11669 13.7496C1.42969 15.3216 0.741687 16.8936 0.0546875 18.4646H2.68569L0.765688 22.9236C2.21369 21.0206 3.66269 19.1166 5.11069 17.2136C4.11269 17.2256 3.11469 17.2386 2.11669 17.2516L4.98469 13.7266L2.11669 13.7496Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.97672 0.0507812V0.370781H3.83372V4.15978H3.38672V0.0507812H8.97672Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_351_330", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "3.65", height: "5.92", fill: "white", transform: "translate(9.37891 81.0703)" }) }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center ${type === VehicleType.CAR ? "gap-[1.35vh]" : "gap-[.85vh]"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${type === VehicleType.CAR ? "w-[12.5vw]" : "w-[10.5vw]"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 132 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M43.9841 15.8671V15.0781H1.74609V22.9721H19.2731V22.1831H2.53509V15.8671H43.9841ZM31.4311 22.9721H85.8271V22.1831H31.4311V22.9721ZM118.829 15.0781V15.8671H129.329V22.1831H103.67V22.9721H130.118V15.0781H118.829ZM54.2481 15.8671H95.6181V15.0781H54.2481V15.8671Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.path,
          {
            id: "fuel-bar",
            d: "M128.738 21.0027H3.7207V17.0547H128.738V21.0027Z",
            fill: "#ECECEC",
            initial: { clipPath: "inset(0 100% 0 0)" },
            animate: {
              clipPath: `inset(0 ${100 - getFuelProgress()}% 0 0)`
            },
            transition: { duration: 0.5 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M72.0132 24.474H40.1172V24H72.0132V24.474Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.93097 24.5526H0.167969V20.6836H0.640969V24.0786H8.93097V24.5526Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M131.778 19.4991H131.304V14.0511H125.699V13.5781H131.778V19.4991Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M85.749 14.0521H64.748V13.5781H85.749V14.0521Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M101.688 15.6397L96.7841 10.7357H91.0391V10.2617H96.9801L102.023 15.3047L101.688 15.6397Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { opacity: "0.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M117.802 15.7899H104.375L97.5848 8.99994H78.8008V8.21094H97.9118L104.702 15.0009H117.802V15.7899Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M76.7488 7.10541C75.8348 7.10541 75.0908 7.84941 75.0908 8.76341C75.0908 9.67741 75.8348 10.4214 76.7488 10.4214C77.6628 10.4214 78.4068 9.67741 78.4068 8.76341C78.4068 7.84941 77.6628 7.10541 76.7488 7.10541ZM76.7488 11.2104C75.3988 11.2104 74.3008 10.1134 74.3008 8.76341C74.3008 7.41341 75.3988 6.31641 76.7488 6.31641C78.0978 6.31641 79.1958 7.41341 79.1958 8.76341C79.1958 10.1134 78.0978 11.2104 76.7488 11.2104Z", fill: "#ECECEC" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M76.1172 8.76481C76.1172 8.41581 76.4002 8.13281 76.7492 8.13281C77.0972 8.13281 77.3802 8.41581 77.3802 8.76481C77.3802 9.11381 77.0972 9.39681 76.7492 9.39681C76.4002 9.39681 76.1172 9.11381 76.1172 8.76481Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M70.7079 9.28525C70.6859 9.32725 70.1739 10.2023 69.3469 10.2023C68.5189 10.2023 68.0079 9.32725 67.9849 9.28525C67.4199 8.28325 67.9639 6.64725 69.3469 5.21225C70.7299 6.64725 71.2739 8.28325 70.7079 9.28525ZM68.7059 2.90625L67.9889 3.19825V3.19925L66.9649 3.61625L65.8379 4.07625V12.2402H72.8559V2.90625H68.7059Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M71.7288 2.90728V0.613281H66.9648V3.61728L67.9888 3.20028V1.63828H70.7038V2.90728H71.7288Z", fill: "#ECECEC" })
      ] }) }),
      type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[2.25vw] bg-cyberpunk2-gear-bg size-[2.25vw] bg-fullSize bg-fullCenter bg-no-repeat flex items-center justify-center mt-[1.85vh] overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: {
            y: isAnimating ? currentGear > prevGear ? -60 : 60 : 0,
            opacity: 0
          },
          animate: {
            y: 0,
            opacity: 1
          },
          exit: {
            y: isAnimating ? currentGear > prevGear ? 60 : -60 : 0,
            opacity: 0
          },
          transition: {
            y: { type: "spring", stiffness: 300, damping: 20 },
            opacity: { duration: 0.05 }
          },
          className: "text-[#ECECEC] text-[2vh] uppercase",
          style: {
            fontFamily: font
          },
          children: currentGear === 0 ? "R" : currentGear
        },
        currentGear
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${type === VehicleType.CAR ? "w-[12.5vw]" : "w-[10.5vw]"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 133 23", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M44.6599 13.6718V12.8828H2.42188V20.7768H19.9489V19.9878H3.21087V13.6718H44.6599ZM32.1069 20.7768H86.5029V19.9878H32.1069V20.7768ZM119.504 12.8828V13.6718H130.005V19.9878H104.346V20.7768H130.794V12.8828H119.504ZM54.9229 13.6718H96.2929V12.8828H54.9229V13.6718Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.path,
          {
            id: "engine-bar",
            d: "M128.814 18.8025H4.39453V14.8555H128.814V18.8025Z",
            fill: "#ECECEC",
            initial: { clipPath: "inset(0 100% 0 0)" },
            animate: {
              clipPath: `inset(0 ${100 - getEngineProgress()}% 0 0)`
            },
            transition: { duration: 0.5 }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M72.6851 22.2787H40.7891V21.8047H72.6851V22.2787Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.6048 22.3573H0.841797V18.4883H1.3148V21.8833H9.6048V22.3573Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M132.45 17.3038H131.976V11.8558H126.371V11.3828H132.45V17.3038Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M86.4229 11.8568H65.4219V11.3828H86.4229V11.8568Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M102.362 13.4444L97.4569 8.54041H91.7129V8.06641H97.6539L102.697 13.1094L102.362 13.4444Z", fill: "#ECECEC" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { opacity: "0.5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M118.478 13.5946H105.051L98.2606 6.80462H79.4766V6.01562H98.5876L105.378 12.8056H118.478V13.5946Z", fill: "#ECECEC" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M77.4236 4.91009C76.5096 4.91009 75.7656 5.65409 75.7656 6.56809C75.7656 7.48209 76.5096 8.22609 77.4236 8.22609C78.3376 8.22609 79.0816 7.48209 79.0816 6.56809C79.0816 5.65409 78.3376 4.91009 77.4236 4.91009ZM77.4236 9.01509C76.0746 9.01509 74.9766 7.91809 74.9766 6.56809C74.9766 5.21809 76.0746 4.12109 77.4236 4.12109C78.7736 4.12109 79.8716 5.21809 79.8716 6.56809C79.8716 7.91809 78.7736 9.01509 77.4236 9.01509Z", fill: "#ECECEC" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M76.791 6.5695C76.791 6.2205 77.074 5.9375 77.423 5.9375C77.771 5.9375 78.054 6.2205 78.054 6.5695C78.054 6.9185 77.771 7.2015 77.423 7.2015C77.074 7.2015 76.791 6.9185 76.791 6.5695Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M71.9003 8.64534H71.2283V7.42034H68.8463L67.7003 9.11934H62.8503L61.1523 6.03834H58.9443V2.48834L61.0863 0.942344H67.0363L68.4583 2.36434H71.0703V1.14034H71.9003V8.64534ZM70.2803 0.350344V1.57434H68.7853L67.3633 0.152344H60.8303L58.1543 2.08334V6.82834H60.6863L62.3843 9.90934H68.1213L69.2663 8.21034H70.4383V9.43534H72.6903V0.350344H70.2803Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M65.7805 7.22266H65.0625V7.93966H65.7805V7.22266Z", fill: "#ECECEC" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M65.7805 6.60109H65.0625V2.12109H65.7805V6.60109Z", fill: "#ECECEC" })
      ] }) })
    ] })
  ] });
}

function HaloDashSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const baseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font?.[SpeedometerThemes.HALO_DASH]?.type);
  const config = useConfigStore((state) => state.config);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const [prevGear, setPrevGear] = reactExports.useState(currentGear);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if ((engineHealth ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
      if ((fuelLevel ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [engineHealth, fuelLevel, indicators]);
  reactExports.useEffect(() => {
    let interval;
    if (indicators > 0) {
      interval = setInterval(() => {
        setIsBlinking((prev) => !prev);
      }, 500);
    } else {
      setIsBlinking(false);
    }
    return () => clearInterval(interval);
  }, [indicators]);
  reactExports.useEffect(() => {
    setPrevGear(currentGear);
  }, [currentGear]);
  const getSpeedUnit = () => config.mph ? "mph" : "km/h";
  const getSpeedValue = () => {
    const value = Math.floor(speed);
    return value;
  };
  const getEngineHealthLevel = () => {
    const health = engineHealth ?? 0;
    if (health <= 25) return 1;
    if (health <= 50) return 2;
    if (health <= 75) return 3;
    return 4;
  };
  const getFuelLevel = () => {
    const fuel = fuelLevel ?? 0;
    if (fuel <= 25) return 1;
    if (fuel <= 50) return 2;
    if (fuel <= 75) return 3;
    return 4;
  };
  const getGearAnimation = () => {
    if (currentGear > prevGear) {
      return {
        initial: { opacity: 0, y: -10 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: 10 }
      };
    }
    return {
      initial: { opacity: 0, y: 10 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: -10 }
    };
  };
  const getRpmColor = () => {
    if (rpm >= 70) return "#ff3333";
    if (rpm >= 40) return "#E0FF00";
    return VehicleStyles.halo_dash.rpmProgress;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-[48%] left-1/2 -translate-x-1/2 -translate-y-1/2 w-[36.25vh]
        ${type === VehicleType.CAR ? "h-[21.25vh]" : "h-[17.25vh]"}
        `, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        className: "size-full",
        viewBox: "0 0 1479 996",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M739.198 0.34375C702.523 0.34375 666.472 2.82675 631.229 7.62175C628.165 8.03875 625.106 8.47275 622.054 8.92475C611.371 10.5058 600.764 12.3008 590.239 14.3018C585.728 15.1608 581.232 16.0567 576.752 16.9907C551.363 22.2837 526.467 28.7907 502.14 36.4427C499.278 37.3427 496.423 38.2598 493.577 39.1908C490.731 40.1228 487.893 41.0707 485.063 42.0337C482.233 42.9967 479.41 43.9757 476.597 44.9707C473.783 45.9647 470.977 46.9747 468.18 47.9997C462.586 50.0507 457.025 52.1628 451.498 54.3358C447.353 55.9658 443.227 57.6298 439.121 59.3268C436.384 60.4588 433.655 61.6058 430.936 62.7668C421.417 66.8328 412.007 71.0808 402.711 75.5068C400.055 76.7718 397.408 78.0508 394.771 79.3438C390.815 81.2838 386.881 83.2567 382.968 85.2607C381.663 85.9287 380.362 86.6007 379.062 87.2757C373.864 89.9777 368.705 92.7348 363.585 95.5488C359.745 97.6588 355.928 99.7997 352.133 101.973C347.074 104.87 342.055 107.821 337.077 110.827C332.099 113.833 327.163 116.893 322.269 120.007C319.822 121.563 317.385 123.133 314.959 124.717C311.321 127.091 307.706 129.496 304.116 131.93C301.723 133.553 299.34 135.188 296.969 136.837C294.597 138.485 292.237 140.147 289.887 141.821C280.49 148.519 271.271 155.421 262.237 162.521C101.89 288.55 0.0742188 476.92 0.0742188 687.395C0.0742188 795.15 26.7632 897.109 74.3282 987.877C77.4992 993.929 80.7632 999.93 84.1182 1005.88H104.294C103.433 1004.4 102.577 1002.92 101.728 1001.43C99.1792 996.968 96.6832 992.477 94.2402 987.957C92.6122 984.943 91.0072 981.917 89.4262 978.878C87.8452 975.838 86.2892 972.786 84.7562 969.722C41.8412 883.913 17.8812 788.255 17.8812 687.395C17.8812 489.223 110.37 311.132 257.412 188.383C264.925 182.111 272.581 175.984 280.373 170.006C287.053 164.882 293.834 159.867 300.712 154.965C311.029 147.612 321.567 140.512 332.313 133.676C335.895 131.397 339.5 129.148 343.129 126.928C345.548 125.448 347.977 123.981 350.416 122.528C351.635 121.801 352.857 121.077 354.082 120.357C356.531 118.917 358.99 117.49 361.458 116.077C362.693 115.37 363.93 114.667 365.169 113.967C367.648 112.567 370.136 111.18 372.634 109.807C375.132 108.435 377.64 107.075 380.158 105.73C382.675 104.384 385.202 103.052 387.738 101.734C390.275 100.416 392.82 99.1117 395.376 97.8217C397.931 96.5317 400.495 95.2548 403.069 93.9928C409.503 90.8378 415.995 87.7697 422.542 84.7907C425.161 83.5997 427.789 82.4228 430.426 81.2598C433.062 80.0978 435.708 78.9488 438.362 77.8158C446.324 74.4148 454.365 71.1448 462.48 68.0078C465.185 66.9628 467.899 65.9317 470.621 64.9167C474.703 63.3927 478.804 61.9038 482.923 60.4478C485.669 59.4768 488.423 58.5217 491.185 57.5817C495.328 56.1717 499.489 54.7958 503.667 53.4548C507.845 52.1138 512.04 50.8078 516.253 49.5358C530.295 45.2988 544.525 41.4507 558.93 38.0057C561.811 37.3157 564.699 36.6438 567.593 35.9868C622.593 23.5108 680.065 16.8958 739.198 16.8958C1137.57 16.8958 1460.52 317.089 1460.52 687.395C1460.52 701.803 1460.03 716.106 1459.06 730.289C1458.82 733.834 1458.55 737.372 1458.25 740.903C1457.95 744.433 1457.62 747.956 1457.26 751.471C1448.12 841.101 1420 925.591 1376.67 1001.43C1375.82 1002.92 1374.96 1004.4 1374.1 1005.88H1394.28C1424.47 952.329 1447.29 894.62 1461.48 833.917C1462.26 830.545 1463.03 827.163 1463.76 823.772C1464.5 820.382 1465.2 816.982 1465.88 813.573C1466.9 808.461 1467.87 803.328 1468.76 798.176C1475.05 762.113 1478.32 725.109 1478.32 687.395C1478.32 307.948 1147.41 0.34375 739.198 0.34375Z", fill: "#FFFFFF99" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "rpm-track",
              d: "M739.198 0.34375C702.523 0.34375 666.472 2.82675 631.229 7.62175C628.165 8.03875 625.106 8.47275 622.054 8.92475C611.371 10.5058 600.764 12.3008 590.239 14.3018C585.728 15.1608 581.232 16.0567 576.752 16.9907C551.363 22.2837 526.467 28.7907 502.14 36.4427C499.278 37.3427 496.423 38.2598 493.577 39.1908C490.731 40.1228 487.893 41.0707 485.063 42.0337C482.233 42.9967 479.41 43.9757 476.597 44.9707C473.783 45.9647 470.977 46.9747 468.18 47.9997C462.586 50.0507 457.025 52.1628 451.498 54.3358C447.353 55.9658 443.227 57.6298 439.121 59.3268C436.384 60.4588 433.655 61.6058 430.936 62.7668C421.417 66.8328 412.007 71.0808 402.711 75.5068C400.055 76.7718 397.408 78.0508 394.771 79.3438C390.815 81.2838 386.881 83.2567 382.968 85.2607C381.663 85.9287 380.362 86.6007 379.062 87.2757C373.864 89.9777 368.705 92.7348 363.585 95.5488C359.745 97.6588 355.928 99.7997 352.133 101.973C347.074 104.87 342.055 107.821 337.077 110.827C332.099 113.833 327.163 116.893 322.269 120.007C319.822 121.563 317.385 123.133 314.959 124.717C311.321 127.091 307.706 129.496 304.116 131.93C301.723 133.553 299.34 135.188 296.969 136.837C294.597 138.485 292.237 140.147 289.887 141.821C280.49 148.519 271.271 155.421 262.237 162.521C101.89 288.55 0.0742188 476.92 0.0742188 687.395C0.0742188 795.15 26.7632 897.109 74.3282 987.877C77.4992 993.929 80.7632 999.93 84.1182 1005.88H104.294C103.433 1004.4 102.577 1002.92 101.728 1001.43C99.1792 996.968 96.6832 992.477 94.2402 987.957C92.6122 984.943 91.0072 981.917 89.4262 978.878C87.8452 975.838 86.2892 972.786 84.7562 969.722C41.8412 883.913 17.8812 788.255 17.8812 687.395C17.8812 489.223 110.37 311.132 257.412 188.383C264.925 182.111 272.581 175.984 280.373 170.006C287.053 164.882 293.834 159.867 300.712 154.965C311.029 147.612 321.567 140.512 332.313 133.676C335.895 131.397 339.5 129.148 343.129 126.928C345.548 125.448 347.977 123.981 350.416 122.528C351.635 121.801 352.857 121.077 354.082 120.357C356.531 118.917 358.99 117.49 361.458 116.077C362.693 115.37 363.93 114.667 365.169 113.967C367.648 112.567 370.136 111.18 372.634 109.807C375.132 108.435 377.64 107.075 380.158 105.73C382.675 104.384 385.202 103.052 387.738 101.734C390.275 100.416 392.82 99.1117 395.376 97.8217C397.931 96.5317 400.495 95.2548 403.069 93.9928C409.503 90.8378 415.995 87.7697 422.542 84.7907C425.161 83.5997 427.789 82.4228 430.426 81.2598C433.062 80.0978 435.708 78.9488 438.362 77.8158C446.324 74.4148 454.365 71.1448 462.48 68.0078C465.185 66.9628 467.899 65.9317 470.621 64.9167C474.703 63.3927 478.804 61.9038 482.923 60.4478C485.669 59.4768 488.423 58.5217 491.185 57.5817C495.328 56.1717 499.489 54.7958 503.667 53.4548C507.845 52.1138 512.04 50.8078 516.253 49.5358C530.295 45.2988 544.525 41.4507 558.93 38.0057C561.811 37.3157 564.699 36.6438 567.593 35.9868C622.593 23.5108 680.065 16.8958 739.198 16.8958C1137.57 16.8958 1460.52 317.089 1460.52 687.395C1460.52 701.803 1460.03 716.106 1459.06 730.289C1458.82 733.834 1458.55 737.372 1458.25 740.903C1457.95 744.433 1457.62 747.956 1457.26 751.471C1448.12 841.101 1420 925.591 1376.67 1001.43C1375.82 1002.92 1374.96 1004.4 1374.1 1005.88H1394.28C1424.47 952.329 1447.29 894.62 1461.48 833.917C1462.26 830.545 1463.03 827.163 1463.76 823.772C1464.5 820.382 1465.2 816.982 1465.88 813.573C1466.9 808.461 1467.87 803.328 1468.76 798.176C1475.05 762.113 1478.32 725.109 1478.32 687.395C1478.32 307.948 1147.41 0.34375 739.198 0.34375Z",
              fill: getRpmColor(),
              initial: { clipPath: "polygon(0 0, 0 100%, 0 100%, 0 0)" },
              animate: { clipPath: `polygon(0 0, ${rpm}% 0, ${rpm}% 100%, 0 100%)` },
              transition: { duration: 0.3, ease: "easeOut" }
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-[34.5vh]
        ${type === VehicleType.CAR ? "h-[20.5vh]" : "h-[16.5vh]"}
        `, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        className: "size-full",
        viewBox: "0 0 1420 966",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M131.554 976C72.9588 882.921 39.3244 774.352 39.3244 658.405C39.3244 313.147 337.524 33.244 705.381 33.244C1073.24 33.244 1371.44 313.137 1371.44 658.405C1371.44 774.352 1337.81 882.921 1279.21 976H1331.34C1387.83 881.65 1420 773.091 1420 657.571C1420 294.41 1102.12 0 710 0C317.876 0 0 294.41 0 657.571C0 773.091 32.1772 881.66 88.6608 976H131.544H131.554Z", fill: "#FFFFFF99" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "speedometer-track",
              d: "M131.554 976C72.9588 882.921 39.3244 774.352 39.3244 658.405C39.3244 313.147 337.524 33.244 705.381 33.244C1073.24 33.244 1371.44 313.137 1371.44 658.405C1371.44 774.352 1337.81 882.921 1279.21 976H1331.34C1387.83 881.65 1420 773.091 1420 657.571C1420 294.41 1102.12 0 710 0C317.876 0 0 294.41 0 657.571C0 773.091 32.1772 881.66 88.6608 976H131.544H131.554Z",
              fill: VehicleStyles.halo_dash.speedometerProgress,
              initial: { clipPath: "polygon(0 0, 0 100%, 0 100%, 0 0)" },
              animate: { clipPath: `polygon(0 0, ${speed}% 0, ${speed}% 100%, 0 100%)` },
              transition: { duration: 0.3, ease: "easeOut" }
            }
          )
        ]
      }
    ) }),
    type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `absolute top-[1.35vh] left-1/2 -translate-x-1/2 flex flex-col items-center
            ${cruiseControl ? "opacity-100" : "opacity-50"}
          `,
          style: ShadowStyle,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-white text-[1.1vh] uppercase",
                style: {
                  fontFamily: font
                },
                children: cruiseControl ? "on" : "off"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/halo-dash-cruise-control.png", className: "w-[3vh] h-[2.5vh] m-[-.25vh_0_-.25vh_0]" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-white text-[1.1vh]",
                style: {
                  fontFamily: font
                },
                children: maxSpeedForCruise
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[3vh] left-[12vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: isHarness ? "nui://envi-hud/web/build/images/halo-dash-harness.png" : "nui://envi-hud/web/build/images/halo-dash-seatbelt.png",
          className: "size-[2.5vh]",
          initial: { opacity: 0.5 },
          animate: {
            opacity: isHarness ? 1 : seatbelt ? 0.75 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[4.5vh] left-[8.5vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: "nui://envi-hud/web/build/images/halo-dash-headlights.png",
          className: "w-[2.25vh] h-[1.75vh]",
          initial: { opacity: 0.5 },
          animate: {
            opacity: headlights === 2 ? 1 : headlights === 1 ? 0.75 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[3.25vh] right-[11.5vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          className: "w-[2.75vh] h-[2.15vh]",
          viewBox: "0 0 73 57",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          style: ShadowStyle,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "handbrake-1",
                d: "M53.4566 41.0416C64.9786 25.8996 52.0386 5.31059 33.5326 7.64459C18.2596 9.57059 9.77162 26.9696 18.5706 39.9486C26.7106 51.9546 44.6356 52.6326 53.4566 41.0416ZM55.2216 10.5516C68.7876 24.2516 62.6146 47.1766 44.4686 52.8606C24.0406 59.2586 4.06361 39.8426 11.8326 19.4276C18.5686 1.72359 41.9316 -2.86941 55.2216 10.5516Z",
                fill: "white",
                animate: { fill: handBrake ? "#ff3333" : "white" },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "handbrake-2",
                d: "M60.7917 2.11177C71.6367 11.5498 74.9427 28.1388 69.8647 41.4248C68.1357 45.9488 63.8037 52.8068 59.7947 55.5908C58.5737 56.4388 56.7397 56.8648 55.8497 55.2848C54.5757 53.0268 56.9817 51.8738 58.2417 50.6048C70.5187 38.2458 70.5087 18.1638 57.9987 5.94577C57.4057 5.36677 55.8247 4.42977 55.6687 3.65577C55.4507 2.58077 55.5167 1.71777 56.4077 1.02277C58.1937 -0.370235 59.4677 0.959765 60.7917 2.11177Z",
                fill: "white",
                animate: { fill: handBrake ? "#ff3333" : "white" },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "handbrake-3",
                d: "M33.4326 17.6692V29.2292C33.8096 29.5002 34.7376 29.5882 35.2676 29.6262C39.4346 29.9212 43.4956 28.5112 43.8026 23.8142C44.2116 17.5632 38.3016 16.7312 33.4326 17.6692ZM33.4326 43.9772H29.7656V15.1982L30.0346 14.9882C36.5596 13.8922 46.7766 13.5282 47.4606 22.3752C48.1016 30.6602 41.2386 32.6572 34.4616 32.5052C34.0426 32.4962 33.6846 32.1822 33.4326 32.5772V43.9772Z",
                fill: "white",
                animate: { fill: handBrake ? "#ff3333" : "white" },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "handbrake-4",
                d: "M15.0037 5.78103C3.09175 17.534 1.83175 36.772 13.3367 49.321C14.3167 50.39 17.0267 52.433 17.2657 53.699C17.6357 55.654 15.2887 57.031 13.5097 56.009C12.4367 55.392 10.0047 52.815 9.11675 51.792C-2.83125 38.042 -2.16025 16.625 10.4667 3.55603C11.0947 2.90603 13.1867 0.883034 13.9057 0.613034C15.6057 -0.0239665 17.5507 1.32703 17.2647 3.16203C17.0527 4.52003 15.8627 4.93303 15.0037 5.78103Z",
                fill: "white",
                animate: { fill: handBrake ? "#ff3333" : "white" },
                transition: { duration: 0.3 }
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-[4vh] right-[8.3vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          className: "size-[2.45vh]",
          viewBox: "0 0 75 65",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          style: ShadowStyle,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "hazards-1",
                d: "M38.1474 14.5183L12.7314 57.6343L13.0954 58.2773L63.0714 57.9633L38.1474 14.5183ZM0.773438 64.6753L37.6764 0.777344L74.8924 64.6753H0.773438Z",
                fill: "white",
                animate: {
                  fill: indicators === 3 ? "#ff3333" : "white",
                  opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 1
                },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "hazards-2",
                d: "M46.1391 48.3823L37.9881 34.0063L29.5261 48.3823H46.1391ZM21.5391 52.8553L37.6761 24.7383L54.1261 52.8553H21.5391Z",
                fill: "white",
                animate: {
                  fill: indicators === 3 ? "#ff3333" : "white",
                  opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 1
                },
                transition: { duration: 0.3 }
              }
            )
          ]
        }
      ) })
    ] }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {}) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute bottom-0 w-[15vh]
        ${type === VehicleType.CAR ? "-left-[2.275vh] h-[7.25vh]" : "-left-[.1vh] h-[6.25vh]"}
        `, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        className: "size-full",
        viewBox: "0 0 145 342",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { clipPath: "url(#clip0_396_191)", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M144.719 341.849H105.517C88.817 313.77 83.47 304.324 78.377 294.738H116.372C121.848 304.344 127.596 313.791 144.719 341.849Z", fill: "#FF000066" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M106.735 277.086H69.3854C60.1894 258.232 52.0174 238.845 44.9434 218.984H80.6504C88.2014 238.899 96.9224 258.289 106.735 277.086Z", fill: "#FF910066" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M74.3122 201.335H38.9843C33.1452 183.035 28.2292 164.36 24.2812 145.359H58.7043C62.8953 164.391 68.1152 183.067 74.3122 201.335Z", fill: "#E0FF0066" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M55.1269 127.709H20.9049C17.8769 110.329 15.6679 92.6919 14.2949 74.8359H48.1269C49.5799 92.7089 51.9229 110.347 55.1269 127.709Z", fill: "#00FF0666" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "engine-health-1",
                d: "M144.719 341.849H105.517C88.817 313.77 83.47 304.324 78.377 294.738H116.372C121.848 304.344 127.596 313.791 144.719 341.849Z",
                fill: "#FF0000",
                initial: { opacity: 0 },
                animate: { opacity: getEngineHealthLevel() >= 1 ? engineHealth <= 20 ? isLowValue.engineHealth ? 0.5 : 1 : 1 : 0 },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "engine-health-2",
                d: "M106.735 277.086H69.3854C60.1894 258.232 52.0174 238.845 44.9434 218.984H80.6504C88.2014 238.899 96.9224 258.289 106.735 277.086Z",
                fill: "#FF9100",
                initial: { opacity: 0 },
                animate: { opacity: getEngineHealthLevel() >= 2 ? 1 : 0 },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "engine-health-3",
                d: "M74.3122 201.335H38.9843C33.1452 183.035 28.2292 164.36 24.2812 145.359H58.7043C62.8953 164.391 68.1152 183.067 74.3122 201.335Z",
                fill: "#E0FF00",
                initial: { opacity: 0 },
                animate: { opacity: getEngineHealthLevel() >= 3 ? 1 : 0 },
                transition: { duration: 0.3 }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.path,
              {
                id: "engine-health-4",
                d: "M55.1269 127.709H20.9049C17.8769 110.329 15.6679 92.6919 14.2949 74.8359H48.1269C49.5799 92.7089 51.9229 110.347 55.1269 127.709Z",
                fill: "#00FF06",
                initial: { opacity: 0 },
                animate: { opacity: getEngineHealthLevel() >= 4 ? 1 : 0 },
                transition: { duration: 0.3 }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M38.7528 39.3885C47.7798 30.1475 34.6178 15.5795 24.4418 24.1325C13.4198 33.3975 28.5628 49.8185 38.7528 39.3885ZM38.4568 9.58246L42.2438 10.8595C44.0918 9.81046 46.2018 7.41846 47.9928 6.51046C48.8888 6.05646 49.2298 6.24046 49.9648 6.79046C51.4228 7.88346 54.5348 11.1115 55.7398 12.5695C56.2518 13.1895 57.0138 14.0275 56.8038 14.8825C56.4548 16.3095 53.2058 19.3245 52.3728 20.7775L52.2998 21.2385L53.9418 25.0815C56.1448 25.5175 58.5388 25.5945 60.7158 26.0795C61.7278 26.3045 62.4238 26.3575 62.5738 27.5845C62.7458 28.9845 62.7908 35.7955 62.5208 37.0015C62.4198 37.4515 61.9898 37.9735 61.5638 38.1455L54.0968 39.2915L52.3158 43.1015C52.4008 43.6895 55.8288 47.4965 56.4368 48.4265C56.7098 48.8455 57.1428 49.2885 57.0668 49.8095C56.9108 50.8815 52.1848 55.5885 51.1208 56.4835C50.6078 56.9155 49.4198 57.9105 48.7888 57.9455C47.4228 58.0215 42.6308 53.1005 41.9688 53.2035L38.4438 54.6255C37.9958 56.8215 37.9948 59.1355 37.4678 61.3165C37.2928 62.0395 37.1848 62.8585 36.5118 63.3015L26.1618 63.3655C25.9548 63.3145 25.7598 63.2295 25.5988 63.0885C24.7338 62.3355 24.6758 56.1085 23.9118 54.6915L20.2848 53.3675L14.5338 57.7085C13.2988 58.5105 11.8918 56.8725 10.9858 56.0635C9.78481 54.9925 8.02381 53.2805 6.99681 52.0695C6.17181 51.0965 5.27881 50.3325 5.79881 48.9735C6.22681 47.8565 10.2638 43.6435 10.1618 43.0225L8.36281 39.1485C6.16381 38.5815 3.59581 38.6305 1.42081 38.1085C0.869812 37.9755 0.387813 37.8865 0.0718125 37.3565L0.0078125 27.0075C0.201813 26.1605 0.903812 26.0685 1.63181 25.9015C3.78881 25.4055 6.33981 25.3275 8.54481 24.9365L10.0138 20.9185L5.66181 15.3825C5.41481 15.0135 5.36981 14.6265 5.45981 14.1965C5.66881 13.2045 9.69681 9.11846 10.6728 8.26246C11.3858 7.63746 12.9728 6.15546 13.8778 6.30546C15.1348 6.51346 19.8558 11.1185 20.4058 11.0695L24.0248 9.43046C24.3798 7.97846 24.6568 1.71946 25.7178 1.03946C26.0578 0.820456 26.3608 0.832456 26.7368 0.798456C28.6228 0.626456 34.2378 0.534456 35.9778 0.820456C36.6008 0.922456 36.9268 1.17746 37.1418 1.75746C37.5748 2.92546 38.0488 9.25646 38.4568 9.58246Z", fill: "#FFFFFF" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("clipPath", { id: "clip0_396_191", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "130.42", height: "267.01", fill: "white", transform: "translate(14.2988 74.8398)" }) }) })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute bottom-0 w-[15vh]
        ${type === VehicleType.CAR ? "-right-[2.275vh] h-[7.25vh]" : "-right-[.1vh] h-[6.25vh]"}
        `, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        className: "size-full",
        viewBox: "0 0 158 350",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 349.013H39.202C55.902 320.934 61.249 311.488 66.342 301.902H28.347C22.871 311.508 17.123 320.955 0 349.013Z", fill: "#FF000066" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M37.9824 284.254H75.3324C84.5284 265.4 92.7004 246.013 99.7744 226.152H64.0674C56.5164 246.067 47.7954 265.457 37.9824 284.254Z", fill: "#FF910066" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M70.4062 208.499H105.734C111.573 190.199 116.489 171.524 120.437 152.523H86.0142C81.8232 171.555 76.6033 190.231 70.4062 208.499Z", fill: "#E0FF0066" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M89.5918 134.873H123.814C126.842 117.493 129.051 99.856 130.424 82H96.5918C95.1388 99.873 92.7958 117.511 89.5918 134.873Z", fill: "#00FF0666" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "fuel-level-1",
              d: "M0 349.013H39.202C55.902 320.934 61.249 311.488 66.342 301.902H28.347C22.871 311.508 17.123 320.955 0 349.013Z",
              fill: "#FF0000",
              initial: { opacity: 0 },
              animate: { opacity: getFuelLevel() >= 1 ? fuelLevel <= 20 ? isLowValue.fuelLevel ? 0.5 : 1 : 1 : 0 },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "fuel-level-2",
              d: "M37.9824 284.254H75.3324C84.5284 265.4 92.7004 246.013 99.7744 226.152H64.0674C56.5164 246.067 47.7954 265.457 37.9824 284.254Z",
              fill: "#FF9100",
              initial: { opacity: 0 },
              animate: { opacity: getFuelLevel() >= 2 ? 1 : 0 },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "fuel-level-3",
              d: "M70.4062 208.499H105.734C111.573 190.199 116.489 171.524 120.437 152.523H86.0142C81.8232 171.555 76.6033 190.231 70.4062 208.499Z",
              fill: "#E0FF00",
              initial: { opacity: 0 },
              animate: { opacity: getFuelLevel() >= 3 ? 1 : 0 },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.path,
            {
              id: "fuel-level-4",
              d: "M89.5918 134.873H123.814C126.842 117.493 129.051 99.856 130.424 82H96.5918C95.1388 99.873 92.7958 117.511 89.5918 134.873Z",
              fill: "#00FF06",
              initial: { opacity: 0 },
              animate: { opacity: getFuelLevel() >= 4 ? 1 : 0 },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M148.586 17.7122C144.279 18.2962 144.788 24.9222 149.308 24.6972C153.961 24.4652 153.396 17.0592 148.586 17.7122ZM128.044 24.6982V7.26516L127.904 7.12516H107.011V24.6982H128.044ZM135.055 31.7092H139.308C140.43 31.7092 142.346 32.7012 143.188 33.4372C145.983 35.8802 145.482 38.5032 145.52 41.8552C145.552 44.6812 145.523 47.5412 145.519 50.3542C145.516 53.0222 144.915 57.6152 148.656 57.9762C151.455 58.2462 152.515 56.1522 152.632 53.7272C152.932 47.5102 152.612 40.8072 152.632 34.5642C152.638 32.7932 152.513 31.0522 152.628 29.2792C151.759 29.4642 150.955 29.8582 150.056 29.9322C139.986 30.7542 136.375 17.2562 145.768 13.1152C145.857 13.0762 145.932 13.1702 145.897 12.9682L138.613 5.59516L142.283 1.99716L155.2 14.7892C156.819 16.6332 157.726 18.5122 157.867 21.0022L157.862 54.8442C156.979 65.9112 141.284 66.0052 140.29 54.9372L140.289 36.9442H135.055V63.1642H100V6.33016C100 5.95916 100.384 4.83516 100.544 4.44416C101.705 1.61516 104.507 0.0601596 107.522 0.11016C114.238 0.38416 121.223 -0.23984 127.908 0.10916C130.565 0.24816 132.858 1.38616 134.168 3.75816C134.505 4.36816 135.055 5.74816 135.055 6.42416V31.7092Z", fill: "#FFFFFF" })
        ]
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          absolute left-1/2 -translate-x-1/2 -translate-y-1/2
          ${type === VehicleType.CAR ? "top-[61.5%]" : "top-[46%]"}
        `,
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: `text-[#FFFDE980] font-bold
          ${type === VehicleType.CAR ? "text-[9vh]" : "text-[7.5vh]"}
          `,
              style: {
                fontFamily: font
              },
              children: "0".repeat(3 - getSpeedValue().toString().length)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: `text-white font-bold
          ${type === VehicleType.CAR ? "text-[9vh]" : "text-[7.5vh]"}
          `,
              style: {
                fontFamily: font
              },
              children: getSpeedValue()
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          absolute left-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center gap-[.1vh]
          ${type === VehicleType.CAR ? "-bottom-[.15vh]" : type === VehicleType.AIR ? "bottom-[2.55vh]" : "bottom-[2.1vh]"}
        `,
        children: [
          type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              className: "w-[4.35vh] h-[1.35vh]",
              viewBox: "0 0 127 80",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              style: ShadowStyle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M47.2098 26.3914V10.6634L46.4388 10.2594L8.19082 39.5084L46.4538 69.4134L47.2098 69.0284V52.9214H119.599V26.3914H47.2098ZM54.0318 19.5694H122.82C124.469 19.5694 126.287 22.2604 126.438 23.9104C127.374 34.1144 125.721 45.7614 126.399 56.1214C126.368 57.3344 123.856 59.7434 122.82 59.7434H54.0318V73.1974C54.0318 73.4854 53.4518 75.7814 53.2948 76.2504C52.0938 79.8584 49.8998 79.6334 46.8548 78.1004L3.82582 45.3304C0.103819 42.2324 -0.0861814 38.0404 3.28682 34.5804L47.0888 1.06741C49.9248 -0.632588 52.0898 0.082412 53.1878 3.16841C53.3918 3.74141 54.0318 6.08441 54.0318 6.49441V19.5694Z", fill: "#FFFFFF99" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "indicator-left",
                    d: "M47.2098 26.3914V10.6634L46.4388 10.2594L8.19082 39.5084L46.4538 69.4134L47.2098 69.0284V52.9214H119.599V26.3914H47.2098ZM54.0318 19.5694H122.82C124.469 19.5694 126.287 22.2604 126.438 23.9104C127.374 34.1144 125.721 45.7614 126.399 56.1214C126.368 57.3344 123.856 59.7434 122.82 59.7434H54.0318V73.1974C54.0318 73.4854 53.4518 75.7814 53.2948 76.2504C52.0938 79.8584 49.8998 79.6334 46.8548 78.1004L3.82582 45.3304C0.103819 42.2324 -0.0861814 38.0404 3.28682 34.5804L47.0888 1.06741C49.9248 -0.632588 52.0898 0.082412 53.1878 3.16841C53.3918 3.74141 54.0318 6.08441 54.0318 6.49441V19.5694Z",
                    fill: "#FFFFFF",
                    initial: { opacity: 0 },
                    animate: {
                      opacity: indicators === 1 || indicators === 3 ? isBlinking ? 1 : 0.5 : 1
                    },
                    transition: { duration: 0.3 }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "flex items-center gap-[1.15vh]",
              style: ShadowStyle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    className: `text-white font-medium uppercase -ml-[.15vw] -mr-[.15vw]
            ${type === VehicleType.CAR ? "text-[2vh]" : type === VehicleType.AIR ? "text-[1.35vh]" : "text-[1.65vh]"}
            `,
                    style: {
                      ...ShadowStyle,
                      fontFamily: font
                    },
                    children: getSpeedUnit()
                  }
                ),
                (type === VehicleType.CAR || type === VehicleType.AIR) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `w-[.2vh] bg-white
              ${type === VehicleType.CAR ? "h-[2vh]" : "h-[1.35vh]"}
              `,
                    style: ShadowStyle
                  }
                ),
                type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.span,
                  {
                    ...getGearAnimation(),
                    transition: { duration: 0.2 },
                    className: "text-white text-[2vh] font-medium",
                    style: {
                      fontFamily: font
                    },
                    children: currentGear === 0 ? "R" : currentGear
                  },
                  currentGear
                ) }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.65vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Icon$1,
                    {
                      icon: "material-symbols:altitude",
                      className: "text-white text-[1.35vh]",
                      style: ShadowStyle
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "span",
                    {
                      className: "text-white text-[1.35vh] font-medium",
                      style: {
                        ...ShadowStyle,
                        fontFamily: font
                      },
                      children: [
                        altitude,
                        " ft."
                      ]
                    }
                  )
                ] }) : null
              ]
            }
          ),
          type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              className: "w-[4.35vh] h-[1.35vh]",
              viewBox: "0 0 127 80",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              style: ShadowStyle,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.43911 26.5672V53.0972H79.8281V69.2042L80.5841 69.5892L118.847 39.6842L80.5991 10.4352L79.8281 10.8392V26.5672H7.43911ZM73.0061 6.67019C73.0061 6.26019 73.6451 3.91719 73.8491 3.34419C74.9481 0.258193 77.1121 -0.456807 79.9481 1.24319L123.75 34.7562C127.124 38.2162 126.934 42.4082 123.212 45.5062L80.1831 78.2762C77.1371 79.8092 74.9431 80.0342 73.7421 76.4262C73.5861 75.9572 73.0061 73.6612 73.0061 73.3732V59.9192H4.21811C3.18111 59.9192 0.669107 57.5102 0.639107 56.2972C1.31611 45.9372 -0.335893 34.2902 0.599107 24.0862C0.750107 22.4362 2.56911 19.7452 4.21811 19.7452H73.0061V6.67019Z", fill: "#FFFFFF99" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "indicator-right",
                    d: "M7.43911 26.5672V53.0972H79.8281V69.2042L80.5841 69.5892L118.847 39.6842L80.5991 10.4352L79.8281 10.8392V26.5672H7.43911ZM73.0061 6.67019C73.0061 6.26019 73.6451 3.91719 73.8491 3.34419C74.9481 0.258193 77.1121 -0.456807 79.9481 1.24319L123.75 34.7562C127.124 38.2162 126.934 42.4082 123.212 45.5062L80.1831 78.2762C77.1371 79.8092 74.9431 80.0342 73.7421 76.4262C73.5861 75.9572 73.0061 73.6612 73.0061 73.3732V59.9192H4.21811C3.18111 59.9192 0.669107 57.5102 0.639107 56.2972C1.31611 45.9372 -0.335893 34.2902 0.599107 24.0862C0.750107 22.4362 2.56911 19.7452 4.21811 19.7452H73.0061V6.67019Z",
                    fill: "#FFFFFF",
                    initial: { opacity: 0 },
                    animate: {
                      opacity: indicators === 2 || indicators === 3 ? isBlinking ? 1 : 0.5 : 1
                    },
                    transition: { duration: 0.3 }
                  }
                )
              ]
            }
          )
        ]
      }
    ),
    type === VehicleType.AIR && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "absolute -bottom-[.25vh] left-1/2 -translate-x-1/2 w-[7vw] flex items-end justify-between",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar.png", className: "size-[3.35vh]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar1.png", className: "size-[3.35vh]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar2.png", className: "size-[3.35vh]" })
        ]
      }
    ),
    type === VehicleType.BOAT && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "absolute bottom-0 left-1/2 -translate-x-1/2 w-[8.25vw] flex items-end justify-between",
        style: ShadowStyle,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar3.png", className: "size-[3.85vh]" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "size-[2.65vh] border-[.25vh] border-white rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: themeIcons?.vehicle.boatWheel,
              className: "text-white text-[1.35vh] animate-spin-slow"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar7.png", className: "size-[3.85vh]" })
        ]
      }
    ),
    nos?.toggle && type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "absolute bottom-0 left-1/2 -translate-x-1/2 w-[18.25vh] h-[.5vh] rounded-[2vh] bg-white",
        style: ShadowStyle,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            className: "h-full bg-[#FF9D00] rounded-[2vh]",
            initial: { width: "0%" },
            animate: { width: `${nos?.value ?? 0}%` },
            transition: { duration: 0.3, ease: "easeOut" }
          }
        )
      }
    )
  ] });
}

function DigitalSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    // maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const [prevGear, setPrevGear] = reactExports.useState(currentGear ?? 0);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if ((fuelLevel ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if ((engineHealth ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (indicators > 0) {
        setIsBlinking((prev) => !prev);
      } else {
        setIsBlinking(false);
      }
    }, 500);
    return () => clearInterval(interval);
  }, [indicators]);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear ?? 0);
      }, 300);
    }
  }, [currentGear, prevGear]);
  const config = useConfigStore((state) => state.config);
  const baseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font?.[SpeedometerThemes.DIGITAL]?.type);
  const maxSpeed = 100;
  const totalItems = 34;
  const litItems = Math.floor(speed / maxSpeed * totalItems);
  const getSpeedValue = () => {
    return Math.floor(speed).toString();
  };
  const getSpeedUnit = () => {
    return config.mph ? "mph" : "km/h";
  };
  const getRpmColor = () => {
    if (rpm >= 70) return "#ff3333";
    if (rpm >= 40) return "#E0FF00";
    return "white";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-end", children: [
    type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh] -mb-[2.75vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: handBrake ? "nui://envi-hud/web/build/images/d&h-handbrake-on.png" : "nui://envi-hud/web/build/images/d&h-handbrake-off.png",
          alt: "handbrake",
          className: "w-[3.5vh] h-[2.75vh]",
          animate: {
            opacity: handBrake ? 1 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: indicators === 3 ? "nui://envi-hud/web/build/images/d&h-hazards-on.png" : "nui://envi-hud/web/build/images/d&h-hazards-off.png",
          alt: "hazards",
          className: "w-[3vh] h-[2.75vh]",
          animate: {
            opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: "nui://envi-hud/web/build/images/d&h-headlights.png",
          alt: "headlights",
          className: "w-[3.15vh] h-[2.15vh]",
          animate: {
            opacity: headlights === 2 ? 1 : headlights === 1 ? 0.75 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.img,
        {
          src: isHarness ? "nui://envi-hud/web/build/images/d&h-harness.png" : seatbelt ? "nui://envi-hud/web/build/images/d&h-seatbelt-on.png" : "nui://envi-hud/web/build/images/d&h-seatbelt-off.png",
          alt: "seatbelt",
          className: `
              ${seatbelt ? "size-[3vh]" : "w-[2.5vh] h-[2.85vh]"}
            `,
          animate: {
            opacity: seatbelt ? 1 : 0.5
          },
          transition: { duration: 0.3 },
          style: ShadowStyle
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `
        flex gap-[.5vh] -mr-[.85vw] -mb-[2vh]
        ${type === VehicleType.CAR ? "items-center" : "items-end"}
      `, children: [
      type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.35vh] -mb-[.5vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.span,
            {
              id: "indicator-left",
              className: "text-[#ED2E24] text-[3vh] font-bold",
              animate: {
                opacity: indicators === 1 || indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
              },
              transition: { duration: 0.3 },
              style: ShadowStyle,
              children: "<"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.span,
            {
              id: "indicator-right",
              className: "text-[#ED2E24] text-[3vh] font-bold",
              animate: {
                opacity: indicators === 2 || indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
              },
              transition: { duration: 0.3 },
              style: ShadowStyle,
              children: ">"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "size-[3vh] rounded-full border-[.25vh] border-[#22B573] flex items-center justify-center overflow-hidden",
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.span,
              {
                initial: {
                  y: isAnimating ? currentGear > prevGear ? -10 : 10 : 0,
                  opacity: 0
                },
                animate: {
                  y: 0,
                  opacity: 1
                },
                exit: {
                  y: isAnimating ? currentGear > prevGear ? 10 : -10 : 0,
                  opacity: 0
                },
                transition: {
                  y: {
                    type: "spring",
                    stiffness: 500,
                    damping: 30,
                    mass: 0.8
                  },
                  opacity: {
                    duration: 0.15
                  }
                },
                className: "text-[#22B573] text-[2vh] font-bold -mt-[.15vh]",
                children: currentGear === 0 ? "R" : currentGear
              },
              currentGear
            ) })
          }
        )
      ] }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-[2.75vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "text-white text-[2vh]",
          style: {
            fontFamily: font
          },
          children: [
            altitude,
            "ft"
          ]
        }
      ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "mb-[3.25vh] size-[3vh] rounded-full border-[.25vh] border-white flex items-center justify-center overflow-hidden",
          style: ShadowStyle,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon: themeIcons?.vehicle?.boatWheel,
              className: "text-white text-[1.65vh] animate-spin-slow"
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-[7.25vw] flex items-center justify-center text-[8vh] mt-[1.25vh] -mr-[.35vw]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "font-normal text-white/40 mr-0",
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: "0".repeat(3 - getSpeedValue().length)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "font-normal text-white",
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: getSpeedValue()
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: `
            text-white font-normal text-[2vh] mr-[1vw]
            ${type === VehicleType.CAR ? "-mb-[.5vh] mt-[.5vh]" : "mb-[2.75vh]"}
          `,
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: getSpeedUnit()
          }
        ),
        type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/d&h-cruise-control.png", alt: "cruise control", className: "size-[2.75vh] -mb-[.5vh]", style: ShadowStyle }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `font-normal text-[2vh] mr-[1vw] ${cruiseControl ? "text-white" : "text-white/40"}`, style: {
            ...ShadowStyle,
            fontFamily: font
          }, children: cruiseControl ? "on" : "off" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[2vh] flex items-center mb-[.75vh]", style: ShadowStyle, children: [...Array(34)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: `w-[.5vh] h-full transform -skew-x-[20deg] ${i < litItems ? "bg-white" : "bg-[#FFFFFF95]"} ml-[.15vh] rounded-[1vh] first:ml-0`
      },
      `speedometer-${i + 1}`
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start gap-[.5vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[12.5vw] h-[.35vh] rounded-[.1vh] bg-[#ECECEC]/50", style: ShadowStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "h-full rounded-[.1vh]",
          initial: { width: 0 },
          animate: {
            width: `${rpm}%`,
            backgroundColor: getRpmColor()
          },
          transition: { duration: 0.5 }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[8.5vw] h-[.35vh] rounded-[.1vh] bg-[#ECECEC]/50", style: ShadowStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "h-full rounded-[.1vh]",
          initial: { width: 0 },
          animate: {
            width: `${engineHealth}%`,
            backgroundColor: (engineHealth ?? 0) <= 20 ? "#ff3333" : "white",
            opacity: (engineHealth ?? 0) <= 20 ? isLowValue.engineHealth ? 0.5 : 1 : 1
          },
          transition: { duration: 0.5 }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[8.5vw] h-[.35vh] rounded-[.1vh] bg-[#ECECEC]/50", style: ShadowStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "h-full rounded-[.1vh]",
          initial: { width: 0 },
          animate: {
            width: `${fuelLevel}%`,
            backgroundColor: (fuelLevel ?? 0) <= 20 ? "#ff3333" : "white",
            opacity: (fuelLevel ?? 0) <= 20 ? isLowValue.fuelLevel ? 0.5 : 1 : 1
          },
          transition: { duration: 0.5 }
        }
      ) }),
      nos.toggle && type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[8.5vw] h-[.35vh] rounded-[.1vh] bg-[#ECECEC]/50", style: ShadowStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          className: "h-full bg-white rounded-[.1vh]",
          initial: { width: 0 },
          animate: { width: `${nos.value}%` },
          transition: { duration: 0.5 }
        }
      ) })
    ] })
  ] });
}

function HologramSpeedometer(props) {
  const {
    type = VehicleType.CAR,
    fuelLevel = 0,
    engineHealth = 0,
    seatbelt = false,
    isHarness = false,
    cruiseControl = false,
    headlights = 0,
    indicators = 1,
    // 1 = left, 2 = right, 3 = hazards
    speed = 0,
    currentGear = 0,
    rpm = 0,
    // maxSpeedForCruise = 0,
    handBrake = false,
    altitude = 0,
    nos = {
      toggle: false,
      value: 0
    },
    themeStyle: _themeStyle,
    themeIcons
  } = props;
  const baseStyle = HudBaseStyles.vehicle;
  const font = getFontFamily(defaultBaseStyle.fonts, baseStyle.font?.[SpeedometerThemes.HOLOGRAM]?.type);
  const [isBlinking, setIsBlinking] = reactExports.useState(false);
  const [isLowValue, setIsLowValue] = reactExports.useState({
    fuelLevel: false,
    engineHealth: false
  });
  const [prevGear, setPrevGear] = reactExports.useState(currentGear ?? 0);
  const [isAnimating, setIsAnimating] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if (indicators > 0) {
        setIsBlinking((prev) => !prev);
      } else {
        setIsBlinking(false);
      }
    }, 500);
    return () => clearInterval(interval);
  }, [indicators]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      if ((fuelLevel ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: !prev.fuelLevel }));
      } else {
        setIsLowValue((prev) => ({ ...prev, fuelLevel: false }));
      }
      if ((engineHealth ?? 0) <= 20) {
        setIsLowValue((prev) => ({ ...prev, engineHealth: !prev.engineHealth }));
      } else {
        setIsLowValue((prev) => ({ ...prev, engineHealth: false }));
      }
    }, 500);
    return () => clearInterval(interval);
  }, [fuelLevel, engineHealth]);
  reactExports.useEffect(() => {
    if (currentGear !== prevGear) {
      setIsAnimating(true);
      setTimeout(() => {
        setIsAnimating(false);
        setPrevGear(currentGear ?? 0);
      }, 300);
    }
  }, [currentGear, prevGear]);
  const config = useConfigStore((state) => state.config);
  const getSpeedValue = () => {
    return Math.floor(speed).toString();
  };
  const getSpeedUnit = () => {
    return config.mph ? "mph" : "km/h";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-[1.65vh]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-end", children: [
      type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start justify-center gap-[.65vh] -mb-[6.25vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-center mr-[6vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.img,
            {
              src: cruiseControl ? "nui://envi-hud/web/build/images/d&h-cruise-control.png" : "nui://envi-hud/web/build/images/d&h-cruise-control.png",
              alt: "Cruise Control",
              className: "size-[3.25vh]",
              animate: {
                opacity: cruiseControl ? 1 : 0.5
              },
              transition: { duration: 0.3 },
              style: ShadowStyle
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `uppercase text-[2.25vh] ${cruiseControl ? "text-white" : "text-white/50"}`, style: {
            ...ShadowStyle,
            fontFamily: font
          }, children: cruiseControl ? "on" : "off" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: "nui://envi-hud/web/build/images/d&h-headlights.png",
            alt: "Headlights",
            className: "w-[3.75vh] h-[2.75vh]",
            animate: {
              opacity: headlights === 2 ? 1 : headlights === 1 ? 0.75 : 0.5
            },
            transition: { duration: 0.3 },
            style: ShadowStyle
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.img,
          {
            src: isHarness ? "nui://envi-hud/web/build/images/d&h-harness.png" : seatbelt ? "nui://envi-hud/web/build/images/d&h-seatbelt-on.png" : "nui://envi-hud/web/build/images/d&h-seatbelt-off.png",
            alt: "Seatbelt",
            className: `
                ${seatbelt ? "size-[3vh]" : "w-[2.5vh] h-[2.85vh]"}
              `,
            animate: {
              opacity: seatbelt ? 1 : 0.5
            },
            transition: { duration: 0.3 },
            style: ShadowStyle
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `
          tracking-[.2vw] gap-[3vh]
          ${type === VehicleType.CAR ? "-mb-[4.35vh]" : "-mb-[3.35vh]"}
          ${type === VehicleType.CAR || type === VehicleType.AIR ? "-skew-x-[5deg]" : ""}
        `, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "uppercase text-[9vh] text-white/20 mr-0",
            style: {
              ...ShadowStyle,
              fontFamily: font
            },
            children: "0".repeat(3 - getSpeedValue().length)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "uppercase text-[9vh] text-white", style: {
          ...ShadowStyle,
          fontFamily: font
        }, children: getSpeedValue() })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `
            flex items-center
            ${type === VehicleType.CAR ? "gap-[.85vh]" : "gap-[1.75vh]"}
          `,
          children: [
            type === VehicleType.CAR ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.15vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.span,
                  {
                    id: "indicator-left",
                    className: `${indicators === 1 || indicators === 3 ? "text-[#ED2E24]" : "text-white/20"} text-[5.75vh]`,
                    animate: {
                      opacity: indicators === 1 || indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
                    },
                    transition: { duration: 0.3 },
                    style: {
                      ...ShadowStyle,
                      fontFamily: font
                    },
                    children: "<"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.span,
                  {
                    id: "indicator-right",
                    className: `${indicators === 2 || indicators === 3 ? "text-[#ED2E24]" : "text-white/20"} text-[5.75vh]`,
                    animate: {
                      opacity: indicators === 2 || indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
                    },
                    transition: { duration: 0.3 },
                    style: {
                      ...ShadowStyle,
                      fontFamily: font
                    },
                    children: ">"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.img,
                {
                  src: handBrake ? "nui://envi-hud/web/build/images/d&h-handbrake-on.png" : "nui://envi-hud/web/build/images/d&h-handbrake-off.png",
                  alt: "Handbrake",
                  className: "w-[3.5vh] h-[2.75vh]",
                  animate: {
                    opacity: handBrake ? 1 : 0.5
                  },
                  transition: { duration: 0.3 },
                  style: ShadowStyle
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.img,
                {
                  src: indicators === 3 ? "nui://envi-hud/web/build/images/d&h-hazards-on.png" : "nui://envi-hud/web/build/images/d&h-hazards-off.png",
                  alt: "Hazards",
                  className: "w-[3.25vh] h-[2.75vh]",
                  animate: {
                    opacity: indicators === 3 ? isBlinking ? 1 : 0.5 : 0.5
                  },
                  transition: { duration: 0.3 },
                  style: ShadowStyle
                }
              )
            ] }) : type === VehicleType.AIR ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh] mb-[.5vh] -skew-x-[5deg]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: "material-symbols:altitude",
                    className: "text-white text-[2.5vh]"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    className: "text-[2.5vh] text-white",
                    style: {
                      fontFamily: font
                    },
                    children: [
                      altitude,
                      " ft."
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[2.5vh] w-[.2vh] bg-white rounded-full -skew-x-[5deg] -ml-[.5vw] mb-[.5vh]" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1vh] mb-[.5vh]", style: ShadowStyle, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.85vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "size-[2.85vh] rounded-full border-[.1vh] border-white flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: themeIcons?.vehicle?.boatWheel,
                    className: "text-white text-[1.75vh] animate-spin-slow"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/radar7.png", alt: "Radar", className: "size-[2.75vh]" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-[2.75vh] w-[.2vh] bg-white rounded-full mb-[.5vh]" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-end -ml-[.65vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `
              text-white text-[2.5vh] uppercase
              ${type === VehicleType.CAR ? "-mb-[1.15vh]" : "mb-[.5vh]"}
              ${type === VehicleType.CAR || type === VehicleType.AIR ? "-skew-x-[5deg]" : ""}
            `, style: {
                ...ShadowStyle,
                fontFamily: font
              }, children: getSpeedUnit() }),
              type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", initial: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.span,
                {
                  initial: {
                    y: isAnimating ? currentGear > prevGear ? -10 : 10 : 0,
                    opacity: 0
                  },
                  animate: {
                    y: 0,
                    opacity: 1
                  },
                  exit: {
                    y: isAnimating ? currentGear > prevGear ? 10 : -10 : 0,
                    opacity: 0
                  },
                  transition: {
                    y: {
                      type: "spring",
                      stiffness: 500,
                      damping: 30,
                      mass: 0.8
                    },
                    opacity: {
                      duration: 0.15
                    }
                  },
                  className: "text-white text-[2.5vh] -skew-x-[5deg]",
                  style: {
                    ...ShadowStyle,
                    fontFamily: font
                  },
                  children: currentGear === 0 ? "R" : currentGear
                },
                currentGear
              ) })
            ] })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-[1vh] mb-[1.75vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          id: "rpm-bar",
          className: `
            relative w-[2.75vh] overflow-hidden
            ${type === VehicleType.CAR ? "h-[14.35vh]" : "h-[11.6vh]"}
          `,
          style: ShadowStyle,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-[#22B573] via-[#E0FF00] via-40% to-[#ff3333] to-70%" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "absolute top-0 inset-x-0 bg-[#4b4b4b]",
                initial: { height: "100%" },
                animate: {
                  height: `${100 - rpm}%`
                },
                transition: { duration: 0.5 }
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center flex-col gap-[.5vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/hologram-fuel.png", alt: "Fuel", className: "w-[1.4vh] h-[2.5vh]", style: ShadowStyle }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "fuel-bar", className: "relative w-[1.4vh] h-[8.5vh] bg-black/10 overflow-hidden", style: ShadowStyle, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 bg-gradient-to-t from-[#ff3333] via-[#E0FF00] via-40% to-[#22B573] to-70%",
              animate: {
                opacity: (fuelLevel ?? 0) <= 20 ? isLowValue.fuelLevel ? 0.5 : 1 : 1
              },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute top-0 inset-x-0 bg-[#4b4b4b]",
              initial: { height: "100%" },
              animate: {
                height: `${100 - fuelLevel}%`
              },
              transition: { duration: 0.5 }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center flex-col gap-[.5vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/hologram-engine.png", alt: "Engine", className: "w-[1.4vh] h-[2.5vh]", style: ShadowStyle }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "engine-bar", className: "relative w-[1.4vh] h-[8.5vh] bg-black/10 overflow-hidden", style: ShadowStyle, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 bg-gradient-to-t from-[#ff3333] via-[#E0FF00] via-40% to-[#22B573] to-70%",
              animate: {
                opacity: (engineHealth ?? 0) <= 20 ? isLowValue.engineHealth ? 0.5 : 1 : 1
              },
              transition: { duration: 0.3 }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute top-0 inset-x-0 bg-[#4b4b4b]",
              initial: { height: "100%" },
              animate: {
                height: `${100 - engineHealth}%`
              },
              transition: { duration: 0.5 }
            }
          )
        ] })
      ] }),
      nos?.toggle && type === VehicleType.CAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center flex-col gap-[.5vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "nui://envi-hud/web/build/images/hologram-nitrous.png", alt: "Nitrous", className: "w-[1.4vh] h-[2.5vh]", style: ShadowStyle }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { id: "nitrous-bar", className: "relative w-[1.4vh] h-[8.5vh] bg-black/10 overflow-hidden", style: ShadowStyle, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute inset-0 bg-gradient-to-t from-[#ff3333] via-[#E0FF00] via-40% to-[#22B573] to-70%"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            motion.div,
            {
              className: "absolute top-0 inset-x-0 bg-[#464646]",
              initial: { height: "100%" },
              animate: {
                height: `${100 - (nos.value ?? 0)}%`
              },
              transition: { duration: 0.5 }
            }
          )
        ] })
      ] })
    ] })
  ] });
}

function Speedometer(props) {
  const theme = useHudStore((state) => state.theme);
  const variant = useHudStore((state) => state.speedometerVariant) || SpeedometerThemes.DEFAULT;
  const themeStyle = VehicleStyles[theme];
  const themeIcons = HudIcons[theme];
  const commonProps = {
    ...props,
    themeStyle,
    themeIcons,
    defaultBaseStyle
  };
  switch (variant) {
    case SpeedometerThemes.MODERN:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ModernSpeedometer, { ...commonProps });
    case SpeedometerThemes.RETRO:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RetroSpeedometer, { ...commonProps });
    case SpeedometerThemes.PIXEL:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PixelSpeedometer, { ...commonProps });
    case SpeedometerThemes.CYBERPUNK_2:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Cyberpunk2Speedometer, { ...commonProps });
    case SpeedometerThemes.HALO_DASH:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HaloDashSpeedometer, { ...commonProps });
    case SpeedometerThemes.DIGITAL:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DigitalSpeedometer, { ...commonProps });
    case SpeedometerThemes.HOLOGRAM:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HologramSpeedometer, { ...commonProps });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultSpeedometer, { ...commonProps });
  }
}
function VehicleHud() {
  const vehicle = useHudStore((state) => state.vehicle);
  const variant = useHudStore((state) => state.speedometerVariant) || SpeedometerThemes.DEFAULT;
  const { elementsVisibility } = useSettingsStore((state) => state.hudSettings);
  const scale = useSettingsStore((state) => state.hudSettings.elementScales.vehicle) / 100;
  const animationProps = useHudAnimation();
  if (!vehicle.toggle || !elementsVisibility?.vehicle) return null;
  const baseStyle = HudBaseStyles.vehicle;
  const position = baseStyle?.container?.position[variant] || baseStyle?.container?.position[SpeedometerThemes.DEFAULT];
  const layout = baseStyle?.container?.layout[variant] || baseStyle?.container?.layout[SpeedometerThemes.DEFAULT];
  const gap = baseStyle?.container?.gap[variant] || baseStyle?.container?.gap[SpeedometerThemes.DEFAULT];
  const getTransformOrigin = () => {
    if (position.right) return "right center";
    if (position.left) return "left center";
    return "center";
  };
  return vehicle.toggle && /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "vehicle",
      className: "absolute",
      style: {
        bottom: position.bottom,
        right: position.right,
        left: position.left
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ...animationProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            width: "fit-content",
            position: "relative",
            transform: `scale(${scale})`,
            transformOrigin: getTransformOrigin()
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${layout} ${gap}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Speedometer,
            {
              type: vehicle.type ?? VehicleType.CAR,
              fuelLevel: vehicle.fuelLevel ?? 0,
              engineHealth: vehicle.engineHealth ?? 0,
              seatbelt: vehicle.seatbelt ?? false,
              isHarness: vehicle.isHarness ?? false,
              headlights: vehicle.headlights ?? 0,
              speed: vehicle.speed ?? 0,
              currentGear: vehicle.currentGear ?? 0,
              cruiseControl: vehicle.cruiseControl ?? false,
              rpm: vehicle.rpm ?? 0,
              maxSpeedForCruise: vehicle.maxSpeedForCruise ?? 0,
              handBrake: vehicle.handBrake ?? false,
              indicators: vehicle.indicators ?? 1,
              nos: vehicle.nos ?? { toggle: false, value: 0 },
              altitude: vehicle.altitude ?? 0
            }
          ) })
        }
      ) })
    }
  );
}

var isDevelopment$3 = false;

/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/

function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  } // this function should always return with a value
  // TS can't understand it though so we make it stop complaining here


  return undefined;
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? !isDevelopment$3 : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    this.tags.forEach(function (tag) {
      var _tag$parentNode;

      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();

var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';

var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var IMPORT = '@import';
var KEYFRAMES = '@keyframes';
var LAYER = '@layer';

/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {object}
 * @return {object}
 */
var assign = Object.assign;

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return charat(value, 0) ^ 45 ? (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3) : 0
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}

var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy$1 (root, props) {
	return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? charat(characters, --position) : 0;

	if (column--, character === 10)
		column = 1, line--;

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < length ? charat(characters, position++) : 0;

	if (column++, character === 10)
		column = 1, line++;

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next();
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character);
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type);
				break
			// \
			case 92:
				next();
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next();

	return slice(index, position)
}

/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = '';
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = type;

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && charat(characters, length - 1) == 58) {
					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1;
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character);
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous);
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7);
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						append(comment(commenter(next(), caret()), root, parent), declarations);
						break
					default:
						characters += '/';
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand;
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0;
					// ;
					case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
						if (property > 0 && (strlen(characters) - length))
							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
						break
					// @ ;
					case 59: characters += ';';
					// { rule/at-rule
					default:
						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

						if (character === 123)
							if (offset === 0)
								parse(characters, root, reference, reference, props, rulesets, length, points, children);
							else
								switch (atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule) {
									// d l m s
									case 100: case 108: case 109: case 115:
										parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
										break
									default:
										parse(characters, reference, reference, reference, [''], children, 0, points, children);
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous;
			default:
				if (variable < 1)
					if (character == 123)
						--variable;
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next());

						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0;
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [''];
	var size = sizeof(rule);

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
				props[k++] = z;

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
}

/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = '';
	var length = sizeof(children);

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || '';

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break
		case IMPORT: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
		case RULESET: element.value = element.props.join(',');
	}

	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = sizeof(collection);

	return function (element, index, children, callback) {
		var output = '';

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || '';

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element);
	}
}

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};

/* eslint-disable no-fallthrough */

function prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order

    case 6165:
      return WEBKIT + value + MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ':', ':' + WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return WEBKIT + value + MS + value + value;
  }

  return value;
}

var prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case DECLARATION:
      element["return"] = prefix(element.value, element.length);
      break;

    case KEYFRAMES:
      return serialize([copy$1(element, {
        value: replace(element.value, '@', '@' + WEBKIT)
      })], callback);

    case RULESET:
      if (element.length) return combine(element.props, function (value) {
        switch (match(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return serialize([copy$1(element, {
              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return serialize([copy$1(element, {
              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
            }), copy$1(element, {
              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
            }), copy$1(element, {
              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }

      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' ');

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

var reactIs$1 = {exports: {}};

var reactIs_production_min = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$6="function"===typeof Symbol&&Symbol.for,c$8=b$6?Symbol.for("react.element"):60103,d$6=b$6?Symbol.for("react.portal"):60106,e$6=b$6?Symbol.for("react.fragment"):60107,f$a=b$6?Symbol.for("react.strict_mode"):60108,g$5=b$6?Symbol.for("react.profiler"):60114,h$7=b$6?Symbol.for("react.provider"):60109,k$4=b$6?Symbol.for("react.context"):60110,l$5=b$6?Symbol.for("react.async_mode"):60111,m$7=b$6?Symbol.for("react.concurrent_mode"):60111,n$5=b$6?Symbol.for("react.forward_ref"):60112,p$5=b$6?Symbol.for("react.suspense"):60113,q$5=b$6?
Symbol.for("react.suspense_list"):60120,r$6=b$6?Symbol.for("react.memo"):60115,t$6=b$6?Symbol.for("react.lazy"):60116,v$4=b$6?Symbol.for("react.block"):60121,w$6=b$6?Symbol.for("react.fundamental"):60117,x$6=b$6?Symbol.for("react.responder"):60118,y$8=b$6?Symbol.for("react.scope"):60119;
function z$4(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c$8:switch(a=a.type,a){case l$5:case m$7:case e$6:case g$5:case f$a:case p$5:return a;default:switch(a=a&&a.$$typeof,a){case k$4:case n$5:case t$6:case r$6:case h$7:return a;default:return u}}case d$6:return u}}}function A$5(a){return z$4(a)===m$7}reactIs_production_min.AsyncMode=l$5;reactIs_production_min.ConcurrentMode=m$7;reactIs_production_min.ContextConsumer=k$4;reactIs_production_min.ContextProvider=h$7;reactIs_production_min.Element=c$8;reactIs_production_min.ForwardRef=n$5;reactIs_production_min.Fragment=e$6;reactIs_production_min.Lazy=t$6;reactIs_production_min.Memo=r$6;reactIs_production_min.Portal=d$6;
reactIs_production_min.Profiler=g$5;reactIs_production_min.StrictMode=f$a;reactIs_production_min.Suspense=p$5;reactIs_production_min.isAsyncMode=function(a){return A$5(a)||z$4(a)===l$5};reactIs_production_min.isConcurrentMode=A$5;reactIs_production_min.isContextConsumer=function(a){return z$4(a)===k$4};reactIs_production_min.isContextProvider=function(a){return z$4(a)===h$7};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c$8};reactIs_production_min.isForwardRef=function(a){return z$4(a)===n$5};reactIs_production_min.isFragment=function(a){return z$4(a)===e$6};reactIs_production_min.isLazy=function(a){return z$4(a)===t$6};
reactIs_production_min.isMemo=function(a){return z$4(a)===r$6};reactIs_production_min.isPortal=function(a){return z$4(a)===d$6};reactIs_production_min.isProfiler=function(a){return z$4(a)===g$5};reactIs_production_min.isStrictMode=function(a){return z$4(a)===f$a};reactIs_production_min.isSuspense=function(a){return z$4(a)===p$5};
reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e$6||a===m$7||a===g$5||a===f$a||a===p$5||a===q$5||"object"===typeof a&&null!==a&&(a.$$typeof===t$6||a.$$typeof===r$6||a.$$typeof===h$7||a.$$typeof===k$4||a.$$typeof===n$5||a.$$typeof===w$6||a.$$typeof===x$6||a.$$typeof===y$8||a.$$typeof===v$4)};reactIs_production_min.typeOf=z$4;

{
  reactIs$1.exports = reactIs_production_min;
}

var reactIsExports = reactIs$1.exports;

var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

var isBrowser = true;

function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};

/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

var isDevelopment$2 = false;

var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  var componentSelector = interpolation;

  if (componentSelector.__emotion_styles !== undefined) {

    return componentSelector;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        var keyframes = interpolation;

        if (keyframes.anim === 1) {
          cursor = {
            name: keyframes.name,
            styles: keyframes.styles,
            next: cursor
          };
          return keyframes.name;
        }

        var serializedStyles = interpolation;

        if (serializedStyles.styles !== undefined) {
          var next = serializedStyles.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = serializedStyles.styles + ";";
          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }

        break;
      }
  } // finalize string values (regular strings and functions interpolated into css calls)


  var asString = interpolation;

  if (registered == null) {
    return asString;
  }

  var cached = registered[asString];
  return cached !== undefined ? cached : asString;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];

      if (typeof value !== 'object') {
        var asString = value;

        if (registered != null && registered[asString] !== undefined) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === 'NO_COMPONENT_SELECTOR' && isDevelopment$2) {
          throw new Error(noComponentSelectorMessage);
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }

            default:
              {

                string += key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g; // this is the cursor for keyframes
// keyframes are stored on the SerializedStyles object as a linked list

var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;

    styles += asTemplateStringsArr[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {
      var templateStringsArr = strings;

      styles += templateStringsArr[i];
    }
  } // using a global regex with .exec is stateful so lastIndex has to be reset each time


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + match[1];
  }

  var name = murmur2(styles) + identifierName;

  return {
    name: name,
    styles: styles,
    next: cursor
  };
}

var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect$1 = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect$1 || syncFallback;

var isDevelopment$1 = false;

var EmotionCacheContext = /* #__PURE__ */reactExports.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
  key: 'css'
}) : null);

EmotionCacheContext.Provider;

var withEmotionCache = function withEmotionCache(func) {
  return /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
    // the cache will never be null in the browser
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext = /* #__PURE__ */reactExports.createContext({});

var hasOwn = {}.hasOwnProperty;

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {

  var newProps = {};

  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }

  newProps[typePropName] = type; // Runtime labeling is an opt-in feature because:

  return newProps;
};

var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, reactExports.useContext(ThemeContext));

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== 'css' && _key2 !== typePropName && (!isDevelopment$1 )) {
      newProps[_key2] = props[_key2];
    }
  }

  newProps.className = className;

  if (ref) {
    newProps.ref = ref;
  }

  return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion$1, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/reactExports.createElement(WrappedComponent, newProps));
});

var Emotion$1 = Emotion;

var jsx$1 = function jsx(type, props, key) {
  if (!hasOwn.call(props, 'css')) {
    return jsxRuntimeExports.jsx(type, props, key);
  }

  return jsxRuntimeExports.jsx(Emotion$1, createEmotionProps(type, props), key);
};
var jsxs = function jsxs(type, props, key) {
  if (!hasOwn.call(props, 'css')) {
    return jsxRuntimeExports.jsxs(type, props, key);
  }

  return jsxRuntimeExports.jsxs(Emotion$1, createEmotionProps(type, props), key);
};

function DashboardButton({
  children,
  icon,
  className,
  css,
  onClick
}) {
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  return /* @__PURE__ */ jsxs(
    "button",
    {
      className: `
        flex items-center gap-[.85vh]
        px-[1.1vw] py-[1vh] border-[.1vh] 
        rounded-[.75vh]
        transition-all duration-250
        ${className}
      `,
      css,
      onClick,
      children: [
        /* @__PURE__ */ jsx$1(Icon$1, { icon, className: "text-[1.75vh]" }),
        /* @__PURE__ */ jsx$1(
          "span",
          {
            className: "text-[1.45vh]",
            style: {
              fontFamily: font
            },
            children
          }
        )
      ]
    }
  );
}

var jsx = function jsx(type, props) {
  // eslint-disable-next-line prefer-rest-params
  var args = arguments;

  if (props == null || !hasOwn.call(props, 'css')) {
    return reactExports.createElement.apply(undefined, args);
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }

  return reactExports.createElement.apply(null, createElementArgArray);
};

(function (_jsx) {
  var JSX;

  (function (_JSX) {})(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));

function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return serializeStyles(args);
}

function DragModeMenu() {
  const {
    toggleDraggable,
    setSettingsVisible,
    setAdminSettingsVisible,
    resetElementPositions,
    elementPositions,
    hudSettings,
    wasAdminMode
  } = useSettingsStore();
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  const handleExitDragMode = () => {
    if (wasAdminMode) {
      setAdminSettingsVisible(true);
    } else {
      setSettingsVisible(true);
    }
    toggleDraggable();
  };
  const handleResetPositions = () => {
    resetElementPositions();
    if (elementPositions["minimap"]) {
      const defaultBuffer = MinimapBufferSize[hudSettings.minimap.type][hudSettings.minimap.size];
      fetchNui("updateMinimap", {
        type: hudSettings.minimap.type,
        size: MinimapSizePixels[hudSettings.minimap.type][hudSettings.minimap.size],
        position: { x: 0, y: 0 },
        buffer: {
          x: hudSettings.minimap.buffer?.x ?? defaultBuffer.x,
          y: hudSettings.minimap.buffer?.y ?? defaultBuffer.y
        }
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      initial: { y: "2vh", opacity: 0 },
      animate: { y: 0, opacity: 1 },
      exit: { y: "2vh", opacity: 0 },
      transition: { type: "spring", stiffness: 300, damping: 30 },
      className: "absolute bottom-[2vh] left-[37.15%] z-[999]\r\n                 border-[.1vh]\r\n                 rounded-[.65vh] px-[1.25vh] py-[1.05vh] flex items-center gap-[2.5vh]",
      style: {
        background: SettingsStyles.dragModeMenu.background,
        backdropFilter: SettingsStyles.dragModeMenu.backdropFilter,
        borderColor: SettingsStyles.dragModeMenu.borderColor
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "font-medium text-[1.35vh]",
            style: {
              fontFamily: font,
              color: SettingsStyles.dragModeMenu.titleColor
            },
            children: localesConfig.hud.dragMode.title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardButton,
            {
              className: "text-[1.15vh] px-[.85vw] py-[1.05vh]",
              icon: "ion:refresh-outline",
              onClick: handleResetPositions,
              css: css`
            background: ${SettingsStyles.button.action.background};
            border-color: ${SettingsStyles.button.action.borderColor};
            color: ${SettingsStyles.button.action.textColor};
            &:hover {
              background: ${SettingsStyles.button.action.hoverBackground};
              border-color: ${SettingsStyles.button.action.hoverBorderColor};
            }
          `,
              children: localesConfig.hud.dragMode.buttons.reset
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardButton,
            {
              className: "text-[1.15vh] px-[.85vw] py-[1.05vh]",
              icon: "healthicons:no-outline",
              onClick: handleExitDragMode,
              css: css`
            background: ${SettingsStyles.button.cancel.background};
            border-color: ${SettingsStyles.button.cancel.borderColor};
            color: ${SettingsStyles.button.cancel.textColor};
            &:hover {
              background: ${SettingsStyles.button.cancel.hoverBackground};
              border-color: ${SettingsStyles.button.cancel.hoverBorderColor};
            }
          `,
              children: localesConfig.hud.dragMode.buttons.exit
            }
          )
        ] })
      ]
    }
  );
}

function DraggableMinimap({ settings }) {
  const { hudSettings, isVisible, isAdminVisible } = useSettingsStore();
  const handleDragEnd = (position) => {
    fetchNui("updateMinimap", {
      position,
      type: settings.type,
      size: MinimapSizePixels[settings.type][settings.size],
      buffer: settings.buffer || MinimapBufferSize[settings.type][settings.size]
    });
  };
  if (!hudSettings?.isDraggable && !isVisible && !isAdminVisible) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DraggableElement,
    {
      elementId: "minimap",
      className: `absolute bottom-[9.25vh] left-[2.25vw]
        pointer-events-auto
        ${settings.type === "circle" ? "rounded-full" : "rounded-lg"}
        bg-white/5
        border-2 border-dashed border-white/50
        flex items-center justify-center
      `,
      onDragEnd: handleDragEnd,
      style: { width: `${MinimapSizePixels[settings.type][settings.size].width}px`, height: `${MinimapSizePixels[settings.type][settings.size].height}px` },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon: "mdi:map",
          className: "text-white/80 text-[3vh]"
        }
      )
    }
  );
}

function DefaultTheme({ progress = 0 }) {
  const progressBarSettings = useHudStore((state) => state.progressBarSettings);
  const progressBar = useHudStore((state) => state.progressBar);
  const progressBarTheme = progressBarSettings.theme;
  const progressBarVariant = progressBarSettings.variant;
  const font = getFontFamily(defaultBaseStyle.fonts, ProgressbarBaseStyle.typography.fontFamily[progressBarTheme] || "default");
  const { typography } = ProgressbarBaseStyle;
  const fontSize = typography.fontSize[progressBarTheme];
  const containerStyles = ProgressbarBaseStyle.container[progressBarTheme];
  const label = progressBar?.label || "progress...";
  const formattedProgress = `${Math.min(100, Math.max(0, Math.floor(progress)))}%`;
  const themeStyles = reactExports.useMemo(() => {
    return ProgressbarStyles[progressBarTheme] ?? ProgressbarStyles[ProgressBarThemes.LIGHT];
  }, [progressBarTheme]);
  const borderRadius = progressBarSettings.isRounded ? containerStyles.borderRadius : "0";
  const renderLabel = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontSize,
            fontWeight: typography.fontWeight
          },
          initial: { opacity: 0.7 },
          animate: { opacity: 1 },
          transition: { repeat: Infinity, repeatType: "reverse", duration: 1.5 },
          children: label
        }
      );
    }
    return null;
  };
  const renderValue = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_VALUE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontWeight: typography.fontWeight,
            fontSize
          },
          initial: { scale: 0.9, opacity: 0.8 },
          animate: { scale: 1, opacity: 1 },
          transition: { type: "spring", stiffness: 500, damping: 15 },
          children: formattedProgress
        },
        formattedProgress
      );
    }
    return null;
  };
  const getJustifyClass = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return "justify-between";
    }
    return "justify-center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center flex-col ${progressBarSettings.textPosition === ProgressbarTextPosition.BELOW_BAR ? "flex-col-reverse" : ""}`,
      style: {
        gap: containerStyles.gap
      },
      children: [
        progressBarVariant !== ProgressbarVariant.ONLY_BAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full flex items-${progressBarSettings.textPosition === ProgressbarTextPosition.ABOVE_BAR ? "end" : "start"} ${getJustifyClass()}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[20vh] break-words", children: renderLabel() }),
          renderValue()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "overflow-hidden relative",
            style: {
              background: themeStyles?.background,
              width: containerStyles.width,
              height: containerStyles.height,
              borderRadius
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                className: "h-full",
                initial: { width: 0 },
                animate: { width: `${progress}%` },
                transition: {
                  type: "spring",
                  stiffness: 120,
                  damping: 20,
                  mass: 0.4
                },
                style: {
                  background: themeStyles?.progress,
                  borderRadius
                }
              }
            )
          }
        )
      ]
    }
  );
}

function RetroTheme({ progress = 0 }) {
  const progressBarSettings = useHudStore((state) => state.progressBarSettings);
  const progressBar = useHudStore((state) => state.progressBar);
  const progressBarVariant = progressBarSettings.variant;
  const themeStyles = ProgressbarStyles.retro;
  const { typography } = ProgressbarBaseStyle;
  const font = getFontFamily(defaultBaseStyle.fonts, typography.fontFamily.retro || "bebas");
  const fontSize = typography.fontSize.retro;
  const containerStyles = ProgressbarBaseStyle.container.retro;
  const label = progressBar?.label || "progress...";
  const formattedProgress = `${Math.min(100, Math.max(0, Math.floor(progress)))}%`;
  const renderLabel = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontSize,
            fontWeight: typography.fontWeight
          },
          initial: { opacity: 0.7 },
          animate: { opacity: 1 },
          transition: { repeat: Infinity, repeatType: "reverse", duration: 1.5 },
          children: label
        }
      );
    }
    return null;
  };
  const renderValue = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_VALUE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontWeight: typography.fontWeight,
            fontSize
          },
          initial: { scale: 0.9, opacity: 0.8 },
          animate: { scale: 1, opacity: 1 },
          transition: { type: "spring", stiffness: 500, damping: 15 },
          children: formattedProgress
        },
        formattedProgress
      );
    }
    return null;
  };
  const getJustifyClass = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return "justify-between";
    }
    return "justify-center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center flex-col ${progressBarSettings.textPosition === ProgressbarTextPosition.BELOW_BAR ? "flex-col-reverse" : ""}`,
      style: {
        gap: containerStyles.gap
      },
      children: [
        progressBarVariant !== ProgressbarVariant.ONLY_BAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full flex items-${progressBarSettings.textPosition === ProgressbarTextPosition.ABOVE_BAR ? "end" : "start"} ${getJustifyClass()} -mb-[.5vh] px-[.05vw]`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[20vh] break-words", children: renderLabel() }),
          renderValue()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative",
            style: {
              width: containerStyles.width,
              height: containerStyles.height
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "svg",
                {
                  className: "absolute top-0 left-0 size-full",
                  viewBox: "0 0 372 34",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M355.074 33.3078H16.6636C7.65263 33.3078 0.348633 26.0028 0.348633 16.9918C0.348633 7.98078 7.65263 0.675781 16.6636 0.675781H355.074C364.085 0.675781 371.39 7.98078 371.39 16.9918C371.39 26.0028 364.085 33.3078 355.074 33.3078Z", fill: "#2E2828" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M354.288 32.1418H16.5377C7.84869 32.1418 0.804688 25.0978 0.804688 16.4088C0.804688 7.71978 7.84869 0.675781 16.5377 0.675781H354.288C362.977 0.675781 370.021 7.71978 370.021 16.4088C370.021 25.0978 362.977 32.1418 354.288 32.1418Z", fill: "#F5F3D9" })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "w-[calc(100%-1.5vh)] h-[calc(100%-1.85vh)] absolute top-[48%] left-1/2 -translate-x-1/2 -translate-y-1/2 overflow-hidden",
                  style: {
                    background: themeStyles?.progressWrapper,
                    borderRadius: containerStyles.borderRadius
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    motion.div,
                    {
                      className: "h-full",
                      initial: { width: 0 },
                      animate: { width: `${progress}%` },
                      transition: {
                        type: "spring",
                        stiffness: 120,
                        damping: 20,
                        mass: 0.4
                      },
                      style: {
                        background: themeStyles?.progress,
                        borderRadius: containerStyles.borderRadius
                      }
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}

function Cyberpunk2Theme({ progress = 0 }) {
  const progressBarSettings = useHudStore((state) => state.progressBarSettings);
  const progressBar = useHudStore((state) => state.progressBar);
  const progressBarVariant = progressBarSettings.variant;
  const themeStyles = ProgressbarStyles.cyberpunk_2;
  const { typography } = ProgressbarBaseStyle;
  const font = getFontFamily(defaultBaseStyle.fonts, typography.fontFamily.cyberpunk_2 || "default");
  const fontSize = typography.fontSize.cyberpunk_2;
  const containerStyles = ProgressbarBaseStyle.container.cyberpunk_2;
  const label = progressBar?.label || "progress...";
  const formattedProgress = `${Math.min(100, Math.max(0, Math.floor(progress)))}%`;
  const renderLabel = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontSize,
            fontWeight: typography.fontWeight
          },
          className: "uppercase",
          initial: { opacity: 0.7 },
          animate: { opacity: 1 },
          transition: { repeat: Infinity, repeatType: "reverse", duration: 1.5 },
          children: label
        }
      );
    }
    return null;
  };
  const renderValue = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_VALUE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontWeight: typography.fontWeight,
            fontSize
          },
          initial: { scale: 0.9, opacity: 0.8 },
          animate: { scale: 1, opacity: 1 },
          transition: { type: "spring", stiffness: 500, damping: 15 },
          children: formattedProgress
        },
        formattedProgress
      );
    }
    return null;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center flex-col ${progressBarSettings.textPosition === ProgressbarTextPosition.BELOW_BAR ? "flex-col-reverse" : ""}`,
      style: {
        gap: containerStyles.gap
      },
      children: [
        progressBarVariant !== ProgressbarVariant.ONLY_BAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full relative`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `max-w-[22vh] break-words absolute ${progressBarSettings.textPosition === ProgressbarTextPosition.ABOVE_BAR ? "-bottom-[.45vh]" : ""} left-[.25vh]`, children: renderLabel() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `absolute ${progressBarSettings.textPosition === ProgressbarTextPosition.ABOVE_BAR ? "-bottom-[2vh]" : ""} right-[.5vh]`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[20vh] break-words", children: renderValue() }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative",
            style: {
              width: containerStyles.width,
              height: containerStyles.height
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute top-0 left-0 size-full", viewBox: "0 0 283 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M116.435 21.3267H205.05V19.6367H116.435V21.3267ZM254.767 19.6367V21.3267H277.258V34.8557H222.294V36.5457H278.95V19.6367H254.767ZM67.5535 36.5457H184.08V34.8557H67.5535V36.5457ZM94.4575 21.3267V19.6367H3.97852V36.5457H41.5065V34.8557H5.67052V21.3267H94.4575Z", fill: "#ECECEC" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M282.504 29.1088H281.476V17.4388H269.48V16.4258H282.504V29.1088Z", fill: "#ECECEC" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19.3577 39.9325H0.59375V31.6445H1.60075V38.9165H19.3577V39.9325Z", fill: "#ECECEC" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M183.908 17.4369H138.926V16.4219H183.908V17.4369Z", fill: "#ECECEC" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.25", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M218.051 20.8403L207.534 10.3363H195.239V9.32031H207.962L218.758 20.1233L218.051 20.8403Z", fill: "#ECECEC" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { opacity: "0.5", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M252.56 21.1598H223.814L209.27 6.61578H169.021V4.92578H209.955L224.499 19.4698H252.56V21.1598Z", fill: "#ECECEC" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M164.63 11.3502C161.738 11.3502 159.382 9.00019 159.382 6.10819C159.382 3.21719 161.738 0.867188 164.63 0.867188C167.522 0.867188 169.878 3.21719 169.878 6.10819C169.878 9.00019 167.522 11.3502 164.63 11.3502ZM164.63 2.55719C162.659 2.55719 161.074 4.15119 161.074 6.10819C161.074 8.06619 162.659 9.66019 164.63 9.66019C166.579 9.66019 168.186 8.06619 168.186 6.10819C168.186 4.15119 166.579 2.55719 164.63 2.55719Z", fill: "#ECECEC" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M163.369 6.27587C163.369 5.52787 163.969 4.92188 164.718 4.92188C165.468 4.92188 166.068 5.52787 166.068 6.27587C166.068 7.02387 165.468 7.62987 164.718 7.62987C163.969 7.62987 163.369 7.02387 163.369 6.27587Z", fill: "#ECECEC" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(100%-1.6vh)] h-[calc(100%-3.18vh)] absolute top-[69.6%] left-1/2 -translate-x-1/2 -translate-y-1/2 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className: "h-full",
                  initial: { width: 0 },
                  animate: { width: `${progress}%` },
                  transition: {
                    type: "spring",
                    stiffness: 120,
                    damping: 20,
                    mass: 0.4
                  },
                  style: {
                    background: themeStyles?.progress
                  }
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}

function PixelTheme({ progress = 0 }) {
  const progressBarSettings = useHudStore((state) => state.progressBarSettings);
  const progressBar = useHudStore((state) => state.progressBar);
  const progressBarVariant = progressBarSettings.variant;
  const themeStyles = ProgressbarStyles.pixel;
  const { typography } = ProgressbarBaseStyle;
  const font = getFontFamily(defaultBaseStyle.fonts, typography.fontFamily.pixel || "pixel");
  const fontSize = typography.fontSize.pixel;
  const containerStyles = ProgressbarBaseStyle.container.pixel;
  const label = progressBar?.label || "progress...";
  const formattedProgress = `${Math.min(100, Math.max(0, Math.floor(progress)))}%`;
  const zeroProgPaths = reactExports.useRef({
    bar1: `M5.68262 14.7505H5.68262V11.0625H5.68262V14.7505Z`,
    bar2: `M5.68262 3.68359V7.27859H5.68262V7.37159H5.77262V3.72059H5.68262V3.68359H5.68262Z`,
    bar3: `M5.68262 3.625V7.317H5.68262V10.968H5.68262V11.065H0.555664V7.374H0.646664V3.722H5.68266V7.411H5.77366V7.374H5.68262V3.625H5.68262Z`,
    bar4: `M5.68262 -0.00390625V3.62409H5.68262V3.68409H5.68262V-0.00390625H5.68262Z`
  }).current;
  const calculatePaths = () => {
    const validProgress = Math.max(0, Math.min(100, progress));
    if (validProgress <= 0) {
      return {
        bar1: `M5.68262 14.7505H5.68262V11.0625H5.68262V14.7505Z`,
        bar2: `M5.68262 3.68359V7.27859H5.68262V7.37159H5.77262V3.72059H5.68262V3.68359H5.68262Z`,
        bar3: `M5.68262 3.625V7.317H5.68262V10.968H5.68262V11.065H0.555664V7.374H0.646664V3.722H5.68266V7.411H5.77366V7.374H5.68262V3.625H5.68262Z`,
        bar4: `M5.68262 -0.00390625V3.62409H5.68262V3.68409H5.68262V-0.00390625H5.68262Z`
      };
    }
    const fullWidth = 263.805 - 5.68262;
    const endX = 5.68262 + fullWidth * validProgress / 100;
    const bar1Path = `M${endX} 14.7505H5.68262V11.0625H${endX}V14.7505Z`;
    const bar2Path = `M${endX} 3.68359V7.27859H${endX - 0.087}V7.37159H5.77262V3.72059H5.68262V3.68359H${endX}Z`;
    let bar3EndX = Math.min(endX + 5, 268.771);
    let bar3EndX2 = Math.min(endX + 4.9, 268.68);
    const bar3Path = `M${bar3EndX} 3.625V7.317H${bar3EndX2}V10.968H${endX}V11.065H0.555664V7.374H0.646664V3.722H5.68266V7.411H5.77366V7.374H${endX}V3.625H${bar3EndX}Z`;
    const bar4Path = `M${endX} -0.00390625V3.62409H${endX - 0.161}V3.68409H5.68262V-0.00390625H${endX}Z`;
    return {
      bar1: bar1Path,
      bar2: bar2Path,
      bar3: bar3Path,
      bar4: bar4Path
    };
  };
  const paths = calculatePaths();
  const getInitialPath1 = () => {
    if (progress <= 0) {
      return { d: zeroProgPaths.bar1 };
    }
    const startWidth = Math.max(0, progress - 10) / 100;
    const fullWidth = 263.805 - 5.68262;
    const initialX = 5.68262 + fullWidth * startWidth;
    return { d: `M${initialX} 14.7505H5.68262V11.0625H${initialX}V14.7505Z` };
  };
  const getInitialPath2 = () => {
    if (progress <= 0) {
      return { d: zeroProgPaths.bar2 };
    }
    const startWidth = Math.max(0, progress - 10) / 100;
    const fullWidth = 263.805 - 5.68262;
    const initialX = 5.68262 + fullWidth * startWidth;
    return { d: `M${initialX} 3.68359V7.27859H${initialX - 0.087}V7.37159H5.77262V3.72059H5.68262V3.68359H${initialX}Z` };
  };
  const getInitialPath3 = () => {
    if (progress <= 0) {
      return { d: zeroProgPaths.bar3 };
    }
    const startWidth = Math.max(0, progress - 10) / 100;
    const fullWidth = 263.805 - 5.68262;
    const initialX = 5.68262 + fullWidth * startWidth;
    return { d: `M${Math.min(initialX + 5, 268.771)} 3.625V7.317H${Math.min(initialX + 4.9, 268.68)}V10.968H${initialX}V11.065H0.555664V7.374H0.646664V3.722H5.68266V7.411H5.77366V7.374H${initialX}V3.625H${Math.min(initialX + 5, 268.771)}Z` };
  };
  const getInitialPath4 = () => {
    if (progress <= 0) {
      return { d: zeroProgPaths.bar4 };
    }
    const startWidth = Math.max(0, progress - 10) / 100;
    const fullWidth = 263.805 - 5.68262;
    const initialX = 5.68262 + fullWidth * startWidth;
    return { d: `M${initialX} -0.00390625V3.62409H${initialX - 0.161}V3.68409H5.68262V-0.00390625H${initialX}Z` };
  };
  const renderLabel = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontSize,
            fontWeight: typography.fontWeight
          },
          initial: { opacity: 0.7 },
          animate: { opacity: 1 },
          transition: { repeat: Infinity, repeatType: "reverse", duration: 1.5 },
          children: label
        }
      );
    }
    return null;
  };
  const renderValue = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_VALUE || progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.span,
        {
          style: {
            color: themeStyles?.text,
            fontFamily: font,
            fontWeight: typography.fontWeight,
            fontSize
          },
          initial: { scale: 0.9, opacity: 0.8 },
          animate: { scale: 1, opacity: 1 },
          transition: { type: "spring", stiffness: 500, damping: 15 },
          children: formattedProgress
        },
        formattedProgress
      );
    }
    return null;
  };
  const getJustifyClass = () => {
    if (progressBarVariant === ProgressbarVariant.INCLUDE_TITLE_VALUE) {
      return "justify-between";
    }
    return "justify-center";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center flex-col ${progressBarSettings.textPosition === ProgressbarTextPosition.BELOW_BAR ? "flex-col-reverse" : ""}`,
      style: {
        gap: containerStyles.gap
      },
      children: [
        progressBarVariant !== ProgressbarVariant.ONLY_BAR && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `w-full flex items-${progressBarSettings.textPosition === ProgressbarTextPosition.ABOVE_BAR ? "end" : "start"} ${getJustifyClass()} mb-[.05vh] px-[.05vw]`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-[22vh] break-words", children: renderLabel() }),
          renderValue()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "relative",
            style: {
              width: containerStyles.width,
              height: containerStyles.height
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "absolute top-0 left-0 size-full z-10", viewBox: "0 0 292 31", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M291.838 22.635H286.714V7.875H291.838V22.635Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.27544 22.635H0.148438V7.875H5.27544V22.635Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M281.587 22.6367H286.714V26.3247H281.587V22.6367Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M281.587 0.494375V4.18637H261.09V4.17237H256.395V4.18637H10.3984V0.494375H256.11V0.484375H261.234V0.494375H281.587Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M286.714 7.8755H281.587V4.1875H286.714V7.8755Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3984 7.8755H5.27441V4.1875H10.3984V7.8755Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M281.587 26.3242V30.0162H261.492V30.0292H256.365V30.0162H10.3984V26.3242H256.395V26.3412H261.09V26.3242H281.587Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.3984 26.3247H5.27441V22.6367H10.3984V26.3247Z", fill: "#FDFCEB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M273.805 11.6836V15.3716H273.557V15.2786H273.644V11.6836H273.805Z", fill: "#FF94FB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M273.805 11.685H273.644V11.625H273.805V11.685Z", fill: "#F27CF2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7726 15.4081H15.6816V15.3711H15.7726V15.4081Z", fill: "#F27CF2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7726 15.3737H15.6816V11.7227H15.7726V15.3737Z", fill: "#FF94FB" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7726 15.4107H15.6816V11.7227H15.7726V15.4107Z", fill: "#9AEFFF" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M273.805 15.3713H273.557V15.2773H273.805V15.3713Z", fill: "#F27CF2" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("g", { opacity: "0.259995", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M286.714 7.87387V22.6339H281.587V26.3229H261.09V26.3399H256.395V26.3229H10.3984V22.6339H5.27441V7.87387H10.3984V4.18588H256.395V4.17188H261.09V4.18588H281.587V7.87387H286.714Z", fill: "#94EEFF" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M273.805 15.3171H273.644V11.625H273.805V15.3171Z", fill: "#9AEFFF" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(100%-1.35vh)] h-[calc(100%-1.6vh)] absolute top-[48%] left-1/2 -translate-x-1/2 -translate-y-1/2 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "size-full", viewBox: "0 0 269 15", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "progress-bar-1",
                    d: paths.bar1,
                    fill: themeStyles?.progress,
                    initial: getInitialPath1(),
                    animate: { d: paths.bar1 },
                    transition: { duration: 0.5 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "progress-bar-2",
                    d: paths.bar2,
                    fill: themeStyles?.progress_2,
                    initial: getInitialPath2(),
                    animate: { d: paths.bar2 },
                    transition: { duration: 0.5 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "progress-bar-3",
                    d: paths.bar3,
                    fill: themeStyles?.progress_3,
                    initial: getInitialPath3(),
                    animate: { d: paths.bar3 },
                    transition: { duration: 0.5 }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  motion.path,
                  {
                    id: "progress-bar-4",
                    d: paths.bar4,
                    fill: themeStyles?.progress_4,
                    initial: getInitialPath4(),
                    animate: { d: paths.bar4 },
                    transition: { duration: 0.5 }
                  }
                )
              ] }) })
            ]
          }
        )
      ]
    }
  );
}

const useProgressbarAnimation = () => {
  const { animation, animationDirection, animationDelay } = useHudStore((state) => state.progressBarSettings);
  const getSlideAnimation = () => {
    switch (animationDirection) {
      case ProgressbarAnimationDirection.TOP:
        return {
          initial: { opacity: 0, y: -20, x: "-50%" },
          animate: { opacity: 1, y: 0, x: "-50%" },
          exit: { opacity: 0, y: -10, x: "-50%" }
        };
      case ProgressbarAnimationDirection.RIGHT:
        return {
          initial: { opacity: 0, x: "0%" },
          animate: { opacity: 1, x: "-50%" },
          exit: { opacity: 0, x: "-30%" }
        };
      case ProgressbarAnimationDirection.LEFT:
        return {
          initial: { opacity: 0, x: "-100%" },
          animate: { opacity: 1, x: "-50%" },
          exit: { opacity: 0, x: "-70%" }
        };
      case ProgressbarAnimationDirection.DEFAULT:
        return {
          initial: { opacity: 0, scale: 0.9, x: "-50%" },
          animate: { opacity: 1, scale: 1, x: "-50%" },
          exit: { opacity: 0, scale: 0.95, x: "-50%" }
        };
      case ProgressbarAnimationDirection.BOTTOM:
      default:
        return {
          initial: { opacity: 0, y: 20, x: "-50%" },
          animate: { opacity: 1, y: 0, x: "-50%" },
          exit: { opacity: 0, y: 10, x: "-50%" }
        };
    }
  };
  const getBounceAnimation = () => {
    const baseScale = { scaleX: 0.85, scaleY: 0.75 };
    const animatedScale = { scaleX: 1, scaleY: 1 };
    switch (animationDirection) {
      case ProgressbarAnimationDirection.TOP:
        return {
          initial: { opacity: 0, y: -50, x: "-50%", ...baseScale },
          animate: { opacity: 1, y: 0, x: "-50%", ...animatedScale },
          exit: { opacity: 0, y: -20, x: "-50%", ...baseScale }
        };
      case ProgressbarAnimationDirection.RIGHT:
        return {
          initial: { opacity: 0, x: "0%", ...baseScale },
          animate: { opacity: 1, x: "-50%", ...animatedScale },
          exit: { opacity: 0, x: "-30%", ...baseScale }
        };
      case ProgressbarAnimationDirection.LEFT:
        return {
          initial: { opacity: 0, x: "-100%", ...baseScale },
          animate: { opacity: 1, x: "-50%", ...animatedScale },
          exit: { opacity: 0, x: "-70%", ...baseScale }
        };
      case ProgressbarAnimationDirection.DEFAULT:
        return {
          initial: { opacity: 0, x: "-50%", ...baseScale },
          animate: { opacity: 1, x: "-50%", ...animatedScale },
          exit: { opacity: 0, x: "-50%", ...baseScale }
        };
      case ProgressbarAnimationDirection.BOTTOM:
      default:
        return {
          initial: { opacity: 0, y: 50, x: "-50%", ...baseScale },
          animate: { opacity: 1, y: 0, x: "-50%", ...animatedScale },
          exit: { opacity: 0, y: 20, x: "-50%", ...baseScale }
        };
    }
  };
  switch (animation) {
    case ProgressbarAnimation.FADE:
      return {
        initial: { opacity: 0, x: "-50%" },
        animate: { opacity: 1, x: "-50%" },
        exit: { opacity: 0, x: "-50%" },
        transition: {
          duration: 0.3,
          ease: "easeInOut",
          delay: animationDelay
        }
      };
    case ProgressbarAnimation.BOUNCE:
      return {
        ...getBounceAnimation(),
        transition: {
          type: "spring",
          stiffness: 400,
          damping: 12,
          mass: 0.8,
          delay: animationDelay
        }
      };
    case ProgressbarAnimation.SLIDE:
      return {
        ...getSlideAnimation(),
        transition: {
          type: "spring",
          stiffness: 300,
          damping: 25,
          delay: animationDelay
        }
      };
    default:
      return {
        initial: { opacity: 0, y: 20, x: "-50%" },
        animate: { opacity: 1, y: 0, x: "-50%" },
        exit: { opacity: 0, y: 10, x: "-50%" },
        transition: {
          type: "spring",
          stiffness: 300,
          damping: 25
        }
      };
  }
};

function ProgressbarContainer() {
  const progressBar = useHudStore((state) => state.progressBar);
  const progressBarTheme = useHudStore((state) => state.progressBarSettings.theme);
  const { setProgressBar } = useHudStore((state) => state);
  const isDraggable = useSettingsStore((state) => state.hudSettings.isDraggable);
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const progressAnimation = useProgressbarAnimation();
  const [progress, setProgress] = reactExports.useState(0);
  const intervalRef = reactExports.useRef(null);
  const prevVisibleRef = reactExports.useRef(false);
  const isDragPreviewRef = reactExports.useRef(false);
  const { position } = ProgressbarBaseStyle;
  reactExports.useEffect(() => {
    if (isDraggable) {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
      isDragPreviewRef.current = true;
      setProgressBar({
        label: localesConfig?.hud?.groups?.progressbar?.previewTitle || "Preview Progress Bar",
        duration: 5e3,
        isVisible: true,
        canCancel: true
      });
      setProgress(50);
    }
  }, [isDraggable, setProgressBar, localesConfig]);
  reactExports.useEffect(() => {
    if (!isDraggable && progressBar?.isVisible && isDragPreviewRef.current) {
      isDragPreviewRef.current = false;
      setProgressBar({
        ...progressBar,
        isVisible: false
      });
    }
  }, [isDraggable, progressBar, setProgressBar]);
  reactExports.useEffect(() => {
    const isVisible = progressBar?.isVisible;
    if (prevVisibleRef.current && !isVisible) {
      setProgress(0);
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    }
    prevVisibleRef.current = isVisible;
  }, [progressBar?.isVisible]);
  reactExports.useEffect(() => {
    if (isDraggable || isDragPreviewRef.current) return;
    if (!progressBar || !progressBar.duration || !progressBar.isVisible) return;
    setProgress(0);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    const duration = progressBar.duration;
    const steps = 100;
    const stepTime = duration / steps;
    intervalRef.current = setInterval(() => {
      setProgress((prev) => {
        const newProgress = prev + 1;
        if (newProgress >= 100) {
          if (intervalRef.current) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
          }
          setTimeout(() => {
            setProgressBar({
              ...progressBar,
              isVisible: false
            });
          }, 500);
          return 100;
        }
        return newProgress;
      });
    }, stepTime);
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [progressBar, setProgressBar, isDraggable, isDragPreviewRef]);
  const renderTheme = () => {
    switch (progressBarTheme) {
      case ProgressBarThemes.RETRO:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RetroTheme, { progress });
      case ProgressBarThemes.CYBERPUNK_2:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Cyberpunk2Theme, { progress });
      case ProgressBarThemes.PIXEL:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PixelTheme, { progress });
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultTheme, { progress });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: progressBar?.isVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      className: "absolute -translate-x-1/2 z-50",
      style: {
        ...ShadowStyle,
        bottom: position.bottom,
        left: position.left
      },
      initial: progressAnimation.initial,
      animate: progressAnimation.animate,
      exit: progressAnimation.exit,
      transition: progressAnimation.transition,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DraggableElement,
        {
          elementId: "progressbar",
          className: "relative",
          children: renderTheme()
        }
      )
    }
  ) });
}

const cinematicBarVariants = {
  hidden: {
    height: 0
  },
  visible: {
    height: "15vh",
    transition: {
      duration: 0.5,
      ease: [0.4, 0, 0.2, 1]
    }
  }
};
function HudContainer() {
  const theme = useHudStore((state) => state.theme);
  const isHudVisible = useHudStore((state) => state.isHudVisible);
  const hudSettings = useSettingsStore((state) => state.hudSettings);
  const advancedMapConfig = useConfigStore((state) => state.config.advancedMap);
  const renderHudContent = () => {
    if (!isHudVisible || !hudSettings?.elementsVisibility?.showAllElements) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      renderThemeComponents(),
      shouldShowHudElement("vehicle") && hudSettings?.elementsVisibility?.vehicle && /* @__PURE__ */ jsxRuntimeExports.jsx(VehicleHud, {}),
      advancedMapConfig && /* @__PURE__ */ jsxRuntimeExports.jsx(DraggableMinimap, { settings: hudSettings?.minimap }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: hudSettings?.isDraggable && /* @__PURE__ */ jsxRuntimeExports.jsx(DragModeMenu, {}) })
    ] });
  };
  const renderThemeComponents = () => {
    switch (theme) {
      case HudThemes.RETRO:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RetroTheme$1, {});
      case HudThemes.PIXEL:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PixelTheme$1, {});
      case HudThemes.CYBERPUNK_2:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Cyberpunk2Theme$1, {});
      default:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultTheme$1, {});
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    renderHudContent(),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressbarContainer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: hudSettings?.cinematicMode && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          variants: cinematicBarVariants,
          initial: "hidden",
          animate: "visible",
          exit: "hidden",
          className: "fixed top-0 left-0 w-full bg-black z-[997]"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          variants: cinematicBarVariants,
          initial: "hidden",
          animate: "visible",
          exit: "hidden",
          className: "fixed bottom-0 left-0 w-full bg-black z-[997]"
        }
      )
    ] }) })
  ] });
}

// eslint-disable-next-line no-undef
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

var isPropValid = /* #__PURE__ */memoize(function (prop) {
  return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
  /* o */
  && prop.charCodeAt(1) === 110
  /* n */
  && prop.charCodeAt(2) < 91;
}
/* Z+1 */
);

var isDevelopment = false;

var testOmitPropsOnStringTag = isPropValid;

var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
  return key !== 'theme';
};

var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
  return typeof tag === 'string' && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
  var shouldForwardProp;

  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }

  if (typeof shouldForwardProp !== 'function' && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }

  return shouldForwardProp;
};

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var createStyled = function createStyled(tag, options) {

  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;

  if (options !== undefined) {
    identifierName = options.label;
    targetClassName = options.target;
  }

  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp('as');
  return function () {
    // eslint-disable-next-line prefer-rest-params
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

    if (identifierName !== undefined) {
      styles.push("label:" + identifierName + ";");
    }

    if (args[0] == null || args[0].raw === undefined) {
      // eslint-disable-next-line prefer-spread
      styles.push.apply(styles, args);
    } else {
      var templateStringsArr = args[0];

      styles.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;

      for (; i < len; i++) {

        styles.push(args[i], templateStringsArr[i]);
      }
    }

    var Styled = withEmotionCache(function (props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = '';
      var classInterpolations = [];
      var mergedProps = props;

      if (props.theme == null) {
        mergedProps = {};

        for (var key in props) {
          mergedProps[key] = props[key];
        }

        mergedProps.theme = reactExports.useContext(ThemeContext);
      }

      if (typeof props.className === 'string') {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }

      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;

      if (targetClassName !== undefined) {
        className += " " + targetClassName;
      }

      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};

      for (var _key in props) {
        if (shouldUseAs && _key === 'as') continue;

        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }

      newProps.className = className;

      if (ref) {
        newProps.ref = ref;
      }

      return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(Insertion, {
        cache: cache,
        serialized: serialized,
        isStringTag: typeof FinalTag === 'string'
      }), /*#__PURE__*/reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, 'toString', {
      value: function value() {
        if (targetClassName === undefined && isDevelopment) {
          return 'NO_COMPONENT_SELECTOR';
        }

        return "." + targetClassName;
      }
    });

    Styled.withComponent = function (nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles);
    };

    return Styled;
  };
};

var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];

// bind it to avoid mutating the original function
var newStyled = createStyled.bind(null);
tags.forEach(function (tagName) {
  newStyled[tagName] = newStyled(tagName);
});

function DashboardItemGroup({
  title,
  children
}) {
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      layout: "preserve-aspect",
      transition: {
        layout: {
          duration: 0.2,
          ease: "easeInOut"
        }
      },
      className: "w-full rounded-[.75vh] p-[1.75vh] border-[.1vh]",
      style: {
        background: SettingsStyles.group.background,
        borderColor: SettingsStyles.group.borderColor
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "h2",
          {
            className: "text-[1.65vh] font-bold mb-[2vh]",
            style: {
              fontFamily: font,
              color: SettingsStyles.group.titleColor
            },
            children: title
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-[2vh]", children })
      ]
    }
  );
}

const overlayVariants$1 = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 }
};
const dialogVariants$2 = {
  initial: { opacity: 0, scale: 0.9, y: 20 },
  animate: {
    opacity: 1,
    scale: 1,
    y: 0,
    transition: {
      duration: 0.3,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.9,
    y: 20,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
const contentVariants = {
  enter: (direction) => ({
    x: direction > 0 ? 100 : -100,
    opacity: 0
  }),
  center: {
    x: 0,
    opacity: 1,
    transition: {
      duration: 0.3,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: (direction) => ({
    x: direction < 0 ? 100 : -100,
    opacity: 0,
    transition: {
      duration: 0.3,
      ease: [0.4, 0, 0.2, 1]
    }
  })
};
function Tutorial() {
  const { isVisible, currentStep, setCurrentStep, setHasSeenTutorial, setTutorialVisible } = useTutorialStore();
  const { setSettingsVisible } = useSettingsStore();
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  reactExports.useEffect(() => {
    const checkTutorial = () => {
      const hasSeenTutorial = localStorage.getItem("envi-hud-tutorial");
      if (!hasSeenTutorial) {
        setTutorialVisible(true);
      }
    };
    checkTutorial();
  }, [setTutorialVisible]);
  const [[page, direction], setPage] = reactExports.useState([0, 0]);
  const handleNext = () => {
    if (currentStep < localesConfig.tutorial.steps.length - 1) {
      setPage([page + 1, 1]);
      setCurrentStep(currentStep + 1);
    } else {
      handleComplete();
    }
  };
  const handleBack = () => {
    if (currentStep > 0) {
      setPage([page - 1, -1]);
      setCurrentStep(currentStep - 1);
    }
  };
  const handleComplete = () => {
    setHasSeenTutorial(true);
    setTutorialVisible(false);
    setTimeout(() => {
      setSettingsVisible(true);
    }, 500);
  };
  const handleSkip = () => {
    setHasSeenTutorial(true);
    setTutorialVisible(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: isVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      variants: overlayVariants$1,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      className: "fixed inset-0 flex items-center justify-center z-[999]",
      style: {
        background: SettingsStyles.container.overlay
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          variants: dialogVariants$2,
          className: "rounded-[.75vh] w-[40vw] overflow-hidden",
          style: {
            background: SettingsStyles.container.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "px-[1.15vw] py-[2vh] border-b-[.15vh]",
                style: {
                  borderBottomColor: SettingsStyles.container.borderColorBottom
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "h1",
                    {
                      className: "text-[2vh] font-semibold",
                      style: {
                        fontFamily: font,
                        color: SettingsStyles.title.header
                      },
                      children: localesConfig.tutorial.title
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      className: "text-[1.35vh] mt-[.5vh]",
                      style: {
                        fontFamily: font,
                        color: SettingsStyles.title.subHeader
                      },
                      children: localesConfig.tutorial.stepCounter.replace("{step}", (currentStep + 1).toString()).replace("{total}", localesConfig.tutorial.steps.length.toString())
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-[1.15vw] py-[2vh]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", custom: direction, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                custom: direction,
                variants: contentVariants,
                initial: "enter",
                animate: "center",
                exit: "exit",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig.tutorial.steps[currentStep]?.title || "", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[2vh] p-[2vh]", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "flex-shrink-0 flex items-center justify-center size-[3.5vh] rounded-full transition-all duration-250",
                      style: {
                        background: SettingsStyles.tutorial.icon.background,
                        boxShadow: SettingsStyles.tutorial.icon.boxShadow
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Icon$1,
                        {
                          icon: localesConfig.tutorial.steps[currentStep]?.icon || "",
                          className: "text-[1.65vh]",
                          style: {
                            color: SettingsStyles.tutorial.icon.color
                          }
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "p",
                    {
                      className: "flex-1 text-[1.45vh] leading-relaxed",
                      style: {
                        fontFamily: font,
                        color: SettingsStyles.tutorial.description
                      },
                      children: localesConfig.tutorial.steps[currentStep]?.description || ""
                    }
                  )
                ] }) })
              },
              page
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "px-[1.15vw] py-[2.5vh] border-t-[.15vh] flex items-center justify-end gap-[1vh]",
                style: {
                  borderTopColor: SettingsStyles.container.borderColorTop
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-[1vh]", children: currentStep > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardButton,
                    {
                      icon: "mdi:arrow-left",
                      onClick: handleBack,
                      css: css`
                      background: ${SettingsStyles.button.action.background};
                      border-color: ${SettingsStyles.button.action.borderColor};
                      color: ${SettingsStyles.button.action.textColor};
                      &:hover {
                        background: ${SettingsStyles.button.action.hoverBackground};
                        border-color: ${SettingsStyles.button.action.hoverBorderColor};
                      }
                    `,
                      children: localesConfig.tutorial.buttons.back
                    }
                  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardButton,
                    {
                      icon: "mdi:close",
                      onClick: handleSkip,
                      css: css`
                      background: ${SettingsStyles.button.action.background};
                      border-color: ${SettingsStyles.button.action.borderColor};
                      color: ${SettingsStyles.button.action.textColor};
                      &:hover {
                        background: ${SettingsStyles.button.action.hoverBackground};
                        border-color: ${SettingsStyles.button.action.hoverBorderColor};
                      }
                    `,
                      children: localesConfig.tutorial.buttons.skip
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardButton,
                    {
                      icon: currentStep === localesConfig.tutorial.steps.length - 1 ? "mdi:check" : "mdi:arrow-right",
                      onClick: handleNext,
                      css: css`
                  background: ${SettingsStyles.button.submit.background};
                  border-color: ${SettingsStyles.button.submit.borderColor};
                  color: ${SettingsStyles.button.submit.textColor};
                  &:hover {
                    background: ${SettingsStyles.button.submit.hoverBackground};
                    border-color: ${SettingsStyles.button.submit.hoverBorderColor};
                  }
                `,
                      children: currentStep === localesConfig.tutorial.steps.length - 1 ? localesConfig.tutorial.buttons.getStarted : localesConfig.tutorial.buttons.next
                    }
                  )
                ]
              }
            )
          ]
        }
      )
    }
  ) });
}

const useClickOutside = (ref, callback, enabled = true) => {
  const handleClick = reactExports.useCallback((event) => {
    if (!ref.current || !enabled) return;
    const isOutside = !ref.current.contains(event.target);
    if (isOutside) {
      callback();
    }
  }, [ref, callback, enabled]);
  reactExports.useEffect(() => {
    if (!enabled) return;
    document.addEventListener("mousedown", handleClick);
    return () => {
      document.removeEventListener("mousedown", handleClick);
    };
  }, [handleClick, enabled]);
};

const variants = {
  initial: { opacity: 0, y: -5 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -5 }
};
const SelectContainer = newStyled.button`
  background: ${SettingsStyles.select.background};
  border-color: ${SettingsStyles.select.borderColor};
  &:hover {
    border-color: ${SettingsStyles.select.hoverBorderColor};
  }
`;
const OptionItem = newStyled.div`
  background: ${({ isActive }) => isActive ? SettingsStyles.select.option.active.background : SettingsStyles.select.option.inActive.background};
  color: ${({ isActive }) => isActive ? SettingsStyles.select.option.active.textColor : SettingsStyles.select.option.inActive.textColor};
  &:hover {
    background: ${SettingsStyles.select.option.active.background};
    color: ${SettingsStyles.select.option.active.textColor};
  }
`;
function DashboardSelect({
  label,
  value,
  onChange,
  options,
  icon,
  disabled = false
}) {
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const dropdownRef = reactExports.useRef(null);
  const optionsContainerRef = reactExports.useRef(null);
  const selectedOptionRef = reactExports.useRef(null);
  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  }, isOpen);
  const currentLabel = options.find((opt) => opt.value === value)?.label || localesConfig?.common.defaultSelectTitle || "Select...";
  reactExports.useEffect(() => {
    if (isOpen && optionsContainerRef.current && selectedOptionRef.current) {
      setTimeout(() => {
        selectedOptionRef.current?.scrollIntoView({
          block: "nearest",
          inline: "nearest",
          behavior: "auto"
        });
      }, 0);
    }
  }, [isOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: disabled ? "opacity-50 pointer-events-none" : "", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh] mb-[1.25vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon,
          className: "text-[1.8vh]",
          style: {
            color: SettingsStyles.select.iconColor
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          className: "text-[1.45vh] font-medium",
          style: {
            fontFamily: font,
            color: SettingsStyles.select.labelColor
          },
          children: label
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", ref: dropdownRef, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SelectContainer,
        {
          type: "button",
          disabled,
          onClick: () => !disabled && setIsOpen(!isOpen),
          className: `w-full px-[.75vw] py-[1vh] border-[.1vh] rounded-[.5vh]
           flex items-center justify-between transition-colors
           ${disabled ? "pointer-events-none" : "cursor-pointer"}
          `,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "text-[1.35vh]",
                style: {
                  fontFamily: font,
                  color: SettingsStyles.select.textColor
                },
                children: currentLabel
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon$1,
              {
                icon: "mdi:chevron-down",
                className: `text-[1.65vh] transition-all duration-250
              ${disabled ? "opacity-50" : ""}`,
                style: {
                  transform: `rotate(${isOpen ? 180 : 0}deg)`,
                  color: SettingsStyles.select.chevronColor
                }
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && !disabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          variants,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          transition: { duration: 0.2 },
          className: "absolute z-50 w-full mt-[1vh] border-[.1vh]\r\n                       rounded-[.5vh] shadow-lg overflow-hidden",
          style: {
            background: SettingsStyles.select.background,
            borderColor: SettingsStyles.select.borderColor
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "max-h-[20vh] overflow-y-auto",
              ref: optionsContainerRef,
              children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  ref: option.value === value ? selectedOptionRef : null,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    OptionItem,
                    {
                      isActive: option.value === value,
                      onClick: () => {
                        onChange(option.value);
                        setIsOpen(false);
                      },
                      className: "px-[1vw] py-[1vh] text-[1.35vh] cursor-pointer transition-colors",
                      style: {
                        fontFamily: font
                      },
                      children: option.label
                    }
                  )
                },
                option.value
              ))
            }
          )
        }
      ) })
    ] })
  ] });
}

const STYLES$1 = {
  container: "w-full flex items-center justify-between px-[1vw] py-[1vh] border-[.1vh] rounded-[.5vh]",
  icon: "text-[1.8vh]",
  label: "text-[1.45vh] font-medium",
  toggleButton: "w-[3.5vh] h-[2vh] rounded-full transition-all duration-250",
  toggleKnob: "w-[1.6vh] h-[1.6vh] mt-[.15vh] rounded-full transition-all duration-250 transform"
};
const Toggle = reactExports.memo(({ value, disabled, onChange }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => onChange(!value),
      disabled,
      "aria-checked": value,
      role: "switch",
      className: `${STYLES$1.toggleButton}
        ${disabled ? "opacity-50 cursor-not-allowed" : ""}`,
      style: {
        background: value ? SettingsStyles.toggle.button.activeBackground : SettingsStyles.toggle.button.inactiveBackground
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `${STYLES$1.toggleKnob}
          ${value ? "translate-x-[1.7vh]" : "translate-x-[0.2vh]"}`,
          style: {
            background: SettingsStyles.toggle.knob.background
          }
        }
      )
    }
  );
});
Toggle.displayName = "Toggle";
const DashboardToggle = reactExports.memo(({
  label,
  icon,
  value,
  disabled = false,
  hasDescription = false,
  customDescription,
  onChange
}) => {
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  if (hasDescription) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh] mb-[1.25vh]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Icon$1,
          {
            icon,
            className: STYLES$1.icon,
            style: {
              color: SettingsStyles.toggle.iconColor
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "label",
          {
            className: STYLES$1.label,
            style: {
              fontFamily: font,
              color: SettingsStyles.toggle.labelColor
            },
            children: label
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: STYLES$1.container,
          style: {
            background: SettingsStyles.toggle.container.background,
            borderColor: SettingsStyles.toggle.container.borderColor
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: STYLES$1.label,
                style: {
                  fontFamily: font,
                  color: SettingsStyles.toggle.description.textColor
                },
                children: value ? customDescription?.enabled : customDescription?.disabled
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { value, disabled, onChange })
          ]
        }
      )
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: STYLES$1.container,
      style: {
        background: SettingsStyles.toggle.container.background,
        borderColor: SettingsStyles.toggle.container.borderColor
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon$1,
            {
              icon,
              className: STYLES$1.icon,
              style: {
                color: SettingsStyles.toggle.iconColor
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "label",
            {
              className: STYLES$1.label,
              style: {
                fontFamily: font,
                color: SettingsStyles.toggle.labelColor
              },
              children: label
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { value, disabled, onChange })
      ]
    }
  );
});
DashboardToggle.displayName = "DashboardToggle";

const InputContainer = newStyled.input`
  background: ${SettingsStyles.input.background};
  border-color: ${SettingsStyles.input.borderColor};
  color: ${SettingsStyles.input.textColor};
  &:focus {
    border-color: ${SettingsStyles.input.focusBorderColor};
  }
`;
function DashboardInput({
  label,
  value,
  onChange,
  icon,
  type = "number",
  min,
  max,
  step,
  disabled
}) {
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  const handleChange = (e) => {
    let newValue = e.target.value;
    if (newValue.length > 1 && newValue.startsWith("0")) {
      newValue = newValue.replace(/^0+/, "");
    }
    const numericValue = Number(newValue);
    if (isNaN(numericValue)) {
      onChange(min ?? 0);
      return;
    }
    if (min !== void 0 && max !== void 0) {
      const clampedValue = Math.min(Math.max(numericValue, min), max);
      onChange(clampedValue);
      return;
    }
    onChange(numericValue);
  };
  const displayValue = isNaN(value) ? min ?? 0 : value;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[.75vh] mb-[1.25vh]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon,
          className: "text-[1.8vh]",
          style: {
            color: SettingsStyles.input.iconColor
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          className: "text-[1.45vh] font-medium",
          style: {
            fontFamily: font,
            color: SettingsStyles.input.labelColor
          },
          children: label
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InputContainer,
      {
        type,
        value: displayValue,
        onChange: handleChange,
        className: "w-full px-[.75vw] py-[1vh] border-[.1vh] rounded-[.5vh] \r\n        text-[1.35vh] transition-colors outline-none",
        style: {
          fontFamily: font
        },
        min,
        max,
        step,
        disabled
      }
    )
  ] });
}

const Tooltip = ({
  children,
  text,
  position = "top"
}) => {
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const triggerRef = reactExports.useRef(null);
  const tooltipRef = reactExports.useRef(null);
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  const positions = {
    top: {
      initial: { opacity: 0, y: 10 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: 10 }
    },
    bottom: {
      initial: { opacity: 0, y: -10 },
      animate: { opacity: 1, y: 0 },
      exit: { opacity: 0, y: -10 }
    },
    left: {
      initial: { opacity: 0, x: 10 },
      animate: { opacity: 1, x: 0 },
      exit: { opacity: 0, x: 10 }
    },
    right: {
      initial: { opacity: 0, x: -10 },
      animate: { opacity: 1, x: 0 },
      exit: { opacity: 0, x: -10 }
    }
  };
  const pxToVh = (px) => {
    return px / window.innerHeight * 100 + "vh";
  };
  const pxToVw = (px) => {
    return px / window.innerWidth * 100 + "vw";
  };
  reactExports.useEffect(() => {
    if (!isVisible || !triggerRef.current || !tooltipRef.current) return;
    const triggerRect = triggerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const tooltipEl = tooltipRef.current;
    if (position === "top") {
      tooltipEl.style.bottom = pxToVh(triggerRect.height + 8);
      tooltipEl.style.left = pxToVw((triggerRect.width - tooltipRect.width) / 2);
      tooltipEl.style.right = "auto";
      tooltipEl.style.top = "auto";
    } else if (position === "bottom") {
      tooltipEl.style.top = pxToVh(triggerRect.height + 8);
      tooltipEl.style.left = pxToVw((triggerRect.width - tooltipRect.width) / 2);
      tooltipEl.style.right = "auto";
      tooltipEl.style.bottom = "auto";
    } else if (position === "left") {
      tooltipEl.style.right = pxToVw(triggerRect.width + 8);
      tooltipEl.style.top = pxToVh((triggerRect.height - tooltipRect.height) / 2);
      tooltipEl.style.left = "auto";
      tooltipEl.style.bottom = "auto";
    } else if (position === "right") {
      tooltipEl.style.left = pxToVw(triggerRect.width + 8);
      tooltipEl.style.top = pxToVh((triggerRect.height - tooltipRect.height) / 2);
      tooltipEl.style.right = "auto";
      tooltipEl.style.bottom = "auto";
    }
  }, [isVisible, position]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative inline-flex justify-center items-center",
      ref: triggerRef,
      onMouseEnter: () => setIsVisible(true),
      onMouseLeave: () => setIsVisible(false),
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            ref: tooltipRef,
            initial: positions[position].initial,
            animate: positions[position].animate,
            exit: positions[position].exit,
            className: "absolute whitespace-nowrap z-50 rounded-[.5vh] px-[1vh] py-[.75vh] text-[1.35vh]",
            style: {
              background: SettingsStyles.tooltip?.background,
              color: SettingsStyles.tooltip?.textColor,
              fontFamily: font,
              boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)"
            },
            children: text
          }
        ) })
      ]
    }
  );
};

const STYLES = {
  wrapper: "w-full",
  labelContainer: "flex items-center gap-[.75vh] mb-[1.25vh]",
  icon: "text-[1.8vh]",
  label: "text-[1.45vh] font-medium",
  container: "w-full px-[.75vw] py-[1vh] border-[.1vh] rounded-[.5vh]",
  sliderContainer: "flex items-center gap-[.95vh] w-full",
  sliderWrapper: "relative w-full py-[1vh] cursor-pointer",
  sliderTrack: "relative w-full h-[.4vh] rounded-full",
  sliderProgress: "absolute h-full rounded-full will-change-[width]",
  sliderInput: "absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10",
  sliderKnob: "absolute size-[1.25vh] rounded-full will-change-[left]",
  valueContainer: "relative w-[5vh] h-[2.4vh] flex items-center justify-end",
  valueText: "text-[1.45vh] text-right cursor-pointer transition-colors w-full truncate",
  valueInput: "absolute inset-0 text-[1.25vh] text-right border rounded-[.3vh] px-[.5vh] py-[.2vh] focus:outline-none"
};
const ValueText = newStyled.span`
  color: ${SettingsStyles.slider.value.textColor};
  &:hover {
    color: ${SettingsStyles.slider.value.hoverTextColor};
  }
`;
const ValueInput = newStyled.input`
  background: ${SettingsStyles.slider.value.inputBackground};
  border-color: ${SettingsStyles.slider.value.inputBorderColor};
  color: ${SettingsStyles.slider.value.inputTextColor};
  &:focus { 
    border-color: ${SettingsStyles.slider.value.focusBorderColor};
  }
`;
const DashboardSlider = reactExports.memo(({
  label,
  value,
  onChange,
  icon,
  min = 50,
  max = 100,
  step = 1,
  disabled = false
}) => {
  const [localValue, setLocalValue] = reactExports.useState(
    typeof value === "number" ? value : min || 0
  );
  const [displayValue, setDisplayValue] = reactExports.useState(localValue);
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [inputValue, setInputValue] = reactExports.useState(localValue.toString());
  const inputRef = reactExports.useRef(null);
  const sliderRef = reactExports.useRef(null);
  const animationRef = reactExports.useRef(null);
  const lastPositionRef = reactExports.useRef(0);
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  reactExports.useEffect(() => {
    if (!isDragging && !isEditing && typeof value === "number") {
      setLocalValue(value);
      setDisplayValue(value);
      setInputValue(value.toString());
    }
  }, [value, isDragging, isEditing]);
  reactExports.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);
  const calculateValue = reactExports.useCallback((clientX) => {
    if (!sliderRef.current) return localValue;
    const rect = sliderRef.current.getBoundingClientRect();
    let position = (clientX - rect.left) / rect.width;
    position = Math.max(0, Math.min(1, position));
    lastPositionRef.current = position;
    const rawValue = min + position * (max - min);
    return rawValue;
  }, [min, max, localValue]);
  reactExports.useEffect(() => {
    const handleMouseMove = (e) => {
      if (!isDragging || disabled) return;
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      animationRef.current = requestAnimationFrame(() => {
        const rawValue = calculateValue(e.clientX);
        setDisplayValue(rawValue);
        const steppedValue = Math.round(rawValue / step) * step;
        setLocalValue(steppedValue);
        setInputValue(steppedValue.toString());
      });
    };
    const handleMouseUp = (e) => {
      if (isDragging) {
        const rawValue = calculateValue(e.clientX);
        const clampedValue = Math.max(min, Math.min(max, rawValue));
        const steppedValue = Math.round(clampedValue / step) * step;
        setLocalValue(steppedValue);
        setDisplayValue(steppedValue);
        setInputValue(steppedValue.toString());
        onChange(steppedValue);
      }
      setIsDragging(false);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
    const handleTouchMove = (e) => {
      if (!isDragging || disabled) return;
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      animationRef.current = requestAnimationFrame(() => {
        const touch = e.touches[0];
        if (!touch) return;
        const rawValue = calculateValue(touch.clientX);
        setDisplayValue(rawValue);
        const steppedValue = Math.round(rawValue / step) * step;
        setLocalValue(steppedValue);
        setInputValue(steppedValue.toString());
      });
    };
    const handleTouchEnd = (e) => {
      if (isDragging && e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        if (!touch) return;
        const rawValue = calculateValue(touch.clientX);
        const clampedValue = Math.max(min, Math.min(max, rawValue));
        const steppedValue = Math.round(clampedValue / step) * step;
        setLocalValue(steppedValue);
        setDisplayValue(steppedValue);
        setInputValue(steppedValue.toString());
        onChange(steppedValue);
      }
      setIsDragging(false);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
    if (isDragging) {
      window.addEventListener("mousemove", handleMouseMove, { passive: true });
      window.addEventListener("mouseup", handleMouseUp);
      window.addEventListener("touchmove", handleTouchMove, { passive: true });
      window.addEventListener("touchend", handleTouchEnd);
    }
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      window.removeEventListener("touchmove", handleTouchMove);
      window.removeEventListener("touchend", handleTouchEnd);
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [isDragging, min, max, step, onChange, disabled, calculateValue]);
  const handleChange = (e) => {
    const newValue = Number(e.target.value);
    const formattedValue = formatNumber(newValue, step);
    setLocalValue(formattedValue);
    setDisplayValue(formattedValue);
    setInputValue(formattedValue.toString());
    onChange(formattedValue);
  };
  const handleSliderClick = (e) => {
    if (disabled) return;
    const rawValue = calculateValue(e.clientX);
    const clampedValue = Math.max(min, Math.min(max, rawValue));
    const steppedValue = Math.round(clampedValue / step) * step;
    const formattedValue = formatNumber(steppedValue, step);
    setLocalValue(formattedValue);
    setDisplayValue(formattedValue);
    setInputValue(formattedValue.toString());
    onChange(formattedValue);
  };
  const handleInputChange = (e) => {
    setInputValue(e.target.value);
  };
  const handleInputBlur = () => {
    commitInputValue();
  };
  const handleInputKeyDown = (e) => {
    if (e.key === "Enter") {
      commitInputValue();
    } else if (e.key === "Escape") {
      setIsEditing(false);
      setInputValue(localValue.toString());
    }
  };
  const commitInputValue = () => {
    let newValue = Number(inputValue);
    if (isNaN(newValue)) {
      newValue = localValue;
    }
    newValue = Math.max(min, Math.min(max, newValue));
    newValue = Math.round(newValue / step) * step;
    const formattedValue = formatNumber(newValue, step);
    setLocalValue(formattedValue);
    setDisplayValue(formattedValue);
    setInputValue(formattedValue.toString());
    onChange(formattedValue);
    setIsEditing(false);
  };
  const percentage = (displayValue - min) / (max - min) * 100;
  const shouldShowTooltip = (val) => {
    const text = val.toString();
    return text.includes(".") && text.length > 6;
  };
  const getDisplayText = (val) => {
    const text = val.toString();
    if (text.length <= 6) return text;
    if (text.includes(".")) {
      const [integer, decimal] = text.split(".");
      if (integer && integer.length > 3) {
        return `${integer.slice(0, 3)}...`;
      }
      const maxDecimal = 6 - (integer?.length || 0) - 1;
      return `${integer}.${decimal?.slice(0, Math.max(1, maxDecimal)) || ""}`;
    }
    return `${text.slice(0, 5)}...`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: STYLES.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: STYLES.labelContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Icon$1,
        {
          icon,
          className: STYLES.icon,
          style: {
            color: SettingsStyles.slider.iconColor
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          className: STYLES.label,
          style: {
            fontFamily: font,
            color: SettingsStyles.slider.labelColor
          },
          children: label
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: STYLES.container,
        style: {
          background: SettingsStyles.slider.container.background,
          borderColor: SettingsStyles.slider.container.borderColor
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: STYLES.sliderContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: sliderRef,
              className: STYLES.sliderWrapper,
              onClick: handleSliderClick,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: STYLES.sliderTrack,
                  style: {
                    background: SettingsStyles.slider.track.background
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: STYLES.sliderProgress,
                        style: {
                          width: `${percentage}%`,
                          background: SettingsStyles.slider.track.progressColor
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "range",
                        value: localValue,
                        onChange: handleChange,
                        onMouseDown: (e) => {
                          e.stopPropagation();
                          setIsDragging(true);
                        },
                        onTouchStart: (e) => {
                          e.stopPropagation();
                          setIsDragging(true);
                        },
                        min,
                        max,
                        step,
                        disabled,
                        className: STYLES.sliderInput,
                        style: { WebkitAppearance: "none" }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: `${STYLES.sliderKnob} ${isDragging ? "scale-110" : ""}`,
                        style: {
                          left: `${percentage}%`,
                          transform: `translateX(-50%) translateY(-50%)`,
                          marginTop: ".3vh",
                          cursor: disabled ? "not-allowed" : isDragging ? "grabbing" : "grab",
                          pointerEvents: "none",
                          background: SettingsStyles.slider.track.knobColor,
                          boxShadow: SettingsStyles.slider.track.knobShadow
                        }
                      }
                    )
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: STYLES.valueContainer, children: [
            shouldShowTooltip(localValue) ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { text: localValue.toString(), position: "top", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ValueText,
              {
                className: STYLES.valueText,
                onClick: () => !disabled && setIsEditing(true),
                style: {
                  fontFamily: font,
                  visibility: isEditing ? "hidden" : "visible"
                },
                children: getDisplayText(localValue)
              }
            ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              ValueText,
              {
                className: STYLES.valueText,
                onClick: () => !disabled && setIsEditing(true),
                style: {
                  fontFamily: font,
                  visibility: isEditing ? "hidden" : "visible"
                },
                children: getDisplayText(localValue)
              }
            ),
            isEditing && /* @__PURE__ */ jsxRuntimeExports.jsx(
              ValueInput,
              {
                ref: inputRef,
                type: "text",
                className: STYLES.valueInput,
                value: inputValue,
                onChange: handleInputChange,
                onBlur: handleInputBlur,
                onKeyDown: handleInputKeyDown,
                style: {
                  fontFamily: font
                }
              }
            )
          ] })
        ] })
      }
    )
  ] });
});
DashboardSlider.displayName = "DashboardSlider";

const ScrollButton = newStyled(motion.button)`
  position: absolute;
  bottom: 6.95vh;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 2.35vh;
  height: 2.35vh;
  border-radius: 50%;
  background: ${SettingsStyles.scrollToTop.background};
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  color: white;
  z-index: 10;
  transition: background .25s ease;
`;
const ScrollToTop = ({ targetRef, className }) => {
  const [isVisible, setIsVisible] = reactExports.useState(false);
  const checkScrollPosition = reactExports.useCallback(() => {
    if (!targetRef.current) return;
    const { scrollTop, clientHeight } = targetRef.current;
    setIsVisible(scrollTop > clientHeight * 0.3);
  }, [targetRef]);
  reactExports.useEffect(() => {
    const scrollContainer = targetRef.current;
    if (!scrollContainer) return;
    scrollContainer.addEventListener("scroll", checkScrollPosition);
    checkScrollPosition();
    return () => {
      scrollContainer.removeEventListener("scroll", checkScrollPosition);
    };
  }, [targetRef, checkScrollPosition]);
  const scrollToTop = () => {
    if (!targetRef.current) return;
    targetRef.current.scrollTo({
      top: 0,
      behavior: "smooth"
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollButton,
    {
      className,
      onClick: scrollToTop,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "mdi:chevron-up", className: "text-[2vh]" })
    }
  ) });
};

const dialogVariants$1 = {
  initial: { opacity: 0, scale: 0.9 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.9 }
};
const CloseButton$1 = newStyled.button`
  background: ${SettingsStyles.button.close.background};
  border-color: ${SettingsStyles.button.close.borderColor};
  color: ${SettingsStyles.button.close.textColor};
  &:hover {
    background: ${SettingsStyles.button.close.hoverBackground};
    border-color: ${SettingsStyles.button.close.hoverBorderColor};
  }
`;
function NotifySettings({ onClose, defaultSettings }) {
  const { hudSettings, updateNotifySettings, saveChanges, discardChanges, hasUnsavedChanges } = useSettingsStore();
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const { setSound, setVolume } = useSound();
  const notification = useNotification(hudSettings?.notification);
  const [currentPreviewType, setCurrentPreviewType] = reactExports.useState(0);
  const scrollContainerRef = reactExports.useRef(null);
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  const themeOptions = formatOptionsFromEntries(
    NotificationThemes
  );
  const positionOptions = formatOptionsFromEntries(
    NotificationPositions,
    "snake_case",
    {
      [NotificationPositions.TOP_LEFT]: localesConfig?.notify.groups.layout.positionOptions.top_left ?? "Top Left",
      [NotificationPositions.TOP_RIGHT]: localesConfig?.notify.groups.layout.positionOptions.top_right ?? "Top Right",
      [NotificationPositions.TOP_CENTER]: localesConfig?.notify.groups.layout.positionOptions.top_center ?? "Top Center",
      [NotificationPositions.BOTTOM_LEFT]: localesConfig?.notify.groups.layout.positionOptions.bottom_left ?? "Bottom Left",
      [NotificationPositions.BOTTOM_RIGHT]: localesConfig?.notify.groups.layout.positionOptions.bottom_right ?? "Bottom Right",
      [NotificationPositions.BOTTOM_CENTER]: localesConfig?.notify.groups.layout.positionOptions.bottom_center ?? "Bottom Center"
    }
  );
  const animationOptions = formatOptionsFromEntries(
    NotificationAnimations,
    "normal",
    {
      [NotificationAnimations.SLIDE]: localesConfig?.notify.groups.animation.options.slide ?? "Slide",
      [NotificationAnimations.FADE]: localesConfig?.notify.groups.animation.options.fade ?? "Fade",
      [NotificationAnimations.BOUNCE]: localesConfig?.notify.groups.animation.options.bounce ?? "Bounce",
      [NotificationAnimations.SCALE]: localesConfig?.notify.groups.animation.options.scale ?? "Scale",
      [NotificationAnimations.ELASTIC]: localesConfig?.notify.groups.animation.options.elastic ?? "Elastic"
    }
  );
  const variantOptions = formatOptionsFromEntries(
    NotificationVariants,
    "snake_case",
    {
      [NotificationVariants.BASIC]: localesConfig?.notify.groups.appearance.variantOptions.basic ?? "Basic",
      [NotificationVariants.TITLE]: localesConfig?.notify.groups.appearance.variantOptions.title ?? "Title Only",
      [NotificationVariants.ICON_ONLY]: localesConfig?.notify.groups.appearance.variantOptions.icon_only ?? "Icon Only",
      [NotificationVariants.TEXT_ONLY]: localesConfig?.notify.groups.appearance.variantOptions.text_only ?? "Text Only",
      [NotificationVariants.ICON_NO_CLOSE]: localesConfig?.notify.groups.appearance.variantOptions.icon_no_close ?? "Icon Without Close",
      [NotificationVariants.LONG_TEXT]: localesConfig?.notify.groups.appearance.variantOptions.long_text ?? "Long Text"
    }
  );
  const soundOptions = formatSoundOptions(NotificationSounds);
  reactExports.useEffect(() => {
    if (!hudSettings || Object.keys(hudSettings).length === 0) {
      const newSettings = { ...defaultSettings };
      updateNotifySettings(newSettings);
    }
  }, [defaultSettings, hudSettings, updateNotifySettings]);
  const handlePositionChange = (value) => {
    updateNotifySettings({
      position: value
    });
  };
  const handleAnimationTypeChange = (value) => {
    updateNotifySettings({
      animation: {
        ...hudSettings?.notification?.animation,
        type: value,
        duration: hudSettings?.notification?.animation?.duration ?? 0.5,
        distance: hudSettings?.notification?.animation?.distance ?? 250
      }
    });
  };
  const handlePreview = reactExports.useCallback(() => {
    if (!hudSettings?.notification?.duration || !hudSettings?.notification?.defaultVariant) return;
    const commonOptions = {
      title: localesConfig?.notify.preview.title,
      message: localesConfig?.notify.preview.message,
      duration: hudSettings?.notification?.duration,
      variant: hudSettings?.notification?.defaultVariant,
      scale: hudSettings?.notification?.scale ?? 100,
      textOptions: hudSettings?.notification?.textOptions ?? {
        enabled: false,
        isTruncated: false,
        maxLines: 2
      },
      sound: hudSettings?.notification?.sound ?? {
        name: hudSettings?.notification?.sound?.name ?? "Sound 1",
        path: hudSettings?.notification?.sound?.path ?? formatSoundPath("/sounds/sound_1.mp3"),
        volume: hudSettings?.notification?.sound?.volume ?? 0.5,
        enabled: hudSettings?.notification?.sound?.enabled ?? false
      }
    };
    const notificationTypes = [
      { type: "info", fn: notification.info },
      { type: "success", fn: notification.success },
      { type: "warning", fn: notification.warning },
      { type: "error", fn: notification.error }
    ];
    const currentType = notificationTypes[currentPreviewType];
    currentType?.fn(`${currentType.type.charAt(0).toUpperCase() + currentType.type.slice(1)} Notification`, commonOptions);
    setCurrentPreviewType((prev) => (prev + 1) % notificationTypes.length);
  }, [notification, hudSettings, currentPreviewType]);
  const handleClose = reactExports.useCallback(() => {
    if (hasUnsavedChanges) {
      discardChanges();
    }
    onClose();
  }, [hasUnsavedChanges, discardChanges, onClose]);
  reactExports.useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === "Escape") {
        handleClose();
      }
    };
    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [handleClose]);
  const handleSave = () => {
    saveChanges();
    onClose();
    notification.success(localesConfig?.hud.notifications.success.notifySettingsSaved, {
      duration: 3e3
    });
  };
  const handleThemeChange = (value) => {
    updateNotifySettings({
      theme: value,
      baseStyle: value
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      variants: dialogVariants$1,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      className: "rounded-[.75vh] w-[40vw] max-h-[90vh] flex flex-col",
      style: {
        background: SettingsStyles.container.background
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "px-[1.15vw] py-[2vh] border-b-[.15vh] flex items-center justify-between",
            style: {
              borderBottomColor: SettingsStyles.container.borderColorBottom
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h1",
                  {
                    className: "text-[2vh] font-semibold",
                    style: {
                      fontFamily: font,
                      color: SettingsStyles.title.header
                    },
                    children: localesConfig.notify.title || "Notification Settings"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "p",
                  {
                    className: "text-[1.35vh] mt-[.5vh]",
                    style: {
                      fontFamily: font,
                      color: SettingsStyles.title.subHeader
                    },
                    children: localesConfig.notify.description || "Customize your notifications in here. Press save when you're done."
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CloseButton$1,
                {
                  className: "\r\n          absolute top-[2.25vh] right-[1.15vw] p-[.75vh] border-[.15vh] \r\n          text-[1.35vh] rounded-[.75vh] transition-all duration-250",
                  onClick: handleClose,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "mdi:close", className: "text-[1.75vh]" })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start gap-[2vh] px-[1.15vw] py-[2vh] overflow-y-auto relative", ref: scrollContainerRef, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig.notify.groups.appearance.title || "Appearance", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardSelect,
                {
                  label: localesConfig.notify.groups.appearance.theme || "Theme",
                  icon: "mdi:theme-light-dark",
                  value: hudSettings?.notification?.theme,
                  onChange: handleThemeChange,
                  options: themeOptions
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardInput,
                {
                  label: localesConfig.notify.groups.appearance.spacing || "Spacing",
                  icon: "iconoir:line-space",
                  value: Number(hudSettings?.notification?.spacing),
                  onChange: (value) => updateNotifySettings({ spacing: value.toString() }),
                  min: 0.5,
                  max: 10,
                  step: 0.5
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardSlider,
                {
                  label: localesConfig.notify.groups.appearance.scale || "Scale",
                  icon: "mdi:scale",
                  value: hudSettings?.notification?.scale ?? 100,
                  onChange: (value) => updateNotifySettings({ scale: value }),
                  min: 30,
                  max: 100,
                  step: 1
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardSelect,
                {
                  label: localesConfig.notify.groups.appearance.variant || "Variant",
                  icon: "mdi:view-grid-outline",
                  value: hudSettings?.notification?.defaultVariant ?? "",
                  onChange: (value) => updateNotifySettings({
                    defaultVariant: value
                  }),
                  options: variantOptions
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig.notify.groups.layout.title, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardSelect,
              {
                label: localesConfig.notify.groups.layout.position || "Position",
                icon: "mdi:map-marker-outline",
                value: hudSettings?.notification?.position ?? "",
                onChange: (value) => handlePositionChange(value),
                options: positionOptions
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardInput,
              {
                label: localesConfig.notify.groups.layout.maxNotifications || "Max Notifications",
                icon: "icon-park-outline:maximum",
                value: hudSettings?.notification?.maxNotifications ?? 0,
                onChange: (value) => updateNotifySettings({ maxNotifications: value }),
                min: 1,
                max: 10
              }
            )
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig.notify.groups.sound.title || "Sound", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-[2vh]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardToggle,
              {
                label: localesConfig.notify.groups.sound.enable || "Enable Sound",
                icon: "mdi:volume-high",
                value: hudSettings?.notification?.sound?.enabled ?? false,
                onChange: (value) => {
                  const newSoundConfig = {
                    ...hudSettings?.notification?.sound,
                    enabled: value
                  };
                  updateNotifySettings({ sound: newSoundConfig });
                  setSound(newSoundConfig);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: hudSettings?.notification?.sound?.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                initial: { opacity: 0, height: 0 },
                animate: { opacity: 1, height: "auto" },
                exit: { opacity: 0, height: 0 },
                transition: {
                  height: {
                    duration: 0.2,
                    ease: "easeInOut"
                  },
                  opacity: {
                    duration: 0.15,
                    ease: "linear"
                  }
                },
                className: "grid grid-cols-2 gap-[2vh]",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardSelect,
                    {
                      label: localesConfig.notify.groups.sound.select || "Notification Sound",
                      icon: "mdi:music-note",
                      value: Object.entries(NotificationSounds).find(
                        ([_, sound]) => sound.path === hudSettings?.notification?.sound?.path
                      )?.[0] || "",
                      onChange: (value) => {
                        const selectedSound = NotificationSounds[value];
                        if (!selectedSound) return;
                        const newSoundConfig = {
                          ...hudSettings?.notification?.sound,
                          name: selectedSound.name,
                          path: selectedSound.path,
                          volume: hudSettings?.notification?.sound?.volume ?? 0.5,
                          enabled: hudSettings?.notification?.sound?.enabled ?? true
                        };
                        updateNotifySettings({ sound: newSoundConfig });
                        setSound(newSoundConfig);
                      },
                      options: soundOptions
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardSlider,
                    {
                      label: localesConfig.notify.groups.sound.volume || "Sound Volume",
                      icon: "mdi:volume-high",
                      value: hudSettings?.notification?.sound?.volume * 100,
                      onChange: (value) => {
                        const normalizedVolume = value / 100;
                        updateNotifySettings({
                          sound: { ...hudSettings?.notification?.sound, volume: normalizedVolume }
                        });
                        setVolume(normalizedVolume);
                      },
                      min: 0,
                      max: 100,
                      step: 1
                    }
                  )
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig.notify.groups.text.title || "Text", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col gap-[2vh]", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardToggle,
              {
                label: localesConfig.notify.groups.text.enableOptions || "Enable Options",
                icon: "carbon:intent-request-active",
                value: hudSettings?.notification?.textOptions?.enabled ?? false,
                onChange: (value) => updateNotifySettings({
                  textOptions: {
                    ...hudSettings?.notification?.textOptions,
                    enabled: value
                  }
                })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: hudSettings?.notification?.textOptions?.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                initial: { opacity: 0, height: 0 },
                animate: { opacity: 1, height: "auto" },
                exit: { opacity: 0, height: 0 },
                transition: {
                  height: {
                    duration: 0.2,
                    ease: "easeInOut"
                  },
                  opacity: {
                    duration: 0.15,
                    ease: "linear"
                  }
                },
                className: "grid grid-cols-2 gap-[2vh]",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardToggle,
                    {
                      label: localesConfig.notify.groups.text.truncate || "Truncate",
                      icon: "mdi:text-box-outline",
                      hasDescription: true,
                      customDescription: {
                        enabled: localesConfig?.toggleStates.enabled,
                        disabled: localesConfig?.toggleStates.disabled
                      },
                      value: hudSettings?.notification?.textOptions?.isTruncated ?? false,
                      onChange: (value) => updateNotifySettings({
                        textOptions: {
                          ...hudSettings?.notification?.textOptions,
                          isTruncated: value
                        }
                      })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardInput,
                    {
                      label: localesConfig.notify.groups.text.maxLines || "Max Lines",
                      icon: "mingcute:menu-line",
                      value: hudSettings?.notification?.textOptions?.maxLines ?? 0,
                      onChange: (value) => updateNotifySettings({
                        textOptions: {
                          ...hudSettings?.notification?.textOptions,
                          maxLines: value
                        }
                      }),
                      min: 1,
                      max: 5,
                      step: 1,
                      disabled: hudSettings?.notification?.textOptions?.isTruncated ?? false
                    }
                  )
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig.notify.groups.animation.title || "Animation", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardSelect,
                {
                  label: localesConfig.notify.groups.animation.type || "Animation Type",
                  icon: "mdi:animation-outline",
                  value: hudSettings?.notification?.animation?.type ?? "",
                  onChange: (value) => handleAnimationTypeChange(value),
                  options: animationOptions
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardSlider,
                {
                  label: localesConfig.notify.groups.animation.duration || "Animation Duration",
                  icon: "mdi:timer-outline",
                  value: hudSettings?.notification?.animation?.duration ?? 0,
                  onChange: (value) => updateNotifySettings({
                    animation: {
                      ...hudSettings?.notification?.animation,
                      duration: value
                    }
                  }),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DashboardSlider,
              {
                label: localesConfig.notify.groups.animation.distance || "Animation Distance",
                icon: "mdi:arrow-expand-horizontal",
                value: hudSettings?.notification?.animation?.distance ?? 0,
                onChange: (value) => updateNotifySettings({
                  animation: {
                    ...hudSettings?.notification?.animation,
                    distance: value
                  }
                }),
                min: 100,
                max: 500,
                step: 50
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig.notify.groups.behavior.title || "Behavior", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DashboardSlider,
            {
              label: localesConfig.notify.groups.behavior.duration || "Display Duration",
              icon: "mdi:timer-outline",
              value: hudSettings?.notification?.duration ?? 0,
              onChange: (value) => updateNotifySettings({ duration: value }),
              min: 1e3,
              max: 1e4,
              step: 500
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollToTop, { targetRef: scrollContainerRef }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "px-[1.15vw] py-[2.5vh] border-t-[.15vh]",
            style: {
              borderTopColor: SettingsStyles.container.borderColorTop
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-[1vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardButton,
                {
                  icon: "ion:eye-outline",
                  onClick: handlePreview,
                  css: css`
              background: ${SettingsStyles.button.action.background};
              border-color: ${SettingsStyles.button.action.borderColor};
              color: ${SettingsStyles.button.action.textColor};
              &:hover {
                background: ${SettingsStyles.button.action.hoverBackground};
                border-color: ${SettingsStyles.button.action.hoverBorderColor};
              }
            `,
                  children: localesConfig.notify.buttons.preview || "Preview"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardButton,
                {
                  icon: "ion:save-outline",
                  onClick: handleSave,
                  css: css`
              background: ${SettingsStyles.button.submit.background};
              border-color: ${SettingsStyles.button.submit.borderColor};
              color: ${SettingsStyles.button.submit.textColor};
              &:hover {
                background: ${SettingsStyles.button.submit.hoverBackground};
                border-color: ${SettingsStyles.button.submit.hoverBorderColor};
              }
            `,
                  children: localesConfig.notify.buttons.save || "Save Changes"
                }
              )
            ] })
          }
        )
      ]
    }
  );
}

const modalOverlayVariants$1 = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 }
};
const modalContentVariants$1 = {
  initial: { opacity: 0, scale: 0.9 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.9 }
};
const DashboardModal = ({
  title,
  message,
  onClick,
  onCancel,
  confirmText = "Confirm",
  cancelText = "Cancel"
}) => {
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      variants: modalOverlayVariants$1,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      className: "fixed inset-0 flex items-center justify-center z-[999]",
      style: {
        background: SettingsStyles.container.overlay
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          variants: modalContentVariants$1,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          className: "rounded-[.75vh] w-[30vw] flex flex-col",
          style: {
            background: SettingsStyles.container.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-[1.15vw] py-[2vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-[1vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Icon$1,
                  {
                    icon: "mdi:alert-circle-outline",
                    className: "text-[2.5vh]",
                    style: {
                      color: SettingsStyles.modal.icon.color
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h1",
                  {
                    className: "text-[2vh] font-semibold",
                    style: {
                      fontFamily: font,
                      color: SettingsStyles.title.header
                    },
                    children: title
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "p",
                {
                  className: "text-[1.35vh] mt-[1vh]",
                  style: {
                    fontFamily: font,
                    color: SettingsStyles.title.subHeader
                  },
                  children: message
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-[1.15vw] py-[2vh] flex justify-end gap-[1vh]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardButton,
                {
                  onClick: onCancel,
                  icon: "mdi:close",
                  css: css`
              background: ${SettingsStyles.button.action.background};
              border-color: ${SettingsStyles.button.action.borderColor};
              color: ${SettingsStyles.button.action.textColor};
              &:hover {
                background: ${SettingsStyles.button.action.hoverBackground};
                border-color: ${SettingsStyles.button.action.hoverBorderColor};
              }
            `,
                  children: cancelText
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DashboardButton,
                {
                  onClick,
                  icon: "mdi:check",
                  css: css`
              background: ${SettingsStyles.button.submit.background};
              border-color: ${SettingsStyles.button.submit.borderColor};
              color: ${SettingsStyles.button.submit.textColor};
              &:hover {
                background: ${SettingsStyles.button.submit.hoverBackground};
                border-color: ${SettingsStyles.button.submit.hoverBorderColor};
              }
            `,
                  children: confirmText
                }
              )
            ] })
          ]
        }
      )
    }
  );
};

const modalOverlayVariants = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 }
};
const modalContentVariants = {
  initial: { opacity: 0, scale: 0.9 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.9 }
};
const HudDisabledElementsModal = ({
  adminDisabledElements,
  onSave,
  onClose
}) => {
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const useCustomNotifications = useConfigStore((state) => state.config.useCustomNotifications);
  const { hudSettings } = useSettingsStore();
  const [localDisabledElements, setLocalDisabledElements] = reactExports.useState(
    adminDisabledElements || {}
  );
  const notification = useNotification({
    theme: hudSettings?.notification?.theme || "light",
    baseStyle: hudSettings?.notification?.baseStyle || "light",
    duration: hudSettings?.notification?.duration || 3e3,
    position: hudSettings?.notification?.position || "top-right",
    maxNotifications: hudSettings?.notification?.maxNotifications || 5,
    spacing: hudSettings?.notification?.spacing || "1.5",
    defaultVariant: hudSettings?.notification?.defaultVariant || "basic",
    scale: hudSettings?.notification?.scale || 100,
    textOptions: hudSettings?.notification?.textOptions || {
      enabled: false,
      isTruncated: false,
      maxLines: 2
    },
    sound: hudSettings?.notification?.sound || {
      name: "Sound 1",
      path: "/sounds/sound_1.mp3",
      volume: 0.5,
      enabled: false
    },
    animation: hudSettings?.notification?.animation || {
      type: "slide",
      duration: 0.5,
      distance: 250
    }
  }, useCustomNotifications);
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  reactExports.useEffect(() => {
    setLocalDisabledElements(adminDisabledElements);
  }, [adminDisabledElements]);
  const handleToggleDisabledElement = (element) => {
    const newValue = !(localDisabledElements?.[element] ?? false);
    setLocalDisabledElements((prev) => ({
      ...prev,
      [element]: newValue
    }));
  };
  const handleToggleNestedDisabledElement = (parent, child) => {
    const currentParent = localDisabledElements?.[parent] || {};
    const newValue = !(currentParent?.[child] ?? false);
    setLocalDisabledElements((prev) => {
      return {
        ...prev,
        [parent]: {
          ...currentParent,
          [child]: newValue
        }
      };
    });
  };
  const handleSave = () => {
    onSave(localDisabledElements);
    notification.success(
      localesConfig?.hud?.notifications?.success.disabledElementsSaved || "Global disabled elements saved successfully!",
      { duration: 3e3 }
    );
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      variants: modalOverlayVariants,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      className: "fixed inset-0 flex items-center justify-center z-[999]",
      style: {
        background: SettingsStyles.container.overlay
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          variants: modalContentVariants,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          className: "rounded-[.75vh] w-[40vw] max-h-[80vh] flex flex-col",
          style: {
            background: SettingsStyles.container.background
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "px-[1.15vw] py-[2vh] border-b-[.15vh] flex items-center justify-between",
                style: {
                  borderBottomColor: SettingsStyles.container.borderColorBottom
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h1",
                      {
                        className: "text-[2vh] font-semibold",
                        style: {
                          fontFamily: font,
                          color: SettingsStyles.title.header
                        },
                        children: localesConfig?.hud?.admin?.disabledElements?.title || "Global Disabled Elements"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        className: "text-[1.35vh] mt-[.5vh]",
                        style: {
                          fontFamily: font,
                          color: SettingsStyles.title.subHeader
                        },
                        children: localesConfig?.hud?.admin?.disabledElements?.description || "Configure which HUD elements should be disabled for all players. Disabled elements will not be visible to any player."
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: onClose,
                      className: "absolute top-[2.25vh] right-[1.15vw] p-[.75vh] border-[.15vh] text-[1.35vh] rounded-[.75vh] transition-all duration-250",
                      style: {
                        background: SettingsStyles.button.close.background,
                        borderColor: SettingsStyles.button.close.borderColor,
                        color: SettingsStyles.button.close.textColor
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "mdi:close", className: "text-[1.75vh]" })
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-[1.15vw] py-[2vh] space-y-[2vh] overflow-y-auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud?.admin?.disabledElements?.mainElements || "Main Elements", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.serverInfo || "Server Info",
                    icon: "mdi:server",
                    value: localDisabledElements?.serverInfo || false,
                    onChange: () => handleToggleDisabledElement("serverInfo"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.location || "Location",
                    icon: "mdi:map-marker",
                    value: localDisabledElements?.location || false,
                    onChange: () => handleToggleDisabledElement("location"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.weapon || "Weapon",
                    icon: "mdi:pistol",
                    value: localDisabledElements?.weapon || false,
                    onChange: () => handleToggleDisabledElement("weapon"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.voice || "Voice",
                    icon: "mdi:microphone",
                    value: localDisabledElements?.voice || false,
                    onChange: () => handleToggleDisabledElement("voice"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.playerStatus || "Player Status",
                    icon: "mdi:account-details",
                    value: localDisabledElements?.playerStatus || false,
                    onChange: () => handleToggleDisabledElement("playerStatus"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.account || "Account",
                    icon: "mdi:wallet",
                    value: localDisabledElements?.account || false,
                    onChange: () => handleToggleDisabledElement("account"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.elements.vehicleHud || "Vehicle HUD",
                    icon: "mdi:car",
                    value: localDisabledElements?.vehicle || false,
                    onChange: () => handleToggleDisabledElement("vehicle"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.serverInfo.title || "Server Info Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    icon: "mdi:server",
                    label: localesConfig?.hud.groups.serverInfo.logo || "Logo",
                    value: localDisabledElements?.serverInfoItems?.logo || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "logo"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    icon: "mdi:server",
                    label: localesConfig?.hud.groups.serverInfo.serverInfo || "Server Info",
                    value: localDisabledElements?.serverInfoItems?.serverInfo || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "serverInfo"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.id || "ID",
                    icon: "mdi:id-card",
                    value: localDisabledElements?.serverInfoItems?.id || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "id"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.players || "Players",
                    icon: "mdi:account-group",
                    value: localDisabledElements?.serverInfoItems?.players || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "players"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.job || "Job",
                    icon: "mdi:briefcase",
                    value: localDisabledElements?.serverInfoItems?.job || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "job"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.job2 || "Job 2",
                    icon: "mdi:briefcase",
                    value: localDisabledElements?.serverInfoItems?.job2 || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "job2"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.gang || "Gang",
                    icon: "mdi:account-group",
                    value: localDisabledElements?.serverInfoItems?.gang || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "gang"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.gang2 || "Gang 2",
                    icon: "mdi:account-group",
                    value: localDisabledElements?.serverInfoItems?.gang2 || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "gang2"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.time || "Time",
                    icon: "mdi:clock",
                    value: localDisabledElements?.serverInfoItems?.time || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "time"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.serverInfo.divider || "Divider",
                    icon: "mdi:divider",
                    value: localDisabledElements?.serverInfoItems?.divider || false,
                    onChange: () => handleToggleNestedDisabledElement("serverInfoItems", "divider"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.account.title || "Account Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.account.cash || "Cash",
                    icon: "mdi:cash",
                    value: localDisabledElements?.accountItems?.cash || false,
                    onChange: () => handleToggleNestedDisabledElement("accountItems", "cash"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.account.bank || "Bank",
                    icon: "mdi:bank",
                    value: localDisabledElements?.accountItems?.bank || false,
                    onChange: () => handleToggleNestedDisabledElement("accountItems", "bank"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.account.blackMoney || "Black Money",
                    icon: "mdi:bank",
                    value: localDisabledElements?.accountItems?.blackMoney || false,
                    onChange: () => handleToggleNestedDisabledElement("accountItems", "blackMoney"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.account.time || "Time",
                    icon: "mdi:clock",
                    value: localDisabledElements?.accountItems?.time || false,
                    onChange: () => handleToggleNestedDisabledElement("accountItems", "time"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.playerStatus.title || "Player Status Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.health || "Health",
                    icon: "mdi:heart",
                    value: localDisabledElements?.playerStatusItems?.health || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "health"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.armor || "Armor",
                    icon: "mdi:shield",
                    value: localDisabledElements?.playerStatusItems?.armor || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "armor"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.hunger || "Hunger",
                    icon: "mdi:food",
                    value: localDisabledElements?.playerStatusItems?.hunger || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "hunger"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.thirst || "Thirst",
                    icon: "mdi:water",
                    value: localDisabledElements?.playerStatusItems?.thirst || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "thirst"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.stamina || "Stamina",
                    icon: "mdi:run",
                    value: localDisabledElements?.playerStatusItems?.stamina || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "stamina"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.stress || "Stress",
                    icon: "mdi:brain",
                    value: localDisabledElements?.playerStatusItems?.stress || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "stress"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardToggle,
                  {
                    label: localesConfig?.hud.groups.playerStatus.oxygen || "Oxygen",
                    icon: "healthicons:oxygen-tank-24px",
                    value: localDisabledElements?.playerStatusItems?.oxygen || false,
                    onChange: () => handleToggleNestedDisabledElement("playerStatusItems", "oxygen"),
                    hasDescription: true,
                    customDescription: {
                      enabled: localesConfig?.toggleStates.disabled || "Disabled",
                      disabled: localesConfig?.toggleStates.enabled || "Enabled"
                    }
                  }
                ) })
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "px-[1.15vw] py-[2vh] flex items-center justify-end border-t-[.15vh] gap-[1vh]",
                style: {
                  borderTopColor: SettingsStyles.container.borderColorTop
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DashboardButton,
                  {
                    css: css`
              background: ${SettingsStyles.button.submit.background};
              border-color: ${SettingsStyles.button.submit.borderColor};
              color: ${SettingsStyles.button.submit.textColor};
              &:hover {
                background: ${SettingsStyles.button.submit.hoverBackground};
                border-color: ${SettingsStyles.button.submit.hoverBorderColor};
              }
            `,
                    icon: "ion:save-outline",
                    onClick: handleSave,
                    children: localesConfig?.hud.buttons.save || "Save Changes"
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
};

const StyledButton = newStyled.button`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1vh;
  border-width: .1vh;
  border-style: solid;
  border-radius: .5vh;
  transition: all 250ms;
  background: ${SettingsStyles.button.utility.background};
  border-color: ${SettingsStyles.button.utility.borderColor};
  color: ${SettingsStyles.button.utility.textColor};
  &:hover {
    background: ${SettingsStyles.button.utility.hoverBackground};
    border-color: ${SettingsStyles.button.utility.hoverBorderColor};
  }
`;
const IconButton = ({
  icon,
  onClick,
  size = "1.8vh",
  className = "",
  ariaLabel
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StyledButton,
    {
      "aria-label": ariaLabel,
      onClick,
      className,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon, style: { fontSize: size } })
    }
  );
};

const overlayVariants = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 }
};
const dialogVariants = {
  initial: { opacity: 0, scale: 0.9 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0, scale: 0.9 }
};
const CloseButton = newStyled.button`
  background: ${SettingsStyles.button.close.background};
  border-color: ${SettingsStyles.button.close.borderColor};
  color: ${SettingsStyles.button.close.textColor};
  &:hover {
    background: ${SettingsStyles.button.close.hoverBackground};
    border-color: ${SettingsStyles.button.close.hoverBorderColor};
  }
`;
function HudSettings() {
  const {
    isVisible,
    isAdminVisible,
    hudSettings,
    updateHudSettings,
    saveHudChanges,
    resetHudSettings,
    toggleDraggable,
    setSettingsVisible,
    closeHudSettings,
    hasUnsavedChanges,
    showUnsavedDialog,
    saveChanges,
    discardHudChanges,
    keepChanges,
    elementPositions,
    setAdminSettingsVisible,
    saveGlobalHudSettings,
    // Admin functions
    updateDisabledElement,
    updateNestedDisabledElement
  } = useSettingsStore();
  const { isVisible: isTutorialVisible, setTutorialVisible } = useTutorialStore();
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const advancedMapConfig = useConfigStore((state) => state.config.advancedMap);
  const availableThemes = useConfigStore((state) => state.config.avaliableThemes) || [];
  const disabledElements = useConfigStore((state) => state.disabledHudElements);
  const mapOption = useConfigStore((state) => state.config.mapOption);
  const useCustomNotifications = useConfigStore((state) => state.config.useCustomNotifications);
  const [isNotifySettingsOpen, setNotifySettingsOpen] = reactExports.useState(false);
  const [isThemeModalOpen, setThemeModalOpen] = reactExports.useState(false);
  const [selectedTheme, setSelectedTheme] = reactExports.useState(null);
  const [isDisabledElementsModalOpen, setDisabledElementsModalOpen] = reactExports.useState(false);
  const [adminDisabledElements, setAdminDisabledElements] = reactExports.useState(
    disabledElements || {}
  );
  const { theme, statusBarVariant, speedometerVariant, progressBarStyle, elementsVisibility } = hudSettings;
  const isSpecialTheme = theme === HudThemes.PIXEL || theme === HudThemes.RETRO;
  const isCyberpunkTheme = theme === HudThemes.CYBERPUNK_2;
  const settingsBaseStyle = HudBaseStyles.settingsMenu;
  const font = getFontFamily(defaultBaseStyle.fonts, settingsBaseStyle.font);
  reactExports.useEffect(() => {
    if (isAdminVisible) {
      setAdminDisabledElements(disabledElements || {});
    }
  }, [isAdminVisible, disabledElements]);
  const getThemeOptions = () => {
    const filteredThemes = {};
    if (!availableThemes || availableThemes.length === 0) {
      return formatOptionsFromEntries(HudThemes);
    }
    Object.entries(HudThemes).forEach(([key, value]) => {
      if (availableThemes.includes(key.toLowerCase()) || availableThemes.includes(value.toLowerCase())) {
        filteredThemes[key] = value;
      }
    });
    return formatOptionsFromEntries(filteredThemes);
  };
  const serverInfoOptions = formatOptionsFromEntries(
    ServerInfoVariant,
    "normal",
    {
      [ServerInfoVariant.DEFAULT]: localesConfig?.hud.groups.variantOptions.default ?? "Default",
      [ServerInfoVariant.SQUARE]: localesConfig?.hud.groups.variantOptions.square ?? "Square",
      [ServerInfoVariant.HEXAGON]: localesConfig?.hud.groups.variantOptions.hexagon ?? "Hexagon",
      [ServerInfoVariant.RHOMBUS]: localesConfig?.hud.groups.variantOptions.rhombus ?? "Rhombus",
      [ServerInfoVariant.ENVI]: localesConfig?.hud.groups.variantOptions.envi ?? "Envi"
    }
  );
  const accountOptions = formatOptionsFromEntries(
    AccountVariant,
    "normal",
    {
      [AccountVariant.DEFAULT]: localesConfig?.hud.groups.variantOptions.default ?? "Default",
      [AccountVariant.SQUARE]: localesConfig?.hud.groups.variantOptions.square ?? "Square",
      [AccountVariant.HEXAGON]: localesConfig?.hud.groups.variantOptions.hexagon ?? "Hexagon",
      [AccountVariant.RHOMBUS]: localesConfig?.hud.groups.variantOptions.rhombus ?? "Rhombus",
      [AccountVariant.ENVI]: localesConfig?.hud.groups.variantOptions.envi ?? "Envi"
    }
  );
  const statusBarOptions = formatOptionsFromEntries(
    StatusBarVariant,
    "normal",
    {
      [StatusBarVariant.DEFAULT]: localesConfig?.hud.groups.variantOptions.default ?? "Default",
      [StatusBarVariant.SQUARE]: localesConfig?.hud.groups.variantOptions.square ?? "Square",
      [StatusBarVariant.HEXAGON]: localesConfig?.hud.groups.variantOptions.hexagon ?? "Hexagon",
      [StatusBarVariant.RHOMBUS]: localesConfig?.hud.groups.variantOptions.rhombus ?? "Rhombus",
      [StatusBarVariant.ENVI]: localesConfig?.hud.groups.variantOptions.envi ?? "Envi"
    }
  );
  const speedometerOptions = formatOptionsFromEntries(SpeedometerThemes);
  const progressBarOptions = formatOptionsFromEntries(
    ProgressBarStyle,
    "normal",
    {
      [ProgressBarStyle.BORDER]: localesConfig?.hud.groups.statusBar.progressStyleOptions.border ?? "Border",
      [ProgressBarStyle.FILL]: localesConfig?.hud.groups.statusBar.progressStyleOptions.fill ?? "Fill"
    }
  );
  const animationOptions = formatOptionsFromEntries(
    HudAnimation,
    "normal",
    {
      [HudAnimation.DEFAULT]: localesConfig?.hud.groups.animation.options.default ?? "Default",
      [HudAnimation.FADE]: localesConfig?.hud.groups.animation.options.fade ?? "Fade",
      [HudAnimation.BOUNCE]: localesConfig?.hud.groups.animation.options.bounce ?? "Bounce",
      [HudAnimation.SLIDE]: localesConfig?.hud.groups.animation.options.slide ?? "Slide",
      [HudAnimation.SCALE]: localesConfig?.hud.groups.animation.options.scale ?? "Scale",
      [HudAnimation.ELASTIC]: localesConfig?.hud.groups.animation.options.elastic ?? "Elastic"
    }
  );
  const minimapTypeOptions = formatOptionsFromEntries(
    MinimapType,
    "normal",
    {
      [MinimapType.SQUARE]: localesConfig?.hud.groups.display.minimap.typeOptions.square ?? "Square",
      [MinimapType.CIRCLE]: localesConfig?.hud.groups.display.minimap.typeOptions.circle ?? "Circle"
    }
  ).filter((option) => option.value !== MinimapType.CIRCLE);
  const minimapSizeOptions = formatOptionsFromEntries(
    MinimapSize,
    "normal",
    {
      [MinimapSize.SMALL]: localesConfig?.hud.groups.display.minimap.sizeOptions.small ?? "Small",
      [MinimapSize.MEDIUM]: localesConfig?.hud.groups.display.minimap.sizeOptions.medium ?? "Medium",
      [MinimapSize.LARGE]: localesConfig?.hud.groups.display.minimap.sizeOptions.large ?? "Large"
    }
  );
  const timeModeOptions = formatOptionsFromEntries(
    TimeMode,
    "normal",
    {
      [TimeMode.IN_GAME]: localesConfig?.hud.groups.display.timeModeOptions.inGame ?? "In Game",
      [TimeMode.REAL_TIME]: localesConfig?.hud.groups.display.timeModeOptions.realTime ?? "Real Time"
    }
  );
  const progressBarVariantOptions = formatOptionsFromEntries(
    ProgressbarVariant,
    "snake_case",
    {
      [ProgressbarVariant.INCLUDE_TITLE_VALUE]: localesConfig?.hud.groups.progressbar.variantOptions.includeTitleValue ?? "Include Title and Value",
      [ProgressbarVariant.INCLUDE_TITLE]: localesConfig?.hud.groups.progressbar.variantOptions.includeTitle ?? "Include Title",
      [ProgressbarVariant.INCLUDE_VALUE]: localesConfig?.hud.groups.progressbar.variantOptions.includeValue ?? "Include Value",
      [ProgressbarVariant.ONLY_BAR]: localesConfig?.hud.groups.progressbar.variantOptions.onlyBar ?? "Only Progress Bar"
    }
  );
  const progressBarAnimationOptions = formatOptionsFromEntries(
    ProgressbarAnimation,
    "normal",
    {
      [ProgressbarAnimation.DEFAULT]: localesConfig?.hud?.groups?.progressbar?.animationOptions?.default || "Default",
      [ProgressbarAnimation.FADE]: localesConfig?.hud?.groups?.progressbar?.animationOptions?.fade || "Fade",
      [ProgressbarAnimation.SLIDE]: localesConfig?.hud?.groups?.progressbar?.animationOptions?.slide || "Slide",
      [ProgressbarAnimation.BOUNCE]: localesConfig?.hud?.groups?.progressbar?.animationOptions?.bounce || "Bounce"
    }
  );
  const progressBarDirectionOptions = formatOptionsFromEntries(
    ProgressbarAnimationDirection,
    "normal",
    {
      [ProgressbarAnimationDirection.DEFAULT]: localesConfig?.hud?.groups?.progressbar?.animationDirectionOptions?.default || "Default",
      [ProgressbarAnimationDirection.TOP]: localesConfig?.hud?.groups?.progressbar?.animationDirectionOptions?.top || "Top",
      [ProgressbarAnimationDirection.RIGHT]: localesConfig?.hud?.groups?.progressbar?.animationDirectionOptions?.right || "Right",
      [ProgressbarAnimationDirection.BOTTOM]: localesConfig?.hud?.groups?.progressbar?.animationDirectionOptions?.bottom || "Bottom",
      [ProgressbarAnimationDirection.LEFT]: localesConfig?.hud?.groups?.progressbar?.animationDirectionOptions?.left || "Left"
    }
  );
  const progressBarTextPositionOptions = formatOptionsFromEntries(
    ProgressbarTextPosition,
    "normal",
    {
      [ProgressbarTextPosition.ABOVE_BAR]: localesConfig?.hud?.groups?.progressbar?.textPositionOptions?.aboveBar || "Above Bar",
      [ProgressbarTextPosition.BELOW_BAR]: localesConfig?.hud?.groups?.progressbar?.textPositionOptions?.belowBar || "Below Bar"
    }
  );
  const currencyMap = getCurrencyCodeMap();
  const currencySymbolOptions = formatOptionsFromEntries(
    currencyMap,
    "normal",
    {
      [CurrencySymbol.USD.code]: localesConfig?.hud.groups.display.currencySymbolOptions.usd ?? "USD",
      [CurrencySymbol.EUR.code]: localesConfig?.hud.groups.display.currencySymbolOptions.eur ?? "EUR",
      [CurrencySymbol.GBP.code]: localesConfig?.hud.groups.display.currencySymbolOptions.gbp ?? "GBP"
    }
  );
  const allowProgressbarTypes = [
    ProgressbarAnimation.SLIDE,
    ProgressbarAnimation.BOUNCE
  ];
  const allowProgressbarThemes = [
    ProgressBarThemes.LIGHT,
    ProgressBarThemes.DARK,
    ProgressBarThemes.CLEAN_SIMPLE,
    ProgressBarThemes.ENVI,
    ProgressBarThemes.MIDNIGHT,
    ProgressBarThemes.CYBERPUNK
  ];
  const notification = useNotification({
    theme: hudSettings.theme,
    baseStyle: hudSettings.theme,
    duration: 3e3,
    position: "top-right",
    maxNotifications: 5,
    spacing: "1.5",
    defaultVariant: "basic",
    scale: 100,
    textOptions: {
      enabled: false,
      isTruncated: false,
      maxLines: 2
    },
    sound: {
      name: "Sound 1",
      path: "/sounds/sound_1.mp3",
      volume: 0.5,
      enabled: false
    },
    animation: {
      type: "slide",
      duration: 0.5,
      distance: 250
    }
  }, useCustomNotifications);
  const handleAnimationChange = (value) => {
    updateHudSettings({
      ...hudSettings,
      hudAnimation: value
    });
  };
  const handleMinimapUpdate = async (updates) => {
    const currentType = updates.type || hudSettings.minimap.type;
    const currentSize = updates.size || hudSettings.minimap.size;
    const defaultBuffer = MinimapBufferSize[currentType][currentSize];
    const buffer = updates.buffer || {
      x: hudSettings.minimap.buffer?.x ?? defaultBuffer.x,
      y: hudSettings.minimap.buffer?.y ?? defaultBuffer.y
    };
    updateHudSettings({
      minimap: {
        ...hudSettings.minimap,
        ...updates,
        buffer
      }
    });
    await fetchNui("updateMinimap", {
      type: currentType,
      size: MinimapSizePixels[currentType][currentSize],
      position: elementPositions["minimap"] || { x: 0, y: 0 },
      buffer
    });
  };
  const handleMinimapTypeChange = (value) => {
    handleMinimapUpdate({ type: value, buffer: MinimapBufferSize[value][hudSettings.minimap.size] });
  };
  const handleMapSizeChange = (value) => {
    handleMinimapUpdate({ size: value, buffer: MinimapBufferSize[hudSettings.minimap.type][value] });
  };
  const handleSave = reactExports.useCallback(() => {
    saveHudChanges();
    if (hasUnsavedChanges) saveChanges();
    handleMinimapUpdate({});
    notification.success(localesConfig?.hud.notifications.success.settingsSaved || "HUD settings saved successfully!", {
      duration: 3e3
    });
    fetchNui("hideHudSettings").then(() => {
      setSettingsVisible(false);
    }).catch((error) => {
      console.error("Error closing settings UI:", error);
    });
  }, [saveHudChanges, saveChanges, hasUnsavedChanges, notification, hudSettings.minimap, elementPositions]);
  const handleAdminSave = reactExports.useCallback(() => {
    saveGlobalHudSettings();
    if (hasUnsavedChanges) saveChanges();
    handleMinimapUpdate({});
    notification.success(localesConfig?.hud.notifications.success.globalSettingsSaved || "Global HUD settings saved successfully!", {
      duration: 3e3
    });
    fetchNui("hideHudSettings").then(() => {
      setAdminSettingsVisible(false);
    }).catch((error) => {
      console.error("Error closing settings UI:", error);
    });
  }, [saveGlobalHudSettings, saveChanges, hasUnsavedChanges, notification, hudSettings.minimap, elementPositions]);
  const handleReset = reactExports.useCallback(() => {
    resetHudSettings();
  }, [resetHudSettings]);
  const handleClose = () => {
    if (hasUnsavedChanges) {
      closeHudSettings();
      return;
    }
    if (!isNotifySettingsOpen && !isTutorialVisible) {
      fetchNui("hideHudSettings").then(() => {
        if (isAdminVisible) {
          setAdminSettingsVisible(false);
        } else {
          setSettingsVisible(false);
        }
      }).catch((error) => {
        console.error("Error closing settings UI:", error);
      });
    }
  };
  reactExports.useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === "Escape" && (isVisible || isAdminVisible)) {
        if (!isNotifySettingsOpen && !isTutorialVisible) {
          handleClose();
        }
      }
    };
    window.addEventListener("keydown", handleKeyPress);
    return () => {
      window.removeEventListener("keydown", handleKeyPress);
    };
  }, [isVisible, isAdminVisible, hasUnsavedChanges, isNotifySettingsOpen, isTutorialVisible]);
  const handleElementVisibilityChange = (element) => {
    const [parent, child] = element.split(".");
    if (child) {
      if (parent === "playerStatusItems") {
        const updatedPlayerStatusItems = {
          ...elementsVisibility.playerStatusItems,
          [child]: !elementsVisibility.playerStatusItems[child]
        };
        updateHudSettings({
          elementsVisibility: {
            ...elementsVisibility,
            playerStatusItems: updatedPlayerStatusItems
          }
        });
      } else if (parent === "serverInfoItems") {
        const updatedServerInfoItems = {
          ...elementsVisibility.serverInfoItems,
          [child]: !elementsVisibility.serverInfoItems[child]
        };
        updateHudSettings({
          elementsVisibility: {
            ...elementsVisibility,
            serverInfoItems: updatedServerInfoItems
          }
        });
      } else if (parent === "accountItems") {
        const updatedAccountItems = {
          ...elementsVisibility.accountItems,
          [child]: !elementsVisibility.accountItems[child]
        };
        updateHudSettings({
          elementsVisibility: {
            ...elementsVisibility,
            accountItems: updatedAccountItems
          }
        });
      }
    } else {
      updateHudSettings({
        elementsVisibility: {
          ...elementsVisibility,
          [element]: !elementsVisibility[element]
        }
      });
    }
  };
  const handleToggleAllElements = () => {
    const newShowAll = !elementsVisibility?.showAllElements;
    updateHudSettings({
      elementsVisibility: {
        ...elementsVisibility,
        showAllElements: newShowAll,
        serverInfo: newShowAll,
        location: newShowAll,
        weapon: newShowAll,
        voice: newShowAll,
        playerStatus: newShowAll,
        account: newShowAll,
        vehicle: newShowAll
      }
    });
    fetchNui("toggleMinimap", { enabled: newShowAll });
  };
  const handleEnableDragMode = () => {
    if (hudSettings?.cinematicMode) return;
    if (isVisible) {
      setSettingsVisible(false);
    } else if (isAdminVisible) {
      setAdminSettingsVisible(false);
    }
    toggleDraggable();
  };
  const handleThemeChange = (value) => {
    setSelectedTheme(value);
    const isThemeAvailableInSpeedometer = speedometerOptions.some((option) => option.value === value);
    const isDifferentFromCurrent = hudSettings.speedometerVariant !== value;
    if (isThemeAvailableInSpeedometer && isDifferentFromCurrent) {
      setThemeModalOpen(true);
    } else {
      updateHudSettings({ theme: value });
    }
  };
  const applyThemeToSpeedometer = () => {
    if (selectedTheme) {
      updateHudSettings({ theme: selectedTheme, speedometerVariant: selectedTheme });
    }
    setThemeModalOpen(false);
  };
  const cancelThemeApplication = () => {
    if (selectedTheme) {
      updateHudSettings({ theme: selectedTheme });
    }
    setThemeModalOpen(false);
  };
  const handleToggleCinematicMode = () => {
    const newCinematicMode = !hudSettings.cinematicMode;
    if (newCinematicMode) {
      updateHudSettings({
        cinematicMode: true,
        previousElementsVisibility: { ...elementsVisibility },
        elementsVisibility: {
          ...elementsVisibility,
          showAllElements: false,
          serverInfo: false,
          location: false,
          weapon: false,
          voice: false,
          playerStatus: false,
          account: false,
          vehicle: false
        }
      });
    } else {
      const previousVisibility = hudSettings.previousElementsVisibility || elementsVisibility;
      updateHudSettings({
        cinematicMode: false,
        elementsVisibility: {
          ...previousVisibility
        }
      });
    }
    fetchNui("toggleMinimap", { enabled: !newCinematicMode });
    fetchNui("toggleCinematicMode", { enabled: newCinematicMode });
  };
  const handleDiscardChanges = () => {
    discardHudChanges();
  };
  const handleKeepChanges = () => {
    keepChanges();
  };
  const isCategoryDisabled = (category) => {
    if (category === "playerStatusItems" && disabledElements?.playerStatus === true) {
      return true;
    } else if (category === "serverInfoItems" && disabledElements?.serverInfo === true) {
      return true;
    } else if (category === "accountItems" && disabledElements?.account === true) {
      return true;
    }
    if (disabledElements?.[category] === true) {
      return true;
    }
    const items = disabledElements?.[category];
    if (!items || typeof items !== "object") {
      return false;
    }
    if (category === "playerStatusItems") {
      const typedItems = items;
      const keys = Object.keys(typedItems);
      return keys.length > 0 && keys.every((key) => typedItems[key] === true);
    } else if (category === "serverInfoItems") {
      const typedItems = items;
      const keys = Object.keys(typedItems);
      return keys.length > 0 && keys.every((key) => typedItems[key] === true);
    } else if (category === "accountItems") {
      const typedItems = items;
      const keys = Object.keys(typedItems);
      return keys.length > 0 && keys.every((key) => typedItems[key] === true);
    }
    return false;
  };
  reactExports.useEffect(() => {
    if (isVisible) {
      const hasSeenTutorial = localStorage.getItem("envi-hud-tutorial");
      if (!hasSeenTutorial) {
        setTutorialVisible(true);
      }
    }
  }, [isVisible, setTutorialVisible]);
  const handleProgressBarAnimationChange = (value) => {
    updateHudSettings({
      progressBarSettings: {
        ...hudSettings.progressBarSettings,
        animation: value
      }
    });
  };
  const handleProgressBarDirectionChange = (value) => {
    updateHudSettings({
      progressBarSettings: {
        ...hudSettings.progressBarSettings,
        animationDirection: value
      }
    });
  };
  const handleProgressBarAnimationDelayChange = (value) => {
    updateHudSettings({
      progressBarSettings: {
        ...hudSettings.progressBarSettings,
        animationDelay: value
      }
    });
  };
  const scrollContainerRef = reactExports.useRef(null);
  const renderAdminContent = () => {
    if (!isAdminVisible) return null;
    return null;
  };
  const handleUpdateDisabledElements = (elements) => {
    setAdminDisabledElements(elements);
    Object.entries(elements).forEach(([key, value]) => {
      if (typeof value === "object") {
        Object.entries(value).forEach(([nestedKey, nestedValue]) => {
          updateNestedDisabledElement(key, nestedKey, !!nestedValue);
        });
      } else {
        updateDisabledElement(key, !!value);
      }
    });
  };
  const handleToggleMap = () => {
    const newMapValue = !elementsVisibility?.map;
    updateHudSettings({
      elementsVisibility: {
        ...elementsVisibility,
        map: newMapValue
      }
    });
    fetchNui("mapToggle", newMapValue);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: (isVisible || isAdminVisible) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Tutorial, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          variants: overlayVariants,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          className: "fixed inset-0 flex items-center justify-center z-[998]",
          style: {
            background: SettingsStyles.container.overlay
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            motion.div,
            {
              variants: dialogVariants,
              className: "w-[45vw] rounded-[.75vh]",
              style: {
                background: SettingsStyles.container.background
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "px-[1.15vw] py-[2vh] border-b-[.15vh] flex items-center justify-between",
                    style: {
                      borderBottomColor: SettingsStyles.container.borderColorBottom
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "h1",
                          {
                            className: "text-[2vh] font-semibold",
                            style: {
                              fontFamily: font,
                              color: SettingsStyles.title.header
                            },
                            children: isAdminVisible ? localesConfig?.hud?.admin?.title || "Admin HUD Settings" : localesConfig?.hud?.player?.title || "HUD Settings"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "p",
                          {
                            className: "text-[1.35vh] mt-[.5vh]",
                            style: {
                              fontFamily: font,
                              color: SettingsStyles.title.subHeader
                            },
                            children: isAdminVisible ? localesConfig?.hud?.admin?.description || "Configure server-wide HUD settings. Press save when you're done." : localesConfig?.hud?.player?.description || "Customize your HUD in here. Press save when you're done."
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        CloseButton,
                        {
                          className: "\r\n                    absolute top-[2.25vh] right-[1.15vw] p-[.75vh] border-[.15vh] \r\n                    text-[1.35vh] rounded-[.75vh] transition-all duration-250",
                          onClick: handleClose,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { icon: "mdi:close", className: "text-[1.75vh]" })
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-[1.15vw] py-[2vh] space-y-[2vh] max-h-[70vh] overflow-y-auto relative", ref: scrollContainerRef, children: [
                  isAdminVisible && renderAdminContent(),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.theme.title || "Theme", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.theme.hud || "HUD",
                        icon: "mdi:palette-outline",
                        value: theme,
                        onChange: handleThemeChange,
                        options: getThemeOptions()
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.theme.speedometer || "Speedometer",
                        icon: "mdi:speedometer",
                        value: speedometerVariant,
                        onChange: (value) => updateHudSettings({ speedometerVariant: value }),
                        options: speedometerOptions
                      }
                    )
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig?.hud.groups.hudShapes.title || "HUD Shapes", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.hudShapes.serverInfo || "Server Info",
                          icon: "mdi:server",
                          value: hudSettings.serverInfoVariant,
                          onChange: (value) => updateHudSettings({ serverInfoVariant: value }),
                          options: serverInfoOptions,
                          disabled: isSpecialTheme || isCyberpunkTheme
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.hudShapes.account || "Account",
                          icon: "mdi:wallet",
                          value: hudSettings.accountVariant,
                          onChange: (value) => updateHudSettings({ accountVariant: value }),
                          options: accountOptions,
                          disabled: isSpecialTheme || isCyberpunkTheme
                        }
                      )
                    ] }),
                    (isSpecialTheme || isCyberpunkTheme) && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[1.35vh] text-gray-400 mt-[1vh]", children: localesConfig?.hud.groups.hudShapes.specialThemeMessage || "Shape settings are disabled for custom themes." })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig?.hud.groups.statusBar.title || "Status Bar", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.statusBar.variant || "Variant",
                          icon: "mdi:view-grid-outline",
                          value: statusBarVariant,
                          onChange: (value) => updateHudSettings({ statusBarVariant: value }),
                          options: statusBarOptions,
                          disabled: isSpecialTheme || isCyberpunkTheme
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.statusBar.progressStyle || "Progress Style",
                          icon: "mdi:progress-check",
                          value: progressBarStyle,
                          onChange: (value) => updateHudSettings({ progressBarStyle: value }),
                          options: progressBarOptions,
                          disabled: isSpecialTheme
                        }
                      )
                    ] }),
                    isSpecialTheme && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[1.35vh] text-gray-400 mt-[1vh]", children: localesConfig?.hud.groups.statusBar.specialThemeMessage || "Status bar settings are disabled for Pixel and Retro themes as they use their own unique styles." }),
                    isCyberpunkTheme && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-[1.35vh] text-gray-400 mt-[1vh]", children: localesConfig?.hud.groups.statusBar.cyberpunkThemeMessage || "Status bar variant is disabled for Cyberpunk theme as it uses its own unique style." })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.animation.title || "Animation Settings", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DashboardSelect,
                    {
                      label: localesConfig?.hud.groups.animation.showAnimation || "Show Animation",
                      value: hudSettings.hudAnimation,
                      onChange: handleAnimationChange,
                      options: animationOptions,
                      icon: "mdi:animation"
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig?.hud.groups.display.title || "Display Mode", children: [
                    advancedMapConfig && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh] mt-[2vh]", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardSelect,
                          {
                            label: localesConfig?.hud.groups.display.minimap.type || "Minimap Type",
                            icon: "mdi:map",
                            value: hudSettings?.minimap.type,
                            onChange: handleMinimapTypeChange,
                            options: minimapTypeOptions
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardSelect,
                          {
                            label: localesConfig?.hud.groups.display.minimap.size || "Minimap Size",
                            icon: "mdi:resize",
                            value: hudSettings.minimap.size,
                            onChange: handleMapSizeChange,
                            options: minimapSizeOptions
                          }
                        )
                      ] }),
                      !isAdminVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh] mt-[2vh]", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardSlider,
                          {
                            label: localesConfig?.hud.groups.display.minimap.buffer.x || "Buffer X",
                            icon: "mdi:axis-x-arrow",
                            value: hudSettings.minimap.buffer?.x || MinimapBufferSize[hudSettings.minimap.type][hudSettings.minimap.size].x,
                            onChange: (value) => handleMinimapUpdate({ buffer: { x: value, y: hudSettings.minimap.buffer?.y || MinimapBufferSize[hudSettings.minimap.type][hudSettings.minimap.size].y } }),
                            min: -1,
                            max: 1,
                            step: 1e-5
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardSlider,
                          {
                            label: localesConfig?.hud.groups.display.minimap.buffer.y || "Buffer Y",
                            icon: "mdi:axis-y-arrow",
                            value: hudSettings.minimap.buffer?.y || MinimapBufferSize[hudSettings.minimap.type][hudSettings.minimap.size].y,
                            onChange: (value) => handleMinimapUpdate({ buffer: { x: hudSettings.minimap.buffer?.x || MinimapBufferSize[hudSettings.minimap.type][hudSettings.minimap.size].x, y: value } }),
                            min: -1,
                            max: 1,
                            step: 1e-5
                          }
                        )
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.display.timeMode || "Time Mode",
                          icon: "mdi:clock",
                          value: hudSettings?.timeMode,
                          onChange: (value) => updateHudSettings({ timeMode: value }),
                          options: timeModeOptions
                        }
                      ) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSelect,
                        {
                          label: localesConfig?.hud.groups.display.currencySymbol || "Currency Symbol",
                          icon: "heroicons:currency-dollar-20-solid",
                          value: hudSettings?.currencySymbol,
                          onChange: (value) => updateHudSettings({ currencySymbol: value }),
                          options: currencySymbolOptions
                        }
                      ) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.display.cinematicMode || "Cinematic Mode",
                          icon: "mdi:movie-open",
                          value: hudSettings?.cinematicMode,
                          onChange: handleToggleCinematicMode,
                          hasDescription: true,
                          customDescription: {
                            enabled: localesConfig?.toggleStates.enabled,
                            disabled: localesConfig?.toggleStates.disabled
                          }
                        }
                      ) })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.progressbar.title || "Progress Bar", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.progressbar.theme || "Theme",
                        icon: "mdi:palette-outline",
                        value: hudSettings?.progressBarSettings?.theme,
                        onChange: (value) => updateHudSettings({ progressBarSettings: { ...hudSettings.progressBarSettings, theme: value } }),
                        options: getThemeOptions()
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.progressbar.variant || "Variant",
                        icon: "mdi:palette-outline",
                        value: hudSettings?.progressBarSettings?.variant,
                        onChange: (value) => updateHudSettings({ progressBarSettings: { ...hudSettings.progressBarSettings, variant: value } }),
                        options: progressBarVariantOptions
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.progressbar.animation || "Animation",
                        value: hudSettings?.progressBarSettings?.animation,
                        onChange: handleProgressBarAnimationChange,
                        options: progressBarAnimationOptions,
                        icon: "mdi:animation"
                      }
                    ) }),
                    allowProgressbarTypes.includes(hudSettings?.progressBarSettings?.animation || ProgressbarAnimation.DEFAULT) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.progressbar.animationDirection || "Animation Direction",
                        value: hudSettings?.progressBarSettings?.animationDirection,
                        options: progressBarDirectionOptions,
                        onChange: handleProgressBarDirectionChange,
                        icon: "mdi:directions"
                      }
                    ) }),
                    hudSettings?.progressBarSettings?.animation !== ProgressbarAnimation.DEFAULT && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSlider,
                      {
                        label: localesConfig?.hud.groups.progressbar.animationDelay || "Animation Delay",
                        icon: "mdi:timer-outline",
                        value: hudSettings?.progressBarSettings?.animationDelay,
                        onChange: handleProgressBarAnimationDelayChange,
                        min: 0,
                        max: 2,
                        step: 0.1
                      }
                    ) }),
                    allowProgressbarThemes.includes(hudSettings?.progressBarSettings?.theme || ProgressBarThemes.LIGHT) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.progressbar.rounded || "Rounded Corners",
                        icon: "mdi:border-radius",
                        hasDescription: true,
                        customDescription: {
                          enabled: localesConfig?.toggleStates.enabled,
                          disabled: localesConfig?.toggleStates.disabled
                        },
                        value: hudSettings?.progressBarSettings?.isRounded,
                        onChange: (value) => updateHudSettings({
                          progressBarSettings: {
                            ...hudSettings.progressBarSettings,
                            isRounded: value
                          }
                        })
                      }
                    ) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSelect,
                      {
                        label: localesConfig?.hud.groups.progressbar.textPosition || "Text Position",
                        value: hudSettings?.progressBarSettings?.textPosition,
                        onChange: (value) => updateHudSettings({
                          progressBarSettings: {
                            ...hudSettings.progressBarSettings,
                            textPosition: value
                          }
                        }),
                        options: progressBarTextPositionOptions,
                        icon: "mdi:text-box-outline"
                      }
                    ) })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig?.hud.groups.elements.title || "HUD Elements Visibility", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.elements.showAll || "Show/Hide All Elements",
                        icon: "mdi:eye-outline",
                        value: elementsVisibility?.showAllElements,
                        onChange: handleToggleAllElements,
                        hasDescription: true,
                        customDescription: {
                          enabled: localesConfig?.toggleStates.show || "Show all",
                          disabled: localesConfig?.toggleStates.hide || "Hide all"
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                      shouldShowHudElement("serverInfo") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.serverInfo || "Server Info",
                          icon: "mdi:server",
                          value: elementsVisibility?.serverInfo,
                          onChange: () => handleElementVisibilityChange("serverInfo")
                        }
                      ) }),
                      shouldShowHudElement("location") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.location || "Location",
                          icon: "mdi:map-marker",
                          value: elementsVisibility?.location,
                          onChange: () => handleElementVisibilityChange("location")
                        }
                      ) }),
                      shouldShowHudElement("weapon") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.weapon || "Weapon",
                          icon: "mdi:pistol",
                          value: elementsVisibility?.weapon,
                          onChange: () => handleElementVisibilityChange("weapon")
                        }
                      ) }),
                      shouldShowHudElement("voice") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.voice || "Voice",
                          icon: "mdi:microphone",
                          value: elementsVisibility?.voice,
                          onChange: () => handleElementVisibilityChange("voice")
                        }
                      ) }),
                      shouldShowHudElement("playerStatus") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.playerStatus || "Player Status",
                          icon: "mdi:account-details",
                          value: elementsVisibility?.playerStatus,
                          onChange: () => handleElementVisibilityChange("playerStatus")
                        }
                      ) }),
                      shouldShowHudElement("account") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.account || "Account",
                          icon: "mdi:wallet",
                          value: elementsVisibility?.account,
                          onChange: () => handleElementVisibilityChange("account")
                        }
                      ) }),
                      shouldShowHudElement("vehicle") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.vehicleHud || "Vehicle HUD",
                          icon: "mdi:car",
                          value: elementsVisibility?.vehicle,
                          onChange: () => handleElementVisibilityChange("vehicle")
                        }
                      ) }),
                      mapOption && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardToggle,
                        {
                          label: localesConfig?.hud.groups.elements.map || "Minimap",
                          icon: "mdi:map",
                          value: elementsVisibility?.map,
                          onChange: handleToggleMap
                        }
                      ) })
                    ] })
                  ] }),
                  !isCategoryDisabled("serverInfoItems") && /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.serverInfo.title || "Server Info Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                    shouldShowHudElement("serverInfoItems", "logo") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        icon: "mdi:server",
                        label: localesConfig?.hud.groups.serverInfo.logo,
                        value: elementsVisibility?.serverInfoItems?.logo,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.logo")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "serverInfo") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        icon: "mdi:server",
                        label: localesConfig?.hud.groups.serverInfo.serverInfo,
                        value: elementsVisibility?.serverInfoItems?.serverInfo,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.serverInfo")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "id") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.id,
                        icon: "mdi:id-card",
                        value: elementsVisibility?.serverInfoItems?.id,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.id")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "players") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.players,
                        icon: "mdi:account-group",
                        value: elementsVisibility?.serverInfoItems?.players,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.players")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "job") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.job,
                        icon: "mdi:briefcase",
                        value: elementsVisibility?.serverInfoItems?.job,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.job")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "job2") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.job2,
                        icon: "mdi:briefcase",
                        value: elementsVisibility?.serverInfoItems?.job2,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.job2")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "gang") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.gang,
                        icon: "mdi:account-group",
                        value: elementsVisibility?.serverInfoItems?.gang,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.gang")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "gang2") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.gang2,
                        icon: "mdi:account-group",
                        value: elementsVisibility?.serverInfoItems?.gang2,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.gang2")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "time") && theme && TimeDisplayLocation[theme] === "serverInfoItems" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.time,
                        icon: "mdi:clock",
                        value: elementsVisibility?.serverInfoItems?.time,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.time")
                      }
                    ) }),
                    shouldShowHudElement("serverInfoItems", "divider") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.serverInfo.divider,
                        icon: "mdi:divider",
                        value: elementsVisibility?.serverInfoItems?.divider,
                        onChange: () => handleElementVisibilityChange("serverInfoItems.divider")
                      }
                    ) })
                  ] }) }),
                  !isCategoryDisabled("accountItems") && /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.account.title || "Account Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                    shouldShowHudElement("accountItems", "cash") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.account.cash || "Cash",
                        icon: "mdi:cash",
                        value: elementsVisibility?.accountItems?.cash,
                        onChange: () => handleElementVisibilityChange("accountItems.cash")
                      }
                    ) }),
                    shouldShowHudElement("accountItems", "bank") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.account.bank || "Bank",
                        icon: "mdi:bank",
                        value: elementsVisibility?.accountItems?.bank,
                        onChange: () => handleElementVisibilityChange("accountItems.bank")
                      }
                    ) }),
                    shouldShowHudElement("accountItems", "blackMoney") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.account.blackMoney || "Black Money",
                        icon: "mdi:bank",
                        value: elementsVisibility?.accountItems?.blackMoney,
                        onChange: () => handleElementVisibilityChange("accountItems.blackMoney")
                      }
                    ) }),
                    shouldShowHudElement("accountItems", "time") && theme && TimeDisplayLocation[theme] === "accountItems" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.account.time || "Time",
                        icon: "mdi:clock",
                        value: elementsVisibility?.accountItems?.time,
                        onChange: () => handleElementVisibilityChange("accountItems.time")
                      }
                    ) })
                  ] }) }),
                  !isCategoryDisabled("playerStatusItems") && /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardItemGroup, { title: localesConfig?.hud.groups.playerStatus.title || "Player Status Items", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-[2vh]", children: [
                    shouldShowHudElement("playerStatusItems", "health") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.health || "Health",
                        icon: "mdi:heart",
                        value: elementsVisibility?.playerStatusItems?.health,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.health")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "armor") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.armor || "Armor",
                        icon: "mdi:shield",
                        value: elementsVisibility?.playerStatusItems?.armor,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.armor")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "hunger") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.hunger || "Hunger",
                        icon: "mdi:food",
                        value: elementsVisibility?.playerStatusItems?.hunger,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.hunger")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "thirst") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.thirst || "Thirst",
                        icon: "mdi:water",
                        value: elementsVisibility?.playerStatusItems?.thirst,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.thirst")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "stamina") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.stamina || "Stamina",
                        icon: "mdi:run",
                        value: elementsVisibility?.playerStatusItems?.stamina,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.stamina")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "stress") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.stress || "Stress",
                        icon: "mdi:brain",
                        value: elementsVisibility?.playerStatusItems?.stress,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.stress")
                      }
                    ) }),
                    shouldShowHudElement("playerStatusItems", "oxygen") && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[calc(50%-1vh)] flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardToggle,
                      {
                        label: localesConfig?.hud.groups.playerStatus.oxygen || "Oxygen",
                        icon: "healthicons:oxygen-tank-24px",
                        value: elementsVisibility?.playerStatusItems?.oxygen,
                        onChange: () => handleElementVisibilityChange("playerStatusItems.oxygen")
                      }
                    ) })
                  ] }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(DashboardItemGroup, { title: localesConfig?.hud.groups.elementScales.title || "Element Scales", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-[2vh]", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.serverInfo || "Server Info",
                          icon: "mdi:server",
                          value: hudSettings?.elementScales?.serverInfo,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              serverInfo: value
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.location || "Location",
                          icon: "mdi:map-marker",
                          value: hudSettings?.elementScales?.location,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              location: value
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.weapon || "Weapon",
                          icon: "mdi:pistol",
                          value: hudSettings?.elementScales?.weapon,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              weapon: value
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.voice || "Voice",
                          icon: "mdi:microphone",
                          value: hudSettings?.elementScales?.voice,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              voice: value
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.playerStatus || "Player Status",
                          icon: "mdi:account-details",
                          value: hudSettings?.elementScales?.playerStatus,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              playerStatus: value
                            }
                          })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        DashboardSlider,
                        {
                          label: localesConfig?.hud.groups.elementScales.account || "Account",
                          icon: "mdi:wallet",
                          value: hudSettings?.elementScales?.account,
                          max: 150,
                          onChange: (value) => updateHudSettings({
                            elementScales: {
                              ...hudSettings?.elementScales,
                              account: value
                            }
                          })
                        }
                      )
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DashboardSlider,
                      {
                        label: localesConfig?.hud.groups.elementScales.vehicle || "Vehicle",
                        icon: "mdi:car",
                        value: hudSettings?.elementScales?.vehicle,
                        max: 150,
                        onChange: (value) => updateHudSettings({
                          elementScales: {
                            ...hudSettings?.elementScales,
                            vehicle: value
                          }
                        })
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollToTop, { targetRef: scrollContainerRef }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "px-[1.15vw] py-[2.5vh] flex items-center justify-between border-t-[.15vh]",
                    style: {
                      borderTopColor: SettingsStyles.container.borderColorTop
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-[1vh]", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardButton,
                          {
                            className: `${hudSettings?.cinematicMode ? "pointer-events-none" : ""}`,
                            icon: "ion:move-outline",
                            css: css`
                        background: ${hudSettings?.cinematicMode ? SettingsStyles.button.disabled.background : SettingsStyles.button.action.background};
                        border-color: ${hudSettings?.cinematicMode ? SettingsStyles.button.disabled.borderColor : SettingsStyles.button.action.borderColor};
                        color: ${hudSettings?.cinematicMode ? SettingsStyles.button.disabled.textColor : SettingsStyles.button.action.textColor};
                        &:hover {
                          background: ${SettingsStyles.button.action.hoverBackground};
                          border-color: ${SettingsStyles.button.action.hoverBorderColor};
                        }
                      `,
                            onClick: handleEnableDragMode,
                            children: localesConfig?.hud.buttons.dragMode || "Enable Drag Mode"
                          }
                        ),
                        !useCustomNotifications && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardButton,
                          {
                            css: css`
                          background: ${SettingsStyles.button.utility.background};
                          border-color: ${SettingsStyles.button.utility.borderColor};
                          color: ${SettingsStyles.button.utility.textColor};
                          &:hover {
                            background: ${SettingsStyles.button.utility.hoverBackground};
                            border-color: ${SettingsStyles.button.utility.hoverBorderColor};
                          }
                        `,
                            icon: "mdi:bell-cog",
                            onClick: () => setNotifySettingsOpen(true),
                            children: localesConfig?.hud.buttons.notifySettings || "Notification Settings"
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end gap-[1vh]", children: [
                        isAdminVisible && /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { text: localesConfig?.hud?.admin?.disabledElements?.manageButton || "Manage Disabled Elements", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          IconButton,
                          {
                            icon: "mdi:eye-off-outline",
                            onClick: () => setDisabledElementsModalOpen(true),
                            ariaLabel: "Manage Disabled Elements"
                          }
                        ) }),
                        isAdminVisible ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Tooltip,
                          {
                            text: localesConfig?.hud.buttons.reset,
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                              IconButton,
                              {
                                icon: "ion:refresh-outline",
                                onClick: handleReset
                              }
                            )
                          }
                        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardButton,
                          {
                            css: css`
                          background: ${SettingsStyles.button.utility.background};
                          border-color: ${SettingsStyles.button.utility.borderColor};
                          color: ${SettingsStyles.button.utility.textColor};
                          &:hover {
                            background: ${SettingsStyles.button.utility.hoverBackground};
                            border-color: ${SettingsStyles.button.utility.hoverBorderColor};
                          }
                        `,
                            icon: "ion:refresh-outline",
                            onClick: handleReset,
                            children: localesConfig?.hud.buttons.reset || "Reset"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          DashboardButton,
                          {
                            css: css`
                        background: ${SettingsStyles.button.submit.background};
                        border-color: ${SettingsStyles.button.submit.borderColor};
                        color: ${SettingsStyles.button.submit.textColor};
                        &:hover {
                          background: ${SettingsStyles.button.submit.hoverBackground};
                          border-color: ${SettingsStyles.button.submit.hoverBorderColor};
                        }
                      `,
                            icon: "ion:save-outline",
                            onClick: isAdminVisible ? handleAdminSave : handleSave,
                            children: isAdminVisible ? localesConfig?.hud.buttons.saveGlobal || "Save Global" : localesConfig?.hud.buttons.save || "Save Changes"
                          }
                        )
                      ] })
                    ]
                  }
                )
              ]
            }
          )
        },
        "hud-settings-panel"
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: isNotifySettingsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "fixed inset-0 flex items-center justify-center z-[999]",
        style: {
          background: SettingsStyles.container.overlay
        },
        variants: overlayVariants,
        initial: "initial",
        animate: "animate",
        exit: "exit",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          NotifySettings,
          {
            onClose: () => setNotifySettingsOpen(false),
            defaultSettings: hudSettings.notification
          }
        )
      },
      "notify-settings-panel"
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: hasUnsavedChanges && showUnsavedDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DashboardModal,
      {
        title: localesConfig?.hud.modals.unsavedChanges.title || "Unsaved Changes",
        message: localesConfig?.hud.modals.unsavedChanges.message || "You have unsaved changes. Do you want to keep them?",
        onClick: handleKeepChanges,
        onCancel: handleDiscardChanges,
        confirmText: localesConfig?.hud.modals.unsavedChanges.keep || "Keep Changes",
        cancelText: localesConfig?.hud.modals.unsavedChanges.discard || "Discard Changes"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isThemeModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      DashboardModal,
      {
        title: localesConfig?.hud.modals.applyTheme.title || "Apply Theme",
        message: localesConfig?.hud.modals.applyTheme.message || "Do you want to apply the theme to the speedometer?",
        onClick: applyThemeToSpeedometer,
        onCancel: cancelThemeApplication
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isDisabledElementsModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      HudDisabledElementsModal,
      {
        adminDisabledElements,
        onSave: handleUpdateDisabledElements,
        onClose: () => setDisabledElementsModalOpen(false)
      }
    ) })
  ] });
}

const useNuiEvent = (action, handler) => {
  const savedHandler = reactExports.useRef(noop);
  reactExports.useEffect(() => {
    savedHandler.current = handler;
  }, [handler]);
  reactExports.useEffect(() => {
    const eventListener = (event) => {
      const { action: eventAction, data } = event?.data;
      if (savedHandler.current) {
        if (eventAction === action) {
          savedHandler.current(data);
        }
      }
    };
    window.addEventListener("message", eventListener);
    return () => window.removeEventListener("message", eventListener);
  }, [action]);
};

function App() {
  const {
    setHudVisible,
    setPlayerStatus,
    setAccount,
    setLocation,
    setServerInfo,
    setWeapon,
    setVehicle,
    setProgressBar
  } = useHudStore((state) => state);
  const {
    hudSettings,
    setSettingsVisible,
    setAdminSettingsVisible,
    setHudSettings,
    updateHudSettings,
    updateElementPosition,
    toggleCinematicMode
  } = useSettingsStore((state) => state);
  const disabledHudElements = useConfigStore((state) => state.disabledHudElements);
  const localesConfig = useConfigStore((state) => state.config.locales) || mockLocales;
  const setConfig = useConfigStore((state) => state.setConfig);
  const setHudConfig = useConfigStore((state) => state.setHudConfig);
  const setDisabledHudElements = useConfigStore((state) => state.setDisabledHudElements);
  const useCustomNotifications = useConfigStore((state) => state.config.useCustomNotifications);
  const notification = useNotification({
    duration: hudSettings?.notification?.duration ?? 5e3,
    position: hudSettings?.notification?.position ?? "bottom-right",
    maxNotifications: hudSettings?.notification?.maxNotifications ?? 5,
    theme: hudSettings?.notification?.theme ?? "light",
    baseStyle: hudSettings?.notification?.baseStyle ?? "default",
    spacing: hudSettings?.notification?.spacing ?? "default",
    defaultVariant: hudSettings?.notification?.defaultVariant ?? "basic",
    textOptions: hudSettings?.notification?.textOptions ?? {
      enabled: true,
      isTruncated: false,
      maxLines: 3
    },
    scale: hudSettings?.notification?.scale ?? 100,
    sound: hudSettings?.notification?.sound ?? {
      enabled: true,
      name: "default",
      path: "/sounds/sound_1.mp3",
      volume: 1
    },
    animation: hudSettings?.notification?.animation ?? {
      type: "slide",
      duration: 500,
      distance: 100
    }
  }, useCustomNotifications);
  const [isPlayerLoaded, setIsPlayerLoaded] = reactExports.useState(false);
  useNuiEvent("setHudVisible", (data) => {
    setHudVisible(data);
  });
  useNuiEvent("updateStatus", setPlayerStatus);
  useNuiEvent("updateAccount", setAccount);
  useNuiEvent("updateLocation", setLocation);
  useNuiEvent("updateInfo", setServerInfo);
  useNuiEvent("updateWeapon", setWeapon);
  useNuiEvent("updateVehicle", setVehicle);
  useNuiEvent("updateProgressBar", setProgressBar);
  useNuiEvent("cancelProgressbar", (data) => {
    if (data?.showCancelMessage) {
      setProgressBar({
        isVisible: true,
        label: localesConfig?.hud?.groups?.progressbar?.cancelTitle || "Cancelling...",
        duration: 0,
        canCancel: false
      });
      setTimeout(() => {
        setProgressBar({ isVisible: false });
      }, 1e3);
    } else {
      setProgressBar({ isVisible: false });
    }
  });
  useNuiEvent("sendConfig", (data) => {
    setConfig({
      mph: data.mph,
      serverInfo: data.serverInfo,
      locales: data.locales,
      enableBlackMoney: data.enableBlackMoney,
      advancedMap: data.advancedMap,
      avaliableThemes: data.avaliableThemes,
      mapOption: data.mapOption,
      useCustomNotifications: data.useCustomNotifications
    });
  });
  useNuiEvent("playerLoaded", () => setIsPlayerLoaded(true));
  useNuiEvent("playerUnloaded", () => setIsPlayerLoaded(false));
  useNuiEvent("setHudConfig", (data) => {
    if (!hudSettings || Object.keys(hudSettings).length === 0) {
      setHudConfig(data);
      setHudSettings(data);
      updateHudSettings(data);
    }
  });
  useNuiEvent("setDisabledHudElements", (data) => {
    if (!disabledHudElements || Object.keys(disabledHudElements).length === 0) {
      setDisabledHudElements(data);
    }
  });
  useNuiEvent("setSettingsVisible", setSettingsVisible);
  useNuiEvent("setAdminSettingsVisible", setAdminSettingsVisible);
  useNuiEvent("notification", (data) => {
    const { type = NotificationTypeValues.INFO, message, ...options } = data;
    switch (type) {
      case "info":
        notification.info(message, options);
        break;
      case "success":
        notification.success(message, options);
        break;
      case "error":
        notification.error(message, options);
        break;
      case "warning":
        notification.warning(message, options);
        break;
      default:
        notification.show({ type, message, ...options });
        break;
    }
  });
  useNuiEvent("toggleCinematicMode", (data) => {
    toggleCinematicMode(data?.enabled);
    fetchNui("toggleMinimap", { enabled: !data?.enabled });
    fetchNui("toggleCinematicMode", { enabled: data?.enabled });
  });
  reactExports.useEffect(() => {
    const fetchConfig = async () => {
      if (!isPlayerLoaded) return;
      try {
        const config = await fetchNui("getHudConfig");
        if (config) {
          setHudConfig(config);
          setHudSettings(config);
          updateHudSettings(config);
          if (config.elementPositions) {
            Object.entries(config.elementPositions).forEach(([key, position]) => {
              updateElementPosition(key, position);
            });
          }
          const minimapType = config.minimap?.type && (config.minimap.type === "square" || config.minimap.type === "circle") ? config.minimap.type : "square";
          const validSizes = Object.keys(MinimapSizePixels[minimapType]);
          const minimapSize = config.minimap?.size && validSizes.includes(config.minimap.size) ? config.minimap.size : "medium";
          fetchNui("updateMinimap", {
            position: config.elementPositions?.["minimap"] || { x: 0, y: 0 },
            type: minimapType,
            size: MinimapSizePixels[minimapType][minimapSize],
            buffer: MinimapBufferSize[minimapType][minimapSize]
          });
        }
      } catch (error) {
        console.error("Error fetching config:", error);
      }
    };
    fetchConfig();
  }, [isPlayerLoaded, setHudConfig]);
  reactExports.useEffect(() => {
    const fetchDisabledElements = async () => {
      try {
        const disabledElements = await fetchNui("getDisabledHudElements");
        if (disabledElements) {
          setDisabledHudElements(disabledElements);
        }
      } catch (error) {
        console.error("Error fetching disabled elements:", error);
      }
    };
    if (isPlayerLoaded) {
      fetchDisabledElements();
    }
  }, [isPlayerLoaded, setDisabledHudElements]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NotificationContainer, { config: hudSettings?.notification }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HudContainer, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HudSettings, {})
  ] });
}

var define_process_env_default = {};
var n$4, l$4, u$a, i$8, r$5, o$9, e$5, f$9, c$7, s$9, a$b, h$6, p$4 = {}, y$7 = [], v$3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, w$5 = Array.isArray;
function d$5(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function g$4(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function _$4(l2, u2, t2) {
  var i2, r2, o3, e2 = {};
  for (o3 in u2) "key" == o3 ? i2 = u2[o3] : "ref" == o3 ? r2 = u2[o3] : e2[o3] = u2[o3];
  if (arguments.length > 2 && (e2.children = arguments.length > 3 ? n$4.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps) for (o3 in l2.defaultProps) null == e2[o3] && (e2[o3] = l2.defaultProps[o3]);
  return m$6(l2, e2, i2, r2, null);
}
function m$6(n2, t2, i2, r2, o3) {
  var e2 = { type: n2, props: t2, key: i2, ref: r2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o3 ? ++u$a : o3, __i: -1, __u: 0 };
  return null == o3 && null != l$4.vnode && l$4.vnode(e2), e2;
}
function b$5() {
  return { current: null };
}
function k$3(n2) {
  return n2.children;
}
function x$5(n2, l2) {
  this.props = n2, this.context = l2;
}
function S$5(n2, l2) {
  if (null == l2) return n2.__ ? S$5(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? S$5(n2) : null;
}
function C$5(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return C$5(n2);
  }
}
function M$4(n2) {
  (!n2.__d && (n2.__d = true) && i$8.push(n2) && !$$2.__r++ || r$5 != l$4.debounceRendering) && ((r$5 = l$4.debounceRendering) || o$9)($$2);
}
function $$2() {
  for (var n2, u2, t2, r2, o3, f2, c2, s2 = 1; i$8.length; ) i$8.length > s2 && i$8.sort(e$5), n2 = i$8.shift(), s2 = i$8.length, n2.__d && (t2 = void 0, o3 = (r2 = (u2 = n2).__v).__e, f2 = [], c2 = [], u2.__P && ((t2 = d$5({}, r2)).__v = r2.__v + 1, l$4.vnode && l$4.vnode(t2), O$3(u2.__P, t2, r2, u2.__n, u2.__P.namespaceURI, 32 & r2.__u ? [o3] : null, f2, null == o3 ? S$5(r2) : o3, !!(32 & r2.__u), c2), t2.__v = r2.__v, t2.__.__k[t2.__i] = t2, z$3(f2, t2, c2), t2.__e != o3 && C$5(t2)));
  $$2.__r = 0;
}
function I$4(n2, l2, u2, t2, i2, r2, o3, e2, f2, c2, s2) {
  var a3, h2, v2, w2, d2, g2, _2 = t2 && t2.__k || y$7, m2 = l2.length;
  for (f2 = P$6(u2, l2, _2, f2, m2), a3 = 0; a3 < m2; a3++) null != (v2 = u2.__k[a3]) && (h2 = -1 == v2.__i ? p$4 : _2[v2.__i] || p$4, v2.__i = a3, g2 = O$3(n2, v2, h2, i2, r2, o3, e2, f2, c2, s2), w2 = v2.__e, v2.ref && h2.ref != v2.ref && (h2.ref && q$4(h2.ref, null, v2), s2.push(v2.ref, v2.__c || w2, v2)), null == d2 && null != w2 && (d2 = w2), 4 & v2.__u || h2.__k === v2.__k ? f2 = A$4(v2, f2, n2) : "function" == typeof v2.type && void 0 !== g2 ? f2 = g2 : w2 && (f2 = w2.nextSibling), v2.__u &= -7);
  return u2.__e = d2, f2;
}
function P$6(n2, l2, u2, t2, i2) {
  var r2, o3, e2, f2, c2, s2 = u2.length, a3 = s2, h2 = 0;
  for (n2.__k = new Array(i2), r2 = 0; r2 < i2; r2++) null != (o3 = l2[r2]) && "boolean" != typeof o3 && "function" != typeof o3 ? (f2 = r2 + h2, (o3 = n2.__k[r2] = "string" == typeof o3 || "number" == typeof o3 || "bigint" == typeof o3 || o3.constructor == String ? m$6(null, o3, null, null, null) : w$5(o3) ? m$6(k$3, { children: o3 }, null, null, null) : null == o3.constructor && o3.__b > 0 ? m$6(o3.type, o3.props, o3.key, o3.ref ? o3.ref : null, o3.__v) : o3).__ = n2, o3.__b = n2.__b + 1, e2 = null, -1 != (c2 = o3.__i = L$4(o3, u2, f2, a3)) && (a3--, (e2 = u2[c2]) && (e2.__u |= 2)), null == e2 || null == e2.__v ? (-1 == c2 && (i2 > s2 ? h2-- : i2 < s2 && h2++), "function" != typeof o3.type && (o3.__u |= 4)) : c2 != f2 && (c2 == f2 - 1 ? h2-- : c2 == f2 + 1 ? h2++ : (c2 > f2 ? h2-- : h2++, o3.__u |= 4))) : n2.__k[r2] = null;
  if (a3) for (r2 = 0; r2 < s2; r2++) null != (e2 = u2[r2]) && 0 == (2 & e2.__u) && (e2.__e == t2 && (t2 = S$5(e2)), B$3(e2, e2));
  return t2;
}
function A$4(n2, l2, u2) {
  var t2, i2;
  if ("function" == typeof n2.type) {
    for (t2 = n2.__k, i2 = 0; t2 && i2 < t2.length; i2++) t2[i2] && (t2[i2].__ = n2, l2 = A$4(t2[i2], l2, u2));
    return l2;
  }
  n2.__e != l2 && (l2 && n2.type && !u2.contains(l2) && (l2 = S$5(n2)), u2.insertBefore(n2.__e, l2 || null), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 == l2.nodeType);
  return l2;
}
function H$6(n2, l2) {
  return l2 = l2 || [], null == n2 || "boolean" == typeof n2 || (w$5(n2) ? n2.some(function(n3) {
    H$6(n3, l2);
  }) : l2.push(n2)), l2;
}
function L$4(n2, l2, u2, t2) {
  var i2, r2, o3 = n2.key, e2 = n2.type, f2 = l2[u2];
  if (null === f2 && null == n2.key || f2 && o3 == f2.key && e2 == f2.type && 0 == (2 & f2.__u)) return u2;
  if (t2 > (null != f2 && 0 == (2 & f2.__u) ? 1 : 0)) for (i2 = u2 - 1, r2 = u2 + 1; i2 >= 0 || r2 < l2.length; ) {
    if (i2 >= 0) {
      if ((f2 = l2[i2]) && 0 == (2 & f2.__u) && o3 == f2.key && e2 == f2.type) return i2;
      i2--;
    }
    if (r2 < l2.length) {
      if ((f2 = l2[r2]) && 0 == (2 & f2.__u) && o3 == f2.key && e2 == f2.type) return r2;
      r2++;
    }
  }
  return -1;
}
function T$6(n2, l2, u2) {
  "-" == l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || v$3.test(l2) ? u2 : u2 + "px";
}
function j$5(n2, l2, u2, t2, i2) {
  var r2;
  n: if ("style" == l2) if ("string" == typeof u2) n2.style.cssText = u2;
  else {
    if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2) for (l2 in t2) u2 && l2 in u2 || T$6(n2.style, l2, "");
    if (u2) for (l2 in u2) t2 && u2[l2] == t2[l2] || T$6(n2.style, l2, u2[l2]);
  }
  else if ("o" == l2[0] && "n" == l2[1]) r2 = l2 != (l2 = l2.replace(f$9, "$1")), l2 = l2.toLowerCase() in n2 || "onFocusOut" == l2 || "onFocusIn" == l2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = c$7, n2.addEventListener(l2, r2 ? a$b : s$9, r2)) : n2.removeEventListener(l2, r2 ? a$b : s$9, r2);
  else {
    if ("http://www.w3.org/2000/svg" == i2) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && "popover" != l2 && l2 in n2) try {
      n2[l2] = null == u2 ? "" : u2;
      break n;
    } catch (n3) {
    }
    "function" == typeof u2 || (null == u2 || false === u2 && "-" != l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
  }
}
function F$6(n2) {
  return function(u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n2];
      if (null == u2.t) u2.t = c$7++;
      else if (u2.t < t2.u) return;
      return t2(l$4.event ? l$4.event(u2) : u2);
    }
  };
}
function O$3(n2, u2, t2, i2, r2, o3, e2, f2, c2, s2) {
  var a3, h2, p2, y2, v2, _2, m2, b2, S2, C2, M2, $2, P2, A2, H2, L2, T2, j2 = u2.type;
  if (null != u2.constructor) return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), o3 = [f2 = u2.__e = t2.__e]), (a3 = l$4.__b) && a3(u2);
  n: if ("function" == typeof j2) try {
    if (b2 = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C2 = (a3 = j2.contextType) && i2[a3.__c], M2 = a3 ? C2 ? C2.props.value : a3.__ : i2, t2.__c ? m2 = (h2 = u2.__c = t2.__c).__ = h2.__E : (S2 ? u2.__c = h2 = new j2(b2, M2) : (u2.__c = h2 = new x$5(b2, M2), h2.constructor = j2, h2.render = D$3), C2 && C2.sub(h2), h2.props = b2, h2.state || (h2.state = {}), h2.context = M2, h2.__n = i2, p2 = h2.__d = true, h2.__h = [], h2._sb = []), S2 && null == h2.__s && (h2.__s = h2.state), S2 && null != j2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = d$5({}, h2.__s)), d$5(h2.__s, j2.getDerivedStateFromProps(b2, h2.__s))), y2 = h2.props, v2 = h2.state, h2.__v = u2, p2) S2 && null == j2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), S2 && null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
    else {
      if (S2 && null == j2.getDerivedStateFromProps && b2 !== y2 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(b2, M2), !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(b2, h2.__s, M2) || u2.__v == t2.__v) {
        for (u2.__v != t2.__v && (h2.props = b2, h2.state = h2.__s, h2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.some(function(n3) {
          n3 && (n3.__ = u2);
        }), $2 = 0; $2 < h2._sb.length; $2++) h2.__h.push(h2._sb[$2]);
        h2._sb = [], h2.__h.length && e2.push(h2);
        break n;
      }
      null != h2.componentWillUpdate && h2.componentWillUpdate(b2, h2.__s, M2), S2 && null != h2.componentDidUpdate && h2.__h.push(function() {
        h2.componentDidUpdate(y2, v2, _2);
      });
    }
    if (h2.context = M2, h2.props = b2, h2.__P = n2, h2.__e = false, P2 = l$4.__r, A2 = 0, S2) {
      for (h2.state = h2.__s, h2.__d = false, P2 && P2(u2), a3 = h2.render(h2.props, h2.state, h2.context), H2 = 0; H2 < h2._sb.length; H2++) h2.__h.push(h2._sb[H2]);
      h2._sb = [];
    } else do {
      h2.__d = false, P2 && P2(u2), a3 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
    } while (h2.__d && ++A2 < 25);
    h2.state = h2.__s, null != h2.getChildContext && (i2 = d$5(d$5({}, i2), h2.getChildContext())), S2 && !p2 && null != h2.getSnapshotBeforeUpdate && (_2 = h2.getSnapshotBeforeUpdate(y2, v2)), L2 = a3, null != a3 && a3.type === k$3 && null == a3.key && (L2 = N$2(a3.props.children)), f2 = I$4(n2, w$5(L2) ? L2 : [L2], u2, t2, i2, r2, o3, e2, f2, c2, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && e2.push(h2), m2 && (h2.__E = h2.__ = null);
  } catch (n3) {
    if (u2.__v = null, c2 || null != o3) if (n3.then) {
      for (u2.__u |= c2 ? 160 : 128; f2 && 8 == f2.nodeType && f2.nextSibling; ) f2 = f2.nextSibling;
      o3[o3.indexOf(f2)] = null, u2.__e = f2;
    } else for (T2 = o3.length; T2--; ) g$4(o3[T2]);
    else u2.__e = t2.__e, u2.__k = t2.__k;
    l$4.__e(n3, u2, t2);
  }
  else null == o3 && u2.__v == t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : f2 = u2.__e = V$2(t2.__e, u2, t2, i2, r2, o3, e2, c2, s2);
  return (a3 = l$4.diffed) && a3(u2), 128 & u2.__u ? void 0 : f2;
}
function z$3(n2, u2, t2) {
  for (var i2 = 0; i2 < t2.length; i2++) q$4(t2[i2], t2[++i2], t2[++i2]);
  l$4.__c && l$4.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$4.__e(n3, u3.__v);
    }
  });
}
function N$2(n2) {
  return "object" != typeof n2 || null == n2 || n2.__b && n2.__b > 0 ? n2 : w$5(n2) ? n2.map(N$2) : d$5({}, n2);
}
function V$2(u2, t2, i2, r2, o3, e2, f2, c2, s2) {
  var a3, h2, y2, v2, d2, _2, m2, b2 = i2.props, k2 = t2.props, x2 = t2.type;
  if ("svg" == x2 ? o3 = "http://www.w3.org/2000/svg" : "math" == x2 ? o3 = "http://www.w3.org/1998/Math/MathML" : o3 || (o3 = "http://www.w3.org/1999/xhtml"), null != e2) {
    for (a3 = 0; a3 < e2.length; a3++) if ((d2 = e2[a3]) && "setAttribute" in d2 == !!x2 && (x2 ? d2.localName == x2 : 3 == d2.nodeType)) {
      u2 = d2, e2[a3] = null;
      break;
    }
  }
  if (null == u2) {
    if (null == x2) return document.createTextNode(k2);
    u2 = document.createElementNS(o3, x2, k2.is && k2), c2 && (l$4.__m && l$4.__m(t2, e2), c2 = false), e2 = null;
  }
  if (null == x2) b2 === k2 || c2 && u2.data == k2 || (u2.data = k2);
  else {
    if (e2 = e2 && n$4.call(u2.childNodes), b2 = i2.props || p$4, !c2 && null != e2) for (b2 = {}, a3 = 0; a3 < u2.attributes.length; a3++) b2[(d2 = u2.attributes[a3]).name] = d2.value;
    for (a3 in b2) if (d2 = b2[a3], "children" == a3) ;
    else if ("dangerouslySetInnerHTML" == a3) y2 = d2;
    else if (!(a3 in k2)) {
      if ("value" == a3 && "defaultValue" in k2 || "checked" == a3 && "defaultChecked" in k2) continue;
      j$5(u2, a3, null, d2, o3);
    }
    for (a3 in k2) d2 = k2[a3], "children" == a3 ? v2 = d2 : "dangerouslySetInnerHTML" == a3 ? h2 = d2 : "value" == a3 ? _2 = d2 : "checked" == a3 ? m2 = d2 : c2 && "function" != typeof d2 || b2[a3] === d2 || j$5(u2, a3, d2, b2[a3], o3);
    if (h2) c2 || y2 && (h2.__html == y2.__html || h2.__html == u2.innerHTML) || (u2.innerHTML = h2.__html), t2.__k = [];
    else if (y2 && (u2.innerHTML = ""), I$4("template" == t2.type ? u2.content : u2, w$5(v2) ? v2 : [v2], t2, i2, r2, "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : o3, e2, f2, e2 ? e2[0] : i2.__k && S$5(i2, 0), c2, s2), null != e2) for (a3 = e2.length; a3--; ) g$4(e2[a3]);
    c2 || (a3 = "value", "progress" == x2 && null == _2 ? u2.removeAttribute("value") : null != _2 && (_2 !== u2[a3] || "progress" == x2 && !_2 || "option" == x2 && _2 != b2[a3]) && j$5(u2, a3, _2, b2[a3], o3), a3 = "checked", null != m2 && m2 != u2[a3] && j$5(u2, a3, m2, b2[a3], o3));
  }
  return u2;
}
function q$4(n2, u2, t2) {
  try {
    if ("function" == typeof n2) {
      var i2 = "function" == typeof n2.__u;
      i2 && n2.__u(), i2 && null == u2 || (n2.__u = n2(u2));
    } else n2.current = u2;
  } catch (n3) {
    l$4.__e(n3, t2);
  }
}
function B$3(n2, u2, t2) {
  var i2, r2;
  if (l$4.unmount && l$4.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || q$4(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount) try {
      i2.componentWillUnmount();
    } catch (n3) {
      l$4.__e(n3, u2);
    }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k) for (r2 = 0; r2 < i2.length; r2++) i2[r2] && B$3(i2[r2], u2, t2 || "function" != typeof n2.type);
  t2 || g$4(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function D$3(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function E$3(u2, t2, i2) {
  var r2, o3, e2, f2;
  t2 == document && (t2 = document.documentElement), l$4.__ && l$4.__(u2, t2), o3 = (r2 = "function" == typeof i2) ? null : i2 && i2.__k || t2.__k, e2 = [], f2 = [], O$3(t2, u2 = (!r2 && i2 || t2).__k = _$4(k$3, null, [u2]), o3 || p$4, p$4, t2.namespaceURI, !r2 && i2 ? [i2] : o3 ? null : t2.firstChild ? n$4.call(t2.childNodes) : null, e2, !r2 && i2 ? i2 : o3 ? o3.__e : t2.firstChild, r2, f2), z$3(e2, u2, f2);
}
function G$3(n2, l2) {
  E$3(n2, l2, G$3);
}
function J$4(l2, u2, t2) {
  var i2, r2, o3, e2, f2 = d$5({}, l2.props);
  for (o3 in l2.type && l2.type.defaultProps && (e2 = l2.type.defaultProps), u2) "key" == o3 ? i2 = u2[o3] : "ref" == o3 ? r2 = u2[o3] : f2[o3] = null == u2[o3] && null != e2 ? e2[o3] : u2[o3];
  return arguments.length > 2 && (f2.children = arguments.length > 3 ? n$4.call(arguments, 2) : t2), m$6(l2.type, f2, i2 || l2.key, r2 || l2.ref, null);
}
function K$3(n2) {
  function l2(n3) {
    var u2, t2;
    return this.getChildContext || (u2 = /* @__PURE__ */ new Set(), (t2 = {})[l2.__c] = this, this.getChildContext = function() {
      return t2;
    }, this.componentWillUnmount = function() {
      u2 = null;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value != n4.value && u2.forEach(function(n5) {
        n5.__e = true, M$4(n5);
      });
    }, this.sub = function(n4) {
      u2.add(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u2 && u2.delete(n4), l3 && l3.call(n4);
      };
    }), n3.children;
  }
  return l2.__c = "__cC" + h$6++, l2.__ = n2, l2.Provider = l2.__l = (l2.Consumer = function(n3, l3) {
    return n3.children(l3);
  }).contextType = l2, l2;
}
n$4 = y$7.slice, l$4 = { __e: function(n2, l2, u2, t2) {
  for (var i2, r2, o3; l2 = l2.__; ) if ((i2 = l2.__c) && !i2.__) try {
    if ((r2 = i2.constructor) && null != r2.getDerivedStateFromError && (i2.setState(r2.getDerivedStateFromError(n2)), o3 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), o3 = i2.__d), o3) return i2.__E = i2;
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, u$a = 0, x$5.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d$5({}, this.state), "function" == typeof n2 && (n2 = n2(d$5({}, u2), this.props)), n2 && d$5(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), M$4(this));
}, x$5.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M$4(this));
}, x$5.prototype.render = k$3, i$8 = [], o$9 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$5 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, $$2.__r = 0, f$9 = /(PointerCapture)$|Capture$/i, c$7 = 0, s$9 = F$6(false), a$b = F$6(true), h$6 = 0;
var f$8 = 0;
function u$9(e2, t2, n2, o3, i2, u2) {
  t2 || (t2 = {});
  var a3, c2, p2 = t2;
  if ("ref" in p2) for (c2 in p2 = {}, t2) "ref" == c2 ? a3 = t2[c2] : p2[c2] = t2[c2];
  var l2 = { type: e2, props: p2, key: n2, ref: a3, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: --f$8, __i: -1, __u: 0, __source: i2, __self: u2 };
  if ("function" == typeof e2 && (a3 = e2.defaultProps)) for (c2 in a3) void 0 === p2[c2] && (p2[c2] = a3[c2]);
  return l$4.vnode && l$4.vnode(l2), l2;
}
var t$5, r$4, u$8, i$7, o$8 = 0, f$7 = [], c$6 = l$4, e$4 = c$6.__b, a$a = c$6.__r, v$2 = c$6.diffed, l$3 = c$6.__c, m$5 = c$6.unmount, s$8 = c$6.__;
function p$3(n2, t2) {
  c$6.__h && c$6.__h(r$4, n2, o$8 || t2), o$8 = 0;
  var u2 = r$4.__H || (r$4.__H = { __: [], __h: [] });
  return n2 >= u2.__.length && u2.__.push({}), u2.__[n2];
}
function d$4(n2) {
  return o$8 = 1, h$5(D$2, n2);
}
function h$5(n2, u2, i2) {
  var o3 = p$3(t$5++, 2);
  if (o3.t = n2, !o3.__c && (o3.__ = [i2 ? i2(u2) : D$2(void 0, u2), function(n3) {
    var t2 = o3.__N ? o3.__N[0] : o3.__[0], r2 = o3.t(t2, n3);
    t2 !== r2 && (o3.__N = [r2, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r$4, !r$4.__f)) {
    var f2 = function(n3, t2, r2) {
      if (!o3.__c.__H) return true;
      var u3 = o3.__c.__H.__.filter(function(n4) {
        return !!n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      })) return !c2 || c2.call(this, n3, t2, r2);
      var i3 = o3.__c.props !== n3;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i3 = true);
        }
      }), c2 && c2.call(this, n3, t2, r2) || i3;
    };
    r$4.__f = true;
    var c2 = r$4.shouldComponentUpdate, e2 = r$4.componentWillUpdate;
    r$4.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n3, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r$4.shouldComponentUpdate = f2;
  }
  return o3.__N || o3.__;
}
function y$6(n2, u2) {
  var i2 = p$3(t$5++, 3);
  !c$6.__s && C$4(i2.__H, u2) && (i2.__ = n2, i2.u = u2, r$4.__H.__h.push(i2));
}
function _$3(n2, u2) {
  var i2 = p$3(t$5++, 4);
  !c$6.__s && C$4(i2.__H, u2) && (i2.__ = n2, i2.u = u2, r$4.__h.push(i2));
}
function A$3(n2) {
  return o$8 = 5, T$5(function() {
    return { current: n2 };
  }, []);
}
function F$5(n2, t2, r2) {
  o$8 = 6, _$3(function() {
    if ("function" == typeof n2) {
      var r3 = n2(t2());
      return function() {
        n2(null), r3 && "function" == typeof r3 && r3();
      };
    }
    if (n2) return n2.current = t2(), function() {
      return n2.current = null;
    };
  }, null == r2 ? r2 : r2.concat(n2));
}
function T$5(n2, r2) {
  var u2 = p$3(t$5++, 7);
  return C$4(u2.__H, r2) && (u2.__ = n2(), u2.__H = r2, u2.__h = n2), u2.__;
}
function q$3(n2, t2) {
  return o$8 = 8, T$5(function() {
    return n2;
  }, t2);
}
function x$4(n2) {
  var u2 = r$4.context[n2.__c], i2 = p$3(t$5++, 9);
  return i2.c = n2, u2 ? (null == i2.__ && (i2.__ = true, u2.sub(r$4)), u2.props.value) : n2.__;
}
function P$5(n2, t2) {
  c$6.useDebugValue && c$6.useDebugValue(t2 ? t2(n2) : n2);
}
function b$4(n2) {
  var u2 = p$3(t$5++, 10), i2 = d$4();
  return u2.__ = n2, r$4.componentDidCatch || (r$4.componentDidCatch = function(n3, t2) {
    u2.__ && u2.__(n3, t2), i2[1](n3);
  }), [i2[0], function() {
    i2[1](void 0);
  }];
}
function g$3() {
  var n2 = p$3(t$5++, 11);
  if (!n2.__) {
    for (var u2 = r$4.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
    var i2 = u2.__m || (u2.__m = [0, 0]);
    n2.__ = "P" + i2[0] + "-" + i2[1]++;
  }
  return n2.__;
}
function j$4() {
  for (var n2; n2 = f$7.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z$2), n2.__H.__h.forEach(B$2), n2.__H.__h = [];
  } catch (t2) {
    n2.__H.__h = [], c$6.__e(t2, n2.__v);
  }
}
c$6.__b = function(n2) {
  r$4 = null, e$4 && e$4(n2);
}, c$6.__ = function(n2, t2) {
  n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), s$8 && s$8(n2, t2);
}, c$6.__r = function(n2) {
  a$a && a$a(n2), t$5 = 0;
  var i2 = (r$4 = n2.__c).__H;
  i2 && (u$8 === r$4 ? (i2.__h = [], r$4.__h = [], i2.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.u = n3.__N = void 0;
  })) : (i2.__h.forEach(z$2), i2.__h.forEach(B$2), i2.__h = [], t$5 = 0)), u$8 = r$4;
}, c$6.diffed = function(n2) {
  v$2 && v$2(n2);
  var t2 = n2.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f$7.push(t2) && i$7 === c$6.requestAnimationFrame || ((i$7 = c$6.requestAnimationFrame) || w$4)(j$4)), t2.__H.__.forEach(function(n3) {
    n3.u && (n3.__H = n3.u), n3.u = void 0;
  })), u$8 = r$4 = null;
}, c$6.__c = function(n2, t2) {
  t2.some(function(n3) {
    try {
      n3.__h.forEach(z$2), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B$2(n4);
      });
    } catch (r2) {
      t2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t2 = [], c$6.__e(r2, n3.__v);
    }
  }), l$3 && l$3(n2, t2);
}, c$6.unmount = function(n2) {
  m$5 && m$5(n2);
  var t2, r2 = n2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
    try {
      z$2(n3);
    } catch (n4) {
      t2 = n4;
    }
  }), r2.__H = void 0, t2 && c$6.__e(t2, r2.__v));
};
var k$2 = "function" == typeof requestAnimationFrame;
function w$4(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), k$2 && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 100);
  k$2 && (t2 = requestAnimationFrame(r2));
}
function z$2(n2) {
  var t2 = r$4, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r$4 = t2;
}
function B$2(n2) {
  var t2 = r$4;
  n2.__c = n2.__(), r$4 = t2;
}
function C$4(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function D$2(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
K$3([]);
function g$2(n2, t2) {
  for (var e2 in t2) n2[e2] = t2[e2];
  return n2;
}
function E$2(n2, t2) {
  for (var e2 in n2) if ("__source" !== e2 && !(e2 in t2)) return true;
  for (var r2 in t2) if ("__source" !== r2 && n2[r2] !== t2[r2]) return true;
  return false;
}
function C$3(n2, t2) {
  var e2 = t2(), r2 = d$4({ t: { __: e2, u: t2 } }), u2 = r2[0].t, o3 = r2[1];
  return _$3(function() {
    u2.__ = e2, u2.u = t2, x$3(u2) && o3({ t: u2 });
  }, [n2, e2, t2]), y$6(function() {
    return x$3(u2) && o3({ t: u2 }), n2(function() {
      x$3(u2) && o3({ t: u2 });
    });
  }, [n2]), e2;
}
function x$3(n2) {
  var t2, e2, r2 = n2.u, u2 = n2.__;
  try {
    var o3 = r2();
    return !((t2 = u2) === (e2 = o3) && (0 !== t2 || 1 / t2 == 1 / e2) || t2 != t2 && e2 != e2);
  } catch (n3) {
    return true;
  }
}
function R$3(n2) {
  n2();
}
function w$3(n2) {
  return n2;
}
function k$1() {
  return [false, R$3];
}
var I$3 = _$3;
function N$1(n2, t2) {
  this.props = n2, this.context = t2;
}
function M$3(n2, e2) {
  function r2(n3) {
    var t2 = this.props.ref, r3 = t2 == n3.ref;
    return !r3 && t2 && (t2.call ? t2(null) : t2.current = null), e2 ? !e2(this.props, n3) || !r3 : E$2(this.props, n3);
  }
  function u2(e3) {
    return this.shouldComponentUpdate = r2, _$4(n2, e3);
  }
  return u2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", u2.prototype.isReactComponent = true, u2.__f = true, u2;
}
(N$1.prototype = new x$5()).isPureReactComponent = true, N$1.prototype.shouldComponentUpdate = function(n2, t2) {
  return E$2(this.props, n2) || E$2(this.state, t2);
};
var T$4 = l$4.__b;
l$4.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), T$4 && T$4(n2);
};
var A$2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function D$1(n2) {
  function t2(t3) {
    var e2 = g$2({}, t3);
    return delete e2.ref, n2(e2, t3.ref || null);
  }
  return t2.$$typeof = A$2, t2.render = t2, t2.prototype.isReactComponent = t2.__f = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
var L$3 = function(n2, t2) {
  return null == n2 ? null : H$6(H$6(n2).map(t2));
}, O$2 = { map: L$3, forEach: L$3, count: function(n2) {
  return n2 ? H$6(n2).length : 0;
}, only: function(n2) {
  var t2 = H$6(n2);
  if (1 !== t2.length) throw "Children.only";
  return t2[0];
}, toArray: H$6 }, F$4 = l$4.__e;
l$4.__e = function(n2, t2, e2, r2) {
  if (n2.then) {
    for (var u2, o3 = t2; o3 = o3.__; ) if ((u2 = o3.__c) && u2.__c) return null == t2.__e && (t2.__e = e2.__e, t2.__k = e2.__k), u2.__c(n2, t2);
  }
  F$4(n2, t2, e2, r2);
};
var U$3 = l$4.unmount;
function V$1(n2, t2, e2) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g$2({}, n2)).__c && (n2.__c.__P === e2 && (n2.__c.__P = t2), n2.__c.__e = true, n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return V$1(n3, t2, e2);
  })), n2;
}
function W(n2, t2, e2) {
  return n2 && e2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return W(n3, t2, e2);
  }), n2.__c && n2.__c.__P === t2 && (n2.__e && e2.appendChild(n2.__e), n2.__c.__e = true, n2.__c.__P = e2)), n2;
}
function P$4() {
  this.__u = 0, this.o = null, this.__b = null;
}
function j$3(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.__a && t2.__a(n2);
}
function z$1(n2) {
  var e2, r2, u2;
  function o3(o4) {
    if (e2 || (e2 = n2()).then(function(n3) {
      r2 = n3.default || n3;
    }, function(n3) {
      u2 = n3;
    }), u2) throw u2;
    if (!r2) throw e2;
    return _$4(r2, o4);
  }
  return o3.displayName = "Lazy", o3.__f = true, o3;
}
function B$1() {
  this.i = null, this.l = null;
}
l$4.unmount = function(n2) {
  var t2 = n2.__c;
  t2 && t2.__R && t2.__R(), t2 && 32 & n2.__u && (n2.type = null), U$3 && U$3(n2);
}, (P$4.prototype = new x$5()).__c = function(n2, t2) {
  var e2 = t2.__c, r2 = this;
  null == r2.o && (r2.o = []), r2.o.push(e2);
  var u2 = j$3(r2.__v), o3 = false, i2 = function() {
    o3 || (o3 = true, e2.__R = null, u2 ? u2(l2) : l2());
  };
  e2.__R = i2;
  var l2 = function() {
    if (!--r2.__u) {
      if (r2.state.__a) {
        var n3 = r2.state.__a;
        r2.__v.__k[0] = W(n3, n3.__c.__P, n3.__c.__O);
      }
      var t3;
      for (r2.setState({ __a: r2.__b = null }); t3 = r2.o.pop(); ) t3.forceUpdate();
    }
  };
  r2.__u++ || 32 & t2.__u || r2.setState({ __a: r2.__b = r2.__v.__k[0] }), n2.then(i2, i2);
}, P$4.prototype.componentWillUnmount = function() {
  this.o = [];
}, P$4.prototype.render = function(n2, e2) {
  if (this.__b) {
    if (this.__v.__k) {
      var r2 = document.createElement("div"), o3 = this.__v.__k[0].__c;
      this.__v.__k[0] = V$1(this.__b, r2, o3.__O = o3.__P);
    }
    this.__b = null;
  }
  var i2 = e2.__a && _$4(k$3, null, n2.fallback);
  return i2 && (i2.__u &= -33), [_$4(k$3, null, e2.__a ? null : n2.children), i2];
};
var H$5 = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.l.delete(t2), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.l.size)) for (e2 = n2.i; e2; ) {
    for (; e2.length > 3; ) e2.pop()();
    if (e2[1] < e2[0]) break;
    n2.i = e2 = e2[2];
  }
};
function Z(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function Y(n2) {
  var e2 = this, r2 = n2.h;
  if (e2.componentWillUnmount = function() {
    E$3(null, e2.v), e2.v = null, e2.h = null;
  }, e2.h && e2.h !== r2 && e2.componentWillUnmount(), !e2.v) {
    for (var u2 = e2.__v; null !== u2 && !u2.__m && null !== u2.__; ) u2 = u2.__;
    e2.h = r2, e2.v = { nodeType: 1, parentNode: r2, childNodes: [], __k: { __m: u2.__m }, contains: function() {
      return true;
    }, appendChild: function(n3) {
      this.childNodes.push(n3), e2.h.appendChild(n3);
    }, insertBefore: function(n3, t2) {
      this.childNodes.push(n3), e2.h.insertBefore(n3, t2);
    }, removeChild: function(n3) {
      this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e2.h.removeChild(n3);
    } };
  }
  E$3(_$4(Z, { context: e2.context }, n2.__v), e2.v);
}
function $$1(n2, e2) {
  var r2 = _$4(Y, { __v: n2, h: e2 });
  return r2.containerInfo = e2, r2;
}
(B$1.prototype = new x$5()).__a = function(n2) {
  var t2 = this, e2 = j$3(t2.__v), r2 = t2.l.get(n2);
  return r2[0]++, function(u2) {
    var o3 = function() {
      t2.props.revealOrder ? (r2.push(u2), H$5(t2, n2, r2)) : u2();
    };
    e2 ? e2(o3) : o3();
  };
}, B$1.prototype.render = function(n2) {
  this.i = null, this.l = /* @__PURE__ */ new Map();
  var t2 = H$6(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t2.reverse();
  for (var e2 = t2.length; e2--; ) this.l.set(t2[e2], this.i = [1, 0, this.i]);
  return n2.children;
}, B$1.prototype.componentDidUpdate = B$1.prototype.componentDidMount = function() {
  var n2 = this;
  this.l.forEach(function(t2, e2) {
    H$5(n2, e2, t2);
  });
};
var q$2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, G$2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, J$3 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, K$2 = /[A-Z0-9]/g, Q = "undefined" != typeof document, X$1 = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n2);
};
function nn(n2, t2, e2) {
  return null == t2.__k && (t2.textContent = ""), E$3(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
function tn(n2, t2, e2) {
  return G$3(n2, t2), "function" == typeof e2 && e2(), n2 ? n2.__c : null;
}
x$5.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t2) {
  Object.defineProperty(x$5.prototype, t2, { configurable: true, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n2) {
    Object.defineProperty(this, t2, { configurable: true, writable: true, value: n2 });
  } });
});
var en = l$4.event;
function rn() {
}
function un() {
  return this.cancelBubble;
}
function on() {
  return this.defaultPrevented;
}
l$4.event = function(n2) {
  return en && (n2 = en(n2)), n2.persist = rn, n2.isPropagationStopped = un, n2.isDefaultPrevented = on, n2.nativeEvent = n2;
};
var ln, cn$1 = { enumerable: false, configurable: true, get: function() {
  return this.class;
} }, fn = l$4.vnode;
l$4.vnode = function(n2) {
  "string" == typeof n2.type && function(n3) {
    var t2 = n3.props, e2 = n3.type, u2 = {}, o3 = -1 === e2.indexOf("-");
    for (var i2 in t2) {
      var l2 = t2[i2];
      if (!("value" === i2 && "defaultValue" in t2 && null == l2 || Q && "children" === i2 && "noscript" === e2 || "class" === i2 || "className" === i2)) {
        var c2 = i2.toLowerCase();
        "defaultValue" === i2 && "value" in t2 && null == t2.value ? i2 = "value" : "download" === i2 && true === l2 ? l2 = "" : "translate" === c2 && "no" === l2 ? l2 = false : "o" === c2[0] && "n" === c2[1] ? "ondoubleclick" === c2 ? i2 = "ondblclick" : "onchange" !== c2 || "input" !== e2 && "textarea" !== e2 || X$1(t2.type) ? "onfocus" === c2 ? i2 = "onfocusin" : "onblur" === c2 ? i2 = "onfocusout" : J$3.test(i2) && (i2 = c2) : c2 = i2 = "oninput" : o3 && G$2.test(i2) ? i2 = i2.replace(K$2, "-$&").toLowerCase() : null === l2 && (l2 = void 0), "oninput" === c2 && u2[i2 = c2] && (i2 = "oninputCapture"), u2[i2] = l2;
      }
    }
    "select" == e2 && u2.multiple && Array.isArray(u2.value) && (u2.value = H$6(t2.children).forEach(function(n4) {
      n4.props.selected = -1 != u2.value.indexOf(n4.props.value);
    })), "select" == e2 && null != u2.defaultValue && (u2.value = H$6(t2.children).forEach(function(n4) {
      n4.props.selected = u2.multiple ? -1 != u2.defaultValue.indexOf(n4.props.value) : u2.defaultValue == n4.props.value;
    })), t2.class && !t2.className ? (u2.class = t2.class, Object.defineProperty(u2, "className", cn$1)) : (t2.className && !t2.class || t2.class && t2.className) && (u2.class = u2.className = t2.className), n3.props = u2;
  }(n2), n2.$$typeof = q$2, fn && fn(n2);
};
var an = l$4.__r;
l$4.__r = function(n2) {
  an && an(n2), ln = n2.__c;
};
var sn = l$4.diffed;
l$4.diffed = function(n2) {
  sn && sn(n2);
  var t2 = n2.props, e2 = n2.__e;
  null != e2 && "textarea" === n2.type && "value" in t2 && t2.value !== e2.value && (e2.value = null == t2.value ? "" : t2.value), ln = null;
};
var hn = { ReactCurrentDispatcher: { current: { readContext: function(n2) {
  return ln.__n[n2.__c].props.value;
}, useCallback: q$3, useContext: x$4, useDebugValue: P$5, useDeferredValue: w$3, useEffect: y$6, useId: g$3, useImperativeHandle: F$5, useInsertionEffect: I$3, useLayoutEffect: _$3, useMemo: T$5, useReducer: h$5, useRef: A$3, useState: d$4, useSyncExternalStore: C$3, useTransition: k$1 } } }, vn = "18.3.1";
function dn(n2) {
  return _$4.bind(null, n2);
}
function mn(n2) {
  return !!n2 && n2.$$typeof === q$2;
}
function pn(n2) {
  return mn(n2) && n2.type === k$3;
}
function yn(n2) {
  return !!n2 && !!n2.displayName && ("string" == typeof n2.displayName || n2.displayName instanceof String) && n2.displayName.startsWith("Memo(");
}
function _n(n2) {
  return mn(n2) ? J$4.apply(null, arguments) : n2;
}
function bn(n2) {
  return !!n2.__k && (E$3(null, n2), true);
}
function Sn(n2) {
  return n2 && (n2.base || 1 === n2.nodeType && n2) || null;
}
var gn = function(n2, t2) {
  return n2(t2);
}, En = function(n2, t2) {
  return n2(t2);
}, Cn = k$3, xn = mn, Rn = { useState: d$4, useId: g$3, useReducer: h$5, useEffect: y$6, useLayoutEffect: _$3, useInsertionEffect: I$3, useTransition: k$1, useDeferredValue: w$3, useSyncExternalStore: C$3, startTransition: R$3, useRef: A$3, useImperativeHandle: F$5, useMemo: T$5, useCallback: q$3, useContext: x$4, useDebugValue: P$5, version: "18.3.1", Children: O$2, render: nn, hydrate: tn, unmountComponentAtNode: bn, createPortal: $$1, createElement: _$4, createContext: K$3, createFactory: dn, cloneElement: _n, createRef: b$5, Fragment: k$3, isValidElement: mn, isElement: xn, isFragment: pn, isMemo: yn, findDOMNode: Sn, Component: x$5, PureComponent: N$1, memo: M$3, forwardRef: D$1, flushSync: En, unstable_batchedUpdates: gn, StrictMode: Cn, Suspense: P$4, SuspenseList: B$1, lazy: z$1, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn };
const t$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Children: O$2,
  Component: x$5,
  Fragment: k$3,
  PureComponent: N$1,
  StrictMode: Cn,
  Suspense: P$4,
  SuspenseList: B$1,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: hn,
  cloneElement: _n,
  createContext: K$3,
  createElement: _$4,
  createFactory: dn,
  createPortal: $$1,
  createRef: b$5,
  default: Rn,
  findDOMNode: Sn,
  flushSync: En,
  forwardRef: D$1,
  hydrate: tn,
  isElement: xn,
  isFragment: pn,
  isMemo: yn,
  isValidElement: mn,
  lazy: z$1,
  memo: M$3,
  render: nn,
  startTransition: R$3,
  unmountComponentAtNode: bn,
  unstable_batchedUpdates: gn,
  useCallback: q$3,
  useContext: x$4,
  useDebugValue: P$5,
  useDeferredValue: w$3,
  useEffect: y$6,
  useErrorBoundary: b$4,
  useId: g$3,
  useImperativeHandle: F$5,
  useInsertionEffect: I$3,
  useLayoutEffect: _$3,
  useMemo: T$5,
  useReducer: h$5,
  useRef: A$3,
  useState: d$4,
  useSyncExternalStore: C$3,
  useTransition: k$1,
  version: vn
}, Symbol.toStringTag, { value: "Module" }));
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a3, b2) => (typeof require !== "undefined" ? require : a3)[b2]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
typeof window !== "undefined" ? window.WebSocket : __require("ws").WebSocket;
function createBridgeContract(contract2) {
  return contract2;
}
typeof window !== "undefined" ? window.WebSocket : __require("ws").WebSocket;
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a3, b2) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b2);
  if (a3 === b2) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a3).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a3, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a3[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a3.length; index2++) {
      const itemA = a3[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b2) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error2.addIssue(makeArgsIssue(args, e2));
          throw error2;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error2.addIssue(makeReturnsIssue(result, e2));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner2.status === "aborted")
          return INVALID;
        if (inner2.status === "dirty")
          status.dirty();
        executeRefinement(inner2.value);
        return { status: status.value, value: inner2.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner2) => {
          if (inner2.status === "aborted")
            return INVALID;
          if (inner2.status === "dirty")
            status.dirty();
          return executeRefinement(inner2.value).then(() => {
            return { status: status.value, value: inner2.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b2) {
    return new ZodPipeline({
      in: a3,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p2 === "string" ? { message: p2 } : p2;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r2 = check(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          var _a2, _b2;
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
createBridgeContract({
  server: {
    triggerAgentPrompt: {
      request: z.object({
        prompt: z.string()
      }),
      response: z.object({
        result: z.object({
          success: z.boolean(),
          error: z.string().optional(),
          output: z.string().optional()
        })
      }),
      update: z.object({
        updateText: z.string()
      })
    }
  }
});
K$3({
  bridge: null,
  isConnecting: false,
  error: null
});
const DropAreaZone = {
  BOTTOM_CENTER: 4
};
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = Rn.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  Rn.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = (createState) => createState ? createImpl(createState) : createImpl;
class DoubleIndexedKV {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.keyToValue.set(key, value);
    this.valueToKey.set(value, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value) {
    return this.valueToKey.get(value);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
}
class Registry {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value, identifier) {
    if (this.kv.getByValue(value)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value);
    }
    this.kv.set(identifier, value);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value) {
    return this.kv.getByValue(value);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
}
class ClassRegistry extends Registry {
  constructor() {
    super((c2) => c2.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value, options.allowProps);
      }
      super.register(value, options.identifier);
    } else {
      super.register(value, options);
    }
  }
  getAllowedProps(value) {
    return this.classToAllowedProps.get(value);
  }
}
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  const values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  const valuesNotNever = values;
  for (let i2 = 0; i2 < valuesNotNever.length; i2++) {
    const value = valuesNotNever[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value]) => run(value, key));
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (let i2 = 0; i2 < record.length; i2++) {
    const value = record[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
class CustomTransformerRegistry {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v2) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v2));
  }
  findByName(name) {
    return this.transfomers[name];
  }
}
const getType$1 = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
const isUndefined = (payload) => typeof payload === "undefined";
const isNull = (payload) => payload === null;
const isPlainObject$1 = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
const isEmptyObject = (payload) => isPlainObject$1(payload) && Object.keys(payload).length === 0;
const isArray$1 = (payload) => Array.isArray(payload);
const isString$1 = (payload) => typeof payload === "string";
const isNumber$1 = (payload) => typeof payload === "number" && !isNaN(payload);
const isBoolean = (payload) => typeof payload === "boolean";
const isRegExp = (payload) => payload instanceof RegExp;
const isMap = (payload) => payload instanceof Map;
const isSet = (payload) => payload instanceof Set;
const isSymbol = (payload) => getType$1(payload) === "Symbol";
const isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
const isError = (payload) => payload instanceof Error;
const isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
const isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber$1(payload) || isString$1(payload) || isSymbol(payload);
const isBigint = (payload) => typeof payload === "bigint";
const isInfinite = (payload) => payload === Infinity || payload === -Infinity;
const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
const isURL = (payload) => payload instanceof URL;
const escapeKey = (key) => key.replace(/\./g, "\\.");
const stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
const parsePath = (string) => {
  const result = [];
  let segment = "";
  for (let i2 = 0; i2 < string.length; i2++) {
    let char = string.charAt(i2);
    const isEscapedDot = char === "\\" && string.charAt(i2 + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i2++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v2) => v2.toString(), (v2) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v2);
    }
    console.error("Please add a BigInt polyfill.");
    return v2;
  }),
  simpleTransformation(isDate, "Date", (v2) => v2.toISOString(), (v2) => new Date(v2)),
  simpleTransformation(isError, "Error", (v2, superJson) => {
    const baseError = {
      name: v2.name,
      message: v2.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v2[prop];
    });
    return baseError;
  }, (v2, superJson) => {
    const e2 = new Error(v2.message);
    e2.name = v2.name;
    e2.stack = v2.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e2[prop] = v2[prop];
    });
    return e2;
  }),
  simpleTransformation(isRegExp, "regexp", (v2) => "" + v2, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v2) => [...v2.values()],
    (v2) => new Set(v2)
  ),
  simpleTransformation(isMap, "map", (v2) => [...v2.entries()], (v2) => new Map(v2)),
  simpleTransformation((v2) => isNaNValue(v2) || isInfinite(v2), "number", (v2) => {
    if (isNaNValue(v2)) {
      return "NaN";
    }
    if (v2 > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v2) => v2 === 0 && 1 / v2 === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v2) => v2.toString(), (v2) => new URL(v2))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
const symbolRule = compositeTransformation((s2, superJson) => {
  if (isSymbol(s2)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s2);
    return isRegistered;
  }
  return false;
}, (s2, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s2);
  return ["symbol", identifier];
}, (v2) => v2.description, (_2, a3, superJson) => {
  const value = superJson.symbolRegistry.getValue(a3[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
const constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
const typedArrayRule = compositeTransformation(isTypedArray, (v2) => ["typed-array", v2.constructor.name], (v2) => [...v2], (v2, a3) => {
  const ctor = constructorToName[a3[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v2);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass == null ? void 0 : potentialClass.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
const classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v2, a3, superJson) => {
  const clazz = superJson.classRegistry.getValue(a3[1]);
  if (!clazz) {
    throw new Error(`Trying to deserialize unknown class '${a3[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  }
  return Object.assign(Object.create(clazz.prototype), v2);
});
const customRule = compositeTransformation((value, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, (value, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, (v2, a3, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a3[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v2);
});
const compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
const transformValue = (value, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
const simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
const untransformValue = (json, type, superJson) => {
  if (isArray$1(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};
const getNthKey = (value, n2) => {
  if (n2 > value.size)
    throw new Error("index out of bounds");
  const keys = value.keys();
  while (n2 > 0) {
    keys.next();
    n2--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
const getDeep = (object, path) => {
  validatePath(path);
  for (let i2 = 0; i2 < path.length; i2++) {
    const key = path[i2];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++i2] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
const setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i2 = 0; i2 < path.length - 1; i2++) {
    const key = path[i2];
    if (isArray$1(parent)) {
      const index2 = +key;
      parent = parent[index2];
    } else if (isPlainObject$1(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i2 === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i2] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray$1(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject$1(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray$1(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v2) => untransformValue(v2, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray$1(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
const isDeep = (object, superJson) => isPlainObject$1(object) || isArray$1(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a3, b2) => a3.length - b2.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = (transformationResult == null ? void 0 : transformationResult.value) ?? object;
  const transformedValue = isArray$1(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value, index2) => {
    if (index2 === "__proto__" || index2 === "constructor" || index2 === "prototype") {
      throw new Error(`Detected property ${index2}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index2], [...objectsInThisPath, object], seenObjects);
    transformedValue[index2] = recursiveResult.transformedValue;
    if (isArray$1(recursiveResult.annotations)) {
      innerAnnotations[index2] = recursiveResult.annotations;
    } else if (isPlainObject$1(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index2) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};
function getType(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray(payload) {
  return getType(payload) === "Array";
}
function isPlainObject(payload) {
  if (getType(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
class SuperJSON {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s2) => s2.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta == null ? void 0 : meta.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta == null ? void 0 : meta.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string) {
    return this.deserialize(JSON.parse(string));
  }
  registerClass(v2, options) {
    this.classRegistry.register(v2, options);
  }
  registerSymbol(v2, identifier) {
    this.symbolRegistry.register(v2, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
}
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
SuperJSON.serialize;
SuperJSON.deserialize;
SuperJSON.stringify;
SuperJSON.parse;
SuperJSON.registerClass;
SuperJSON.registerCustom;
SuperJSON.registerSymbol;
SuperJSON.allowErrorProps;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, void 0)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn2) => (input) => {
  try {
    const result = fn2(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            const migration = options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
            if (migration instanceof Promise) {
              return migration.then((result) => [true, result]);
            }
            return [true, migration];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a2;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persist = persistImpl;
const createAppStore = (s2) => {
  const set = s2;
  return {
    appBlockRequestList: [],
    appUnblockRequestList: [],
    lastBlockRequestNumber: 0,
    lastUnblockRequestNumber: 0,
    isMainAppBlocked: false,
    requestMainAppBlock: () => {
      let newHandleValue = 0;
      set((state) => {
        newHandleValue = state.lastBlockRequestNumber + 1;
        return {
          appBlockRequestList: [...state.appBlockRequestList, newHandleValue],
          lastBlockRequestNumber: newHandleValue,
          isMainAppBlocked: state.appUnblockRequestList.length === 0
          // Unblock requests override block requests
        };
      });
      return newHandleValue;
    },
    requestMainAppUnblock: () => {
      let newHandleValue = 0;
      set((state) => {
        newHandleValue = state.lastUnblockRequestNumber + 1;
        return {
          appUnblockRequestList: [
            ...state.appUnblockRequestList,
            newHandleValue
          ],
          lastUnblockRequestNumber: newHandleValue,
          isMainAppBlocked: false
        };
      });
      return newHandleValue;
    },
    discardMainAppBlock: (handle) => {
      set((state) => {
        const newBlockRequestList = state.appBlockRequestList.filter(
          (h2) => h2 !== handle
        );
        return {
          appBlockRequestList: newBlockRequestList,
          isMainAppBlocked: newBlockRequestList.length > 0 && state.appUnblockRequestList.length === 0
        };
      });
    },
    discardMainAppUnblock: (handle) => {
      set((state) => {
        const newUnblockRequestList = state.appUnblockRequestList.filter(
          (h2) => h2 !== handle
        );
        return {
          appUnblockRequestList: newUnblockRequestList,
          isMainAppBlocked: state.appBlockRequestList.length > 0 && newUnblockRequestList.length === 0
        };
      });
    },
    toolbarPosition: DropAreaZone.BOTTOM_CENTER,
    setToolbarPosition: (position) => set(() => ({ toolbarPosition: position })),
    toolbarBoxRef: b$5(),
    setToolbarBoxRef: (ref) => set(() => ({ toolbarBoxRef: ref })),
    unsetToolbarBoxRef: () => set(() => ({ toolbarBoxRef: b$5() })),
    minimized: false,
    minimize: () => set(() => ({ minimized: true })),
    expand: () => set(() => ({ minimized: false })),
    promotedOnStartup: false,
    promotionFinished: () => set(() => ({ promotedOnStartup: true }))
  };
};
function createSuperJSONStorage(storage) {
  return {
    getItem: (name) => {
      const str = storage.getItem(name);
      if (!str) return null;
      return SuperJSON.parse(str);
    },
    setItem: (name, value) => {
      storage.setItem(name, SuperJSON.stringify(value));
    },
    removeItem: (name) => storage.removeItem(name)
  };
}
create(
  persist(createAppStore, {
    name: "stgws:companion",
    storage: createSuperJSONStorage(sessionStorage),
    partialize: (state) => {
      return {
        toolbarPosition: state.toolbarPosition
      };
    }
  })
);
const ChatContext = K$3({
  chats: [],
  currentChatId: null,
  createChat: () => "",
  deleteChat: () => {
  },
  setCurrentChat: () => {
  },
  setChatInput: () => {
  },
  addChatDomContext: () => {
  },
  removeChatDomContext: () => {
  },
  addMessage: () => {
  },
  chatAreaState: "hidden",
  setChatAreaState: () => {
  },
  isPromptCreationActive: false,
  startPromptCreation: () => {
  },
  stopPromptCreation: () => {
  }
});
function useChatState() {
  const context = x$4(ChatContext);
  if (!context) {
    throw new Error("useChatState must be used within a ChatStateProvider");
  }
  return context;
}
K$3(new URL(window.location.href));
function r$3(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o3 = e2.length;
    for (t2 = 0; t2 < o3; t2++) e2[t2] && (f2 = r$3(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o3 = arguments.length; f2 < o3; f2++) (e2 = arguments[f2]) && (t2 = r$3(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  var _a;
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return (_a = classPartObject.validators.find(({
    validator
  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
  }
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const MODIFIER_SEPARATOR = ":";
const MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
const createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className) => experimentalParseClassName({
      className,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
const stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
const createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
const arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
const fractionRegex = /^\d+\/\d+$/;
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isFraction = (value) => fractionRegex.test(value);
const isNumber = (value) => !!value && !Number.isNaN(Number(value));
const isInteger = (value) => !!value && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const isAny = () => true;
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
const isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
const isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
const isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow);
const isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
const isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
const isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
const isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
const isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
const isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
const isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
const getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
const isLabelPosition = (label) => label === "position" || label === "percentage";
const isLabelImage = (label) => label === "image" || label === "url";
const isLabelSize = (label) => label === "length" || label === "size" || label === "bg-size";
const isLabelLength = (label) => label === "length";
const isLabelNumber = (label) => label === "number";
const isLabelFamilyName = (label) => label === "family-name";
const isLabelShadow = (label) => label === "shadow";
const getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeTextShadow = fromTheme("text-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ];
  const scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleBgRepeat = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }];
  const scaleBgSize = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleRotate = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: scalePositionWithArbitrary()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: scaleBgPosition()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: scaleBgRepeat()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: scaleBgSize()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: scaleColor()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": scaleMaskImagePosition()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": scaleMaskImagePosition()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": scaleColor()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": scaleColor()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": scaleMaskImagePosition()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": scaleMaskImagePosition()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": scaleColor()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": scaleColor()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": scaleMaskImagePosition()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": scaleMaskImagePosition()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": scaleColor()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": scaleColor()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": scaleMaskImagePosition()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": scaleMaskImagePosition()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": scaleColor()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": scaleColor()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": scaleMaskImagePosition()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": scaleMaskImagePosition()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": scaleColor()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": scaleColor()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": scaleMaskImagePosition()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": scaleMaskImagePosition()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": scaleColor()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": scaleColor()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": scaleMaskImagePosition()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": scaleMaskImagePosition()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": scaleColor()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": scaleColor()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": scaleMaskImagePosition()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": scaleMaskImagePosition()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": scaleColor()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": scaleColor()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": scalePosition()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": scaleMaskImagePosition()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": scaleMaskImagePosition()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": scaleColor()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": scaleColor()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: scaleBgPosition()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: scaleBgRepeat()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: scaleBgSize()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": scaleColor()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scalePositionWithArbitrary()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scalePositionWithArbitrary()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
};
const mergeConfigs = (baseConfig, {
  cacheSize,
  prefix,
  experimentalParseClassName,
  extend: extend2 = {},
  override = {}
}) => {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
  overrideConfigProperties(baseConfig.theme, override.theme);
  overrideConfigProperties(baseConfig.classGroups, override.classGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
  overrideProperty(baseConfig, "orderSensitiveModifiers", override.orderSensitiveModifiers);
  mergeConfigProperties(baseConfig.theme, extend2.theme);
  mergeConfigProperties(baseConfig.classGroups, extend2.classGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroups, extend2.conflictingClassGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend2.conflictingClassGroupModifiers);
  mergeArrayProperties(baseConfig, extend2, "orderSensitiveModifiers");
  return baseConfig;
};
const overrideProperty = (baseObject, overrideKey, overrideValue) => {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
};
const overrideConfigProperties = (baseObject, overrideObject) => {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
};
const mergeConfigProperties = (baseObject, mergeObject) => {
  if (mergeObject) {
    for (const key in mergeObject) {
      mergeArrayProperties(baseObject, mergeObject, key);
    }
  }
};
const mergeArrayProperties = (baseObject, mergeObject, key) => {
  const mergeValue = mergeObject[key];
  if (mergeValue !== void 0) {
    baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
  }
};
const extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);
const customTwMerge = extendTailwindMerge({
  extend: {
    classGroups: {
      "bg-image": [
        "bg-gradient",
        "bg-gradient-light-1",
        "bg-gradient-light-2",
        "bg-gradient-light-3"
      ]
    }
  }
});
function cn(...inputs) {
  return customTwMerge(clsx(inputs));
}
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? Rn.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn2) {
  const ref = A$3(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    ref.current = fn2;
  }, [
    fn2
  ]);
  return q$3((...args) => {
    const f2 = ref.current;
    return f2 === null || f2 === void 0 ? void 0 : f2(...args);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el) return el;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc.defaultView || window;
};
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
  return otherNode && node ? node.contains(otherNode) : false;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  return doc.activeElement;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  return event.target;
}
function $c87311424ea30a05$var$testUserAgent(re) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn2) {
  let res = null;
  return () => {
    if (res == null) res = fn2();
    return res;
  };
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
const $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = A$3(/* @__PURE__ */ new Map());
  let addGlobalListener = q$3((eventTarget, type, listener, options) => {
    let fn2 = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn: fn2,
      options
    });
    eventTarget.addEventListener(type, fn2, options);
  }, []);
  let removeGlobalListener = q$3((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn2 = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn2, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = q$3(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  y$6(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  event.nativeEvent = nativeEvent;
  event.isDefaultPrevented = () => event.defaultPrevented;
  event.isPropagationStopped = () => event.cancelBubble;
  event.persist = () => {
  };
  return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  });
  Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = A$3({
    isFocused: false,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
  });
  return q$3((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e2.target;
      let onBlurHandler = (e3) => {
        stateRef.current.isFocused = false;
        if (target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);
          dispatchBlur(event);
        }
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
let $507fabe10e71c6fb$var$currentModality = null;
let $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e2)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  if ($6a7db85432448f7f$export$60278871457622de(e2)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  if (e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 === null || e2 === void 0 ? void 0 : e2.target);
  const IHTMLInputElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn2, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  y$6(() => {
    let handler = (modality, e2) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e2)) return;
      fn2($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = q$3((e2) => {
    if (e2.target === e2.currentTarget) {
      if (onBlurProp) onBlurProp(e2);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  const onFocus = q$3((e2) => {
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    if (e2.target === e2.currentTarget && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusProp) onFocusProp(e2);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e2);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = A$3({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let onBlur = q$3((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    if (state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin) onBlurWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  let onFocus = q$3((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);
    if (!state.current.isFocusWithin && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusWithin) onFocusWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let nativeEvent = new ownerDocument.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          });
          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled) return {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  if (e2.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = d$4(false);
  let state = A$3({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  y$6($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let { hoverProps, triggerHoverEnd } = T$5(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        if (state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target) return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e2) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse") return;
        triggerHoverStart(e2, e2.pointerType);
      };
      hoverProps2.onPointerLeave = (e2) => {
        if (!isDisabled && e2.currentTarget.contains(e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  y$6(() => {
    if (isDisabled) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = A$3({
    isFocused: false,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  });
  let [isFocused, setFocused] = d$4(false);
  let [isFocusVisibleState, setFocusVisible] = d$4(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = q$3(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = q$3((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var i$6 = Object.defineProperty;
var d$3 = (t2, e2, n2) => e2 in t2 ? i$6(t2, e2, { enumerable: true, configurable: true, writable: true, value: n2 }) : t2[e2] = n2;
var r$2 = (t2, e2, n2) => (d$3(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$7 = class o {
  constructor() {
    r$2(this, "current", this.detect());
    r$2(this, "handoffState", "pending");
    r$2(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
let s$7 = new o$7();
function o$6(n2) {
  var e2, r2;
  return s$7.isServer ? null : n2 ? "ownerDocument" in n2 ? n2.ownerDocument : "current" in n2 ? (r2 = (e2 = n2.current) == null ? void 0 : e2.ownerDocument) != null ? r2 : document : null : document;
}
function t$3(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$5() {
  let n2 = [], r2 = { addEventListener(e2, t2, s2, a3) {
    return e2.addEventListener(t2, s2, a3), r2.add(() => e2.removeEventListener(t2, s2, a3));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: true };
    return t$3(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = false;
    });
  }, style(e2, t2, s2) {
    let a3 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: a3 });
    });
  }, group(e2) {
    let t2 = o$5();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return n2.includes(e2) || n2.push(e2), () => {
      let t2 = n2.indexOf(e2);
      if (t2 >= 0) for (let s2 of n2.splice(t2, 1)) s2();
    };
  }, dispose() {
    for (let e2 of n2.splice(0)) e2();
  } };
  return r2;
}
function p$2() {
  let [e2] = d$4(o$5);
  return y$6(() => () => e2.dispose(), [e2]), e2;
}
let n$3 = (e2, t2) => {
  s$7.isServer ? y$6(e2, t2) : _$3(e2, t2);
};
function s$6(e2) {
  let r2 = A$3(e2);
  return n$3(() => {
    r2.current = e2;
  }, [e2]), r2;
}
let o$4 = function(t2) {
  let e2 = s$6(t2);
  return Rn.useCallback((...r2) => e2.current(...r2), [e2]);
};
function E$1(e2) {
  let t2 = e2.width / 2, n2 = e2.height / 2;
  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };
}
function P$3(e2, t2) {
  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);
}
function w$2({ disabled: e2 = false } = {}) {
  let t2 = A$3(null), [n2, l2] = d$4(false), r2 = p$2(), o3 = o$4(() => {
    t2.current = null, l2(false), r2.dispose();
  }), f2 = o$4((s2) => {
    if (r2.dispose(), t2.current === null) {
      t2.current = s2.currentTarget, l2(true);
      {
        let i2 = o$6(s2.currentTarget);
        r2.addEventListener(i2, "pointerup", o3, false), r2.addEventListener(i2, "pointermove", (c2) => {
          if (t2.current) {
            let p2 = E$1(c2);
            l2(P$3(p2, t2.current.getBoundingClientRect()));
          }
        }, false), r2.addEventListener(i2, "pointercancel", o3, false);
      }
    }
  });
  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f2, onPointerUp: o3, onClick: o3 } };
}
let e$3 = K$3(void 0);
function a$9() {
  return x$4(e$3);
}
function t$2(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(r2, n2, ...a3) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a3) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$7), t2;
}
var O$1 = ((a3) => (a3[a3.None = 0] = "None", a3[a3.RenderStrategy = 1] = "RenderStrategy", a3[a3.Static = 2] = "Static", a3))(O$1 || {}), A$1 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(A$1 || {});
function L$2() {
  let n2 = U$2();
  return q$3((r2) => C$2({ mergeRefs: n2, ...r2 }), [n2]);
}
function C$2({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a3, features: s2, visible: t2 = true, name: l2, mergeRefs: i2 }) {
  i2 = i2 != null ? i2 : $;
  let o3 = P$2(r2, n2);
  if (t2) return F$3(o3, e2, a3, l2, i2);
  let y2 = s2 != null ? s2 : 0;
  if (y2 & 2) {
    let { static: f2 = false, ...u2 } = o3;
    if (f2) return F$3(u2, e2, a3, l2, i2);
  }
  if (y2 & 1) {
    let { unmount: f2 = true, ...u2 } = o3;
    return u$7(f2 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return F$3({ ...u2, hidden: true, style: { display: "none" } }, e2, a3, l2, i2);
    } });
  }
  return F$3(o3, e2, a3, l2, i2);
}
function F$3(n2, r2 = {}, e2, a3, s2) {
  let { as: t2 = e2, children: l2, refName: i2 = "ref", ...o3 } = h$4(n2, ["unmount", "static"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f2 = typeof l2 == "function" ? l2(r2) : l2;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(r2)), o3["aria-labelledby"] && o3["aria-labelledby"] === o3.id && (o3["aria-labelledby"] = void 0);
  let u2 = {};
  if (r2) {
    let d2 = false, p2 = [];
    for (let [c2, T2] of Object.entries(r2)) typeof T2 == "boolean" && (d2 = true), T2 === true && p2.push(c2.replace(/([A-Z])/g, (g2) => `-${g2.toLowerCase()}`));
    if (d2) {
      u2["data-headlessui-state"] = p2.join(" ");
      for (let c2 of p2) u2[`data-${c2}`] = "";
    }
  }
  if (t2 === k$3 && (Object.keys(m$4(o3)).length > 0 || Object.keys(m$4(u2)).length > 0)) if (!mn(f2) || Array.isArray(f2) && f2.length > 1) {
    if (Object.keys(m$4(o3)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a3} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(o3)).concat(Object.keys(m$4(u2))).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
  } else {
    let d2 = f2.props, p2 = d2 == null ? void 0 : d2.className, c2 = typeof p2 == "function" ? (...R2) => t$2(p2(...R2), o3.className) : t$2(p2, o3.className), T2 = c2 ? { className: c2 } : {}, g2 = P$2(f2.props, m$4(h$4(o3, ["ref"])));
    for (let R2 in u2) R2 in g2 && delete u2[R2];
    return _n(f2, Object.assign({}, g2, u2, y2, { ref: s2(H$4(f2), y2.ref) }, T2));
  }
  return _$4(t2, Object.assign({}, h$4(o3, ["ref"]), t2 !== k$3 && y2, t2 !== k$3 && u2), f2);
}
function U$2() {
  let n2 = A$3([]), r2 = q$3((e2) => {
    for (let a3 of n2.current) a3 != null && (typeof a3 == "function" ? a3(e2) : a3.current = e2);
  }, []);
  return (...e2) => {
    if (!e2.every((a3) => a3 == null)) return n2.current = e2, r2;
  };
}
function $(...n2) {
  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {
    for (let e2 of n2) e2 != null && (typeof e2 == "function" ? e2(r2) : e2.current = r2);
  };
}
function P$2(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  if (r2.disabled || r2["aria-disabled"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {
    var l2;
    return (l2 = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l2.call(t2);
  }]);
  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l2) {
    let i2 = e2[s2];
    for (let o3 of i2) {
      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;
      o3(t2, ...l2);
    }
  } });
  return r2;
}
function _$2(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {
    let l2 = e2[s2];
    for (let i2 of l2) i2 == null || i2(...t2);
  } });
  return r2;
}
function K$1(n2) {
  var r2;
  return Object.assign(D$1(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });
}
function m$4(n2) {
  let r2 = Object.assign({}, n2);
  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];
  return r2;
}
function h$4(n2, r2 = []) {
  let e2 = Object.assign({}, n2);
  for (let a3 of r2) a3 in e2 && delete e2[a3];
  return e2;
}
function H$4(n2) {
  return Rn.version.split(".")[0] >= "19" ? n2.props.ref : n2.ref;
}
let R$2 = "button";
function v$1(a3, u2) {
  var p2;
  let l2 = a$9(), { disabled: e2 = l2 || false, autoFocus: t2 = false, ...o3 } = a3, { isFocusVisible: r2, focusProps: i2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t2 }), { isHovered: s2, hoverProps: T2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), { pressed: n2, pressProps: d2 } = w$2({ disabled: e2 }), f2 = _$2({ ref: u2, type: (p2 = o3.type) != null ? p2 : "button", disabled: e2 || void 0, autoFocus: t2 }, i2, T2, d2), m2 = T$5(() => ({ disabled: e2, hover: s2, focus: r2, active: n2, autofocus: t2 }), [e2, s2, r2, n2, t2]);
  return L$2()({ ourProps: f2, theirProps: o3, slot: m2, defaultTag: R$2, name: "Button" });
}
let H$3 = K$1(v$1);
let e$2 = K$3(void 0);
function u$6() {
  return x$4(e$2);
}
function r$1(n2) {
  let e2 = n2.parentElement, l2 = null;
  for (; e2 && !(e2 instanceof HTMLFieldSetElement); ) e2 instanceof HTMLLegendElement && (l2 = e2), e2 = e2.parentElement;
  let t2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return t2 && i$5(l2) ? false : t2;
}
function i$5(n2) {
  if (!n2) return false;
  let e2 = n2.previousElementSibling;
  for (; e2 !== null; ) {
    if (e2 instanceof HTMLLegendElement) return false;
    e2 = e2.previousElementSibling;
  }
  return true;
}
let u$5 = Symbol();
function T$3(t2, n2 = true) {
  return Object.assign(t2, { [u$5]: n2 });
}
function y$5(...t2) {
  let n2 = A$3(t2);
  y$6(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$4((e2) => {
    for (let o3 of n2.current) o3 != null && (typeof o3 == "function" ? o3(e2) : o3.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$5])) ? void 0 : c2;
}
let a$8 = K$3(null);
a$8.displayName = "DescriptionContext";
function f$6() {
  let r2 = x$4(a$8);
  if (r2 === null) {
    let e2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e2, f$6), e2;
  }
  return r2;
}
function U$1() {
  var r2, e2;
  return (e2 = (r2 = x$4(a$8)) == null ? void 0 : r2.value) != null ? e2 : void 0;
}
function w$1() {
  let [r2, e2] = d$4([]);
  return [r2.length > 0 ? r2.join(" ") : void 0, T$5(() => function(t2) {
    let i2 = o$4((n2) => (e2((s2) => [...s2, n2]), () => e2((s2) => {
      let o3 = s2.slice(), p2 = o3.indexOf(n2);
      return p2 !== -1 && o3.splice(p2, 1), o3;
    }))), l2 = T$5(() => ({ register: i2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [i2, t2.slot, t2.name, t2.props, t2.value]);
    return Rn.createElement(a$8.Provider, { value: l2 }, t2.children);
  }, [e2])];
}
let S$4 = "p";
function C$1(r2, e2) {
  let d2 = g$3(), t2 = a$9(), { id: i2 = `headlessui-description-${d2}`, ...l2 } = r2, n2 = f$6(), s2 = y$5(e2);
  n$3(() => n2.register(i2), [i2, n2.register]);
  let o3 = t2 || false, p2 = T$5(() => ({ ...n2.slot, disabled: o3 }), [n2.slot, o3]), D2 = { ref: s2, ...n2.props, id: i2 };
  return L$2()({ ourProps: D2, theirProps: l2, slot: p2, defaultTag: S$4, name: n2.name || "Description" });
}
let _$1 = K$1(C$1);
Object.assign(_$1, {});
var o$3 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$3 || {});
let c$5 = K$3(null);
c$5.displayName = "LabelContext";
function P$1() {
  let r2 = x$4(c$5);
  if (r2 === null) {
    let l2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l2, P$1), l2;
  }
  return r2;
}
function I$2(r2) {
  var a3, e2, o3;
  let l2 = (e2 = (a3 = x$4(c$5)) == null ? void 0 : a3.value) != null ? e2 : void 0;
  return ((o3 = void 0) != null ? o3 : 0) > 0 ? [l2, ...r2].filter(Boolean).join(" ") : l2;
}
function K({ inherit: r2 = false } = {}) {
  let l2 = I$2(), [a3, e2] = d$4([]), o3 = r2 ? [l2, ...a3].filter(Boolean) : a3;
  return [o3.length > 0 ? o3.join(" ") : void 0, T$5(() => function(t2) {
    let s2 = o$4((i2) => (e2((p2) => [...p2, i2]), () => e2((p2) => {
      let u2 = p2.slice(), d2 = u2.indexOf(i2);
      return d2 !== -1 && u2.splice(d2, 1), u2;
    }))), m2 = T$5(() => ({ register: s2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [s2, t2.slot, t2.name, t2.props, t2.value]);
    return Rn.createElement(c$5.Provider, { value: m2 }, t2.children);
  }, [e2])];
}
let N = "label";
function G$1(r2, l2) {
  var y2;
  let a3 = g$3(), e2 = P$1(), o3 = u$6(), g2 = a$9(), { id: t2 = `headlessui-label-${a3}`, htmlFor: s2 = o3 != null ? o3 : (y2 = e2.props) == null ? void 0 : y2.htmlFor, passive: m2 = false, ...i2 } = r2, p2 = y$5(l2);
  n$3(() => e2.register(t2), [t2, e2.register]);
  let u2 = o$4((L2) => {
    let b2 = L2.currentTarget;
    if (b2 instanceof HTMLLabelElement && L2.preventDefault(), e2.props && "onClick" in e2.props && typeof e2.props.onClick == "function" && e2.props.onClick(L2), b2 instanceof HTMLLabelElement) {
      let n2 = document.getElementById(b2.htmlFor);
      if (n2) {
        let E2 = n2.getAttribute("disabled");
        if (E2 === "true" || E2 === "") return;
        let x2 = n2.getAttribute("aria-disabled");
        if (x2 === "true" || x2 === "") return;
        (n2 instanceof HTMLInputElement && (n2.type === "radio" || n2.type === "checkbox") || n2.role === "radio" || n2.role === "checkbox" || n2.role === "switch") && n2.click(), n2.focus({ preventScroll: true });
      }
    }
  }), d2 = g2 || false, C2 = T$5(() => ({ ...e2.slot, disabled: d2 }), [e2.slot, d2]), f2 = { ref: p2, ...e2.props, id: t2, htmlFor: s2, onClick: u2 };
  return m2 && ("onClick" in f2 && (delete f2.htmlFor, delete f2.onClick), "onClick" in i2 && delete i2.onClick), L$2()({ ourProps: f2, theirProps: i2, slot: C2, defaultTag: s2 ? N : "div", name: e2.name || "Label" });
}
let U = K$1(G$1);
Object.assign(U, {});
function f$5(e2) {
  if (e2 === null) return { width: 0, height: 0 };
  let { width: t2, height: r2 } = e2.getBoundingClientRect();
  return { width: t2, height: r2 };
}
function d$2(e2, t2 = false) {
  let [r2, u2] = h$5(() => ({}), {}), i2 = T$5(() => f$5(e2), [e2, r2]);
  return n$3(() => {
    if (!e2) return;
    let n2 = new ResizeObserver(u2);
    return n2.observe(e2), () => {
      n2.disconnect();
    };
  }, [e2]), t2 ? { width: `${i2.width}px`, height: `${i2.height}px` } : i2;
}
let a$7 = class a extends Map {
  constructor(t2) {
    super();
    this.factory = t2;
  }
  get(t2) {
    let e2 = super.get(t2);
    return e2 === void 0 && (e2 = this.factory(t2), this.set(t2, e2)), e2;
  }
};
function a$6(o3, r2) {
  let t2 = o3(), n2 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t2;
  }, subscribe(e2) {
    return n2.add(e2), () => n2.delete(e2);
  }, dispatch(e2, ...s2) {
    let i2 = r2[e2].call(t2, ...s2);
    i2 && (t2 = i2, n2.forEach((c2) => c2()));
  } };
}
function o$2(t2) {
  return C$3(t2.subscribe, t2.getSnapshot, t2.getSnapshot);
}
let p$1 = new a$7(() => a$6(() => [], { ADD(r2) {
  return this.includes(r2) ? this : [...this, r2];
}, REMOVE(r2) {
  let e2 = this.indexOf(r2);
  if (e2 === -1) return this;
  let t2 = this.slice();
  return t2.splice(e2, 1), t2;
} }));
function x$2(r2, e2) {
  let t2 = p$1.get(e2), i2 = g$3(), h2 = o$2(t2);
  if (n$3(() => {
    if (r2) return t2.dispatch("ADD", i2), () => t2.dispatch("REMOVE", i2);
  }, [t2, r2]), !r2) return false;
  let s2 = h2.indexOf(i2), o3 = h2.length;
  return s2 === -1 && (s2 = o3, o3 += 1), s2 === o3 - 1;
}
let f$4 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(t2) {
  var e2;
  let r2 = (e2 = u$4.get(t2)) != null ? e2 : 0;
  return u$4.set(t2, r2 + 1), r2 !== 0 ? () => m$3(t2) : (f$4.set(t2, { "aria-hidden": t2.getAttribute("aria-hidden"), inert: t2.inert }), t2.setAttribute("aria-hidden", "true"), t2.inert = true, () => m$3(t2));
}
function m$3(t2) {
  var i2;
  let r2 = (i2 = u$4.get(t2)) != null ? i2 : 1;
  if (r2 === 1 ? u$4.delete(t2) : u$4.set(t2, r2 - 1), r2 !== 1) return;
  let e2 = f$4.get(t2);
  e2 && (e2["aria-hidden"] === null ? t2.removeAttribute("aria-hidden") : t2.setAttribute("aria-hidden", e2["aria-hidden"]), t2.inert = e2.inert, f$4.delete(t2));
}
function y$4(t2, { allowed: r2, disallowed: e2 } = {}) {
  let i2 = x$2(t2, "inert-others");
  n$3(() => {
    var d2, c2;
    if (!i2) return;
    let a3 = o$5();
    for (let n2 of (d2 = e2 == null ? void 0 : e2()) != null ? d2 : []) n2 && a3.add(h$3(n2));
    let s2 = (c2 = r2 == null ? void 0 : r2()) != null ? c2 : [];
    for (let n2 of s2) {
      if (!n2) continue;
      let l2 = o$6(n2);
      if (!l2) continue;
      let o3 = n2.parentElement;
      for (; o3 && o3 !== l2.body; ) {
        for (let p2 of o3.children) s2.some((E2) => p2.contains(E2)) || a3.add(h$3(p2));
        o3 = o3.parentElement;
      }
    }
    return a3.dispose;
  }, [i2, r2, e2]);
}
function m$2(s2, n2, l2) {
  let i2 = s$6((t2) => {
    let e2 = t2.getBoundingClientRect();
    e2.x === 0 && e2.y === 0 && e2.width === 0 && e2.height === 0 && l2();
  });
  y$6(() => {
    if (!s2) return;
    let t2 = n2 === null ? null : n2 instanceof HTMLElement ? n2 : n2.current;
    if (!t2) return;
    let e2 = o$5();
    if (typeof ResizeObserver != "undefined") {
      let r2 = new ResizeObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    if (typeof IntersectionObserver != "undefined") {
      let r2 = new IntersectionObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    return () => e2.dispose();
  }, [n2, i2, s2]);
}
let f$3 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var F$2 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2[n2.AutoFocus = 64] = "AutoFocus", n2))(F$2 || {}), T$2 = ((o3) => (o3[o3.Error = 0] = "Error", o3[o3.Overflow = 1] = "Overflow", o3[o3.Success = 2] = "Success", o3[o3.Underflow = 3] = "Underflow", o3))(T$2 || {}), y$3 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(y$3 || {});
function b$3(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(f$3)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$3(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(p)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(h$2 || {});
function A(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = o$6(e2)) == null ? void 0 : t2.body) ? false : u$7(r2, { [0]() {
    return e2.matches(f$3);
  }, [1]() {
    let u2 = e2;
    for (; u2 !== null; ) {
      if (u2.matches(f$3)) return true;
      u2 = u2.parentElement;
    }
    return false;
  } });
}
function G(e2) {
  let r2 = o$6(e2);
  o$5().nextFrame(() => {
    r2 && !A(r2.activeElement, 0) && I$1(e2);
  });
}
var H$2 = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(H$2 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e2) => {
  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e2) => {
  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function I$1(e2) {
  e2 == null || e2.focus({ preventScroll: true });
}
let w = ["textarea", "input"].join(",");
function O(e2) {
  var r2, t2;
  return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, w)) != null ? t2 : false;
}
function _(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, u2) => {
    let o3 = r2(t2), c2 = r2(u2);
    if (o3 === null || c2 === null) return 0;
    let l2 = o3.compareDocumentPosition(c2);
    return l2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$2(e2, r2) {
  return P(b$3(), r2, { relativeTo: e2 });
}
function P(e2, r2, { sorted: t2 = true, relativeTo: u2 = null, skipElements: o3 = [] } = {}) {
  let c2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2.ownerDocument, l2 = Array.isArray(e2) ? t2 ? _(e2) : e2 : r2 & 64 ? S$3(e2) : b$3(e2);
  o3.length > 0 && l2.length > 1 && (l2 = l2.filter((s2) => !o3.some((a3) => a3 != null && "current" in a3 ? (a3 == null ? void 0 : a3.current) === s2 : a3 === s2))), u2 = u2 != null ? u2 : c2.activeElement;
  let n2 = (() => {
    if (r2 & 5) return 1;
    if (r2 & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = (() => {
    if (r2 & 1) return 0;
    if (r2 & 2) return Math.max(0, l2.indexOf(u2)) - 1;
    if (r2 & 4) return Math.max(0, l2.indexOf(u2)) + 1;
    if (r2 & 8) return l2.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), M2 = r2 & 32 ? { preventScroll: true } : {}, m2 = 0, d2 = l2.length, i2;
  do {
    if (m2 >= d2 || m2 + d2 <= 0) return 0;
    let s2 = x2 + m2;
    if (r2 & 16) s2 = (s2 + d2) % d2;
    else {
      if (s2 < 0) return 3;
      if (s2 >= d2) return 1;
    }
    i2 = l2[s2], i2 == null || i2.focus(M2), m2 += n2;
  } while (i2 !== c2.activeElement);
  return r2 & 6 && O(i2) && i2.select(), 2;
}
function t$1() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$4() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$1() || i$4();
}
function i$3(t2, e2, o3, n2) {
  let u2 = s$6(o3);
  y$6(() => {
    if (!t2) return;
    function r2(m2) {
      u2.current(m2);
    }
    return document.addEventListener(e2, r2, n2), () => document.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
function s$5(t2, e2, o3, n2) {
  let i2 = s$6(o3);
  y$6(() => {
    if (!t2) return;
    function r2(d2) {
      i2.current(d2);
    }
    return window.addEventListener(e2, r2, n2), () => window.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
const E = 30;
function R$1(p2, f2, C2) {
  let u2 = x$2(p2, "outside-click"), m2 = s$6(C2), s2 = q$3(function(e2, n2) {
    if (e2.defaultPrevented) return;
    let r2 = n2(e2);
    if (r2 === null || !r2.getRootNode().contains(r2) || !r2.isConnected) return;
    let h2 = function l2(o3) {
      return typeof o3 == "function" ? l2(o3()) : Array.isArray(o3) || o3 instanceof Set ? o3 : [o3];
    }(f2);
    for (let l2 of h2) if (l2 !== null && (l2.contains(r2) || e2.composed && e2.composedPath().includes(l2))) return;
    return !A(r2, h$2.Loose) && r2.tabIndex !== -1 && e2.preventDefault(), m2.current(e2, r2);
  }, [m2, f2]), i2 = A$3(null);
  i$3(u2, "pointerdown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, true), i$3(u2, "mousedown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, true), i$3(u2, "click", (t2) => {
    n$2() || i2.current && (s2(t2, () => i2.current), i2.current = null);
  }, true);
  let a3 = A$3({ x: 0, y: 0 });
  i$3(u2, "touchstart", (t2) => {
    a3.current.x = t2.touches[0].clientX, a3.current.y = t2.touches[0].clientY;
  }, true), i$3(u2, "touchend", (t2) => {
    let e2 = { x: t2.changedTouches[0].clientX, y: t2.changedTouches[0].clientY };
    if (!(Math.abs(e2.x - a3.current.x) >= E || Math.abs(e2.y - a3.current.y) >= E)) return s2(t2, () => t2.target instanceof HTMLElement ? t2.target : null);
  }, true), s$5(u2, "blur", (t2) => s2(t2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
function n$1(...e2) {
  return T$5(() => o$6(...e2), [...e2]);
}
function e$1(t2, u2) {
  return T$5(() => {
    var n2;
    if (t2.type) return t2.type;
    let r2 = (n2 = t2.as) != null ? n2 : "button";
    if (typeof r2 == "string" && r2.toLowerCase() === "button" || (u2 == null ? void 0 : u2.tagName) === "BUTTON" && !u2.hasAttribute("type")) return "button";
  }, [t2.type, t2.as, u2]);
}
function d$1() {
  let r2;
  return { before({ doc: e2 }) {
    var l2;
    let o3 = e2.documentElement, t2 = (l2 = e2.defaultView) != null ? l2 : window;
    r2 = Math.max(0, t2.innerWidth - o3.clientWidth);
  }, after({ doc: e2, d: o3 }) {
    let t2 = e2.documentElement, l2 = Math.max(0, t2.clientWidth - t2.offsetWidth), n2 = Math.max(0, r2 - l2);
    o3.style(t2, "paddingRight", `${n2}px`);
  } };
}
function d() {
  return t$1() ? { before({ doc: r2, d: n2, meta: c2 }) {
    function o3(a3) {
      return c2.containers.flatMap((l2) => l2()).some((l2) => l2.contains(a3));
    }
    n2.microTask(() => {
      var s2;
      if (window.getComputedStyle(r2.documentElement).scrollBehavior !== "auto") {
        let t2 = o$5();
        t2.style(r2.documentElement, "scrollBehavior", "auto"), n2.add(() => n2.microTask(() => t2.dispose()));
      }
      let a3 = (s2 = window.scrollY) != null ? s2 : window.pageYOffset, l2 = null;
      n2.addEventListener(r2, "click", (t2) => {
        if (t2.target instanceof HTMLElement) try {
          let e2 = t2.target.closest("a");
          if (!e2) return;
          let { hash: f2 } = new URL(e2.href), i2 = r2.querySelector(f2);
          i2 && !o3(i2) && (l2 = i2);
        } catch {
        }
      }, true), n2.addEventListener(r2, "touchstart", (t2) => {
        if (t2.target instanceof HTMLElement) if (o3(t2.target)) {
          let e2 = t2.target;
          for (; e2.parentElement && o3(e2.parentElement); ) e2 = e2.parentElement;
          n2.style(e2, "overscrollBehavior", "contain");
        } else n2.style(t2.target, "touchAction", "none");
      }), n2.addEventListener(r2, "touchmove", (t2) => {
        if (t2.target instanceof HTMLElement) {
          if (t2.target.tagName === "INPUT") return;
          if (o3(t2.target)) {
            let e2 = t2.target;
            for (; e2.parentElement && e2.dataset.headlessuiPortal !== "" && !(e2.scrollHeight > e2.clientHeight || e2.scrollWidth > e2.clientWidth); ) e2 = e2.parentElement;
            e2.dataset.headlessuiPortal === "" && t2.preventDefault();
          } else t2.preventDefault();
        }
      }, { passive: false }), n2.add(() => {
        var e2;
        let t2 = (e2 = window.scrollY) != null ? e2 : window.pageYOffset;
        a3 !== t2 && window.scrollTo(0, a3), l2 && l2.isConnected && (l2.scrollIntoView({ block: "nearest" }), l2 = null);
      });
    });
  } } : {};
}
function r() {
  return { before({ doc: e2, d: o3 }) {
    o3.style(e2.documentElement, "overflow", "hidden");
  } };
}
function m$1(e2) {
  let n2 = {};
  for (let t2 of e2) Object.assign(n2, t2(n2));
  return n2;
}
let a$5 = a$6(() => /* @__PURE__ */ new Map(), { PUSH(e2, n2) {
  var o3;
  let t2 = (o3 = this.get(e2)) != null ? o3 : { doc: e2, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return t2.count++, t2.meta.add(n2), this.set(e2, t2), this;
}, POP(e2, n2) {
  let t2 = this.get(e2);
  return t2 && (t2.count--, t2.meta.delete(n2)), this;
}, SCROLL_PREVENT({ doc: e2, d: n2, meta: t2 }) {
  let o3 = { doc: e2, d: n2, meta: m$1(t2) }, c2 = [d(), d$1(), r()];
  c2.forEach(({ before: r2 }) => r2 == null ? void 0 : r2(o3)), c2.forEach(({ after: r2 }) => r2 == null ? void 0 : r2(o3));
}, SCROLL_ALLOW({ d: e2 }) {
  e2.dispose();
}, TEARDOWN({ doc: e2 }) {
  this.delete(e2);
} });
a$5.subscribe(() => {
  let e2 = a$5.getSnapshot(), n2 = /* @__PURE__ */ new Map();
  for (let [t2] of e2) n2.set(t2, t2.documentElement.style.overflow);
  for (let t2 of e2.values()) {
    let o3 = n2.get(t2.doc) === "hidden", c2 = t2.count !== 0;
    (c2 && !o3 || !c2 && o3) && a$5.dispatch(t2.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t2), t2.count === 0 && a$5.dispatch("TEARDOWN", t2);
  }
});
function a$4(r2, e2, n2 = () => ({ containers: [] })) {
  let f2 = o$2(a$5), o3 = e2 ? f2.get(e2) : void 0, i2 = o3 ? o3.count > 0 : false;
  return n$3(() => {
    if (!(!e2 || !r2)) return a$5.dispatch("PUSH", e2, n2), () => a$5.dispatch("POP", e2, n2);
  }, [r2, e2]), i2;
}
function f$2(e2, c2, n2 = () => [document.body]) {
  let r2 = x$2(e2, "scroll-lock");
  a$4(r2, c2, (t2) => {
    var o3;
    return { containers: [...(o3 = t2.containers) != null ? o3 : [], n2] };
  });
}
function t(e2) {
  return [e2.screenX, e2.screenY];
}
function u$3() {
  let e2 = A$3([-1, -1]);
  return { wasMoved(r2) {
    let n2 = t(r2);
    return e2.current[0] === n2[0] && e2.current[1] === n2[1] ? false : (e2.current = n2, true);
  }, update(r2) {
    e2.current = t(r2);
  } };
}
function c$4(u2 = 0) {
  let [t2, l2] = d$4(u2), g2 = q$3((e2) => l2(e2), [t2]), s2 = q$3((e2) => l2((a3) => a3 | e2), [t2]), m2 = q$3((e2) => (t2 & e2) === e2, [t2]), n2 = q$3((e2) => l2((a3) => a3 & ~e2), [l2]), F2 = q$3((e2) => l2((a3) => a3 ^ e2), [l2]);
  return { flags: t2, setFlag: g2, addFlag: s2, hasFlag: m2, removeFlag: n2, toggleFlag: F2 };
}
var T$1, b$2;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T$1 = process == null ? void 0 : define_process_env_default) == null ? void 0 : T$1["NODE_ENV"]) === "test" && typeof ((b$2 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$2.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L$1 = ((r2) => (r2[r2.None = 0] = "None", r2[r2.Closed = 1] = "Closed", r2[r2.Enter = 2] = "Enter", r2[r2.Leave = 4] = "Leave", r2))(L$1 || {});
function R(t2) {
  let n2 = {};
  for (let e2 in t2) t2[e2] === true && (n2[`data-${e2}`] = "");
  return n2;
}
function x$1(t2, n2, e2, i2) {
  let [r2, o3] = d$4(e2), { hasFlag: s2, addFlag: a3, removeFlag: l2 } = c$4(t2 && r2 ? 3 : 0), u2 = A$3(false), f2 = A$3(false), E2 = p$2();
  return n$3(() => {
    var d2;
    if (t2) {
      if (e2 && o3(true), !n2) {
        e2 && a3(3);
        return;
      }
      return (d2 = void 0) == null || d2.call(i2, e2), C(n2, { inFlight: u2, prepare() {
        f2.current ? f2.current = false : f2.current = u2.current, u2.current = true, !f2.current && (e2 ? (a3(3), l2(4)) : (a3(4), l2(2)));
      }, run() {
        f2.current ? e2 ? (l2(3), a3(4)) : (l2(4), a3(3)) : e2 ? l2(1) : a3(1);
      }, done() {
        var p2;
        f2.current && typeof n2.getAnimations == "function" && n2.getAnimations().length > 0 || (u2.current = false, l2(7), e2 || o3(false), (p2 = void 0) == null || p2.call(i2, e2));
      } });
    }
  }, [t2, e2, n2, E2]), t2 ? [r2, { closed: s2(1), enter: s2(2), leave: s2(4), transition: s2(2) || s2(4) }] : [e2, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(t2, { prepare: n2, run: e2, done: i2, inFlight: r2 }) {
  let o3 = o$5();
  return j$1(t2, { prepare: n2, inFlight: r2 }), o3.nextFrame(() => {
    e2(), o3.requestAnimationFrame(() => {
      o3.add(M$2(t2, i2));
    });
  }), o3.dispose;
}
function M$2(t2, n2) {
  var o3, s2;
  let e2 = o$5();
  if (!t2) return e2.dispose;
  let i2 = false;
  e2.add(() => {
    i2 = true;
  });
  let r2 = (s2 = (o3 = t2.getAnimations) == null ? void 0 : o3.call(t2).filter((a3) => a3 instanceof CSSTransition)) != null ? s2 : [];
  return r2.length === 0 ? (n2(), e2.dispose) : (Promise.allSettled(r2.map((a3) => a3.finished)).then(() => {
    i2 || n2();
  }), e2.dispose);
}
function j$1(t2, { inFlight: n2, prepare: e2 }) {
  if (n2 != null && n2.current) {
    e2();
    return;
  }
  let i2 = t2.style.transition;
  t2.style.transition = "none", e2(), t2.offsetHeight, t2.style.transition = i2;
}
function F$1(c2, { container: e2, accept: t2, walk: r2 }) {
  let o3 = A$3(t2), l2 = A$3(r2);
  y$6(() => {
    o3.current = t2, l2.current = r2;
  }, [t2, r2]), n$3(() => {
    if (!e2 || !c2) return;
    let n2 = o$6(e2);
    if (!n2) return;
    let f2 = o3.current, p2 = l2.current, i2 = Object.assign((m2) => f2(m2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, i2, false);
    for (; u2.nextNode(); ) p2(u2.currentNode);
  }, [e2, c2, o3, l2]);
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b2) {
  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const detectOverflow = detectOverflow$1;
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? _$3 : y$6;
function deepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (typeof a3 !== typeof b2) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a3 && b2 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a3[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = A$3(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = d$4({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = d$4(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = d$4(null);
  const [_floating, _setFloating] = d$4(null);
  const setReference = q$3((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = q$3((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = A$3(null);
  const floatingRef = A$3(null);
  const dataRef = A$3(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = q$3(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        En(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = A$3(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = T$5(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = T$5(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = T$5(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return T$5(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const SafeReact = {
  ...t$4
};
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn2) => fn2());
function useEffectEvent(callback) {
  const ref = A$3(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return q$3(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document !== "undefined" ? _$3 : y$6;
let serverHandoffComplete = false;
let count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = d$4(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  y$6(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ K$3(null);
const FloatingTreeContext = /* @__PURE__ */ K$3(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = x$4(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => x$4(FloatingTreeContext);
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = A$3({});
  const [events] = d$4(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = d$4(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = T$5(() => ({
    setPositionReference
  }), []);
  const elements = T$5(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return T$5(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = d$4(null);
  const [positionReference, _setPositionReference] = d$4(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = A$3(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = q$3((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = q$3((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = T$5(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = T$5(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = T$5(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return T$5(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn2) => fn2(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = q$3(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = q$3(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = q$3(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return T$5(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
const inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index2 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state);
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index2];
    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const clientTop = floating.clientTop || scrollEl.clientTop;
    const floatingIsBordered = floating.clientTop !== 0;
    const scrollElIsBordered = scrollEl.clientTop !== 0;
    const floatingIsScrollEl = floating === scrollEl;
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
    const refOverflow = await detectOverflow(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
    const rounder = isScrollable ? (v2) => v2 : round;
    const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    scrollEl.style.maxHeight = maxHeight + "px";
    scrollEl.scrollTop = diffY;
    if (onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      En(() => onFallbackChange(shouldFallback));
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = A$3(false);
  const prevScrollTopRef = A$3(null);
  const initialOverflowRef = A$3(null);
  y$6(() => {
    if (!enabled) return;
    function onWheel(e2) {
      if (e2.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e2.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e2.preventDefault();
        En(() => {
          onChange((d2) => d2 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = T$5(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          En(() => onChange((d2) => d2 + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return T$5(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}
let y$2 = K$3({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$2.displayName = "FloatingContext";
let H$1 = K$3(null);
H$1.displayName = "PlacementContext";
function xe(e2) {
  return T$5(() => e2 ? typeof e2 == "string" ? { to: e2 } : e2 : null, [e2]);
}
function ye() {
  return x$4(y$2).setReference;
}
function Fe() {
  return x$4(y$2).getReferenceProps;
}
function be() {
  let { getFloatingProps: e2, slot: t2 } = x$4(y$2);
  return q$3((...n2) => Object.assign({}, e2(...n2), { "data-anchor": t2.anchor }), [e2, t2]);
}
function Re(e2 = null) {
  e2 === false && (e2 = null), typeof e2 == "string" && (e2 = { to: e2 });
  let t2 = x$4(H$1), n2 = T$5(() => e2, [JSON.stringify(e2, (r2, o3) => {
    var u2;
    return (u2 = o3 == null ? void 0 : o3.outerHTML) != null ? u2 : o3;
  })]);
  n$3(() => {
    t2 == null || t2(n2 != null ? n2 : null);
  }, [t2, n2]);
  let l2 = x$4(y$2);
  return T$5(() => [l2.setFloating, e2 ? l2.styles : {}], [l2.setFloating, e2, l2.styles]);
}
let q$1 = 4;
function Me({ children: e2, enabled: t2 = true }) {
  let [n2, l2] = d$4(null), [r2, o3] = d$4(0), u2 = A$3(null), [f2, s2] = d$4(null);
  pe(f2);
  let i2 = t2 && n2 !== null && f2 !== null, { to: F2 = "bottom", gap: E2 = 0, offset: v2 = 0, padding: c2 = 0, inner: P2 } = ce(n2, f2), [a3, p2 = "center"] = F2.split(" ");
  n$3(() => {
    i2 && o3(0);
  }, [i2]);
  let { refs: b2, floatingStyles: w2, context: g2 } = useFloating({ open: i2, placement: a3 === "selection" ? p2 === "center" ? "bottom" : `bottom-${p2}` : p2 === "center" ? `${a3}` : `${a3}-${p2}`, strategy: "absolute", transform: false, middleware: [offset({ mainAxis: a3 === "selection" ? 0 : E2, crossAxis: v2 }), shift({ padding: c2 }), a3 !== "selection" && flip({ padding: c2 }), a3 === "selection" && P2 ? inner({ ...P2, padding: c2, overflowRef: u2, offset: r2, minItemsVisible: q$1, referenceOverflowThreshold: c2, onFallbackChange(h2) {
    var O2, W2;
    if (!h2) return;
    let d2 = g2.elements.floating;
    if (!d2) return;
    let T2 = parseFloat(getComputedStyle(d2).scrollPaddingBottom) || 0, $2 = Math.min(q$1, d2.childElementCount), L2 = 0, N2 = 0;
    for (let m2 of (W2 = (O2 = g2.elements.floating) == null ? void 0 : O2.childNodes) != null ? W2 : []) if (m2 instanceof HTMLElement) {
      let x2 = m2.offsetTop, k2 = x2 + m2.clientHeight + T2, S2 = d2.scrollTop, U2 = S2 + d2.clientHeight;
      if (x2 >= S2 && k2 <= U2) $2--;
      else {
        N2 = Math.max(0, Math.min(k2, U2) - Math.max(x2, S2)), L2 = m2.clientHeight;
        break;
      }
    }
    $2 >= 1 && o3((m2) => {
      let x2 = L2 * $2 - N2 + T2;
      return m2 >= x2 ? m2 : x2;
    });
  } }) : null, size({ padding: c2, apply({ availableWidth: h2, availableHeight: d2, elements: T2 }) {
    Object.assign(T2.floating.style, { overflow: "auto", maxWidth: `${h2}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d2}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I2 = a3, B2 = p2] = g2.placement.split("-");
  a3 === "selection" && (I2 = "selection");
  let G2 = T$5(() => ({ anchor: [I2, B2].filter(Boolean).join(" ") }), [I2, B2]), K2 = useInnerOffset(g2, { overflowRef: u2, onChange: o3 }), { getReferenceProps: Q2, getFloatingProps: X2 } = useInteractions([K2]), Y2 = o$4((h2) => {
    s2(h2), b2.setFloating(h2);
  });
  return _$4(H$1.Provider, { value: l2 }, _$4(y$2.Provider, { value: { setFloating: Y2, setReference: b2.setReference, styles: w2, getReferenceProps: Q2, getFloatingProps: X2, slot: G2 } }, e2));
}
function pe(e2) {
  n$3(() => {
    if (!e2) return;
    let t2 = new MutationObserver(() => {
      let n2 = window.getComputedStyle(e2).maxHeight, l2 = parseFloat(n2);
      if (isNaN(l2)) return;
      let r2 = parseInt(n2);
      isNaN(r2) || l2 !== r2 && (e2.style.maxHeight = `${Math.ceil(l2)}px`);
    });
    return t2.observe(e2, { attributes: true, attributeFilter: ["style"] }), () => {
      t2.disconnect();
    };
  }, [e2]);
}
function ce(e2, t2) {
  var o3, u2, f2;
  let n2 = V((o3 = e2 == null ? void 0 : e2.gap) != null ? o3 : "var(--anchor-gap, 0)", t2), l2 = V((u2 = e2 == null ? void 0 : e2.offset) != null ? u2 : "var(--anchor-offset, 0)", t2), r2 = V((f2 = e2 == null ? void 0 : e2.padding) != null ? f2 : "var(--anchor-padding, 0)", t2);
  return { ...e2, gap: n2, offset: l2, padding: r2 };
}
function V(e2, t2, n2 = void 0) {
  let l2 = p$2(), r2 = o$4((s2, i2) => {
    if (s2 == null) return [n2, null];
    if (typeof s2 == "number") return [s2, null];
    if (typeof s2 == "string") {
      if (!i2) return [n2, null];
      let F2 = J$2(s2, i2);
      return [F2, (E2) => {
        let v2 = D(s2);
        {
          let c2 = v2.map((P2) => window.getComputedStyle(i2).getPropertyValue(P2));
          l2.requestAnimationFrame(function P2() {
            l2.nextFrame(P2);
            let a3 = false;
            for (let [b2, w2] of v2.entries()) {
              let g2 = window.getComputedStyle(i2).getPropertyValue(w2);
              if (c2[b2] !== g2) {
                c2[b2] = g2, a3 = true;
                break;
              }
            }
            if (!a3) return;
            let p2 = J$2(s2, i2);
            F2 !== p2 && (E2(p2), F2 = p2);
          });
        }
        return l2.dispose;
      }];
    }
    return [n2, null];
  }), o3 = T$5(() => r2(e2, t2)[0], [e2, t2]), [u2 = o3, f2] = d$4();
  return n$3(() => {
    let [s2, i2] = r2(e2, t2);
    if (f2(s2), !!i2) return i2(f2);
  }, [e2, t2]), u2;
}
function D(e2) {
  let t2 = /var\((.*)\)/.exec(e2);
  if (t2) {
    let n2 = t2[1].indexOf(",");
    if (n2 === -1) return [t2[1]];
    let l2 = t2[1].slice(0, n2).trim(), r2 = t2[1].slice(n2 + 1).trim();
    return r2 ? [l2, ...D(r2)] : [l2];
  }
  return [];
}
function J$2(e2, t2) {
  let n2 = document.createElement("div");
  t2.appendChild(n2), n2.style.setProperty("margin-top", "0px", "important"), n2.style.setProperty("margin-top", e2, "important");
  let l2 = parseFloat(window.getComputedStyle(n2).marginTop) || 0;
  return t2.removeChild(n2), l2;
}
let n = K$3(null);
n.displayName = "OpenClosedContext";
var i$2 = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(i$2 || {});
function u$2() {
  return x$4(n);
}
function c$3({ value: o3, children: t2 }) {
  return Rn.createElement(n.Provider, { value: o3 }, t2);
}
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React = t$4;
  function is(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
  useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return useSyncExternalStoreWithSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
var f$1 = (t2, e2, r2) => {
  if (!e2.has(t2)) throw TypeError("Cannot " + r2);
};
var a$3 = (t2, e2, r2) => (f$1(t2, e2, "read from private field"), r2 ? r2.call(t2) : e2.get(t2)), l$2 = (t2, e2, r2) => {
  if (e2.has(t2)) throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2);
}, c$2 = (t2, e2, r2, n2) => (f$1(t2, e2, "write to private field"), e2.set(t2, r2), r2);
var i$1, s$4, o$1;
class m {
  constructor(e2) {
    l$2(this, i$1, {});
    l$2(this, s$4, new a$7(() => /* @__PURE__ */ new Set()));
    l$2(this, o$1, /* @__PURE__ */ new Set());
    c$2(this, i$1, e2);
  }
  get state() {
    return a$3(this, i$1);
  }
  subscribe(e2, r2) {
    let n2 = { selector: e2, callback: r2, current: e2(a$3(this, i$1)) };
    return a$3(this, o$1).add(n2), () => {
      a$3(this, o$1).delete(n2);
    };
  }
  on(e2, r2) {
    return a$3(this, s$4).get(e2).add(r2), () => {
      a$3(this, s$4).get(e2).delete(r2);
    };
  }
  send(e2) {
    c$2(this, i$1, this.reduce(a$3(this, i$1), e2));
    for (let r2 of a$3(this, o$1)) {
      let n2 = r2.selector(a$3(this, i$1));
      h$1(r2.current, n2) || (r2.current = n2, r2.callback(n2));
    }
    for (let r2 of a$3(this, s$4).get(e2.type)) r2(a$3(this, i$1), e2);
  }
}
i$1 = /* @__PURE__ */ new WeakMap(), s$4 = /* @__PURE__ */ new WeakMap(), o$1 = /* @__PURE__ */ new WeakMap();
function h$1(t2, e2) {
  return Object.is(t2, e2) ? true : typeof t2 != "object" || t2 === null || typeof e2 != "object" || e2 === null ? false : Array.isArray(t2) && Array.isArray(e2) ? t2.length !== e2.length ? false : u$1(t2[Symbol.iterator](), e2[Symbol.iterator]()) : t2 instanceof Map && e2 instanceof Map || t2 instanceof Set && e2 instanceof Set ? t2.size !== e2.size ? false : u$1(t2.entries(), e2.entries()) : S$2(t2) && S$2(e2) ? u$1(Object.entries(t2)[Symbol.iterator](), Object.entries(e2)[Symbol.iterator]()) : false;
}
function u$1(t2, e2) {
  do {
    let r2 = t2.next(), n2 = e2.next();
    if (r2.done && n2.done) return true;
    if (r2.done || n2.done || !Object.is(r2.value, n2.value)) return false;
  } while (true);
}
function S$2(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]") return false;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || Object.getPrototypeOf(e2) === null;
}
function g$1(t2) {
  let [e2, r2] = t2(), n2 = o$5();
  return (...b2) => {
    e2(...b2), n2.dispose(), n2.microTask(r2);
  };
}
function S$1(e2, n2, r2 = h$1) {
  return withSelectorExports.useSyncExternalStoreWithSelector(o$4((i2) => e2.subscribe(s$3, i2)), o$4(() => e2.state), o$4(() => e2.state), o$4(n2), r2);
}
function s$3(e2) {
  return e2;
}
function u(l2) {
  throw new Error("Unexpected object: " + l2);
}
var c$1 = ((i2) => (i2[i2.First = 0] = "First", i2[i2.Previous = 1] = "Previous", i2[i2.Next = 2] = "Next", i2[i2.Last = 3] = "Last", i2[i2.Specific = 4] = "Specific", i2[i2.Nothing = 5] = "Nothing", i2))(c$1 || {});
function f(l2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0) return null;
  let r2 = n2.resolveActiveIndex(), s2 = r2 != null ? r2 : -1;
  switch (l2.focus) {
    case 0: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 1: {
      s2 === -1 && (s2 = t2.length);
      for (let e2 = s2 - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 2: {
      for (let e2 = s2 + 1; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 3: {
      for (let e2 = t2.length - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 4: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (n2.resolveId(t2[e2], e2, t2) === l2.id) return e2;
      return r2;
    }
    case 5:
      return null;
    default:
      u(l2);
  }
}
function c(t2) {
  let r2 = o$4(t2), e2 = A$3(false);
  y$6(() => (e2.current = false, () => {
    e2.current = true, t$3(() => {
      e2.current && r2();
    });
  }), [r2]);
}
function s$2() {
  let r2 = typeof document == "undefined";
  return "useSyncExternalStore" in t$4 ? ((o3) => o3.useSyncExternalStore)(t$4)(() => () => {
  }, () => false, () => !r2) : false;
}
function l$1() {
  let r2 = s$2(), [e2, n2] = d$4(s$7.isHandoffComplete);
  return e2 && s$7.isHandoffComplete === false && n2(false), y$6(() => {
    e2 !== true && n2(true);
  }, [e2]), y$6(() => s$7.handoff(), []), r2 ? false : e2;
}
let e = K$3(false);
function a$2() {
  return x$4(e);
}
function j(t2) {
  let o3 = a$2(), n2 = x$4(b$1), [r2, u2] = d$4(() => {
    var s2, a3;
    if (!o3 && n2 !== null) return (s2 = n2.current) != null ? s2 : null;
    if (s$7.isServer) return null;
    let e2 = t2 == null ? void 0 : t2.getElementById("stagewise-toolbar-portal-root");
    if (e2) return e2;
    if (t2 === null) return null;
    let l2 = t2.createElement("div");
    return l2.setAttribute("id", "stagewise-toolbar-portal-root"), l2.style.pointerEvents = "auto", ((a3 = t2.querySelector("stagewise-companion-anchor")) != null ? a3 : t2.body).appendChild(l2);
  });
  return y$6(() => {
    var l2;
    if (r2 === null) return;
    const e2 = (l2 = t2 == null ? void 0 : t2.querySelector("stagewise-companion-anchor")) != null ? l2 : t2 == null ? void 0 : t2.body;
    e2 != null && e2.contains(r2) || e2 == null || e2.appendChild(r2);
  }, [r2, t2]), y$6(() => {
    o3 || n2 !== null && u2(n2.current);
  }, [n2, u2, o3]), r2;
}
let M$1 = k$3, I = K$1(function(o3, n2) {
  let { ownerDocument: r2 = null, ...u2 } = o3, e2 = A$3(null), l2 = y$5(T$3((i2) => {
    e2.current = i2;
  }), n2), R2 = n$1(e2), s2 = r2 != null ? r2 : R2, a3 = j(s2), [p2] = d$4(() => {
    var i2;
    return s$7.isServer ? null : (i2 = s2 == null ? void 0 : s2.createElement("div")) != null ? i2 : null;
  }), f2 = x$4(y$1), H2 = l$1();
  n$3(() => {
    !a3 || !p2 || a3.contains(p2) || (p2.setAttribute("data-headlessui-portal", ""), a3.appendChild(p2));
  }, [a3, p2]), n$3(() => {
    if (p2 && f2) return f2.register(p2);
  }, [f2, p2]), c(() => {
    var i2;
    !a3 || !p2 || (p2 instanceof Node && a3.contains(p2) && a3.removeChild(p2), a3.childNodes.length <= 0 && ((i2 = a3.parentElement) == null || i2.removeChild(a3)));
  });
  let h2 = L$2();
  return H2 ? !a3 || !p2 ? null : $$1(h2({ ourProps: { ref: l2 }, theirProps: u2, slot: {}, defaultTag: M$1, name: "Portal" }), p2) : null;
});
function q(t2, o3) {
  let n2 = y$5(o3), { enabled: r2 = true, ownerDocument: u2, ...e2 } = t2, l2 = L$2();
  return r2 ? Rn.createElement(I, { ...e2, ownerDocument: u2, ref: n2 }) : l2({ ourProps: { ref: n2 }, theirProps: e2, slot: {}, defaultTag: M$1, name: "Portal" });
}
let J$1 = k$3, b$1 = K$3(null);
function X(t2, o3) {
  let { target: n2, ...r2 } = t2, e2 = { ref: y$5(o3) }, l2 = L$2();
  return Rn.createElement(b$1.Provider, { value: n2 }, l2({ ourProps: e2, theirProps: r2, defaultTag: J$1, name: "Popover.Group" }));
}
let y$1 = K$3(null);
let k = K$1(q), B = K$1(X), oe = Object.assign(k, { Group: B });
function s$1(n2, t2) {
  let e2 = A$3({ left: 0, top: 0 });
  if (n$3(() => {
    if (!t2) return;
    let r2 = t2.getBoundingClientRect();
    r2 && (e2.current = r2);
  }, [n2, t2]), t2 == null || !n2 || t2 === document.activeElement) return false;
  let o3 = t2.getBoundingClientRect();
  return o3.top !== e2.current.top || o3.left !== e2.current.left;
}
let a$1 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o2(e2) {
  var r2, i2;
  let n2 = (r2 = e2.innerText) != null ? r2 : "", t2 = e2.cloneNode(true);
  if (!(t2 instanceof HTMLElement)) return n2;
  let u2 = false;
  for (let f2 of t2.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) f2.remove(), u2 = true;
  let l2 = u2 ? (i2 = t2.innerText) != null ? i2 : "" : n2;
  return a$1.test(l2) && (l2 = l2.replace(a$1, "")), l2;
}
function g(e2) {
  let n2 = e2.getAttribute("aria-label");
  if (typeof n2 == "string") return n2.trim();
  let t2 = e2.getAttribute("aria-labelledby");
  if (t2) {
    let u2 = t2.split(" ").map((l2) => {
      let r2 = document.getElementById(l2);
      if (r2) {
        let i2 = r2.getAttribute("aria-label");
        return typeof i2 == "string" ? i2.trim() : o2(r2).trim();
      }
      return null;
    }).filter(Boolean);
    if (u2.length > 0) return u2.join(", ");
  }
  return o2(e2).trim();
}
function s(c2) {
  let t2 = A$3(""), r2 = A$3("");
  return o$4(() => {
    let e2 = c2.current;
    if (!e2) return "";
    let u2 = e2.innerText;
    if (t2.current === u2) return r2.current;
    let n2 = g(e2).trim().toLowerCase();
    return t2.current = u2, r2.current = n2, n2;
  });
}
var h = Object.defineProperty;
var y = (e2, n2, t2) => n2 in e2 ? h(e2, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n2] = t2;
var v = (e2, n2, t2) => (y(e2, typeof n2 != "symbol" ? n2 + "" : n2, t2), t2);
var M = ((t2) => (t2[t2.Open = 0] = "Open", t2[t2.Closed = 1] = "Closed", t2))(M || {}), T = ((t2) => (t2[t2.Pointer = 0] = "Pointer", t2[t2.Other = 1] = "Other", t2))(T || {}), b = ((i2) => (i2[i2.OpenMenu = 0] = "OpenMenu", i2[i2.CloseMenu = 1] = "CloseMenu", i2[i2.GoToItem = 2] = "GoToItem", i2[i2.Search = 3] = "Search", i2[i2.ClearSearch = 4] = "ClearSearch", i2[i2.RegisterItems = 5] = "RegisterItems", i2[i2.UnregisterItems = 6] = "UnregisterItems", i2[i2.SetButtonElement = 7] = "SetButtonElement", i2[i2.SetItemsElement = 8] = "SetItemsElement", i2[i2.SortItems = 9] = "SortItems", i2))(b || {});
function S(e2, n2 = (t2) => t2) {
  let t2 = e2.activeItemIndex !== null ? e2.items[e2.activeItemIndex] : null, r2 = _(n2(e2.items.slice()), (u2) => u2.dataRef.current.domRef.current), l2 = t2 ? r2.indexOf(t2) : null;
  return l2 === -1 && (l2 = null), { items: r2, activeItemIndex: l2 };
}
let F = { [1](e2) {
  return e2.menuState === 1 ? e2 : { ...e2, activeItemIndex: null, pendingFocus: { focus: c$1.Nothing }, menuState: 1 };
}, [0](e2, n2) {
  return e2.menuState === 0 ? e2 : { ...e2, __demoMode: false, pendingFocus: n2.focus, menuState: 0 };
}, [2]: (e2, n2) => {
  var u2, m2, d2, a3, I2;
  if (e2.menuState === 1) return e2;
  let t2 = { ...e2, searchQuery: "", activationTrigger: (u2 = n2.trigger) != null ? u2 : 1, __demoMode: false };
  if (n2.focus === c$1.Nothing) return { ...t2, activeItemIndex: null };
  if (n2.focus === c$1.Specific) return { ...t2, activeItemIndex: e2.items.findIndex((i2) => i2.id === n2.id) };
  if (n2.focus === c$1.Previous) {
    let i2 = e2.activeItemIndex;
    if (i2 !== null) {
      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });
      if (o3 !== null) {
        let s2 = e2.items[o3].dataRef.current.domRef;
        if (((m2 = g2.current) == null ? void 0 : m2.previousElementSibling) === s2.current || ((d2 = s2.current) == null ? void 0 : d2.previousElementSibling) === null) return { ...t2, activeItemIndex: o3 };
      }
    }
  } else if (n2.focus === c$1.Next) {
    let i2 = e2.activeItemIndex;
    if (i2 !== null) {
      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });
      if (o3 !== null) {
        let s2 = e2.items[o3].dataRef.current.domRef;
        if (((a3 = g2.current) == null ? void 0 : a3.nextElementSibling) === s2.current || ((I2 = s2.current) == null ? void 0 : I2.nextElementSibling) === null) return { ...t2, activeItemIndex: o3 };
      }
    }
  }
  let r2 = S(e2), l2 = f(n2, { resolveItems: () => r2.items, resolveActiveIndex: () => r2.activeItemIndex, resolveId: (i2) => i2.id, resolveDisabled: (i2) => i2.dataRef.current.disabled });
  return { ...t2, ...r2, activeItemIndex: l2 };
}, [3]: (e2, n2) => {
  let r2 = e2.searchQuery !== "" ? 0 : 1, l2 = e2.searchQuery + n2.value.toLowerCase(), m2 = (e2.activeItemIndex !== null ? e2.items.slice(e2.activeItemIndex + r2).concat(e2.items.slice(0, e2.activeItemIndex + r2)) : e2.items).find((a3) => {
    var I2;
    return ((I2 = a3.dataRef.current.textValue) == null ? void 0 : I2.startsWith(l2)) && !a3.dataRef.current.disabled;
  }), d2 = m2 ? e2.items.indexOf(m2) : -1;
  return d2 === -1 || d2 === e2.activeItemIndex ? { ...e2, searchQuery: l2 } : { ...e2, searchQuery: l2, activeItemIndex: d2, activationTrigger: 1 };
}, [4](e2) {
  return e2.searchQuery === "" ? e2 : { ...e2, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e2, n2) => {
  let t2 = e2.items.concat(n2.items.map((l2) => l2)), r2 = e2.activeItemIndex;
  return e2.pendingFocus.focus !== c$1.Nothing && (r2 = f(e2.pendingFocus, { resolveItems: () => t2, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (l2) => l2.id, resolveDisabled: (l2) => l2.dataRef.current.disabled })), { ...e2, items: t2, activeItemIndex: r2, pendingFocus: { focus: c$1.Nothing }, pendingShouldSort: true };
}, [6]: (e2, n2) => {
  let t2 = e2.items, r2 = [], l2 = new Set(n2.items);
  for (let [u2, m2] of t2.entries()) if (l2.has(m2.id) && (r2.push(u2), l2.delete(m2.id), l2.size === 0)) break;
  if (r2.length > 0) {
    t2 = t2.slice();
    for (let u2 of r2.reverse()) t2.splice(u2, 1);
  }
  return { ...e2, items: t2, activationTrigger: 1 };
}, [7]: (e2, n2) => e2.buttonElement === n2.element ? e2 : { ...e2, buttonElement: n2.element }, [8]: (e2, n2) => e2.itemsElement === n2.element ? e2 : { ...e2, itemsElement: n2.element }, [9]: (e2) => e2.pendingShouldSort ? { ...e2, ...S(e2), pendingShouldSort: false } : e2 };
class x extends m {
  constructor(t2) {
    super(t2);
    v(this, "actions", { registerItem: g$1(() => {
      let t3 = [], r2 = /* @__PURE__ */ new Set();
      return [(l2, u2) => {
        r2.has(u2) || (r2.add(u2), t3.push({ id: l2, dataRef: u2 }));
      }, () => (r2.clear(), this.send({ type: 5, items: t3.splice(0) }))];
    }), unregisterItem: g$1(() => {
      let t3 = [];
      return [(r2) => t3.push(r2), () => this.send({ type: 6, items: t3.splice(0) })];
    }) });
    v(this, "selectors", { activeDescendantId(t3) {
      var u2;
      let r2 = t3.activeItemIndex, l2 = t3.items;
      return r2 === null || (u2 = l2[r2]) == null ? void 0 : u2.id;
    }, isActive(t3, r2) {
      var m2;
      let l2 = t3.activeItemIndex, u2 = t3.items;
      return l2 !== null ? ((m2 = u2[l2]) == null ? void 0 : m2.id) === r2 : false;
    }, shouldScrollIntoView(t3, r2) {
      return t3.__demoMode || t3.menuState !== 0 || t3.activationTrigger === 0 ? false : this.isActive(t3, r2);
    } });
    this.on(5, () => {
      requestAnimationFrame(() => {
        this.send({ type: 9 });
      });
    });
  }
  static new({ __demoMode: t2 = false } = {}) {
    return new x({ __demoMode: t2, menuState: t2 ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1, pendingShouldSort: false, pendingFocus: { focus: c$1.Nothing } });
  }
  reduce(t2, r2) {
    return u$7(r2.type, F, t2, r2);
  }
}
const a2 = K$3(null);
function l(e2) {
  let n2 = x$4(a2);
  if (n2 === null) {
    let t2 = new Error(`<${e2} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t2, i), t2;
  }
  return n2;
}
function i({ __demoMode: e2 = false } = {}) {
  return T$5(() => x.new({ __demoMode: e2 }), []);
}
let ze = k$3;
function Qe(T2, E2) {
  let { __demoMode: i$12 = false, ...a$12 } = T2, n2 = i({ __demoMode: i$12 }), [s2, o3, P2] = S$1(n2, (p2) => [p2.menuState, p2.itemsElement, p2.buttonElement]), c2 = y$5(E2), _2 = s2 === M.Open;
  R$1(_2, [P2, o3], (p2, F2) => {
    var A$12;
    n2.send({ type: b.CloseMenu }), A(F2, h$2.Loose) || (p2.preventDefault(), (A$12 = n2.state.buttonElement) == null || A$12.focus());
  });
  let t2 = o$4(() => {
    n2.send({ type: b.CloseMenu });
  }), R2 = T$5(() => ({ open: s2 === M.Open, close: t2 }), [s2, t2]), I2 = { ref: c2 }, g2 = L$2();
  return Rn.createElement(Me, null, Rn.createElement(a2.Provider, { value: n2 }, Rn.createElement(c$3, { value: u$7(s2, { [M.Open]: i$2.Open, [M.Closed]: i$2.Closed }) }, g2({ ourProps: I2, theirProps: a$12, slot: R2, defaultTag: ze, name: "Menu" }))));
}
let Ye = "button";
function Ze(T$12, E2) {
  let i2 = l("Menu.Button"), a3 = g$3(), { id: n2 = `headlessui-menu-button-${a3}`, disabled: s2 = false, autoFocus: o3 = false, ...P2 } = T$12, c2 = A$3(null), _2 = Fe(), t2 = y$5(E2, c2, ye(), o$4((l2) => i2.send({ type: b.SetButtonElement, element: l2 }))), R2 = o$4((l2) => {
    switch (l2.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.First } });
        break;
      case o$3.ArrowUp:
        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Last } });
        break;
    }
  }), I2 = o$4((l2) => {
    switch (l2.key) {
      case o$3.Space:
        l2.preventDefault();
        break;
    }
  }), [g2, p2] = S$1(i2, (l2) => [l2.menuState, l2.itemsElement]), F2 = o$4((l2) => {
    var H2;
    if (l2.button === 0) {
      if (r$1(l2.currentTarget)) return l2.preventDefault();
      s2 || (g2 === M.Open ? (En(() => i2.send({ type: b.CloseMenu })), (H2 = c2.current) == null || H2.focus({ preventScroll: true })) : (l2.preventDefault(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Nothing }, trigger: T.Pointer })));
    }
  }), { isFocusVisible: A2, focusProps: f2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o3 }), { isHovered: M$12, hoverProps: L2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: s2 }), { pressed: S2, pressProps: O2 } = w$2({ disabled: s2 }), x2 = T$5(() => ({ open: g2 === M.Open, active: S2 || g2 === M.Open, disabled: s2, hover: M$12, focus: A2, autofocus: o3 }), [g2, M$12, A2, S2, s2, o3]), U2 = _$2(_2(), { ref: t2, id: n2, type: e$1(T$12, c2.current), "aria-haspopup": "menu", "aria-controls": p2 == null ? void 0 : p2.id, "aria-expanded": g2 === M.Open, disabled: s2 || void 0, autoFocus: o3, onKeyDown: R2, onKeyUp: I2, onMouseDown: F2 }, f2, L2, O2);
  return L$2()({ ourProps: U2, theirProps: P2, slot: x2, defaultTag: Ye, name: "Menu.Button" });
}
let et = "div", tt = O$1.RenderStrategy | O$1.Static;
function ot(T2, E2) {
  let i2 = g$3(), { id: a3 = `headlessui-menu-items-${i2}`, anchor: n2, portal: s2 = false, modal: o3 = true, transition: P2 = false, ...c2 } = T2, _2 = xe(n2), t2 = l("Menu.Items"), [R$12, I2] = Re(_2), g2 = be(), [p2, F2] = d$4(null), A2 = y$5(E2, _2 ? R$12 : null, o$4((e2) => t2.send({ type: b.SetItemsElement, element: e2 })), F2), [f2, M$12] = S$1(t2, (e2) => [e2.menuState, e2.buttonElement]), L2 = n$1(M$12), S2 = n$1(p2);
  _2 && (s2 = true);
  let O2 = u$2(), [x2, U2] = x$1(P2, p2, O2 !== null ? (O2 & i$2.Open) === i$2.Open : f2 === M.Open);
  m$2(x2, M$12, () => {
    t2.send({ type: b.CloseMenu });
  });
  let G$12 = S$1(t2, (e2) => e2.__demoMode), l$12 = G$12 ? false : o3 && f2 === M.Open;
  f$2(l$12, S2);
  let H2 = G$12 ? false : o3 && f2 === M.Open;
  y$4(H2, { allowed: q$3(() => [M$12, p2], [M$12, p2]) });
  let u2 = f2 !== M.Open, ae = s$1(u2, M$12) ? false : x2;
  y$6(() => {
    let e2 = p2;
    e2 && f2 === M.Open && e2 !== (S2 == null ? void 0 : S2.activeElement) && e2.focus({ preventScroll: true });
  }, [f2, p2, S2]), F$1(f2 === M.Open, { container: p2, accept(e2) {
    return e2.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : e2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e2) {
    e2.setAttribute("role", "none");
  } });
  let q2 = p$2(), se = o$4((e2) => {
    var N2, z2, Q2;
    switch (q2.dispose(), e2.key) {
      case o$3.Space:
        if (t2.state.searchQuery !== "") return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.Search, value: e2.key });
      case o$3.Enter:
        if (e2.preventDefault(), e2.stopPropagation(), t2.state.activeItemIndex !== null) {
          let { dataRef: de } = t2.state.items[t2.state.activeItemIndex];
          (z2 = (N2 = de.current) == null ? void 0 : N2.domRef.current) == null || z2.click();
        }
        t2.send({ type: b.CloseMenu }), G(t2.state.buttonElement);
        break;
      case o$3.ArrowDown:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Next });
      case o$3.ArrowUp:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Last });
      case o$3.Escape:
        e2.preventDefault(), e2.stopPropagation(), En(() => t2.send({ type: b.CloseMenu })), (Q2 = t2.state.buttonElement) == null || Q2.focus({ preventScroll: true });
        break;
      case o$3.Tab:
        e2.preventDefault(), e2.stopPropagation(), En(() => t2.send({ type: b.CloseMenu })), j$2(t2.state.buttonElement, e2.shiftKey ? F$2.Previous : F$2.Next);
        break;
      default:
        e2.key.length === 1 && (t2.send({ type: b.Search, value: e2.key }), q2.setTimeout(() => t2.send({ type: b.ClearSearch }), 350));
        break;
    }
  }), le = o$4((e2) => {
    switch (e2.key) {
      case o$3.Space:
        e2.preventDefault();
        break;
    }
  }), pe2 = T$5(() => ({ open: f2 === M.Open }), [f2]), ie = _$2(_2 ? g2() : {}, { "aria-activedescendant": S$1(t2, t2.selectors.activeDescendantId), "aria-labelledby": S$1(t2, (e2) => {
    var N2;
    return (N2 = e2.buttonElement) == null ? void 0 : N2.id;
  }), id: a3, onKeyDown: se, onKeyUp: le, role: "menu", tabIndex: f2 === M.Open ? 0 : void 0, ref: A2, style: { ...c2.style, ...I2, "--button-width": d$2(M$12, true).width }, ...R(U2) }), ue = L$2();
  return Rn.createElement(oe, { enabled: s2 ? T2.static || x2 : false, ownerDocument: L2 }, ue({ ourProps: ie, theirProps: c2, slot: pe2, defaultTag: et, features: tt, visible: ae, name: "Menu.Items" }));
}
let nt = k$3;
function rt(T$12, E2) {
  let i2 = g$3(), { id: a3 = `headlessui-menu-item-${i2}`, disabled: n2 = false, ...s$12 } = T$12, o3 = l("Menu.Item"), P2 = S$1(o3, (u2) => o3.selectors.isActive(u2, a3)), c2 = A$3(null), _2 = y$5(E2, c2), t2 = S$1(o3, (u2) => o3.selectors.shouldScrollIntoView(u2, a3));
  n$3(() => {
    if (t2) return o$5().requestAnimationFrame(() => {
      var u2, J2;
      (J2 = (u2 = c2.current) == null ? void 0 : u2.scrollIntoView) == null || J2.call(u2, { block: "nearest" });
    });
  }, [t2, c2]);
  let R2 = s(c2), I2 = A$3({ disabled: n2, domRef: c2, get textValue() {
    return R2();
  } });
  n$3(() => {
    I2.current.disabled = n2;
  }, [I2, n2]), n$3(() => (o3.actions.registerItem(a3, I2), () => o3.actions.unregisterItem(a3)), [I2, a3]);
  let g2 = o$4(() => {
    o3.send({ type: b.CloseMenu });
  }), p2 = o$4((u2) => {
    if (n2) return u2.preventDefault();
    o3.send({ type: b.CloseMenu }), G(o3.state.buttonElement);
  }), F2 = o$4(() => {
    if (n2) return o3.send({ type: b.GoToItem, focus: c$1.Nothing });
    o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3 });
  }), A2 = u$3(), f2 = o$4((u2) => {
    A2.update(u2), !n2 && (P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));
  }), M2 = o$4((u2) => {
    A2.wasMoved(u2) && (n2 || P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));
  }), L2 = o$4((u2) => {
    A2.wasMoved(u2) && (n2 || P2 && o3.send({ type: b.GoToItem, focus: c$1.Nothing }));
  }), [S2, O2] = K(), [x2, U2] = w$1(), G$12 = T$5(() => ({ active: P2, focus: P2, disabled: n2, close: g2 }), [P2, n2, g2]), l$12 = { id: a3, ref: _2, role: "menuitem", tabIndex: n2 === true ? void 0 : -1, "aria-disabled": n2 === true ? true : void 0, "aria-labelledby": S2, "aria-describedby": x2, disabled: void 0, onClick: p2, onFocus: F2, onPointerEnter: f2, onMouseEnter: f2, onPointerMove: M2, onMouseMove: M2, onPointerLeave: L2, onMouseLeave: L2 }, H2 = L$2();
  return Rn.createElement(O2, null, Rn.createElement(U2, null, H2({ ourProps: l$12, theirProps: s$12, slot: G$12, defaultTag: nt, name: "Menu.Item" })));
}
let at = "div";
function st(T2, E2) {
  let [i2, a3] = K(), n2 = T2, s2 = { ref: E2, "aria-labelledby": i2, role: "group" }, o3 = L$2();
  return Rn.createElement(a3, null, o3({ ourProps: s2, theirProps: n2, slot: {}, defaultTag: at, name: "Menu.Section" }));
}
let lt = "header";
function pt(T2, E2) {
  let i2 = g$3(), { id: a3 = `headlessui-menu-heading-${i2}`, ...n2 } = T2, s2 = P$1();
  n$3(() => s2.register(a3), [a3, s2.register]);
  let o3 = { id: a3, ref: E2, role: "presentation", ...s2.props };
  return L$2()({ ourProps: o3, theirProps: n2, slot: {}, defaultTag: lt, name: "Menu.Heading" });
}
let it = "div";
function ut(T2, E2) {
  let i2 = T2, a3 = { ref: E2, role: "separator" };
  return L$2()({ ourProps: a3, theirProps: i2, slot: {}, defaultTag: it, name: "Menu.Separator" });
}
let dt = K$1(Qe), mt = K$1(Ze), Tt = K$1(ot), ft = K$1(rt), ct = K$1(st), yt = K$1(pt), Et = K$1(ut); Object.assign(dt, { Button: mt, Items: Tt, Item: ft, Section: ct, Heading: yt, Separator: Et });
let L = "textarea";
function H(s2, l2) {
  let i2 = g$3(), d2 = u$6(), n2 = a$9(), { id: p2 = d2 || `headlessui-textarea-${i2}`, disabled: e2 = n2 || false, autoFocus: r2 = false, invalid: a3 = false, ...T2 } = s2, f2 = I$2(), m2 = U$1(), { isFocused: o3, focusProps: u2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r2 }), { isHovered: t2, hoverProps: b2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), y2 = _$2({ ref: l2, id: p2, "aria-labelledby": f2, "aria-describedby": m2, "aria-invalid": a3 ? "true" : void 0, disabled: e2 || void 0, autoFocus: r2 }, u2, b2), x2 = T$5(() => ({ disabled: e2, invalid: a3, hover: t2, focus: o3, autofocus: r2 }), [e2, a3, t2, o3, r2]);
  return L$2()({ ourProps: y2, theirProps: T2, slot: x2, defaultTag: L, name: "Textarea" });
}
K$1(H);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
const toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index2;
}).join(" ").trim();
const hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = D$1(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return _$4(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => _$4(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = D$1(
    ({ className, ...props }, ref) => _$4(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component.displayName = toPascalCase(iconName);
  return Component;
};
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
const ChevronDown = createLucideIcon("chevron-down", __iconNode$6);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
const ChevronUp = createLucideIcon("chevron-up", __iconNode$5);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
];
createLucideIcon("ellipsis", __iconNode$4);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["polyline", { points: "4 14 10 14 10 20", key: "11kfnr" }],
  ["polyline", { points: "20 10 14 10 14 4", key: "rlmsce" }],
  ["line", { x1: "14", x2: "21", y1: "10", y2: "3", key: "o5lafz" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
];
createLucideIcon("minimize-2", __iconNode$3);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
const Plus = createLucideIcon("plus", __iconNode$2);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
createLucideIcon("send", __iconNode$1);
/**
 * @license lucide-react v0.503.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
createLucideIcon("trash-2", __iconNode);
M$3(() => {
  const { chatAreaState } = useChatState();
  if (chatAreaState === "hidden") return null;
  return /* @__PURE__ */ u$9(ChatAreaBox, { children: [
    /* @__PURE__ */ u$9(ChatAreaResizeBar, {}),
    chatAreaState === "compact" && /* @__PURE__ */ u$9(ChatAreaCompact, {}),
    chatAreaState === "expanded" && /* @__PURE__ */ u$9(ChatAreaExpanded, {})
  ] });
});
const ChatAreaBox = M$3(({ children }) => /* @__PURE__ */ u$9("div", { className: "h-auto w-full overflow-x-hidden", children }));
const ChatAreaResizeBar = M$3(() => {
  const { chatAreaState, setChatAreaState, stopPromptCreation } = useChatState();
  const handleResizeBarClick = q$3(() => {
    setChatAreaState(chatAreaState === "compact" ? "expanded" : "compact");
  }, [chatAreaState, setChatAreaState]);
  const handleCloseChatArea = q$3(() => {
    stopPromptCreation();
    setChatAreaState("hidden");
  }, [setChatAreaState, stopPromptCreation]);
  return /* @__PURE__ */ u$9("div", { className: "flex w-full flex-row items-center justify-center rounded-t-3xl px-3 py-1", children: [
    /* @__PURE__ */ u$9(
      H$3,
      {
        className: "size-5 bg-transparent text-muted-foreground/30 transition-colors duration-100 hover:text-muted-foreground",
        onClick: handleResizeBarClick,
        children: chatAreaState === "compact" ? /* @__PURE__ */ u$9(ChevronUp, { className: "size-5" }) : /* @__PURE__ */ u$9(ChevronDown, { className: "size-5" })
      }
    ),
    /* @__PURE__ */ u$9(
      H$3,
      {
        className: "absolute right-2 flex h-fit w-fit flex-row items-center gap-1 bg-transparent p-1 text-xs text-zinc-950 opacity-50 transition-all duration-100 hover:opacity-100",
        onClick: handleCloseChatArea,
        children: [
          "Close menu",
          /* @__PURE__ */ u$9("div", { className: "rounded-md bg-zinc-600 px-0.5 py-0 text-xs text-zinc-50", children: "esc" })
        ]
      }
    )
  ] });
});
const ChatAreaCompact = M$3(() => /* @__PURE__ */ u$9("div", { className: "flex w-full flex-col gap-1 p-3", children: /* @__PURE__ */ u$9("span", { className: "text-sm text-zinc-950/50", children: "This is the compact chat area... Showing just the last response from the assistant." }) }));
const ChatAreaExpanded = M$3(() => {
  const { chats, currentChatId, setCurrentChat, createChat } = useChatState();
  const currentChat = chats.find((chat) => chat.id === currentChatId);
  const hasNewChat = chats.some((chat) => chat.id === "new_chat");
  const handleCreateChat = q$3(() => {
    createChat();
  }, [createChat]);
  const handleSetCurrentChat = q$3(
    (chatId) => {
      setCurrentChat(chatId);
    },
    [setCurrentChat]
  );
  return /* @__PURE__ */ u$9("div", { className: "flex max-h-[50vh] w-full flex-col gap-3 p-3 pb-0", children: [
    /* @__PURE__ */ u$9("div", { className: "flex flex-1 flex-col gap-2 overflow-y-auto p-1", children: currentChat == null ? void 0 : currentChat.messages.map((message) => /* @__PURE__ */ u$9(
      "div",
      {
        className: `flex ${message.sender === "assistant" ? "justify-start" : "justify-end"}`,
        children: /* @__PURE__ */ u$9(
          "div",
          {
            className: `max-w-[80%] rounded-xl px-2 py-1 text-sm ${message.sender === "assistant" ? "bg-zinc-950/5 text-zinc-950" : "bg-blue-600 text-white"}`,
            children: message.content
          }
        )
      },
      message.id
    )) }),
    /* @__PURE__ */ u$9("div", { className: "flex flex-row items-center justify-start gap-2 overflow-x-auto overflow-y-visible border-border/10 border-t pt-2 pb-2", children: [
      !hasNewChat && /* @__PURE__ */ u$9(
        H$3,
        {
          className: "h-6 flex-shrink-0 rounded-full bg-zinc-950/5 px-2 font-semibold text-foreground text-xs",
          onClick: handleCreateChat,
          children: /* @__PURE__ */ u$9(Plus, { className: "size-3" })
        }
      ),
      chats.map((chat) => /* @__PURE__ */ u$9(
        H$3,
        {
          className: cn(
            "h-5 max-w-48 flex-shrink-0 overflow-hidden truncate rounded-full bg-zinc-950/5 px-2 text-muted-foreground text-xs",
            chat.id === currentChatId && "bg-white/60 text-zinc-950 shadow-blue-600/50 shadow-sm"
          ),
          onClick: () => handleSetCurrentChat(chat.id),
          children: chat.title || "New chat"
        },
        chat.id
      ))
    ] })
  ] });
});
var UNDEF_TYPE = "undefined", OBJ_TYPE = "object", UA_BROWSER = "browser", UA_CPU = "cpu", UA_DEVICE = "device", UA_ENGINE = "engine", UA_OS = "os", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", MAJOR = "major", MODEL = "model", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded";
var isWindow = typeof window !== UNDEF_TYPE, NAVIGATOR = isWindow && window.navigator ? window.navigator : void 0; NAVIGATOR && NAVIGATOR.userAgentData ? NAVIGATOR.userAgentData : void 0;
var enumerize = function(arr) {
  var enums = {};
  for (var i2 = 0; i2 < arr.length; i2++) {
    enums[arr[i2].toUpperCase()] = arr[i2];
  }
  return enums;
}, setProps = function(arr) {
  for (var i2 in arr) {
    var propName = arr[i2];
    if (typeof propName == OBJ_TYPE && propName.length == 2) {
      this[propName[0]] = propName[1];
    } else {
      this[propName] = void 0;
    }
  }
  return this;
};
(function() {
  var props = { init: {}, isIgnore: {}, isIgnoreRgx: {}, toString: {} };
  setProps.call(props.init, [
    [UA_BROWSER, [NAME, VERSION, MAJOR, TYPE]],
    [UA_CPU, [ARCHITECTURE]],
    [UA_DEVICE, [TYPE, MODEL, VENDOR]],
    [UA_ENGINE, [NAME, VERSION]],
    [UA_OS, [NAME, VERSION]]
  ]);
  setProps.call(props.isIgnore, [
    [UA_BROWSER, [VERSION, MAJOR]],
    [UA_ENGINE, [VERSION]],
    [UA_OS, [VERSION]]
  ]);
  setProps.call(props.isIgnoreRgx, [
    [UA_BROWSER, / ?browser$/i],
    [UA_OS, / ?os$/i]
  ]);
  setProps.call(props.toString, [
    [UA_BROWSER, [NAME, VERSION]],
    [UA_CPU, [ARCHITECTURE]],
    [UA_DEVICE, [VENDOR, MODEL]],
    [UA_ENGINE, [NAME, VERSION]],
    [UA_OS, [NAME, VERSION]]
  ]);
  return props;
})();
enumerize([NAME, VERSION, MAJOR, TYPE]);
enumerize([ARCHITECTURE]);
enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
enumerize([NAME, VERSION]);
D$1(
  (props, ref) => {
    return /* @__PURE__ */ u$9(mt, { as: k$3, ref, ...props });
  }
);
D$1(
  (props, ref) => {
    return /* @__PURE__ */ u$9(
      Tt,
      {
        ref,
        anchor: "bottom",
        transition: true,
        portal: true,
        ...props,
        className: cn(
          "z-50 flex w-fit min-w-24 max-w-90 flex-col items-stretch justify-start gap-1 rounded-lg border border-border/30 border-solid bg-background/60 p-1 shadow-black/50 shadow-lg outline-none backdrop-blur-md data-focus:outline-none",
          props.className
        )
      }
    );
  }
);
const DropdownMenuItemStyles = "w-full flex flex-row select-none items-center justify-start gap-2 p-2 pr-6 truncate overflow-hidden rounded-md hover:bg-zinc-950/10 focus:text-zinc-900 cursor-pointer transition-color duration-150 text-sm font-normal text-foreground";
D$1(
  (props, ref) => {
    return /* @__PURE__ */ u$9(ft, { ref, children: /* @__PURE__ */ u$9(
      H$3,
      {
        ...props,
        className: cn(DropdownMenuItemStyles, props.className)
      }
    ) });
  }
);
D$1(
  (props, ref) => {
    return /* @__PURE__ */ u$9(ft, { ref, children: /* @__PURE__ */ u$9("a", { ...props, className: cn(DropdownMenuItemStyles, props.className) }) });
  }
);
function ToolbarItem(props) {
  return /* @__PURE__ */ u$9("div", { className: "flex h-full shrink-0 items-center justify-center", children: [
    props.children,
    props.badgeContent && /* @__PURE__ */ u$9(
      "div",
      {
        className: cn(
          "bg-blue-600 text-white",
          props.badgeClassName,
          "-bottom-0.5 -right-1 pointer-events-none absolute flex h-4 w-max min-w-4 max-w-8 select-none items-center justify-center truncate rounded-full px-1 font-semibold text-xs"
        ),
        children: props.badgeContent
      }
    ),
    props.statusDot && /* @__PURE__ */ u$9(
      "div",
      {
        className: cn(
          "bg-rose-600",
          props.statusDotClassName,
          "pointer-events-none absolute top-0 right-0 size-1.5 rounded-full"
        )
      }
    )
  ] });
}
const ToolbarButton = D$1(
  ({
    badgeContent,
    badgeClassName,
    statusDot,
    statusDotClassName,
    tooltipHint,
    variant = "default",
    ...props
  }, ref) => {
    const button = /* @__PURE__ */ u$9(
      H$3,
      {
        ref,
        ...props,
        className: cn(
          "flex items-center justify-center rounded-full p-1 text-zinc-950 hover:bg-zinc-950/5",
          variant === "default" ? "size-8" : "h-8 rounded-full"
        )
      }
    );
    return /* @__PURE__ */ u$9(
      ToolbarItem,
      {
        badgeContent,
        badgeClassName,
        statusDot,
        statusDotClassName,
        children: button
      }
    );
  }
);
ToolbarButton.displayName = "ToolbarButton";
K$3(
  null
);

client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SoundProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
);
