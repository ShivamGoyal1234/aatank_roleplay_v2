var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d, c = {}, k = null, h = null;
    if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
    return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape2(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P2 = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P2, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P2, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d = "" === d ? "." : d + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d + Q(k, g);
      h += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d = [], c = 0;
    R(a, d, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X2() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X2;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X2;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y;
      try {
        G(b);
        for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if ("function" === typeof d) {
            v.callback = null;
            y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r) && k(r);
            G(b);
          } else k(r);
          v = h(r);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P2 = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P2 ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
    if (d) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d = l;
        }
        a();
      }
    } catch (l) {
      if (l && d && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (null != c) if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  }(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d, e, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d = e.return;
        if (null !== d) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c) {
            g = true;
            c = e;
            d = f;
            break;
          }
          if (h === d) {
            g = true;
            d = e;
            c = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c) {
              g = true;
              c = f;
              d = e;
              break;
            }
            if (h === d) {
              g = true;
              d = f;
              c = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
    } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
    if (0 === d) return 0;
    if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d & 4) && (d |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
      } else k <= b && (a.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f = 1 << e;
      b[e] = 0;
      d[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d;
        c.target.dispatchEvent(d);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d) {
    if (dd) {
      var e = Yc(a, b, c, d);
      if (null === e) hd(a, b, d, id2, c), Sc(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d);
          null === f && hd(a, b, d, id2, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id2 = null;
  function Yc(a, b, c, d) {
    id2 = null;
    a = xb(d);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id2 = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return false;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d; c; ) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d && Ne(c)) {
        if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d.start, e);
          d = void 0 === d.end ? f : Math.min(d.end, e);
          !a.extend && f > d && (e = d, d = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
        else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, false), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4);
    pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
      if (null === d) return;
      var g = d.tag;
      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a);
        if (void 0 !== h2) {
          var k3 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
          t = [];
          for (var w = d2, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf2(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t.length && (h2 = new k3(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a || "pointerover" === a;
          k3 = "mouseout" === a || "pointerout" === a;
          if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k3 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k3) {
              if (n = c.relatedTarget || c.toElement, k3 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k3 = null, n = d2;
            if (k3 !== n) {
              t = Bd;
              F = "onMouseLeave";
              x = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
              J = null == k3 ? h2 : ue(k3);
              u = null == n ? h2 : ue(n);
              h2 = new t(F, w + "leave", k3, c, e2);
              h2.target = J;
              h2.relatedTarget = u;
              F = null;
              Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
              J = F;
              if (k3 && n) b: {
                t = k3;
                x = n;
                w = 0;
                for (u = t; u; u = vf(u)) w++;
                u = 0;
                for (F = x; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t = vf(t), w--;
                for (; 0 < u - w; ) x = vf(x), u--;
                for (; w--; ) {
                  if (t === x || null !== x && t === x.alternate) break b;
                  t = vf(t);
                  x = vf(x);
                }
                t = null;
              }
              else t = null;
              null !== k3 && wf(g2, h2, k3, t, false);
              null !== n && null !== J && wf(g2, J, n, t, true);
            }
          }
        }
        a: {
          h2 = d2 ? ue(d2) : window;
          k3 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h2.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a, d2))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h2, d2);
          "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d2 ? ue(d2) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf2(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf2(a, f, e)), f = Kb(a, b), null != f && d.push(tf2(a, f, e)));
      a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d; ) {
      var h = c, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf2(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf2(c, k, h))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(true);
          while (null !== d);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e);
    c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d & (1 << g) - 1).toString(32);
      d >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d;
      sg = f + a;
    } else rg = 1 << f | c << e | d, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c6) {
      if (a) {
        var d2 = b2.deletions;
        null === d2 ? (b2.deletions = [c6], b2.flags |= 16) : d2.push(c6);
      }
    }
    function c(c6, d2) {
      if (!a) return null;
      for (; null !== d2; ) b(c6, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c6, d2) {
      b2.index = d2;
      if (!a) return b2.flags |= 1048576, c6;
      d2 = b2.alternate;
      if (null !== d2) return d2 = d2.index, d2 < c6 ? (b2.flags |= 2, c6) : d2;
      b2.flags |= 2;
      return c6;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a2, b2, c6, d2) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c6, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c6);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c6, d2) {
      var f2 = c6.type;
      if (f2 === ya) return m(a2, b2, c6.props.children, d2, c6.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c6.props), d2.ref = Lg(a2, b2, c6), d2.return = a2, d2;
      d2 = Rg(c6.type, c6.key, c6.props, null, a2.mode, d2);
      d2.ref = Lg(a2, b2, c6);
      d2.return = a2;
      return d2;
    }
    function l(a2, b2, c6, d2) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c6.containerInfo || b2.stateNode.implementation !== c6.implementation) return b2 = Sg(c6, a2.mode, d2), b2.return = a2, b2;
      b2 = e(b2, c6.children || []);
      b2.return = a2;
      return b2;
    }
    function m(a2, b2, c6, d2, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c6, a2.mode, d2, f2), b2.return = a2, b2;
      b2 = e(b2, c6);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c6) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c6), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c6 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c6), c6.ref = Lg(a2, null, b2), c6.return = a2, c6;
          case wa:
            return b2 = Sg(b2, a2.mode, c6), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q(a2, d2(b2._payload), c6);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c6, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r(a2, b2, c6, d2) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c6 && "" !== c6 || "number" === typeof c6) return null !== e2 ? null : h(a2, b2, "" + c6, d2);
      if ("object" === typeof c6 && null !== c6) {
        switch (c6.$$typeof) {
          case va:
            return c6.key === e2 ? k(a2, b2, c6, d2) : null;
          case wa:
            return c6.key === e2 ? l(a2, b2, c6, d2) : null;
          case Ha:
            return e2 = c6._init, r(
              a2,
              b2,
              e2(c6._payload),
              d2
            );
        }
        if (eb(c6) || Ka(c6)) return null !== e2 ? null : m(a2, b2, c6, d2, null);
        Mg(a2, c6);
      }
      return null;
    }
    function y(a2, b2, c6, d2, e2) {
      if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c6) || null, h(b2, a2, "" + d2, e2);
      if ("object" === typeof d2 && null !== d2) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(null === d2.key ? c6 : d2.key) || null, k(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(null === d2.key ? c6 : d2.key) || null, l(b2, a2, d2, e2);
          case Ha:
            var f2 = d2._init;
            return y(a2, b2, c6, f2(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c6) || null, m(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g2, h2, k3) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x = u, u = null) : x = u.sibling;
        var n2 = r(e2, u, h2[w], k3);
        if (null === n2) {
          null === u && (u = x);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m2 ? l2 = n2 : m2.sibling = n2;
        m2 = n2;
        u = x;
      }
      if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++) u = q(e2, h2[w], k3), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k3), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t(e2, g2, h2, k3) {
      var l2 = Ka(h2);
      if ("function" !== typeof l2) throw Error(p(150));
      h2 = l2.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
        m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
        var t2 = r(e2, m2, n2.value, k3);
        if (null === t2) {
          null === m2 && (m2 = x);
          break;
        }
        a && m2 && null === t2.alternate && b(e2, m2);
        g2 = f(t2, g2, w);
        null === u ? l2 = t2 : u.sibling = t2;
        u = t2;
        m2 = x;
      }
      if (n2.done) return c(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k3), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k3), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d2, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k3 = f2.key, l2 = d2; null !== l2; ) {
                if (l2.key === k3) {
                  k3 = f2.type;
                  if (k3 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d2 = e(l2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                  } else if (l2.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l2.type) {
                    c(a2, l2.sibling);
                    d2 = e(l2, f2.props);
                    d2.ref = Lg(a2, l2, f2);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d2; ) {
                if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f2, a2.mode, h2);
              d2.return = a2;
              a2 = d2;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
        }
        if (eb(f2)) return n(a2, d2, f2, h2);
        if (Ka(f2)) return t(a2, d2, f2, h2);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (null === d) return null;
    d = d.shared;
    if (0 !== (K & 2)) {
      var e = d.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d.pending = b;
      return ih(a, c);
    }
    e = d.interleaved;
    null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
    d.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a.alternate;
      null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h = f;
      do {
        var r = h.lane, y = h.eventTime;
        if ((d & r) === r) {
          null !== m && (m = m.next = {
            eventTime: y,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n = a, t = h;
            r = b;
            y = c;
            switch (t.tag) {
              case 1:
                n = t.payload;
                if ("function" === typeof n) {
                  q = n.call(y, q, r);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t.payload;
                r = "function" === typeof n ? n.call(y, q, r) : n;
                if (null === r || void 0 === r) break a;
                q = A({}, q, r);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
        } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh2 = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh2, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh2);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh2, a), G(uh, c));
  }
  function Bh(a) {
    vh2.current === a && (E(uh), E(vh2));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N, e = d.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d = d.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d : k.next = h;
      He(d, b.memoizedState) || (dh = true);
      b.memoizedState = d;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
    f && (d.memoizedState = e, dh = true);
    d = d.queue;
    $h(ai.bind(null, c, d, a), [a]);
    if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c;
    b.getSnapshot = d;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    a = { tag: a, create: b, destroy: c, deps: d, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = void 0 === d ? null : d;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d && Mh(d, g.deps)) {
        e.memoizedState = bi(b, c, f, d);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Mh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d = yi(a);
    c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), null !== c) {
      var e = R();
      gi(c, a, d, e);
      Bi(c, b, d);
    }
  }
  function ii(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d);
      null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d = b.lanes;
      d &= a.pendingLanes;
      c |= d;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d,
      f,
      a
    ), [a]);
    d.flags |= 2048;
    bi(9, ci.bind(null, d, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R(), e = yi(a), f = mh(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d = yi(a), e = mh(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d);
    null !== b && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if ("function" === typeof d) {
      var e = b.value;
      c.payload = function() {
        return d(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c6 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c6 ? c6 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (null === d) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d) {
    b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d = Nh(a, b, c, d, f, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d, e);
    return b.child;
  }
  function $i(a, b, c, d, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
      a = Rg(c.type, null, d, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d;
    }
    else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d, f, e);
    d = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
    else if (null === a) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
      jh = false;
      var r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      k = b.memoizedState;
      h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l;
      q = b.pendingProps;
      r = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y = c.getDerivedStateFromProps;
      (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
      jh = false;
      r = b.memoizedState;
      g.state = r;
      qh(b, d, g, e);
      var n = b.memoizedState;
      h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
    }
    return jj(a, b, c, d, f, e);
  }
  function jj(a, b, c, d, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
    d = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
    b.memoizedState = d.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d.children;
      a = d.fallback;
      return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
    if (f) {
      f = d.fallback;
      g = b.mode;
      e = a.child;
      h = e.sibling;
      var k = { mode: "hidden", children: d.children };
      0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d.return = b;
      d.sibling = f;
      b.child = d;
      d = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d;
    }
    f = a.child;
    a = f.sibling;
    d = Pg(f, { mode: "visible", children: d.children });
    0 === (b.mode & 1) && (d.lanes = c);
    d.return = b;
    d.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d;
    b.memoizedState = null;
    return d;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d) {
    null !== d && Jg(d);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d.fallback;
      e = b.mode;
      d = pj({ mode: "visible", children: d.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d.return = b;
      f.return = b;
      d.sibling = f;
      b.child = d;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d = e.nextSibling && e.nextSibling.dataset;
      if (d) var h = d.dgst;
      d = h;
      f = Error(p(419));
      d = Ki(f, d, void 0);
      return sj(a, b, g, d);
    }
    h = 0 !== (g & a.childLanes);
    if (dh || h) {
      d = Q;
      if (null !== d) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      tj();
      d = Ki(Error(p(421)));
      return sj(a, b, g, d);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    null !== d && (d.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f = d.tail;
    Xi(a, b, d.children, c);
    d = L.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    G(L, d);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G(Wg, d._currentValue);
        d._currentValue = e;
        break;
      case 13:
        d = b.memoizedState;
        if (null !== d) {
          if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d = A({}, d, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
      }
      ub(c, d);
      var g;
      c = null;
      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];
        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d) {
        var k = d[l];
        h = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[Of] = b;
            d[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d);
                D("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d);
                break;
              case "source":
                D("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d
                );
                D("load", d);
                break;
              case "details":
                D("toggle", d);
                break;
              case "input":
                Za(d, f);
                D("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d);
                break;
              case "textarea":
                hb(d, f), D("invalid", d);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d.textContent,
                h,
                a
              ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d);
                db(d, f, true);
                break;
              case "textarea":
                Va(d);
                jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d.onclick = Bf);
            }
            d = e;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D("error", a);
                  e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d;
                  break;
                case "details":
                  D("toggle", a);
                  e = d;
                  break;
                case "input":
                  Za(a, d);
                  e = Ya(a, d);
                  D("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple };
                  e = A({}, d, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d);
                  e = gb(a, d);
                  D("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e);
              h = e;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d.value && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple;
                  f = d.value;
                  null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = true;
                  break a;
                default:
                  d = false;
              }
            }
            d && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
        else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d = b.stateNode;
            c = b.memoizedProps;
            d[Of] = b;
            if (f = d.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d && null !== d.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d = null !== d;
        d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d = g.updateQueue;
              null !== d && (b.updateQueue = d, b.flags |= 4);
              b.subtreeFlags = 0;
              d = c;
              for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d) {
      W(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W(a, b, d);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
          b: for (; ; ) {
            for (var y; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
              q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y = q.firstChild)) break;
              r = q;
              q = y;
            }
            for (; ; ) {
              if (q === a) break b;
              r === c && ++l === e && (h = g);
              r === f && ++m === d && (k = g);
              if (null !== (y = q.nextSibling)) break;
              q = r;
              r = q.parentNode;
            }
            q = y;
          }
          c = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
              x.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    d = null !== d ? d.lastEffect : null;
    if (null !== d) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X2 = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d = X2, e = Xj;
        X2 = null;
        Yj(a, b, c);
        X2 = d;
        Xj = e;
        null !== X2 && (Xj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X2.removeChild(c.stateNode));
        break;
      case 18:
        null !== X2 && (Xj ? (a = X2, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X2, c.stateNode));
        break;
      case 4:
        d = X2;
        e = Xj;
        X2 = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X2 = d;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
          e = d = d.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h) {
          W(c, b, h);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f = a, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X2 = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X2 = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X2 = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X2) throw Error(p(160));
        Zj(f, g, e);
        X2 = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t) {
            W(a, a.return, t);
          }
          try {
            Pj(5, a, a.return);
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W(a, a.return, t);
          }
        }
        if (d & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
            vb(h, g);
            var l = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
            }
            switch (h) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y = f.value;
                null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t) {
          W(a, a.return, t);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d & 4 && ak(a);
        break;
      case 22:
        m = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
            for (q = V = m; null !== V; ) {
              r = V;
              y = r.child;
              switch (r.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r, r.return);
                  break;
                case 1:
                  Lj(r, r.return);
                  var n = r.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d = r;
                    c = r.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W(d, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r, r.return);
                  break;
                case 22:
                  if (null !== r.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y ? (y.return = r, V = y) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t) {
                  W(a, a.return, t);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t) {
                W(a, a.return, t);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d.stateNode.containerInfo, h = Uj(a);
            Vj(a, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e;
          Jj = h;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r) {
          W(b, b.return, r);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d = b.stateNode;
            if ("function" === typeof d.componentDidMount) {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q ? Z : 0);
    if (0 === d) return null;
    if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
    else {
      b = d;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      if (6 === b) Ck(a, d);
      else {
        e = a.current.alternate;
        if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d);
            if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d) !== d) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d);
            if ((d & 4194240) === d) break;
            b = a.eventTimes;
            for (e = -1; 0 < d; ) {
              var g = 31 - oc(d);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d &= ~f;
            }
            d = e;
            d = B() - d;
            d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
            if (10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d = xc(a);
      0 !== d && (b = d, c = Nk(a, d));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d.next = g;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d = M.memoizedState; null !== d; ) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h = c, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r = m.alternate;
              r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y = Ui(g);
            if (null !== y) {
              y.flags &= -257;
              Vi(y, g, h, f, b);
              y.mode & 1 && Si(f, l, b);
              b = y;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k);
                b.updateQueue = t;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x = Ni(f, k, b);
                ph(f, x);
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d);
    } finally {
      ok.transition = e, C = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h;
      C = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V = l; null !== V; ) {
                    var m = V;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V = q;
                    else for (; null !== V; ) {
                      m = V;
                      var r = m.sibling, y = m.return;
                      Sj(m);
                      if (m === l) {
                        V = null;
                        break;
                      }
                      if (null !== r) {
                        r.return = y;
                        V = r;
                        break;
                      }
                      V = y;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J = t.sibling;
                      t.sibling = null;
                      t = J;
                    } while (null !== t);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x = f.sibling;
              if (null !== x) {
                x.return = f.return;
                V = x;
                break b;
              }
              V = f.return;
            }
          }
          var w = a.current;
          for (V = w; null !== V; ) {
            g = V;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
            else b: for (g = w; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V = F;
                break b;
              }
              V = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d = true;
        }
        return d;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d && d.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d._init;
          d = e(d._payload);
          b.type = d;
          e = b.tag = Zk(d);
          a = Ci(d, a);
          switch (e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d, null, c);
          var g = b.memoizedState;
          d = g.element;
          if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d._currentValue);
          d._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h = g.alternate;
              null !== h && (h.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d) {
    a = Bg(7, a, d, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d) {
    a = Bg(22, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f, g, h, k) {
    a = new al(a, b, c, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d, e, f, g, h, k) {
    a = bl(c, d, true, a, e, f, g, h, k);
    a.context = dl(null);
    c = a.current;
    d = R();
    e = yi(c);
    f = mh(d, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d);
    Dk(a, d);
    return a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if ("function" === typeof d) {
        var f = d;
        d = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el(b, d, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d) {
      var h = d;
      d = function() {
        var a2 = gl(k);
        h.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d);
    });
    return k;
  }
  function rl(a, b, c, d, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a2 = gl(g);
          h.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c6 = R();
            gi(b2, a, 1, c6);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d = R();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d);
              bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const PresenceContext = reactExports.createContext(null);
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const { nonce } = reactExports.useContext(MotionConfigContext);
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left } = size.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size, children: reactExports.cloneElement(children, { ref }) });
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const memoizedOnExitComplete = reactExports.useCallback((childId) => {
    presenceChildren.set(childId, true);
    for (const isComplete of presenceChildren.values()) {
      if (!isComplete)
        return;
    }
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]);
  const context2 = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: memoizedOnExitComplete,
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context2, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = true) {
  const context2 = reactExports.useContext(PresenceContext);
  if (context2 === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context2;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe)
      register(id2);
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const isBrowser$1 = typeof window !== "undefined";
const useIsomorphicLayoutEffect$1 = isBrowser$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = reactExports.useRef(true);
  const pendingPresentChildren = reactExports.useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
  useIsomorphicLayoutEffect$1(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return;
  }
  const { forceRender } = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = () => {
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender === null || forceRender === void 0 ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
        onExitComplete && onExitComplete();
      }
    };
    return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom: isPresent ? void 0 : custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
  }) });
};
const noop$1 = (any2) => any2;
let invariant = noop$1;
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const progress = (from, to2, value) => {
  const toFromDifference = to2 - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
const MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame2 = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step2.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step2 = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame2;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame2.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame2] = [nextFrame2, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step2.process(frameData2);
      }
    }
  };
  return step2;
}
const stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps2 = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { read, resolveKeyframes, update: update2, preRender, render, postRender } = steps2;
  const processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    read.process(state);
    resolveKeyframes.process(state);
    update2.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule2 = stepsOrder.reduce((acc, key) => {
    const step2 = steps2[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step2.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps2[stepsOrder[i]].cancel(process2);
    }
  };
  return { schedule: schedule2, cancel, state, steps: steps2 };
}
const { schedule: frame$1, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$1, true);
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}
const MotionContext = reactExports.createContext({});
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context2) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context2 : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);
const SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a2, _b;
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !((_a2 = window.MotionHandoffIsComplete) === null || _a2 === void 0 ? void 0 : _a2.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect$1(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a3;
        (_a3 = window.MotionHandoffMarkAsComplete) === null || _a3 === void 0 ? void 0 : _a3.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  var _a2, _b;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context2 = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context2.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context2, children: [MeasureLayout2 && context2.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context2.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context2.visualElement, externalRef), visualState, isStatic, context2.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${(_b = (_a2 = Component.displayName) !== null && _a2 !== void 0 ? _a2 : Component.name) !== null && _b !== void 0 ? _b : ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a2;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a2 = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
const isKeyframesTarget = (v) => {
  return Array.isArray(v);
};
const isCustomValue = (v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
const resolveFinalValueInKeyframes = (v) => {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context2, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context2, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance) => onMount(props, instance, state);
  }
  return state;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context2 = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config2, props, context2, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context2, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context2 && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context2.initial;
    if (animate === void 0)
      animate = context2.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp$3 = (min2, max2, v) => {
  if (v > max2)
    return max2;
  if (v < min2)
    return min2;
  return v;
};
const number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
const alpha = {
  ...number,
  transform: (v) => clamp$3(0, 1, v)
};
const scale = {
  ...number,
  default: 1
};
const createUnitType = (unit) => ({
  test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px$1 = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
};
const browserNumberValueTypes = {
  // Border props
  borderWidth: px$1,
  borderTopWidth: px$1,
  borderRightWidth: px$1,
  borderBottomWidth: px$1,
  borderLeftWidth: px$1,
  borderRadius: px$1,
  radius: px$1,
  borderTopLeftRadius: px$1,
  borderTopRightRadius: px$1,
  borderBottomRightRadius: px$1,
  borderBottomLeftRadius: px$1,
  // Positioning props
  width: px$1,
  maxWidth: px$1,
  height: px$1,
  maxHeight: px$1,
  top: px$1,
  right: px$1,
  bottom: px$1,
  left: px$1,
  // Spacing props
  padding: px$1,
  paddingTop: px$1,
  paddingRight: px$1,
  paddingBottom: px$1,
  paddingLeft: px$1,
  margin: px$1,
  marginTop: px$1,
  marginRight: px$1,
  marginBottom: px$1,
  marginLeft: px$1,
  // Misc
  backgroundPositionX: px$1,
  backgroundPositionY: px$1
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px$1,
  translateX: px$1,
  translateY: px$1,
  translateZ: px$1,
  x: px$1,
  y: px$1,
  z: px$1,
  perspective: px$1,
  transformPerspective: px$1,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px$1
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px$1,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform2[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px$1.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px$1.transform(-offset);
  const pathLength = px$1.transform(length);
  const pathSpacing = px$1.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame$1.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch (e) {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      });
      frame$1.render(() => {
        buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate);
        renderSVG(instance, renderState);
      });
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent2(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config2 = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config2);
  };
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
class BaseGroupPlaybackControls {
  constructor(animations2) {
    this.stop = () => this.runAll("stop");
    this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => "finished" in animation ? animation.finished : animation));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => {
      if (supportsScrollTimeline() && animation.attachTimeline) {
        return animation.attachTimeline(timeline);
      } else if (typeof fallback === "function") {
        return fallback(animation);
      }
    });
    return () => {
      subscriptions.forEach((cancel, i) => {
        cancel && cancel();
        this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max2 = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max2 = Math.max(max2, this.animations[i].duration);
    }
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupPlaybackControls extends BaseGroupPlaybackControls {
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
}
function getValueTransition(transition, key) {
  return transition ? transition[key] || transition["default"] || transition : void 0;
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
function isGenerator(type) {
  return typeof type === "function";
}
function attachTimeline(animation, timeline) {
  animation.timeline = timeline;
  animation.onfinish = null;
}
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const supportsFlags = {
  linearEasing: void 0
};
function memoSupports(callback, supportsFlag) {
  const memoized = memo(callback);
  return () => {
    var _a2;
    return (_a2 = supportsFlags[supportsFlag]) !== null && _a2 !== void 0 ? _a2 : memoized();
  };
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e) {
    return false;
  }
  return true;
}, "linearEasing");
const generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i = 0; i < numPoints; i++) {
    points += easing(progress(0, numPoints - 1, i)) + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
function isWaapiSupportedEasing(easing) {
  return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function" && supportsLinearEasing()) {
    return generateLinearEasing(easing, duration);
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
const isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  var _a2;
  if (elementOrSelector instanceof Element) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    const elements = (_a2 = void 0) !== null && _a2 !== void 0 ? _a2 : root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function filterEvents$1(callback) {
  return (event) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    callback(event);
  };
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = filterEvents$1((enterEvent) => {
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = filterEvents$1((leaveEvent) => {
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    });
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  });
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(elementOrSelector, onPressStart, options = {}) {
  const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);
  const startPress = (startEvent) => {
    const element = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent) || isPressing.has(element))
      return;
    isPressing.add(element);
    const onPressEnd = onPressStart(startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
        return;
      }
      isPressing.delete(element);
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, options.useGlobalTarget || isNodeOrChild(element, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  elements.forEach((element) => {
    if (!isElementKeyboardAccessible(element) && element.getAttribute("tabindex") === null) {
      element.tabIndex = 0;
    }
    const target = options.useGlobalTarget ? window : element;
    target.addEventListener("pointerdown", startPress, eventOptions);
    element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);
  });
  return cancelEvents;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
let now$1;
function clearTime() {
  now$1 = void 0;
}
const time$1 = {
  now: () => {
    if (now$1 === void 0) {
      time$1.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now$1;
  },
  set: (newTime) => {
    now$1 = newTime;
    queueMicrotask(clearTime);
  }
};
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "11.17.0";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v, render = true) => {
      const currentTime = time$1.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time$1.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame$1.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time$1.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound2, upperBound2, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound2 + (upperBound2 - lowerBound2) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound2 = currentT;
    } else {
      lowerBound2 = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$1;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
const circIn = (p) => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const sanitize = (v) => Math.round(v * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type, testProp) => (v) => {
  return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
};
const splitColor = (aName, bName, cName) => (v) => {
  if (typeof v !== "string")
    return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v) => clamp$3(0, 255, v);
const rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
};
const rgba$1 = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v) {
  let r = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r += r;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba$1.transform
};
const hsla$1 = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v) => rgba$1.test(v) || hex.test(v) || hsla$1.test(v),
  parse: (v) => {
    if (rgba$1.test(v)) {
      return rgba$1.parse(v);
    } else if (hsla$1.test(v)) {
      return hsla$1.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba$1.transform(v) : hsla$1.transform(v);
  }
};
const colorRegex$1 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  var _a2, _b;
  return isNaN(v) && typeof v === "string" && (((_a2 = v.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) || 0) + (((_b = v.match(colorRegex$1)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split2 = tokenised.split(SPLIT_TOKEN);
  return { values, split: split2, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split: split2, types } = analyseComplexValue(source);
  const numSections = split2.length;
  return (v) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split2[i];
      if (v[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex$1 = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex$1,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex$1;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
const isNumOrPxType = (v) => v === number || v === px$1;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/u);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a2;
          (_a2 = element.getValue(key)) === null || _a2 === void 0 ? void 0 : _a2.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete());
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.isComplete = false;
    this.isAsync = false;
    this.needsMeasurement = false;
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame$1.read(readAllKeyframes);
        frame$1.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null) {
        if (i === 0) {
          const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
        }
      }
    }
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete)
      this.scheduleResolve();
  }
}
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable$1(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable$1(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const testValueType = (v) => (type) => type.test(v);
const auto = {
  test: (v) => v === "auto",
  parse: (v) => v
};
const dimensionValueTypes = [number, px$1, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a2;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a2 = this.removedTransforms) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex$1.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
}
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.createdAt = time$1.now();
    this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    if (!this.resolvedAt)
      return this.createdAt;
    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time$1.now();
    this.hasAttemptedResolve = true;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity)) {
      if (!delay2) {
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete === null || onComplete === void 0 ? void 0 : onComplete();
        this.resolveFinishedPromise();
        return;
      } else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    if (resolvedAnimation === false)
      return;
    this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.type = "keyframes";
    this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
}
const mixNumber$1 = (from, to2, progress2) => {
  return from + (to2 - from) * progress2;
};
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a, b) {
  return (p) => p > 0 ? b : a;
}
const mixLinearColor = (from, to2, v) => {
  const fromExpo = from * from;
  const expo = v * (to2 * to2 - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba$1, hsla$1];
const getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla$1) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to2) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to2);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to2);
  }
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba$1.transform(blended);
  };
};
const combineFunctions = (a, b) => (v) => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p) => p <= 0 ? origin : target;
  } else {
    return (p) => p >= 1 ? target : origin;
  }
}
function mixNumber(a, b) {
  return (p) => mixNumber$1(a, b, p);
}
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
function mixObject(a, b) {
  const output = { ...a, ...b };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  var _a2;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = (_a2 = origin.values[originIndex]) !== null && _a2 !== void 0 ? _a2 : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex$1.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
function mix(from, to2, p) {
  if (typeof from === "number" && typeof to2 === "number" && typeof p === "number") {
    return mixNumber$1(from, to2, p);
  }
  const mixer = getMixer(from);
  return mixer(from, to2);
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$3(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp$3(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp$3(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0;
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    }
  };
  return generator;
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
  const nearestBoundary = (v) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    }
  };
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const easingLookup = {
  linear: noop$1,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0);
    return easingLookup[definition];
  }
  return definition;
};
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop$1 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate$1(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v) => {
    if (isZeroDeltaRange && v < input[0])
      return output[0];
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp$3(input[0], input[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min2 = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate$1(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t) => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }
  };
}
const frameloopDriver = (update2) => {
  const passTimestamp = ({ timestamp }) => update2(timestamp);
  return {
    start: () => frame$1.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time$1.now()
  };
};
const generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
const percentToProgress = (percent2) => percent2 / 100;
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    this.holdTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.startTime = null;
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element);
    this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten();
    if (this._resolved) {
      Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: true, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$3(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now2 = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    } else if (this.state === "finished") {
      this.startTime = now2;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a2;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a2 = this.currentTime) !== null && _a2 !== void 0 ? _a2 : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time2) {
    this.startTime = 0;
    return this.tick(time2, true);
  }
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
const sampleDelta = 10;
const maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t = 0;
  while (!state.done && t < maxDuration) {
    state = sampleAnimation.sample(t);
    pregeneratedKeyframes.push(state.value);
    t += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    var _a2;
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
    if (!((_a2 = motionValue2.owner) === null || _a2 === void 0 ? void 0 : _a2.current)) {
      return false;
    }
    if (typeof ease2 === "string" && supportsLinearEasing() && isUnsupportedEase(ease2)) {
      ease2 = unsupportedEasingFunctions[ease2];
    }
    if (requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes;
      if (keyframes2.length === 1) {
        keyframes2[1] = keyframes2[0];
      }
      duration = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease2 = pregeneratedAnimation.ease;
      type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    if (this.pendingTimeline) {
      attachTimeline(animation, this.pendingTimeline);
      this.pendingTimeline = void 0;
    } else {
      animation.onfinish = () => {
        const { onComplete } = this.options;
        motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const { resolved } = this;
      if (!resolved)
        return noop$1;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop$1;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    if (animation.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle")
      return;
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished") {
      return;
    }
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: true
      });
      const sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop();
    this.cancel();
  }
  complete() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue2 && motionValue2.owner && motionValue2.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !motionValue2.owner.getProps().onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame$1.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return new GroupPlaybackControls([]);
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a2;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a2 = visualElement.latestValues[key]) !== null && _a2 !== void 0 ? _a2 : null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame$1);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame$1.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a2;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context3 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context3.initial = visualElement.props.initial;
    }
    return context3;
  }
  const context2 = {};
  for (let i = 0; i < numVariantProps; i++) {
    const name = variantProps[i];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context2[name] = prop;
    }
  }
  return context2;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a2;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a2 = visualElement.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context2 = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context2[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context2[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a2;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach((child) => {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a2;
    this.node.animationState.reset();
    (_a2 = this.unmountControls) === null || _a2 === void 0 ? void 0 : _a2.call(this);
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers2, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame$1.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers2;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers2;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers2) {
    this.handlers = handlers2;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$3(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
  transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame$1.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis((axis) => {
      var _a2;
      return this.getAnimationState(axis) === "paused" && ((_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.play());
    });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame$1.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a2;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a2;
      return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.pause();
    });
  }
  getAnimationState(axis) {
    var _a2;
    return (_a2 = this.getAxisMotionValue(axis).animation) === null || _a2 === void 0 ? void 0 : _a2.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame$1.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop$1;
    this.removeListeners = noop$1;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$1;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame$1.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$1;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame$1.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px$1.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex$1.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex$1.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame$1.postRender(() => {
          const stack2 = projection.getStack();
          if (!stack2 || !stack2.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start2 = time$1.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start2;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame$1.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px$1.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$1);
function compress(min2, max2, easing) {
  return (p) => {
    if (p < min2)
      return 0;
    if (p > max2)
      return 1;
    return easing(progress(min2, max2, p));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform2 = `perspective(${transformPerspective}px) ${transform2}`;
    if (rotate)
      transform2 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform2 += `skewX(${skewX}deg) `;
    if (skewY)
      transform2 += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
const metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
const isDebug = typeof window !== "undefined" && window.MotionDebug !== void 0;
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = { visibility: "hidden" };
const animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame$1, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (isDebug) {
          metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (isDebug) {
          window.MotionDebug.record(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack2 = this.getStack();
      stack2 && stack2.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time$1.now();
      frameData.delta = clamp$3(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame$1.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame$1.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a2;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a2 = this.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a2;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a2 = this.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (isDebug) {
        metrics.resolvedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a2;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (isDebug) {
        metrics.recalculatedProjection++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2;
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.scheduleRender();
      if (notifyAll) {
        const stack2 = this.getStack();
        stack2 && stack2.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack2 = this.getStack();
      const isOnlyMember = !stack2 || stack2.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame$1.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack2 = this.getStack();
      stack2 && stack2.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack2 = this.sharedNodes.get(layoutId);
      stack2.add(node);
      const config2 = node.options.initialPromotionConfig;
      node.promote({
        transition: config2 ? config2.transition : void 0,
        preserveFollowOpacity: config2 && config2.shouldPreserveFollowOpacity ? config2.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack2 = this.getStack();
      return stack2 ? stack2.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack2 = this.getStack();
      if (stack2)
        stack2.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack2 = this.getStack();
      if (stack2) {
        return stack2.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a2, _b;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x, y } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b = (_a2 = valuesToRender.opacity) !== null && _a2 !== void 0 ? _a2 : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2;
  const snapshot = ((_a2 = node.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (isDebug) {
    metrics.totalNodes++;
  }
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack2) {
  stack2.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber$1(delta.translate, 0, p);
  output.scale = mixNumber$1(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to2, p) {
  output.min = mixNumber$1(from.min, to2.min, p);
  output.max = mixNumber$1(from.max, to2.max, p);
}
function mixBox(output, from, to2, p) {
  mixAxis(output.x, from.x, to2.x, p);
  mixAxis(output.y, from.y, to2.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string2) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string2);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node) {
  var _a2;
  return node !== node.root && ((_a2 = node.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame$1.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame$1.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once: once2 } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once2 && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser$1)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const valueTypes = [...dimensionValueTypes, color, complex$1];
const findValueType = (v) => valueTypes.find(testValueType(v));
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time$1.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame$1.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame$1.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a2;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a2 = this.getBaseTargetFromProps(this.props, key)) !== null && _a2 !== void 0 ? _a2 : this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex$1.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a2;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a2 = this.presenceContext) === null || _a2 === void 0 ? void 0 : _a2.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
function getComputedStyle(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment
  });
};
const createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);
const motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);
class DragControls {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    this.componentControls.add(controls);
    return () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach((controls) => {
      controls.start(event.nativeEvent || event, options);
    });
  }
}
const createDragControls = () => new DragControls();
function useDragControls() {
  return useConstant(createDragControls);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const EPSILON_FLOAT32 = 1e-7;
const EPSILON_FLOAT16 = 1e-4;
class DataStorage {
  constructor(backend2, dataMover) {
    this.backend = backend2;
    this.dataMover = dataMover;
    this.data = /* @__PURE__ */ new WeakMap();
    this.dataIdsCount = 0;
  }
  get(dataId) {
    if (!this.data.has(dataId)) {
      this.dataMover.moveData(this.backend, dataId);
    }
    return this.data.get(dataId);
  }
  set(dataId, value) {
    this.dataIdsCount++;
    this.data.set(dataId, value);
  }
  has(dataId) {
    return this.data.has(dataId);
  }
  delete(dataId) {
    this.dataIdsCount--;
    return this.data.delete(dataId);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
}
class KernelBackend {
  refCount(dataId) {
    return notYetImplemented("refCount");
  }
  incRef(dataId) {
    return notYetImplemented("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(f) {
    return notYetImplemented("time");
  }
  read(dataId) {
    return notYetImplemented("read");
  }
  readSync(dataId) {
    return notYetImplemented("readSync");
  }
  readToGPU(dataId, options) {
    return notYetImplemented("readToGPU");
  }
  numDataIds() {
    return notYetImplemented("numDataIds");
  }
  disposeData(dataId, force) {
    return notYetImplemented("disposeData");
  }
  write(values, shape, dtype) {
    return notYetImplemented("write");
  }
  move(dataId, values, shape, dtype, refCount) {
    return notYetImplemented("move");
  }
  createTensorFromGPUData(values, shape, dtype) {
    return notYetImplemented("createTensorFromGPUData");
  }
  memory() {
    return notYetImplemented("memory");
  }
  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */
  floatPrecision() {
    return notYetImplemented("floatPrecision");
  }
  /** Returns the smallest representable number.  */
  epsilon() {
    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
  }
  dispose() {
    return notYetImplemented("dispose");
  }
}
function notYetImplemented(kernelName) {
  throw new Error(`'${kernelName}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function shuffle(array) {
  let counter = array.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array, counter, index);
  }
}
function shuffleCombo(array, array2) {
  if (array.length !== array2.length) {
    throw new Error(`Array sizes must match to be shuffled together First array length was ${array.length}Second array length was ${array2.length}`);
  }
  let counter = array.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array, counter, index);
    swap(array2, counter, index);
  }
}
function clamp$2(min2, x, max2) {
  return Math.max(min2, Math.min(x, max2));
}
function nearestLargerEven(val) {
  return val % 2 === 0 ? val : val + 1;
}
function swap(object, left, right) {
  const temp = object[left];
  object[left] = object[right];
  object[right] = temp;
}
function sum$1(arr) {
  let sum2 = 0;
  for (let i = 0; i < arr.length; i++) {
    sum2 += arr[i];
  }
  return sum2;
}
function randUniform(a, b) {
  const r = Math.random();
  return b * r + (1 - r) * a;
}
function distSquared(a, b) {
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    const diff = Number(a[i]) - Number(b[i]);
    result += diff * diff;
  }
  return result;
}
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
  assert(arraysEqual$1(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function assertNonNull(a) {
  assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
}
function sizeFromShape(shape) {
  if (shape.length === 0) {
    return 1;
  }
  let size = shape[0];
  for (let i = 1; i < shape.length; i++) {
    size *= shape[i];
  }
  return size;
}
function isScalarShape(shape) {
  return shape.length === 0;
}
function arraysEqualWithNull(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0; i < n1.length; i++) {
    if (n1[i] !== null && n2[i] !== null && n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}
function arraysEqual$1(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0; i < n1.length; i++) {
    if (n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}
function isInt(a) {
  return a % 1 === 0;
}
function tanh$1(x) {
  if (Math.tanh != null) {
    return Math.tanh(x);
  }
  if (x === Infinity) {
    return 1;
  } else if (x === -Infinity) {
    return -1;
  } else {
    const e2x = Math.exp(2 * x);
    return (e2x - 1) / (e2x + 1);
  }
}
function sizeToSquarishShape(size) {
  const width = Math.ceil(Math.sqrt(size));
  return [width, Math.ceil(size / width)];
}
function createShuffledIndices(n) {
  const shuffledIndices = new Uint32Array(n);
  for (let i = 0; i < n; ++i) {
    shuffledIndices[i] = i;
  }
  shuffle(shuffledIndices);
  return shuffledIndices;
}
function rightPad(a, size) {
  if (size <= a.length) {
    return a;
  }
  return a + " ".repeat(size - a.length);
}
function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter, scheduleFn) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      if (scheduleFn != null) {
        scheduleFn(tryFn, nextBackoff);
      } else {
        setTimeout(tryFn, nextBackoff);
      }
    };
    tryFn();
  });
}
function inferFromImplicitShape(shape, size) {
  let shapeProd = 1;
  let implicitIdx = -1;
  for (let i = 0; i < shape.length; ++i) {
    if (shape[i] >= 0) {
      shapeProd *= shape[i];
    } else if (shape[i] === -1) {
      if (implicitIdx !== -1) {
        throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${implicitIdx} and dim ${i}`);
      }
      implicitIdx = i;
    } else if (shape[i] < 0) {
      throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
    }
  }
  if (implicitIdx === -1) {
    if (size > 0 && size !== shapeProd) {
      throw Error(`Size(${size}) must match the product of shape ${shape}`);
    }
    return shape;
  }
  if (shapeProd === 0) {
    throw Error(`Cannot infer the missing size in [${shape}] when there are 0 elements`);
  }
  if (size % shapeProd !== 0) {
    throw Error(`The implicit shape can't be a fractional number. Got ${size} / ${shapeProd}`);
  }
  const newShape = shape.slice();
  newShape[implicitIdx] = size / shapeProd;
  return newShape;
}
function parseAxisParam(axis, shape) {
  const rank = shape.length;
  axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
  assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`);
  assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but got axis ${axis}`);
  return axis.map((a) => a < 0 ? rank + a : a);
}
function squeezeShape(shape, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
  let j = 0;
  for (let i = 0; i < shape.length; ++i) {
    if (axes != null) {
      if (axes[j] === i && shape[i] !== 1) {
        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
      }
      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
        newShape.push(shape[i]);
        keptDims.push(i);
      }
      if (axes[j] <= i) {
        j++;
      }
    }
    if (shape[i] !== 1) {
      newShape.push(shape[i]);
      keptDims.push(i);
    }
  }
  return { newShape, keptDims };
}
function getTypedArrayFromDType(dtype, size) {
  return getArrayFromDType(dtype, size);
}
function getArrayFromDType(dtype, size) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else if (dtype === "string") {
    values = new Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function checkConversionForErrors(vals, dtype) {
  for (let i = 0; i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
    }
  }
}
function isValidDtype(dtype) {
  return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
}
function hasEncodingLoss(oldType, newType) {
  if (newType === "complex64") {
    return false;
  }
  if (newType === "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "bool" && oldType === "bool") {
    return false;
  }
  return true;
}
function bytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else if (dtype === "bool") {
    return 1;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function bytesFromStringArray(arr) {
  if (arr == null) {
    return 0;
  }
  let bytes = 0;
  arr.forEach((x) => bytes += x.length);
  return bytes;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isNumber(value) {
  return typeof value === "number";
}
function inferDtype(values) {
  if (Array.isArray(values)) {
    return inferDtype(values[0]);
  }
  if (values instanceof Float32Array) {
    return "float32";
  } else if (values instanceof Int32Array || values instanceof Uint8Array || values instanceof Uint8ClampedArray) {
    return "int32";
  } else if (isNumber(values)) {
    return "float32";
  } else if (isString(values)) {
    return "string";
  } else if (isBoolean(values)) {
    return "bool";
  }
  return "float32";
}
function isFunction(f) {
  return !!(f && f.constructor && f.call && f.apply);
}
function nearestDivisor(size, start2) {
  for (let i = start2; i < size; ++i) {
    if (size % i === 0) {
      return i;
    }
  }
  return size;
}
function computeStrides(shape) {
  const rank = shape.length;
  if (rank < 2) {
    return [];
  }
  const strides = new Array(rank - 1);
  strides[rank - 2] = shape[rank - 1];
  for (let i = rank - 3; i >= 0; --i) {
    strides[i] = strides[i + 1] * shape[i + 1];
  }
  return strides;
}
function createNestedArray(offset, shape, a, isComplex = false) {
  const ret = new Array();
  if (shape.length === 1) {
    const d = shape[0] * (isComplex ? 2 : 1);
    for (let i = 0; i < d; i++) {
      ret[i] = a[offset + i];
    }
  } else {
    const d = shape[0];
    const rest = shape.slice(1);
    const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
    for (let i = 0; i < d; i++) {
      ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);
    }
  }
  return ret;
}
function toNestedArray(shape, a, isComplex = false) {
  if (shape.length === 0) {
    return a[0];
  }
  const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
  if (size === 0) {
    return [];
  }
  if (size !== a.length) {
    throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? " for a complex tensor" : ""}.`);
  }
  return createNestedArray(0, shape, a, isComplex);
}
function convertBackendValuesAndArrayBuffer(data, dtype) {
  if (Array.isArray(data)) {
    return data;
  }
  if (dtype === "float32") {
    return data instanceof Float32Array ? data : new Float32Array(data);
  } else if (dtype === "int32") {
    return data instanceof Int32Array ? data : new Int32Array(data);
  } else if (dtype === "bool" || dtype === "string") {
    return Uint8Array.from(new Int32Array(data));
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function makeOnesTypedArray(size, dtype) {
  const array = makeZerosTypedArray(size, dtype);
  for (let i = 0; i < array.length; i++) {
    array[i] = 1;
  }
  return array;
}
function makeZerosTypedArray(size, dtype) {
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(size);
  } else if (dtype === "int32") {
    return new Int32Array(size);
  } else if (dtype === "bool") {
    return new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function makeZerosNestedTypedArray(shape, dtype) {
  const size = shape.reduce((prev, curr) => prev * curr, 1);
  if (dtype == null || dtype === "float32") {
    return toNestedArray(shape, new Float32Array(size));
  } else if (dtype === "int32") {
    return toNestedArray(shape, new Int32Array(size));
  } else if (dtype === "bool") {
    return toNestedArray(shape, new Uint8Array(size));
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function assertNonNegativeIntegerDimensions(shape) {
  shape.forEach((dimSize) => {
    assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${shape}].`);
  });
}
function locToIndex(locs, rank, strides) {
  if (rank === 0) {
    return 0;
  } else if (rank === 1) {
    return locs[0];
  }
  let index = locs[locs.length - 1];
  for (let i = 0; i < locs.length - 1; ++i) {
    index += strides[i] * locs[i];
  }
  return index;
}
function indexToLoc(index, rank, strides) {
  if (rank === 0) {
    return [];
  } else if (rank === 1) {
    return [index];
  }
  const locs = new Array(rank);
  for (let i = 0; i < locs.length - 1; ++i) {
    locs[i] = Math.floor(index / strides[i]);
    index -= locs[i] * strides[i];
  }
  locs[locs.length - 1] = index;
  return locs;
}
function isPromise(object) {
  return object && object.then && typeof object.then === "function";
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags";
class Environment {
  // tslint:disable-next-line: no-any
  constructor(global2) {
    this.global = global2;
    this.flags = {};
    this.flagRegistry = {};
    this.urlFlags = {};
    this.getQueryParams = getQueryParams;
    this.populateURLFlags();
  }
  setPlatform(platformName, platform) {
    if (this.platform != null) {
      if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
        console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${platformName}.`);
      }
    }
    this.platformName = platformName;
    this.platform = platform;
  }
  registerFlag(flagName, evaluationFn, setHook) {
    this.flagRegistry[flagName] = { evaluationFn, setHook };
    if (this.urlFlags[flagName] != null) {
      const flagValue = this.urlFlags[flagName];
      if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
        console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
      }
      this.set(flagName, flagValue);
    }
  }
  async getAsync(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    this.flags[flagName] = await this.evaluateFlag(flagName);
    return this.flags[flagName];
  }
  get(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    const flagValue = this.evaluateFlag(flagName);
    if (isPromise(flagValue)) {
      throw new Error(`Flag ${flagName} cannot be synchronously evaluated. Please use getAsync() instead.`);
    }
    this.flags[flagName] = flagValue;
    return this.flags[flagName];
  }
  getNumber(flagName) {
    return this.get(flagName);
  }
  getBool(flagName) {
    return this.get(flagName);
  }
  getString(flagName) {
    return this.get(flagName);
  }
  getFlags() {
    return this.flags;
  }
  // For backwards compatibility.
  get features() {
    return this.flags;
  }
  set(flagName, value) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
    }
    this.flags[flagName] = value;
    if (this.flagRegistry[flagName].setHook != null) {
      this.flagRegistry[flagName].setHook(value);
    }
  }
  evaluateFlag(flagName) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
    }
    return this.flagRegistry[flagName].evaluationFn();
  }
  setFlags(flags) {
    this.flags = Object.assign({}, flags);
  }
  reset() {
    this.flags = {};
    this.urlFlags = {};
    this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
      return;
    }
    const urlParams = this.getQueryParams(this.global.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
      keyValues.forEach((keyValue) => {
        const [key, value] = keyValue.split(":");
        this.urlFlags[key] = parseValue(key, value);
      });
    }
  }
}
function getQueryParams(queryString) {
  const params = {};
  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
    decodeParam(params, t[0], t[1]);
    return t.join("=");
  });
  return params;
}
function decodeParam(params, name, value) {
  params[decodeURIComponent(name)] = decodeURIComponent(value || "");
}
function parseValue(flagName, value) {
  const lowerCaseValue = value.toLowerCase();
  if (lowerCaseValue === "true" || lowerCaseValue === "false") {
    return lowerCaseValue === "true";
  } else if (`${+lowerCaseValue}` === lowerCaseValue) {
    return +lowerCaseValue;
  } else {
    return value;
  }
}
function env() {
  return ENV$2;
}
let ENV$2 = null;
function setEnvironmentGlobal(environment) {
  ENV$2 = environment;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let globalNameSpace;
function getGlobalNamespace() {
  if (globalNameSpace == null) {
    let ns;
    if (typeof window !== "undefined") {
      ns = window;
    } else if (typeof global !== "undefined") {
      ns = global;
    } else if (typeof process !== "undefined") {
      ns = process;
    } else if (typeof self !== "undefined") {
      ns = self;
    } else {
      throw new Error("Could not find a global object");
    }
    globalNameSpace = ns;
  }
  return globalNameSpace;
}
function getGlobalMap() {
  const ns = getGlobalNamespace();
  if (ns._tfGlobals == null) {
    ns._tfGlobals = /* @__PURE__ */ new Map();
  }
  return ns._tfGlobals;
}
function getGlobal(key, init) {
  const globalMap = getGlobalMap();
  if (globalMap.has(key)) {
    return globalMap.get(key);
  } else {
    const singleton = init();
    globalMap.set(key, singleton);
    return globalMap.get(key);
  }
}
const Abs = "Abs";
const Acos = "Acos";
const Acosh = "Acosh";
const Add = "Add";
const AddN = "AddN";
const All = "All";
const Any = "Any";
const ArgMax = "ArgMax";
const ArgMin = "ArgMin";
const Asin = "Asin";
const Asinh = "Asinh";
const Atan = "Atan";
const Atanh = "Atanh";
const Atan2 = "Atan2";
const AvgPool = "AvgPool";
const AvgPoolGrad = "AvgPoolGrad";
const AvgPool3D = "AvgPool3D";
const AvgPool3DGrad = "AvgPool3DGrad";
const BatchMatMul = "BatchMatMul";
const BatchToSpaceND = "BatchToSpaceND";
const Bincount = "Bincount";
const BitwiseAnd = "BitwiseAnd";
const BroadcastTo = "BroadcastTo";
const BroadcastArgs = "BroadcastArgs";
const Cast = "Cast";
const Ceil = "Ceil";
const ClipByValue = "ClipByValue";
const Complex = "Complex";
const ComplexAbs = "ComplexAbs";
const Concat = "Concat";
const Conv2D = "Conv2D";
const Conv2DBackpropFilter = "Conv2DBackpropFilter";
const Conv2DBackpropInput = "Conv2DBackpropInput";
const Conv3D = "Conv3D";
const Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2";
const Conv3DBackpropInputV2 = "Conv3DBackpropInputV2";
const Cos = "Cos";
const Cosh = "Cosh";
const Cumprod = "Cumprod";
const Cumsum = "Cumsum";
const CropAndResize = "CropAndResize";
const DenseBincount = "DenseBincount";
const DepthToSpace = "DepthToSpace";
const DepthwiseConv2dNative = "DepthwiseConv2dNative";
const DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter";
const DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput";
const Diag = "Diag";
const Dilation2D = "Dilation2D";
const Dilation2DBackpropInput = "Dilation2DBackpropInput";
const Dilation2DBackpropFilter = "Dilation2DBackpropFilter";
const Draw = "Draw";
const RealDiv = "RealDiv";
const Einsum = "Einsum";
const Elu = "Elu";
const EluGrad = "EluGrad";
const Erf = "Erf";
const Equal = "Equal";
const Exp = "Exp";
const ExpandDims = "ExpandDims";
const Expm1 = "Expm1";
const FFT = "FFT";
const Fill = "Fill";
const FlipLeftRight = "FlipLeftRight";
const Floor = "Floor";
const FloorDiv = "FloorDiv";
const FusedBatchNorm = "FusedBatchNorm";
const GatherV2 = "GatherV2";
const GatherNd = "GatherNd";
const Greater = "Greater";
const GreaterEqual = "GreaterEqual";
const Identity = "Identity";
const IFFT = "IFFT";
const Imag = "Imag";
const IsFinite = "IsFinite";
const IsInf = "IsInf";
const IsNan = "IsNan";
const LeakyRelu = "LeakyRelu";
const Less = "Less";
const LessEqual = "LessEqual";
const LinSpace = "LinSpace";
const Log = "Log";
const Log1p = "Log1p";
const LogicalAnd = "LogicalAnd";
const LogicalNot = "LogicalNot";
const LogicalOr = "LogicalOr";
const LogicalXor = "LogicalXor";
const LogSoftmax = "LogSoftmax";
const LowerBound = "LowerBound";
const LRN = "LRN";
const LRNGrad = "LRNGrad";
const MatrixBandPart = "MatrixBandPart";
const Max = "Max";
const Maximum = "Maximum";
const MaxPool = "MaxPool";
const MaxPoolGrad = "MaxPoolGrad";
const MaxPool3D = "MaxPool3D";
const MaxPool3DGrad = "MaxPool3DGrad";
const MaxPoolWithArgmax = "MaxPoolWithArgmax";
const Mean = "Mean";
const Min = "Min";
const Minimum = "Minimum";
const MirrorPad = "MirrorPad";
const Mod = "Mod";
const Multinomial = "Multinomial";
const Multiply = "Multiply";
const Neg = "Neg";
const NotEqual = "NotEqual";
const NonMaxSuppressionV3 = "NonMaxSuppressionV3";
const NonMaxSuppressionV4 = "NonMaxSuppressionV4";
const NonMaxSuppressionV5 = "NonMaxSuppressionV5";
const OnesLike = "OnesLike";
const OneHot = "OneHot";
const Pack = "Pack";
const PadV2 = "PadV2";
const Pool = "Pool";
const Pow = "Pow";
const Prelu = "Prelu";
const Prod = "Prod";
const RaggedGather = "RaggedGather";
const RaggedRange = "RaggedRange";
const RaggedTensorToTensor = "RaggedTensorToTensor";
const Range = "Range";
const Real = "Real";
const Reciprocal = "Reciprocal";
const Relu = "Relu";
const Reshape = "Reshape";
const ResizeNearestNeighbor = "ResizeNearestNeighbor";
const ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad";
const ResizeBilinear = "ResizeBilinear";
const ResizeBilinearGrad = "ResizeBilinearGrad";
const Relu6 = "Relu6";
const Reverse = "Reverse";
const Round = "Round";
const Rsqrt = "Rsqrt";
const ScatterNd = "ScatterNd";
const TensorScatterUpdate = "TensorScatterUpdate";
const SearchSorted = "SearchSorted";
const Select = "Select";
const Selu = "Selu";
const Slice = "Slice";
const Sin = "Sin";
const Sinh = "Sinh";
const Sign = "Sign";
const Sigmoid = "Sigmoid";
const Softplus = "Softplus";
const Sqrt = "Sqrt";
const Sum = "Sum";
const SpaceToBatchND = "SpaceToBatchND";
const SplitV = "SplitV";
const Softmax = "Softmax";
const SparseFillEmptyRows = "SparseFillEmptyRows";
const SparseReshape = "SparseReshape";
const SparseSegmentMean = "SparseSegmentMean";
const SparseSegmentSum = "SparseSegmentSum";
const SparseToDense = "SparseToDense";
const SquaredDifference = "SquaredDifference";
const Square = "Square";
const StaticRegexReplace = "StaticRegexReplace";
const StridedSlice = "StridedSlice";
const StringNGrams = "StringNGrams";
const StringSplit = "StringSplit";
const StringToHashBucketFast = "StringToHashBucketFast";
const Sub = "Sub";
const Tan = "Tan";
const Tanh = "Tanh";
const Tile = "Tile";
const TopK = "TopK";
const Transform = "Transform";
const Transpose = "Transpose";
const Unique = "Unique";
const Unpack = "Unpack";
const UnsortedSegmentSum = "UnsortedSegmentSum";
const UpperBound = "UpperBound";
const ZerosLike = "ZerosLike";
const Step = "Step";
const FromPixels = "FromPixels";
const RotateWithOffset = "RotateWithOffset";
const _FusedMatMul = "_FusedMatMul";
const FusedConv2D = "FusedConv2D";
const FusedDepthwiseConv2D = "FusedDepthwiseConv2D";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function warn(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.warn(...msg);
  }
}
function log$1(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.log(...msg);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kernelRegistry = getGlobal("kernelRegistry", () => /* @__PURE__ */ new Map());
const gradRegistry = getGlobal("gradRegistry", () => /* @__PURE__ */ new Map());
function getKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  return kernelRegistry.get(key);
}
function getGradient(kernelName) {
  return gradRegistry.get(kernelName);
}
function getKernelsForBackend(backendName) {
  const it = kernelRegistry.entries();
  const result = [];
  while (true) {
    const { done, value } = it.next();
    if (done) {
      break;
    }
    const [key, config2] = value;
    const [backend2] = key.split("_");
    if (backend2 === backendName) {
      result.push(config2);
    }
  }
  return result;
}
function registerKernel(config2) {
  const { kernelName, backendName } = config2;
  const key = makeKey(kernelName, backendName);
  if (kernelRegistry.has(key)) {
    warn(`The kernel '${kernelName}' for backend '${backendName}' is already registered`);
  }
  kernelRegistry.set(key, config2);
}
function registerGradient(config2) {
  const { kernelName } = config2;
  if (gradRegistry.has(kernelName)) {
    if (env().getBool("DEBUG")) {
      warn(`Overriding the gradient for '${kernelName}'`);
    }
  }
  gradRegistry.set(kernelName, config2);
}
function unregisterKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  if (!kernelRegistry.has(key)) {
    throw new Error(`The kernel '${kernelName}' for backend '${backendName}' is not registered`);
  }
  kernelRegistry.delete(key);
}
function unregisterGradient(kernelName) {
  if (!gradRegistry.has(kernelName)) {
    throw new Error(`The gradient '${kernelName}' for backend is not registered`);
  }
  gradRegistry.delete(kernelName);
}
function copyRegisteredKernels(registeredBackendName, newBackendName) {
  const kernels = getKernelsForBackend(registeredBackendName);
  kernels.forEach((kernelConfig) => {
    const newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });
    registerKernel(newKernelConfig);
  });
}
function makeKey(kernelName, backendName) {
  return `${backendName}_${kernelName}`;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isTypedArrayBrowser(a) {
  return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array || a instanceof Uint8ClampedArray;
}
var long$1;
var hasRequiredLong;
function requireLong() {
  if (hasRequiredLong) return long$1;
  hasRequiredLong = 1;
  long$1 = Long2;
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  function Long2(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  Long2.prototype.__isLong__;
  Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  Long2.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  Long2.fromInt = fromInt;
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  Long2.fromNumber = fromNumber;
  function fromBits(lowBits, highBits, unsigned) {
    return new Long2(lowBits, highBits, unsigned);
  }
  Long2.fromBits = fromBits;
  var pow_dbl = Math.pow;
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return ZERO;
    if (typeof unsigned === "number") {
      radix = unsigned, unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  Long2.fromString = fromString;
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  Long2.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long2.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long2.UZERO = UZERO;
  var ONE = fromInt(1);
  Long2.ONE = ONE;
  var UONE = fromInt(1, true);
  Long2.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long2.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long2.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long2.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long2.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
        return div2.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals2(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(
      /* validates */
      other
    );
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(
      /* validates */
      other
    ) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(
      /* validates */
      other
    ) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(
      /* validates */
      other
    ) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add2(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return ZERO;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm.mul(
        this.low,
        this.high,
        multiplier.low,
        multiplier.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
        this.low,
        this.high,
        divisor.low,
        divisor.high
      );
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      var high = this.high;
      if (numBits < 32) {
        var low = this.low;
        return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return fromBits(high, 0, this.unsigned);
      else
        return fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long2.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long2.fromBytesLE(bytes, unsigned) : Long2.fromBytesBE(bytes, unsigned);
  };
  Long2.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long2(
      bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
      bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
      unsigned
    );
  };
  Long2.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long2(
      bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
      bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
      unsigned
    );
  };
  return long$1;
}
var longExports = requireLong();
const long = /* @__PURE__ */ getDefaultExportFromCjs(longExports);
const LongExports = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: long
}, [longExports]);
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const Long = (
  // tslint:disable-next-line
  long || LongExports
);
function hexToLong(hex2) {
  return Long.fromString(hex2, true, 16);
}
const k0 = hexToLong("c3a5c85c97cb3127");
const k1 = hexToLong("b492b66fbe98f273");
const k2 = hexToLong("9ae16a3b2f90404f");
function shiftMix(val) {
  return val.xor(val.shru(47));
}
function fetch$2(s, offset, numBytes) {
  const bytes = s.slice(offset, offset + numBytes);
  return Long.fromBytes(Array.from(bytes), true, true);
}
function fetch64(s, offset) {
  return fetch$2(s, offset, 8);
}
function fetch32(s, offset) {
  return fetch$2(s, offset, 4);
}
function rotate64(val, shift) {
  return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
}
function hashLen16(u, v, mul2 = hexToLong("9ddfea08eb382d69")) {
  let a = u.xor(v).mul(mul2);
  a = a.xor(a.shru(47));
  let b = v.xor(a).mul(mul2);
  b = b.xor(b.shru(47));
  b = b.mul(mul2);
  return b;
}
function weakHashLen32WithSeeds(w, x, y, z, a, b) {
  a = a.add(w);
  b = rotate64(b.add(a).add(z), 21);
  const c = a;
  a = a.add(x);
  a = a.add(y);
  b = b.add(rotate64(a, 44));
  return [a.add(z), b.add(c)];
}
function weakHashLen32WithSeedsStr(s, offset, a, b) {
  return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);
}
function hashLen0to16(s, len = s.length) {
  if (len >= 8) {
    const mul2 = k2.add(len * 2);
    const a = fetch64(s, 0).add(k2);
    const b = fetch64(s, len - 8);
    const c = rotate64(b, 37).mul(mul2).add(a);
    const d = rotate64(a, 25).add(b).mul(mul2);
    return hashLen16(c, d, mul2);
  }
  if (len >= 4) {
    const mul2 = k2.add(len * 2);
    const a = fetch32(s, 0);
    return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul2);
  }
  if (len > 0) {
    const a = s[0];
    const b = s[len >> 1];
    const c = s[len - 1];
    const y = a + (b << 8);
    const z = len + (c << 2);
    return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);
  }
  return k2;
}
function hashLen17to32(s, len = s.length) {
  const mul2 = k2.add(len * 2);
  const a = fetch64(s, 0).mul(k1);
  const b = fetch64(s, 8);
  const c = fetch64(s, len - 8).mul(mul2);
  const d = fetch64(s, len - 16).mul(k2);
  return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul2);
}
function hashLen33to64(s, len = s.length) {
  const mul2 = k2.add(len * 2);
  const a = fetch64(s, 0).mul(k2);
  const b = fetch64(s, 8);
  const c = fetch64(s, len - 8).mul(mul2);
  const d = fetch64(s, len - 16).mul(k2);
  const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);
  const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul2);
  const e = fetch64(s, 16).mul(mul2);
  const f = fetch64(s, 24);
  const g = y.add(fetch64(s, len - 32)).mul(mul2);
  const h = z.add(fetch64(s, len - 24)).mul(mul2);
  return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul2);
}
function fingerPrint64(s, len = s.length) {
  const seed = Long.fromNumber(81, true);
  if (len <= 32) {
    if (len <= 16) {
      return hashLen0to16(s, len);
    } else {
      return hashLen17to32(s, len);
    }
  } else if (len <= 64) {
    return hashLen33to64(s, len);
  }
  let x = seed;
  let y = seed.mul(k1).add(113);
  let z = shiftMix(y.mul(k2).add(113)).mul(k2);
  let v = [Long.UZERO, Long.UZERO];
  let w = [Long.UZERO, Long.UZERO];
  x = x.mul(k2).add(fetch64(s, 0));
  let offset = 0;
  const end = (len - 1 >> 6) * 64;
  const last64 = end + (len - 1 & 63) - 63;
  do {
    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);
    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);
    x = x.xor(w[1]);
    y = y.add(v[0]).add(fetch64(s, offset + 40));
    z = rotate64(z.add(w[0]), 33).mul(k1);
    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));
    w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
    [z, x] = [x, z];
    offset += 64;
  } while (offset !== end);
  const mul2 = k1.add(z.and(255).shl(1));
  offset = last64;
  w[0] = w[0].add(len - 1 & 63);
  v[0] = v[0].add(w[0]);
  w[0] = w[0].add(v[0]);
  x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul2);
  y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul2);
  x = x.xor(w[1].mul(9));
  y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));
  z = rotate64(z.add(w[0]), 33).mul(mul2);
  v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul2), x.add(w[0]));
  w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
  [z, x] = [x, z];
  return hashLen16(hashLen16(v[0], w[0], mul2).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul2).add(x), mul2);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function createScalarValue(value, dtype) {
  if (dtype === "string") {
    return encodeString(value);
  }
  return toTypedArray([value], dtype);
}
function noConversionNeeded(a, dtype) {
  return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
}
function toTypedArray(a, dtype) {
  if (dtype === "string") {
    throw new Error("Cannot convert a string[] to a TypedArray");
  }
  if (Array.isArray(a)) {
    a = flatten$1(a);
  }
  if (env().getBool("DEBUG")) {
    checkConversionForErrors(a, dtype);
  }
  if (noConversionNeeded(a, dtype)) {
    return a;
  }
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(a);
  } else if (dtype === "int32") {
    return new Int32Array(a);
  } else if (dtype === "bool") {
    const bool = new Uint8Array(a.length);
    for (let i = 0; i < bool.length; ++i) {
      if (Math.round(a[i]) !== 0) {
        bool[i] = 1;
      }
    }
    return bool;
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function now() {
  return env().platform.now();
}
function fetch$1(path, requestInits) {
  return env().platform.fetch(path, requestInits);
}
function encodeString(s, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.encode(s, encoding);
}
function decodeString(bytes, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.decode(bytes, encoding);
}
function isTypedArray(a) {
  if (env().platform.isTypedArray != null) {
    return env().platform.isTypedArray(a);
  } else {
    return isTypedArrayBrowser(a);
  }
}
function flatten$1(arr, result = [], skipTypedArray = false) {
  if (result == null) {
    result = [];
  }
  if (typeof arr === "boolean" || typeof arr === "number" || typeof arr === "string" || isPromise(arr) || arr == null || isTypedArray(arr) && skipTypedArray) {
    result.push(arr);
  } else if (Array.isArray(arr) || isTypedArray(arr)) {
    for (let i = 0; i < arr.length; ++i) {
      flatten$1(arr[i], result, skipTypedArray);
    }
  } else {
    let maxIndex = -1;
    for (const key of Object.keys(arr)) {
      if (/^([1-9]+[0-9]*|0)$/.test(key)) {
        maxIndex = Math.max(maxIndex, Number(key));
      }
    }
    for (let i = 0; i <= maxIndex; i++) {
      flatten$1(arr[i], result, skipTypedArray);
    }
  }
  return result;
}
const util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arraysEqual: arraysEqual$1,
  arraysEqualWithNull,
  assert,
  assertNonNegativeIntegerDimensions,
  assertNonNull,
  assertShapesMatch,
  bytesFromStringArray,
  bytesPerElement,
  checkConversionForErrors,
  clamp: clamp$2,
  computeStrides,
  convertBackendValuesAndArrayBuffer,
  createScalarValue,
  createShuffledIndices,
  decodeString,
  distSquared,
  encodeString,
  fetch: fetch$1,
  fingerPrint64,
  flatten: flatten$1,
  getArrayFromDType,
  getTypedArrayFromDType,
  hasEncodingLoss,
  hexToLong,
  indexToLoc,
  inferDtype,
  inferFromImplicitShape,
  isBoolean,
  isFunction,
  isInt,
  isNumber,
  isPromise,
  isScalarShape,
  isString,
  isTypedArray,
  isValidDtype,
  locToIndex,
  makeOnesTypedArray,
  makeZerosNestedTypedArray,
  makeZerosTypedArray,
  nearestDivisor,
  nearestLargerEven,
  now,
  parseAxisParam,
  randUniform,
  repeatedTry,
  rightPad,
  shuffle,
  shuffleCombo,
  sizeFromShape,
  sizeToSquarishShape,
  squeezeShape,
  sum: sum$1,
  swap,
  tanh: tanh$1,
  toNestedArray,
  toTypedArray
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Profiler {
  constructor(backendTimer, logger) {
    this.backendTimer = backendTimer;
    this.logger = logger;
    if (logger == null) {
      this.logger = new Logger();
    }
  }
  profileKernel(kernelName, inputs, f) {
    let outputs;
    const holdResultWrapperFn = () => {
      outputs = f();
    };
    let timer;
    const start2 = now();
    if (this.backendTimer.timerAvailable()) {
      timer = this.backendTimer.time(holdResultWrapperFn);
    } else {
      holdResultWrapperFn();
      for (const output of outputs) {
        output.dataSync();
      }
      timer = Promise.resolve({ kernelMs: now() - start2 });
    }
    if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
      for (let i = 0; i < outputs.length; i++) {
        const output = outputs[i];
        output.data().then((tensorVals) => {
          checkComputationForErrors(tensorVals, output.dtype, kernelName);
        });
      }
    }
    const kernelProfile = {
      kernelName,
      outputs,
      inputs,
      timeMs: timer.then((timing) => timing.kernelMs),
      extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
    };
    return kernelProfile;
  }
  logKernelProfile(kernelProfile) {
    const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
    outputs.forEach((result) => {
      Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
        this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
      });
    });
  }
}
function checkComputationForErrors(vals, dtype, kernelName) {
  if (dtype !== "float32") {
    return false;
  }
  for (let i = 0; i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      console.warn(`Found ${num} in the result of '${kernelName}'`);
      return true;
    }
  }
  return false;
}
class Logger {
  logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
    const time2 = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
    const paddedName = rightPad(name, 25);
    const rank = result.rank;
    const size = result.size;
    const shape = rightPad(result.shape.toString(), 14);
    let inputShapesDescription = "";
    for (const name2 in inputs) {
      const input = inputs[name2];
      if (input != null) {
        const inputShape = input.shape || result.shape;
        const inputRank = inputShape.length;
        inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
      }
    }
    console.log(`%c${paddedName}	%c${time2}	%c${rank}D ${shape}	%c${size}	%c${inputShapesDescription}	%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getFilteredNodesXToY(tape, xs, y) {
  const tensorsFromX = {};
  const nodesFromX = {};
  for (let i = 0; i < xs.length; i++) {
    tensorsFromX[xs[i].id] = true;
  }
  for (let i = 0; i < tape.length; i++) {
    const node = tape[i];
    const nodeInputs = node.inputs;
    for (const inputName in nodeInputs) {
      const input = nodeInputs[inputName];
      let anyInputFromX = false;
      for (let j = 0; j < xs.length; j++) {
        if (tensorsFromX[input.id]) {
          node.outputs.forEach((output) => tensorsFromX[output.id] = true);
          anyInputFromX = true;
          nodesFromX[node.id] = true;
          break;
        }
      }
      if (anyInputFromX) {
        break;
      }
    }
  }
  const tensorsLeadToY = {};
  tensorsLeadToY[y.id] = true;
  const nodesToY = {};
  for (let i = tape.length - 1; i >= 0; i--) {
    const node = tape[i];
    const nodeInputs = node.inputs;
    for (let j = 0; j < node.outputs.length; j++) {
      if (tensorsLeadToY[node.outputs[j].id]) {
        for (const inputName in nodeInputs) {
          tensorsLeadToY[nodeInputs[inputName].id] = true;
          nodesToY[node.id] = true;
        }
        break;
      }
    }
  }
  const filteredTape = [];
  for (let i = 0; i < tape.length; i++) {
    const node = tape[i];
    if (nodesFromX[node.id] && nodesToY[node.id]) {
      const prunedInputs = {};
      for (const inputName in node.inputs) {
        const nodeInput = node.inputs[inputName];
        if (tensorsFromX[nodeInput.id]) {
          prunedInputs[inputName] = nodeInput;
        }
      }
      const prunedNode = Object.assign({}, node);
      prunedNode.inputs = prunedInputs;
      prunedNode.outputs = node.outputs;
      filteredTape.push(prunedNode);
    }
  }
  return filteredTape;
}
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy2, add2) {
  for (let i = filteredTape.length - 1; i >= 0; i--) {
    const node = filteredTape[i];
    const dys = [];
    node.outputs.forEach((o) => {
      const gradTensor = tensorAccumulatedGradientMap[o.id];
      if (gradTensor != null) {
        dys.push(gradTensor);
      } else {
        dys.push(null);
      }
    });
    if (node.gradient == null) {
      throw new Error(`Cannot compute gradient: gradient function not found for ${node.kernelName}.`);
    }
    const inputGradients = node.gradient(dys);
    for (const inputName in node.inputs) {
      if (!(inputName in inputGradients)) {
        throw new Error(`Cannot backprop through input ${inputName}. Available gradients found: ${Object.keys(inputGradients)}.`);
      }
      const dx = tidy2(() => inputGradients[inputName]());
      if (dx.dtype !== "float32") {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
      }
      const x = node.inputs[inputName];
      if (!arraysEqual$1(dx.shape, x.shape)) {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input '${inputName}' has shape '${dx.shape}', which does not match the shape of the input '${x.shape}'`);
      }
      if (tensorAccumulatedGradientMap[x.id] == null) {
        tensorAccumulatedGradientMap[x.id] = dx;
      } else {
        const curGradient = tensorAccumulatedGradientMap[x.id];
        tensorAccumulatedGradientMap[x.id] = add2(curGradient, dx);
        curGradient.dispose();
      }
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const FORMAT_LIMIT_NUM_VALS = 20;
const FORMAT_NUM_FIRST_LAST_VALS = 3;
const FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(vals, shape, dtype, verbose) {
  const strides = computeStrides(shape);
  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
  const rank = shape.length;
  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
  const lines = ["Tensor"];
  if (verbose) {
    lines.push(`  dtype: ${dtype}`);
    lines.push(`  rank: ${rank}`);
    lines.push(`  shape: [${shape}]`);
    lines.push(`  values:`);
  }
  lines.push(valsLines.map((l) => "    " + l).join("\n"));
  return lines.join("\n");
}
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
  const n = sizeFromShape(shape);
  const numCols = strides[strides.length - 1];
  const padPerCol = new Array(numCols).fill(0);
  const rank = shape.length;
  const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
  if (rank > 1) {
    for (let row = 0; row < n / numCols; row++) {
      const offset = row * numCols;
      for (let j = 0; j < numCols; j++) {
        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
      }
    }
  }
  return padPerCol;
}
function valToString(val, pad2, dtype) {
  let valStr;
  if (Array.isArray(val)) {
    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
  } else if (isString(val)) {
    valStr = `'${val}'`;
  } else if (dtype === "bool") {
    valStr = boolNumToString(val);
  } else {
    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
  }
  return rightPad(valStr, pad2);
}
function boolNumToString(v) {
  return v === 0 ? "false" : "true";
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
  const storagePerElement = dtype === "complex64" ? 2 : 1;
  const size = shape[0];
  const rank = shape.length;
  if (rank === 0) {
    if (dtype === "complex64") {
      const complexTuple = createComplexTuples(vals);
      return [valToString(complexTuple[0], 0, dtype)];
    }
    if (dtype === "bool") {
      return [boolNumToString(vals[0])];
    }
    return [vals[0].toString()];
  }
  if (rank === 1) {
    if (size > FORMAT_LIMIT_NUM_VALS) {
      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
      let firstVals = Array.from(vals.slice(0, firstValsSize));
      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
      if (dtype === "complex64") {
        firstVals = createComplexTuples(firstVals);
        lastVals = createComplexTuples(lastVals);
      }
      return [
        "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
      ];
    }
    const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
    return [
      "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
    ];
  }
  const subshape = shape.slice(1);
  const substrides = strides.slice(1);
  const stride = strides[0] * storagePerElement;
  const lines = [];
  if (size > FORMAT_LIMIT_NUM_VALS) {
    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
      const start2 = i * stride;
      const end = start2 + stride;
      lines.push(...subTensorToString(
        vals.slice(start2, end),
        subshape,
        dtype,
        substrides,
        padPerCol,
        false
        /* isLast */
      ));
    }
    lines.push("...");
    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
      const start2 = i * stride;
      const end = start2 + stride;
      lines.push(...subTensorToString(
        vals.slice(start2, end),
        subshape,
        dtype,
        substrides,
        padPerCol,
        i === size - 1
        /* isLast */
      ));
    }
  } else {
    for (let i = 0; i < size; i++) {
      const start2 = i * stride;
      const end = start2 + stride;
      lines.push(...subTensorToString(
        vals.slice(start2, end),
        subshape,
        dtype,
        substrides,
        padPerCol,
        i === size - 1
        /* isLast */
      ));
    }
  }
  const sep = rank === 2 ? "," : "";
  lines[0] = "[" + (size > 0 ? lines[0] + sep : "");
  for (let i = 1; i < lines.length - 1; i++) {
    lines[i] = " " + lines[i] + sep;
  }
  let newLineSep = ",\n";
  for (let i = 2; i < rank; i++) {
    newLineSep += "\n";
  }
  lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
  return lines;
}
function createComplexTuples(vals) {
  const complexTuples = [];
  for (let i = 0; i < vals.length; i += 2) {
    complexTuples.push([vals[i], vals[i + 1]]);
  }
  return complexTuples;
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorBuffer {
  constructor(shape, dtype, values) {
    this.dtype = dtype;
    this.shape = shape.slice();
    this.size = sizeFromShape(shape);
    if (values != null) {
      const n = values.length;
      assert(n === this.size, () => `Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`);
    }
    if (dtype === "complex64") {
      throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`);
    }
    this.values = values || getArrayFromDType(dtype, this.size);
    this.strides = computeStrides(shape);
  }
  /**
   * Sets a value in the buffer at a given location.
   *
   * @param value The value to set.
   * @param locs  The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  set(value, ...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must match the rank (${this.rank})`);
    const index = this.locToIndex(locs);
    this.values[index] = value;
  }
  /**
   * Returns the value in the buffer at the provided location.
   *
   * @param locs The location indices.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  get(...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    let i = 0;
    for (const loc of locs) {
      if (loc < 0 || loc >= this.shape[i]) {
        const msg = `Requested out of range element at ${locs}.   Buffer shape=${this.shape}`;
        throw new Error(msg);
      }
      i++;
    }
    let index = locs[locs.length - 1];
    for (let i2 = 0; i2 < locs.length - 1; ++i2) {
      index += this.strides[i2] * locs[i2];
    }
    return this.values[index];
  }
  locToIndex(locs) {
    if (this.rank === 0) {
      return 0;
    } else if (this.rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i = 0; i < locs.length - 1; ++i) {
      index += this.strides[i] * locs[i];
    }
    return index;
  }
  indexToLoc(index) {
    if (this.rank === 0) {
      return [];
    } else if (this.rank === 1) {
      return [index];
    }
    const locs = new Array(this.shape.length);
    for (let i = 0; i < locs.length - 1; ++i) {
      locs[i] = Math.floor(index / this.strides[i]);
      index -= locs[i] * this.strides[i];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Creates an immutable `tf.Tensor` object from the buffer.
   *
   * @doc {heading: 'Tensors', subheading: 'Creation'}
   */
  toTensor() {
    return trackerFn().makeTensor(this.values, this.shape, this.dtype);
  }
}
let trackerFn = null;
let opHandler$1 = null;
function setTensorTracker(fn) {
  trackerFn = fn;
}
function setOpHandler(handler) {
  opHandler$1 = handler;
}
class Tensor {
  constructor(shape, dtype, dataId, id2) {
    this.kept = false;
    this.isDisposedInternal = false;
    this.shape = shape.slice();
    this.dtype = dtype || "float32";
    this.size = sizeFromShape(shape);
    this.strides = computeStrides(shape);
    this.dataId = dataId;
    this.id = id2;
    this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  /**
   * Returns a promise of `tf.TensorBuffer` that holds the underlying data.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async buffer() {
    const vals = await this.data();
    return opHandler$1.buffer(this.shape, this.dtype, vals);
  }
  /**
   * Returns a `tf.TensorBuffer` that holds the underlying data.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  bufferSync() {
    return opHandler$1.buffer(this.shape, this.dtype, this.dataSync());
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * asynchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async array() {
    const vals = await this.data();
    return toNestedArray(this.shape, vals, this.dtype === "complex64");
  }
  /**
   * Returns the tensor data as a nested array. The transfer of data is done
   * synchronously.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  arraySync() {
    return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  /**
   * Asynchronously downloads the values from the `tf.Tensor`. Returns a
   * promise of `TypedArray` that resolves when the computation has finished.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  async data() {
    this.throwIfDisposed();
    const data = trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      const bytes = await data;
      try {
        return bytes.map((b) => decodeString(b));
      } catch (_a2) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  /**
   * Copy the tensor's data to a new GPU resource. Comparing to the `dataSync()`
   * and `data()`, this method prevents data from being downloaded to CPU.
   *
   * For WebGL backend, the data will be stored on a densely packed texture.
   * This means that the texture will use the RGBA channels to store value.
   *
   * For WebGPU backend, the data will be stored on a buffer. There is no
   * parameter, so can not use a user-defined size to create the buffer.
   *
   * @param options:
   *     For WebGL,
   *         - customTexShape: Optional. If set, will use the user defined
   *     texture shape to create the texture.
   *
   * @returns For WebGL backend, a GPUData contains the new texture and
   *     its information.
   *     {
   *        tensorRef: The tensor that is associated with this texture,
   *        texture: WebGLTexture,
   *        texShape: [number, number] // [height, width]
   *     }
   *
   *     For WebGPU backend, a GPUData contains the new buffer.
   *     {
   *        tensorRef: The tensor that is associated with this buffer,
   *        buffer: GPUBuffer,
   *     }
   *
   *     Remember to dispose the GPUData after it is used by
   *     `res.tensorRef.dispose()`.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataToGPU(options) {
    this.throwIfDisposed();
    return trackerFn().readToGPU(this.dataId, options);
  }
  /**
   * Synchronously downloads the values from the `tf.Tensor`. This blocks the
   * UI thread until the values are ready, which can cause performance issues.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dataSync() {
    this.throwIfDisposed();
    const data = trackerFn().readSync(this.dataId);
    if (this.dtype === "string") {
      try {
        return data.map((b) => decodeString(b));
      } catch (_a2) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  /** Returns the underlying bytes of the tensor's data. */
  async bytes() {
    this.throwIfDisposed();
    const data = await trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      return data;
    } else {
      return new Uint8Array(data.buffer);
    }
  }
  /**
   * Disposes `tf.Tensor` from memory.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    if (this.kerasMask) {
      this.kerasMask.dispose();
    }
    trackerFn().disposeTensor(this);
    this.isDisposedInternal = true;
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed) {
      throw new Error(`Tensor is disposed.`);
    }
  }
  /**
   * Prints the `tf.Tensor`. See `tf.print` for details.
   *
   * @param verbose Whether to print verbose information about the tensor,
   *    including dtype and size.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  print(verbose = false) {
    return opHandler$1.print(this, verbose);
  }
  /**
   * Returns a copy of the tensor. See `tf.clone` for details.
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  clone() {
    this.throwIfDisposed();
    return opHandler$1.clone(this);
  }
  /**
   * Returns a human-readable description of the tensor. Useful for logging.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  toString(verbose = false) {
    const vals = this.dataSync();
    return tensorToString(vals, this.shape, this.dtype, verbose);
  }
  cast(dtype) {
    this.throwIfDisposed();
    return opHandler$1.cast(this, dtype);
  }
  variable(trainable = true, name, dtype) {
    this.throwIfDisposed();
    return trackerFn().makeVariable(this, trainable, name, dtype);
  }
}
Object.defineProperty(Tensor, Symbol.hasInstance, {
  value: (instance) => {
    return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
  }
});
function getGlobalTensorClass() {
  return getGlobal("Tensor", () => {
    return Tensor;
  });
}
getGlobalTensorClass();
class Variable extends Tensor {
  constructor(initialValue, trainable, name, tensorId) {
    super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
    this.trainable = trainable;
    this.name = name;
  }
  /**
   * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
   * the same shape and dtype as the old `tf.Tensor`.
   *
   * @param newValue New tensor to be assigned to this variable.
   *
   * @doc {heading: 'Tensors', subheading: 'Classes'}
   */
  assign(newValue) {
    if (newValue.dtype !== this.dtype) {
      throw new Error(`dtype of the new value (${newValue.dtype}) and previous value (${this.dtype}) must match`);
    }
    if (!arraysEqual$1(newValue.shape, this.shape)) {
      throw new Error(`shape of the new value (${newValue.shape}) and previous value (${this.shape}) must match`);
    }
    trackerFn().disposeTensor(this);
    this.dataId = newValue.dataId;
    trackerFn().incRef(
      this,
      null
      /* backend */
    );
  }
  dispose() {
    trackerFn().disposeVariable(this);
    this.isDisposedInternal = true;
  }
}
Object.defineProperty(Variable, Symbol.hasInstance, {
  value: (instance) => {
    return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
  }
});
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Rank;
(function(Rank2) {
  Rank2["R0"] = "R0";
  Rank2["R1"] = "R1";
  Rank2["R2"] = "R2";
  Rank2["R3"] = "R3";
  Rank2["R4"] = "R4";
  Rank2["R5"] = "R5";
  Rank2["R6"] = "R6";
})(Rank || (Rank = {}));
var UpcastInt32AndMap;
(function(UpcastInt32AndMap2) {
  UpcastInt32AndMap2["float32"] = "float32";
  UpcastInt32AndMap2["int32"] = "int32";
  UpcastInt32AndMap2["bool"] = "int32";
  UpcastInt32AndMap2["complex64"] = "complex64";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function(UpcastBoolAndMap2) {
  UpcastBoolAndMap2["float32"] = "float32";
  UpcastBoolAndMap2["int32"] = "int32";
  UpcastBoolAndMap2["bool"] = "bool";
  UpcastBoolAndMap2["complex64"] = "complex64";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function(UpcastFloat32AndMap2) {
  UpcastFloat32AndMap2["float32"] = "float32";
  UpcastFloat32AndMap2["int32"] = "float32";
  UpcastFloat32AndMap2["bool"] = "float32";
  UpcastFloat32AndMap2["complex64"] = "complex64";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var UpcastComplex64AndMap;
(function(UpcastComplex64AndMap2) {
  UpcastComplex64AndMap2["float32"] = "complex64";
  UpcastComplex64AndMap2["int32"] = "complex64";
  UpcastComplex64AndMap2["bool"] = "complex64";
  UpcastComplex64AndMap2["complex64"] = "complex64";
})(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
const upcastTypeMap = {
  "float32": UpcastFloat32AndMap,
  "int32": UpcastInt32AndMap,
  "bool": UpcastBoolAndMap,
  "complex64": UpcastComplex64AndMap
};
function upcastType(typeA, typeB) {
  if (typeA === "string" || typeB === "string") {
    if (typeA === "string" && typeB === "string") {
      return "string";
    }
    throw new Error(`Can not upcast ${typeA} with ${typeB}`);
  }
  return upcastTypeMap[typeA][typeB];
}
function sumOutType(type) {
  return upcastType(type, "int32");
}
function isWebGLData(values) {
  return values != null && typeof values === "object" && "texture" in values && values.texture instanceof WebGLTexture;
}
function isWebGPUData(values) {
  return typeof GPUBuffer !== "undefined" && values != null && typeof values === "object" && "buffer" in values && values.buffer instanceof GPUBuffer;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function makeTypesMatch(a, b) {
  if (a.dtype === b.dtype) {
    return [a, b];
  }
  const dtype = upcastType(a.dtype, b.dtype);
  return [a.cast(dtype), b.cast(dtype)];
}
function assertTypesMatch(a, b) {
  assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and second(${b.dtype}) input must match`);
}
function isTensorInList(tensor2, tensorList) {
  return tensorList.some((x) => x.id === tensor2.id);
}
function getTensorsInContainer(result) {
  const list = [];
  const seen = /* @__PURE__ */ new Set();
  walkTensorContainer(result, list, seen);
  return list;
}
function walkTensorContainer(container, list, seen) {
  if (container == null) {
    return;
  }
  if (container instanceof Tensor) {
    list.push(container);
    return;
  }
  if (!isIterable(container)) {
    return;
  }
  const iterable = container;
  for (const k in iterable) {
    const val = iterable[k];
    if (!seen.has(val)) {
      seen.add(val);
      walkTensorContainer(val, list, seen);
    }
  }
}
function isIterable(obj) {
  return Array.isArray(obj) || typeof obj === "object";
}
const tensor_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertTypesMatch,
  getTensorsInContainer,
  isTensorInList,
  makeTypesMatch
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isRegisteredKernelInvocation(kernelInvocation) {
  return kernelInvocation.kernelName != null;
}
class EngineState {
  constructor() {
    this.registeredVariables = {};
    this.nextTapeNodeId = 0;
    this.numBytes = 0;
    this.numTensors = 0;
    this.numStringTensors = 0;
    this.numDataBuffers = 0;
    this.gradientDepth = 0;
    this.kernelDepth = 0;
    this.scopeStack = [];
    this.numDataMovesStack = [];
    this.nextScopeId = 0;
    this.tensorInfo = /* @__PURE__ */ new WeakMap();
    this.profiling = false;
    this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((k) => k.name)));
      }
    };
  }
  dispose() {
    for (const variableName in this.registeredVariables) {
      this.registeredVariables[variableName].dispose();
    }
  }
}
class Engine {
  constructor(ENV2) {
    this.ENV = ENV2;
    this.registry = {};
    this.registryFactory = {};
    this.pendingBackendInitId = 0;
    this.state = new EngineState();
  }
  async ready() {
    if (this.pendingBackendInit != null) {
      return this.pendingBackendInit.then(() => {
      });
    }
    if (this.backendInstance != null) {
      return;
    }
    const sortedBackends = this.getSortedBackends();
    for (let i = 0; i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const success = await this.initializeBackend(backendName).success;
      if (success) {
        await this.setBackend(backendName);
        return;
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  get backend() {
    if (this.pendingBackendInit != null) {
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
    }
    if (this.backendInstance == null) {
      const { name, asyncInit } = this.initializeBackendsAndReturnBest();
      if (asyncInit) {
        throw new Error(`The highest priority backend '${name}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
      }
      this.setBackend(name);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(backendName) {
    if (!(backendName in this.registry)) {
      if (backendName in this.registryFactory) {
        const { asyncInit } = this.initializeBackend(backendName);
        if (asyncInit) {
          return null;
        }
      } else {
        return null;
      }
    }
    return this.registry[backendName];
  }
  findBackendFactory(backendName) {
    if (!(backendName in this.registryFactory)) {
      return null;
    }
    return this.registryFactory[backendName].factory;
  }
  registerBackend(backendName, factory, priority2 = 1) {
    if (backendName in this.registryFactory) {
      warn(`${backendName} backend was already registered. Reusing existing backend factory.`);
      return false;
    }
    this.registryFactory[backendName] = { factory, priority: priority2 };
    return true;
  }
  async setBackend(backendName) {
    if (this.registryFactory[backendName] == null) {
      throw new Error(`Backend name '${backendName}' not found in registry`);
    }
    this.backendName = backendName;
    if (this.registry[backendName] == null) {
      this.backendInstance = null;
      const { success, asyncInit } = this.initializeBackend(backendName);
      const result = asyncInit ? await success : success;
      if (!result) {
        return false;
      }
    }
    this.backendInstance = this.registry[backendName];
    this.setupRegisteredKernels();
    this.profiler = new Profiler(this.backendInstance);
    return true;
  }
  setupRegisteredKernels() {
    const kernels = getKernelsForBackend(this.backendName);
    kernels.forEach((kernel) => {
      if (kernel.setupFunc != null) {
        kernel.setupFunc(this.backendInstance);
      }
    });
  }
  disposeRegisteredKernels(backendName) {
    const kernels = getKernelsForBackend(backendName);
    kernels.forEach((kernel) => {
      if (kernel.disposeFunc != null) {
        kernel.disposeFunc(this.registry[backendName]);
      }
    });
  }
  /**
   * Initializes a backend by looking up the backend name in the factory
   * registry and calling the factory method. Returns a boolean representing
   * whether the initialization of the backend succeeded. Throws an error if
   * there is no backend in the factory registry.
   */
  initializeBackend(backendName) {
    const registryFactoryEntry = this.registryFactory[backendName];
    if (registryFactoryEntry == null) {
      throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
    }
    try {
      const backend2 = registryFactoryEntry.factory();
      if (backend2 && !(backend2 instanceof KernelBackend) && typeof backend2.then === "function") {
        const promiseId = ++this.pendingBackendInitId;
        const success = backend2.then((backendInstance) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.registry[backendName] = backendInstance;
          this.pendingBackendInit = null;
          return true;
        }).catch((err) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.pendingBackendInit = null;
          warn(`Initialization of backend ${backendName} failed`);
          warn(err.stack || err.message);
          return false;
        });
        this.pendingBackendInit = success;
        return { success, asyncInit: true };
      } else {
        this.registry[backendName] = backend2;
        return { success: true, asyncInit: false };
      }
    } catch (err) {
      warn(`Initialization of backend ${backendName} failed`);
      warn(err.stack || err.message);
      return { success: false, asyncInit: false };
    }
  }
  removeBackend(backendName) {
    if (!(backendName in this.registryFactory)) {
      throw new Error(`${backendName} backend not found in registry`);
    }
    if (this.backendName === backendName && this.pendingBackendInit != null) {
      this.pendingBackendInitId++;
    }
    if (backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    delete this.registryFactory[backendName];
    if (this.backendName === backendName) {
      this.pendingBackendInit = null;
      this.backendName = null;
      this.backendInstance = null;
    }
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0) {
      throw new Error("No backend found in registry.");
    }
    return Object.keys(this.registryFactory).sort((a, b) => {
      return this.registryFactory[b].priority - this.registryFactory[a].priority;
    });
  }
  initializeBackendsAndReturnBest() {
    const sortedBackends = this.getSortedBackends();
    for (let i = 0; i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const { success, asyncInit } = this.initializeBackend(backendName);
      if (asyncInit || success) {
        return { name: backendName, asyncInit };
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations failed.`);
  }
  moveData(backend2, dataId) {
    const info = this.state.tensorInfo.get(dataId);
    const srcBackend = info.backend;
    const values = this.readSync(dataId);
    const refCount = srcBackend.refCount(dataId);
    srcBackend.disposeData(dataId, true);
    info.backend = backend2;
    backend2.move(dataId, values, info.shape, info.dtype, refCount);
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
  }
  tidy(nameOrFn, fn) {
    let name = null;
    if (fn == null) {
      if (typeof nameOrFn !== "function") {
        throw new Error("Please provide a function to tidy()");
      }
      fn = nameOrFn;
    } else {
      if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
        throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      }
      name = nameOrFn;
    }
    let result;
    return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
      result = fn();
      if (result instanceof Promise) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      return result;
    });
  }
  scopedRun(start2, end, f) {
    start2();
    try {
      const res = f();
      end();
      return res;
    } catch (ex) {
      end();
      throw ex;
    }
  }
  nextTensorId() {
    return Engine.nextTensorId++;
  }
  nextVariableId() {
    return Engine.nextVariableId++;
  }
  /**
   * This method is called instead of the public-facing tensor.clone() when
   * saving a tensor for backwards pass. It makes sure to add the clone
   * operation to the tape regardless of being called inside a kernel
   * execution.
   */
  clone(x) {
    const y = ENGINE.runKernel(Identity, { x });
    const inputs = { x };
    const grad2 = (dy) => ({
      x: () => {
        const dtype = "float32";
        const gradInputs = { x: dy };
        const attrs = { dtype };
        return ENGINE.runKernel(
          Cast,
          gradInputs,
          // tslint:disable-next-line: no-unnecessary-type-assertion
          attrs
        );
      }
    });
    const saved = [];
    this.addTapeNode(this.state.activeScope.name, inputs, [y], grad2, saved, {});
    return y;
  }
  /**
   * Execute a kernel with the given name and return the output tensor.
   *
   * @param kernelName The name of the kernel to execute.
   * @param inputs A map of input names to tensors.
   * @param attrs A map of attribute names to their values. An attribute is a
   *     primitive (non-tensor) input to the kernel.
   * @param inputsToSave A list of tensors, inputs to save for the backprop
   *     computation.
   * @param outputsToSave A list of booleans, specifying which output to save
   *     for the backprop computation. These are booleans since the output
   * tensors are not visible to the user.
   */
  runKernel(kernelName, inputs, attrs) {
    if (this.backendName == null) {
      this.backend;
    }
    const hasKernel = getKernel(kernelName, this.backendName) != null;
    if (!hasKernel) {
      throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
    }
    return this.runKernelFunc({ kernelName, inputs, attrs });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
    const numDataIdsAfter = this.backend.numDataIds();
    let numOutputDataIds = 0;
    outInfos.forEach((info) => {
      numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
    });
    const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
    if (dataIdsLeaked > 0) {
      throw new Error(`Backend '${this.backendName}' has an internal memory leak (${dataIdsLeaked} data ids) after running '${kernelName}'`);
    }
  }
  /**
   * Internal helper method to execute a kernel Func
   *
   * Use `runKernel` to execute kernels from outside of engine.
   */
  runKernelFunc(kernelParams) {
    let outputs;
    let saved = [];
    const isTapeOn = this.isTapeOn();
    const startingBytecount = this.state.numBytes;
    const startingNumTensors = this.state.numTensors;
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack.push(0);
    }
    let kernelFunc;
    if (this.backendName == null) {
      this.backend;
    }
    let out;
    const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (isRegisteredKernelInvocation(kernelParams)) {
      const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
      if (this.backendName == null) {
        this.backend;
      }
      const kernel = getKernel(kernelName, this.backendName);
      assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
      kernelFunc = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
        const outInfos = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
        }
        const outTensors = outInfos.map((outInfo) => {
          if (outInfo.rank != null) {
            return outInfo;
          }
          return this.makeTensorFromTensorInfo(outInfo);
        });
        if (isTapeOn) {
          const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
          saved = this.saveTensorsForBackwardMode(tensorsToSave);
        }
        return outTensors;
      };
    } else {
      const { forwardFunc } = kernelParams;
      const saveFunc = (tensors) => {
        if (!isTapeOn) {
          return;
        }
        saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
      };
      kernelFunc = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = this.tidy(() => forwardFunc(this.backend, saveFunc));
        const outs = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
        }
        return outs;
      };
    }
    const { inputs, attrs } = kernelParams;
    const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
    let kernelProfile;
    this.scopedRun(
      // Stop recording to a tape when running a kernel.
      () => this.state.kernelDepth++,
      () => this.state.kernelDepth--,
      () => {
        if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
          outputs = kernelFunc();
        } else {
          kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
          if (this.ENV.getBool("DEBUG")) {
            this.profiler.logKernelProfile(kernelProfile);
          }
          outputs = kernelProfile.outputs;
        }
      }
    );
    if (isTapeOn) {
      this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
    }
    if (this.state.profiling) {
      this.state.activeProfile.kernels.push({
        name: kernelOrScopeName,
        bytesAdded: this.state.numBytes - startingBytecount,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - startingNumTensors,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
        outputShapes: outputs.map((item) => item.shape),
        kernelTimeMs: kernelProfile.timeMs,
        extraInfo: kernelProfile.extraInfo
      });
    }
    return Array.isArray(out) ? outputs : outputs[0];
  }
  /**
   * Saves tensors used in forward mode for use in backward mode.
   *
   * @param tensors the list of tensors to save.
   */
  saveTensorsForBackwardMode(tensors) {
    const saved = tensors.map((tensor2) => this.keep(this.clone(tensor2)));
    return saved;
  }
  /**
   * Returns a list of tensors to save for a given gradient calculation.
   *
   * @param kernelName name of kernel to look up gradient for.
   * @param inputs a map of input tensors.
   * @param outputs an array of output tensors from forward mode of kernel.
   */
  getTensorsForGradient(kernelName, inputs, outputs) {
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      const inputsToSave = gradConfig.inputsToSave || [];
      const outputsToSave = gradConfig.outputsToSave || [];
      let inputTensorsToSave;
      if (gradConfig.saveAllInputs) {
        assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
        inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
      } else {
        inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
      }
      const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
      return inputTensorsToSave.concat(outputTensorsToSave);
    }
    return [];
  }
  /**
   * Internal method used by public APIs for tensor creation. Makes a new
   * tensor with the provided shape, dtype and values. It always
   * creates a new data id and writes the values to the underlying backend.
   */
  makeTensor(values, shape, dtype, backend2) {
    if (values == null) {
      throw new Error("Values passed to engine.makeTensor() are null");
    }
    dtype = dtype || "float32";
    backend2 = backend2 || this.backend;
    let backendVals = values;
    if (dtype === "string" && isString(values[0])) {
      backendVals = values.map((d) => encodeString(d));
    }
    const dataId = backend2.write(backendVals, shape, dtype);
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t, backend2);
    if (dtype === "string") {
      const info = this.state.tensorInfo.get(dataId);
      const newBytes = bytesFromStringArray(backendVals);
      this.state.numBytes += newBytes - info.bytes;
      info.bytes = newBytes;
    }
    return t;
  }
  /**
   * Internal method used by backends. Makes a new tensor
   * that is a wrapper around an existing data id. It doesn't create
   * a new data id, only increments the ref count used in memory tracking.
   * @deprecated
   */
  makeTensorFromDataId(dataId, shape, dtype, backend2) {
    dtype = dtype || "float32";
    const tensorInfo = { dataId, shape, dtype };
    return this.makeTensorFromTensorInfo(tensorInfo, backend2);
  }
  /**
   * Internal method used by backends. Makes a new tensor that is a wrapper
   * around an existing data id in TensorInfo. It doesn't create a new data id,
   * only increments the ref count used in memory tracking.
   */
  makeTensorFromTensorInfo(tensorInfo, backend2) {
    const { dataId, shape, dtype } = tensorInfo;
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t, backend2);
    return t;
  }
  makeVariable(initialValue, trainable = true, name, dtype) {
    name = name || this.nextVariableId().toString();
    if (dtype != null && dtype !== initialValue.dtype) {
      initialValue = initialValue.cast(dtype);
    }
    const v = new Variable(initialValue, trainable, name, this.nextTensorId());
    if (this.state.registeredVariables[v.name] != null) {
      throw new Error(`Variable with name ${v.name} was already registered`);
    }
    this.state.registeredVariables[v.name] = v;
    this.incRef(v, this.backend);
    return v;
  }
  trackTensor(a, backend2) {
    this.state.numTensors++;
    if (a.dtype === "string") {
      this.state.numStringTensors++;
    }
    let bytes = 0;
    if (a.dtype !== "complex64" && a.dtype !== "string") {
      bytes = a.size * bytesPerElement(a.dtype);
    }
    this.state.numBytes += bytes;
    if (!this.state.tensorInfo.has(a.dataId)) {
      this.state.numDataBuffers++;
      this.state.tensorInfo.set(a.dataId, {
        backend: backend2 || this.backend,
        dtype: a.dtype,
        shape: a.shape,
        bytes
      });
    }
    if (!(a instanceof Variable)) {
      this.track(a);
    }
  }
  // Track the tensor by dataId and increase the refCount for the dataId in the
  // backend.
  // TODO(pyu10055): This is currently used by makeVariable method, to increase
  // refCount on the backend for the dataId. It can potentially be replaced with
  // Identity op indead of calling backend directly.
  incRef(a, backend2) {
    this.trackTensor(a, backend2);
    this.backend.incRef(a.dataId);
  }
  removeDataId(dataId, backend2) {
    if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend2) {
      this.state.tensorInfo.delete(dataId);
      this.state.numDataBuffers--;
    }
  }
  disposeTensor(a) {
    if (!this.state.tensorInfo.has(a.dataId)) {
      return;
    }
    const info = this.state.tensorInfo.get(a.dataId);
    this.state.numTensors--;
    if (a.dtype === "string") {
      this.state.numStringTensors--;
      this.state.numBytes -= info.bytes;
    }
    if (a.dtype !== "complex64" && a.dtype !== "string") {
      const bytes = a.size * bytesPerElement(a.dtype);
      this.state.numBytes -= bytes;
    }
    if (info.backend.disposeData(a.dataId)) {
      this.removeDataId(a.dataId, info.backend);
    }
  }
  disposeVariables() {
    for (const varName in this.state.registeredVariables) {
      const v = this.state.registeredVariables[varName];
      this.disposeVariable(v);
    }
  }
  disposeVariable(v) {
    this.disposeTensor(v);
    if (this.state.registeredVariables[v.name] != null) {
      delete this.state.registeredVariables[v.name];
    }
  }
  memory() {
    const info = this.backend.memory();
    info.numTensors = this.state.numTensors;
    info.numDataBuffers = this.state.numDataBuffers;
    info.numBytes = this.state.numBytes;
    if (this.state.numStringTensors > 0) {
      info.unreliable = true;
      if (info.reasons == null) {
        info.reasons = [];
      }
      info.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)");
    }
    return info;
  }
  async profile(query) {
    this.state.profiling = true;
    const startBytes = this.state.numBytes;
    const startNumTensors = this.state.numTensors;
    this.state.activeProfile.kernels = [];
    this.state.activeProfile.result = await query();
    this.state.profiling = false;
    this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
    this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
    for (const kernel of this.state.activeProfile.kernels) {
      kernel.kernelTimeMs = await kernel.kernelTimeMs;
      kernel.extraInfo = await kernel.extraInfo;
    }
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
    const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      gradientsFunc = gradConfig.gradFunc;
    }
    if (gradientsFunc != null) {
      tapeNode.gradient = (dys) => {
        dys = dys.map((dy, i) => {
          if (dy == null) {
            const output = outputs[i];
            const vals = makeZerosTypedArray(output.size, output.dtype);
            return this.makeTensor(vals, output.shape, output.dtype);
          }
          return dy;
        });
        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
      };
    }
    this.state.activeTape.push(tapeNode);
  }
  keep(result) {
    result.kept = true;
    return result;
  }
  startTape() {
    if (this.state.gradientDepth === 0) {
      this.state.activeTape = [];
    }
    this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  /**
   * Start a scope. Use this with endScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  startScope(name) {
    const scopeInfo = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    if (name) {
      scopeInfo.name = name;
    }
    this.state.scopeStack.push(scopeInfo);
    this.state.activeScope = scopeInfo;
  }
  /**
   * End a scope. Use this with startScope() to achieve the same functionality
   * as scope() without the need for a function closure.
   */
  endScope(result) {
    const tensorsToTrackInParent = getTensorsInContainer(result);
    const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
    for (let i = 0; i < this.state.activeScope.track.length; i++) {
      const tensor2 = this.state.activeScope.track[i];
      if (!tensor2.kept && !tensorsToTrackInParentSet.has(tensor2.id)) {
        tensor2.dispose();
      }
    }
    const oldScope = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
    tensorsToTrackInParent.forEach((tensor2) => {
      if (!tensor2.kept && tensor2.scopeId === oldScope.id) {
        this.track(tensor2);
      }
    });
  }
  /**
   * Returns gradients of `f` with respect to each of the `xs`. The gradients
   * returned are of the same length as `xs`, but some might be null if `f`
   * was not a function of that `x`. It also takes optional dy to multiply the
   * gradient, which defaults to `1`.
   */
  gradients(f, xs, dy, allowNoGradients = false) {
    assert(xs.length > 0, () => "gradients() received an empty list of xs.");
    if (dy != null && dy.dtype !== "float32") {
      throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
    }
    const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
    assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
    const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    }
    return this.tidy("backward", () => {
      const accumulatedGradientMap = {};
      accumulatedGradientMap[y.id] = dy == null ? ones$1(y.shape) : dy;
      backpropagateGradients(
        accumulatedGradientMap,
        filteredTape,
        // Pass the tidy function to avoid circular dep with `tape.ts`.
        (f2) => this.tidy(f2),
        // Pass an add function to avoide a circular dep with `tape.ts`.
        add$1
      );
      const grads2 = xs.map((x) => accumulatedGradientMap[x.id]);
      if (this.state.gradientDepth === 0) {
        this.state.activeTape.forEach((node) => {
          for (const tensor2 of node.saved) {
            tensor2.dispose();
          }
        });
        this.state.activeTape = null;
      }
      return { value: y, grads: grads2 };
    });
  }
  customGrad(f) {
    assert(isFunction(f), () => "The f passed in customGrad(f) must be a function.");
    return (...inputs) => {
      assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let res;
      const inputMap = {};
      inputs.forEach((input, i) => {
        inputMap[i] = input;
      });
      const forwardFunc = (_, save) => {
        res = f(...[...inputs, save]);
        assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");
        assert(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");
        return res.value;
      };
      const backwardsFunc = (dy, saved) => {
        const gradRes = res.gradFunc(dy, saved);
        const grads2 = Array.isArray(gradRes) ? gradRes : [gradRes];
        assert(grads2.length === inputs.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");
        assert(grads2.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const gradMap = {};
        grads2.forEach((grad2, i) => {
          gradMap[i] = () => grad2;
        });
        return gradMap;
      };
      return this.runKernelFunc({
        forwardFunc,
        backwardsFunc,
        inputs: inputMap
      });
    };
  }
  readSync(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readSync(dataId);
  }
  read(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.read(dataId);
  }
  readToGPU(dataId, options) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readToGPU(dataId, options);
  }
  async time(query) {
    const start2 = now();
    const timingInfo = await this.backend.time(query);
    timingInfo.wallMs = now() - start2;
    return timingInfo;
  }
  /**
   * Tracks a Tensor in the current scope to be automatically cleaned up
   * when the current scope ends, and returns the value.
   *
   * @param result The Tensor to track in the current scope.
   */
  track(result) {
    if (this.state.activeScope != null) {
      result.scopeId = this.state.activeScope.id;
      this.state.activeScope.track.push(result);
    }
    return result;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  /**
   * Resets the engine state. Removes all backends but does not remove
   * registered backend factories.
   */
  reset() {
    this.pendingBackendInitId++;
    this.state.dispose();
    this.ENV.reset();
    this.state = new EngineState();
    for (const backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    this.backendName = null;
    this.backendInstance = null;
    this.pendingBackendInit = null;
  }
}
Engine.nextTensorId = 0;
Engine.nextVariableId = 0;
function ones$1(shape) {
  const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
  return ENGINE.makeTensor(values, shape, "float32");
}
function getOrMakeEngine() {
  const ns = getGlobalNamespace();
  if (ns._tfengine == null) {
    const environment = new Environment(ns);
    ns._tfengine = new Engine(environment);
  }
  setEnvironmentGlobal(ns._tfengine.ENV);
  setTensorTracker(() => ns._tfengine);
  return ns._tfengine;
}
const ENGINE = getOrMakeEngine();
function add$1(a, b) {
  const inputs = { a, b };
  return ENGINE.runKernel(Add, inputs);
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function _isNavigatorDefined() {
  return typeof navigator !== "undefined" && navigator != null;
}
let isMobileMockValue;
function mockIsMobile(value) {
  isMobileMockValue = value;
}
function isMobile(nav) {
  if (isMobileMockValue !== void 0) {
    return isMobileMockValue;
  }
  if (nav || _isNavigatorDefined()) {
    if (!nav) {
      nav = navigator;
    }
    if (nav.product === "ReactNative") {
      return true;
    }
    const a = nav.userAgent || nav.vendor || // tslint:disable-next-line:no-any
    (typeof window !== "undefined" ? window.opera : "");
    if (!a) {
      const navAny = nav;
      return navAny.userAgentData && navAny.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || // tslint:disable-next-line:max-line-length
    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
  }
  return false;
}
function isBrowser() {
  return typeof window !== "undefined" && window.document != null || //@ts-ignore
  typeof WorkerGlobalScope !== "undefined";
}
const device_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isBrowser,
  isMobile,
  mockIsMobile
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ENV$1 = env();
ENV$1.registerFlag("DEBUG", () => false, (debugValue) => {
  if (debugValue) {
    console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
  }
});
ENV$1.registerFlag("IS_BROWSER", () => isBrowser());
ENV$1.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
ENV$1.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
ENV$1.registerFlag("IS_SAFARI", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
ENV$1.registerFlag("PROD", () => false);
ENV$1.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV$1.getBool("DEBUG"));
ENV$1.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
ENV$1.registerFlag("IS_TEST", () => false);
ENV$1.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => ENV$1.getBool("DEBUG"));
ENV$1.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
ENV$1.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
ENV$1.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function inferShape(val, dtype) {
  let firstElem = val;
  if (isTypedArray(val)) {
    return dtype === "string" ? [] : [val.length];
  }
  if (isWebGLData(val)) {
    const usedChannels = val.channels || "RGBA";
    return [val.height, val.width * usedChannels.length];
  } else if (isWebGPUData(val)) {
    return [val.buffer.size / (dtype == null ? 4 : bytesPerElement(dtype))];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  const shape = [];
  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
    shape.push(firstElem.length);
    firstElem = firstElem[0];
  }
  if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
    deepAssertShapeConsistency(val, shape, []);
  }
  return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
  indices = indices || [];
  if (!Array.isArray(val) && !isTypedArray(val)) {
    assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, but should be an array/TypedArray of ${shape[0]} elements`);
    return;
  }
  assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, but is an array of ${val.length} elements`);
  assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} elements, but has ${val.length} elements`);
  const subShape = shape.slice(1);
  for (let i = 0; i < val.length; ++i) {
    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
  }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
  if (expectedDtype === "string_or_numeric") {
    return;
  }
  if (expectedDtype == null) {
    throw new Error(`Expected dtype cannot be null.`);
  }
  if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be ${expectedDtype} tensor, but got ${actualDType} tensor`);
  }
}
function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
  if (x instanceof getGlobalTensorClass()) {
    assertDtype(parseAsDtype, x.dtype, argName, functionName);
    return x;
  }
  let inferredDtype = inferDtype(x);
  if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
    inferredDtype = parseAsDtype;
  }
  assertDtype(parseAsDtype, inferredDtype, argName, functionName);
  if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
    const type = x == null ? "null" : x.constructor.name;
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be a Tensor or TensorLike, but got '${type}'`);
  }
  const inferredShape = inferShape(x, inferredDtype);
  if (!isTypedArray(x) && !Array.isArray(x)) {
    x = [x];
  }
  const skipTypedArray = true;
  const values = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten$1(x, [], skipTypedArray);
  return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
  if (!Array.isArray(arg)) {
    throw new Error(`Argument ${argName} passed to ${functionName} must be a \`Tensor[]\` or \`TensorLike[]\``);
  }
  const tensors = arg;
  return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OP_SCOPE_SUFFIX = "__op";
function op(f) {
  const keys = Object.keys(f);
  if (keys.length !== 1) {
    throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${keys.length} keys.`);
  }
  let opName = keys[0];
  const fn = f[opName];
  if (opName.endsWith("_")) {
    opName = opName.substring(0, opName.length - 1);
  }
  opName = opName + OP_SCOPE_SUFFIX;
  const f2 = (...args) => {
    ENGINE.startScope(opName);
    try {
      const result = fn(...args);
      if (isPromise(result)) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      ENGINE.endScope(result);
      return result;
    } catch (ex) {
      ENGINE.endScope(null);
      throw ex;
    }
  };
  Object.defineProperty(f2, "name", { value: opName, configurable: true });
  return f2;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function complex_(real2, imag2) {
  const $real = convertToTensor(real2, "real", "complex");
  const $imag = convertToTensor(imag2, "imag", "complex");
  assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, must match in call to tf.complex().`);
  const inputs = { real: $real, imag: $imag };
  return ENGINE.runKernel(Complex, inputs);
}
const complex = /* @__PURE__ */ op({ complex_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function makeTensor(values, shape, inferredShape, dtype) {
  if (dtype == null) {
    dtype = inferDtype(values);
  } else if (dtype === "complex64") {
    throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`);
  }
  if (isWebGPUData(values) || isWebGLData(values)) {
    if (dtype !== "float32" && dtype !== "int32") {
      throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${dtype}.`);
    }
    return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);
  }
  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
    throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  }
  if (shape != null) {
    assertNonNegativeIntegerDimensions(shape);
    const providedSize = sizeFromShape(shape);
    const inferredSize = sizeFromShape(inferredShape);
    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ${providedSize} values but has ${inferredSize}`);
    for (let i = 0; i < inferredShape.length; ++i) {
      const inferred = inferredShape[i];
      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape (${inferredShape}) does not match the provided shape (${shape}). `);
    }
  }
  if (!isTypedArray(values) && !Array.isArray(values)) {
    values = [values];
  }
  shape = shape || inferredShape;
  values = dtype !== "string" ? toTypedArray(values, dtype) : flatten$1(values, [], true);
  return ENGINE.makeTensor(values, shape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor(values, shape, dtype) {
  const inferredShape = inferShape(values, dtype);
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DTYPE_VALUE_SIZE_MAP = {
  "float32": 4,
  "float16": 2,
  "int32": 4,
  "uint16": 2,
  "uint8": 1,
  "bool": 1,
  "complex64": 8
};
class CompositeArrayBuffer {
  /**
   * Concatenate a number of ArrayBuffers into one.
   *
   * @param buffers An array of ArrayBuffers to concatenate, or a single
   *     ArrayBuffer.
   * @returns Result of concatenating `buffers` in order.
   */
  static join(buffers) {
    return new CompositeArrayBuffer(buffers).slice();
  }
  constructor(buffers) {
    this.shards = [];
    this.previousShardIndex = 0;
    if (buffers == null) {
      return;
    }
    if (!(buffers instanceof Array)) {
      buffers = [buffers];
    }
    buffers = buffers.map((bufferOrTypedArray) => {
      if (isTypedArray(bufferOrTypedArray)) {
        return bufferOrTypedArray.buffer;
      }
      return bufferOrTypedArray;
    });
    if (buffers.length === 0) {
      return;
    }
    this.bufferUniformSize = buffers[0].byteLength;
    let start2 = 0;
    for (let i = 0; i < buffers.length; i++) {
      const buffer2 = buffers[i];
      if (i !== buffers.length - 1 && buffer2.byteLength !== this.bufferUniformSize) {
        this.bufferUniformSize = void 0;
      }
      const end = start2 + buffer2.byteLength;
      this.shards.push({ buffer: buffer2, start: start2, end });
      start2 = end;
    }
    if (this.shards.length === 0) {
      this.byteLength = 0;
    }
    this.byteLength = this.shards[this.shards.length - 1].end;
  }
  slice(start2 = 0, end = this.byteLength) {
    if (this.shards.length === 0) {
      return new ArrayBuffer(0);
    }
    start2 = isNaN(Number(start2)) ? 0 : start2;
    end = isNaN(Number(end)) ? 0 : end;
    start2 = Math.max(0, start2);
    end = Math.min(this.byteLength, end);
    if (end <= start2) {
      return new ArrayBuffer(0);
    }
    const startShardIndex = this.findShardForByte(start2);
    if (startShardIndex === -1) {
      throw new Error(`Could not find start shard for byte ${start2}`);
    }
    const size = end - start2;
    const outputBuffer = new ArrayBuffer(size);
    const outputArray = new Uint8Array(outputBuffer);
    let sliced = 0;
    for (let i = startShardIndex; i < this.shards.length; i++) {
      const shard = this.shards[i];
      const globalStart = start2 + sliced;
      const localStart = globalStart - shard.start;
      const outputStart = sliced;
      const globalEnd = Math.min(end, shard.end);
      const localEnd = globalEnd - shard.start;
      const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);
      outputArray.set(outputSlice, outputStart);
      sliced += outputSlice.length;
      if (end < shard.end) {
        break;
      }
    }
    return outputBuffer;
  }
  /**
   * Get the index of the shard that contains the byte at `byteIndex`.
   */
  findShardForByte(byteIndex) {
    if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {
      return -1;
    }
    if (this.bufferUniformSize != null) {
      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);
      return this.previousShardIndex;
    }
    function check(shard) {
      if (byteIndex < shard.start) {
        return -1;
      }
      if (byteIndex >= shard.end) {
        return 1;
      }
      return 0;
    }
    if (check(this.shards[this.previousShardIndex]) === 0) {
      return this.previousShardIndex;
    }
    const index = search(this.shards, check);
    if (index === -1) {
      return -1;
    }
    this.previousShardIndex = index;
    return this.previousShardIndex;
  }
}
function search(sortedArray, compare) {
  let min2 = 0;
  let max2 = sortedArray.length;
  while (min2 <= max2) {
    const middle = Math.floor((max2 - min2) / 2) + min2;
    const side = compare(sortedArray[middle]);
    if (side === 0) {
      return middle;
    } else if (side < 0) {
      max2 = middle;
    } else {
      min2 = middle + 1;
    }
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function enableProdMode() {
  env().set("PROD", true);
}
function enableDebugMode() {
  env().set("DEBUG", true);
}
function disableDeprecationWarnings() {
  env().set("DEPRECATION_WARNINGS_ENABLED", false);
  console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
}
function deprecationWarn(msg) {
  if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
    console.warn(msg + " You can disable deprecation warnings with tf.disableDeprecationWarnings().");
  }
}
function disposeVariables() {
  ENGINE.disposeVariables();
}
function engine() {
  return ENGINE;
}
function memory() {
  return ENGINE.memory();
}
function profile(f) {
  return ENGINE.profile(f);
}
function tidy(nameOrFn, fn) {
  return ENGINE.tidy(nameOrFn, fn);
}
function dispose(container) {
  const tensors = getTensorsInContainer(container);
  tensors.forEach((tensor2) => tensor2.dispose());
}
function keep(result) {
  return ENGINE.keep(result);
}
function time(f) {
  return ENGINE.time(f);
}
function setBackend(backendName) {
  return ENGINE.setBackend(backendName);
}
function ready() {
  return ENGINE.ready();
}
function getBackend() {
  return ENGINE.backendName;
}
function removeBackend(name) {
  ENGINE.removeBackend(name);
}
function findBackend(name) {
  return ENGINE.findBackend(name);
}
function findBackendFactory(name) {
  return ENGINE.findBackendFactory(name);
}
function registerBackend(name, factory, priority2 = 1) {
  return ENGINE.registerBackend(name, factory, priority2);
}
function backend() {
  return ENGINE.backend;
}
function setPlatform(platformName, platform) {
  env().setPlatform(platformName, platform);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NUM_BYTES_STRING_LENGTH = 4;
async function encodeWeights(tensors, group) {
  const specs = [];
  const dataPromises = [];
  const names = Array.isArray(tensors) ? tensors.map((tensor2) => tensor2.name) : Object.keys(tensors);
  for (let i = 0; i < names.length; ++i) {
    const name = names[i];
    const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
    if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
      throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
    }
    const spec = { name, shape: t.shape, dtype: t.dtype };
    if (t.dtype === "string") {
      const utf8bytes = new Promise(async (resolve) => {
        const vals = await t.bytes();
        const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
        const bytes = new Uint8Array(totalNumBytes);
        let offset = 0;
        for (let i2 = 0; i2 < vals.length; i2++) {
          const val = vals[i2];
          const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
          bytes.set(bytesOfLength, offset);
          offset += NUM_BYTES_STRING_LENGTH;
          bytes.set(val, offset);
          offset += val.length;
        }
        resolve(bytes);
      });
      dataPromises.push(utf8bytes);
    } else {
      dataPromises.push(t.data());
    }
    if (group != null) {
      spec.group = group;
    }
    specs.push(spec);
  }
  const tensorValues = await Promise.all(dataPromises);
  return { data: concatenateTypedArrays(tensorValues), specs };
}
function decodeWeights(weightData, specs) {
  const compositeBuffer = new CompositeArrayBuffer(weightData);
  const out = {};
  let offset = 0;
  for (const spec of specs) {
    const byteLength = getWeightBytelength(spec, (start2, end) => {
      return compositeBuffer.slice(offset + start2, offset + end);
    });
    out[spec.name] = decodeWeight(spec, compositeBuffer.slice(offset, offset + byteLength));
    offset += byteLength;
  }
  return out;
}
function getWeightBytelength(spec, slice2) {
  const size = sizeFromShape(spec.shape);
  let bytesPerValue;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
  } else if (spec.dtype === "string") {
    let byteLength = 0;
    for (let i = 0; i < size; i++) {
      byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(slice2(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
    }
    return byteLength;
  } else {
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
  }
  return size * bytesPerValue;
}
async function getWeightBytelengthAsync(spec, slice2) {
  const size = sizeFromShape(spec.shape);
  let bytesPerValue;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
  } else if (spec.dtype === "string") {
    let byteLength = 0;
    for (let i = 0; i < size; i++) {
      byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(await slice2(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
    }
    return byteLength;
  } else {
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
  }
  return size * bytesPerValue;
}
function decodeWeight(spec, byteBuffer) {
  const name = spec.name;
  const dtype = spec.dtype;
  const shape = spec.shape;
  const size = sizeFromShape(shape);
  let values;
  let offset = 0;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
      if (!("min" in quantization && "scale" in quantization)) {
        throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} doesn't have corresponding metadata min and scale.`);
      }
    } else if (quantization.dtype === "float16") {
      if (dtype !== "float32") {
        throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} which only supports weights of type float32 not ${dtype}.`);
      }
    } else {
      throw new Error(`Weight ${spec.name} has unknown quantization dtype ${quantization.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
    }
    const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
    const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
    if (dtype === "float32") {
      if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
        values = new Float32Array(quantizedArray.length);
        for (let i = 0; i < quantizedArray.length; i++) {
          const v = quantizedArray[i];
          values[i] = v * quantization.scale + quantization.min;
        }
      } else if (quantization.dtype === "float16") {
        const float16Decode = getFloat16Decoder();
        values = float16Decode(quantizedArray);
      } else {
        throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type float32.`);
      }
    } else if (dtype === "int32") {
      if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
        throw new Error(`Unsupported quantization type ${quantization.dtype} for weight type int32.`);
      }
      values = new Int32Array(quantizedArray.length);
      for (let i = 0; i < quantizedArray.length; i++) {
        const v = quantizedArray[i];
        values[i] = Math.round(v * quantization.scale + quantization.min);
      }
    } else {
      throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
    }
    offset += size * quantizationSizeFactor;
  } else if (dtype === "string") {
    const size2 = sizeFromShape(spec.shape);
    values = [];
    for (let i = 0; i < size2; i++) {
      const byteLength = new Uint32Array(byteBuffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
      offset += NUM_BYTES_STRING_LENGTH;
      const bytes = new Uint8Array(byteBuffer.slice(offset, offset + byteLength));
      values.push(bytes);
      offset += byteLength;
    }
  } else {
    const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
    if (dtype === "float32") {
      values = new Float32Array(byteBuffer);
    } else if (dtype === "int32") {
      values = new Int32Array(byteBuffer);
    } else if (dtype === "bool") {
      values = new Uint8Array(byteBuffer);
    } else if (dtype === "complex64") {
      values = new Float32Array(byteBuffer);
      const real2 = new Float32Array(values.length / 2);
      const image2 = new Float32Array(values.length / 2);
      for (let i = 0; i < real2.length; i++) {
        real2[i] = values[i * 2];
        image2[i] = values[i * 2 + 1];
      }
      const realTensor = tensor(real2, shape, "float32");
      const imageTensor = tensor(image2, shape, "float32");
      const complexTensor = complex(realTensor, imageTensor);
      realTensor.dispose();
      imageTensor.dispose();
      return complexTensor;
    } else {
      throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
    }
    offset += size * dtypeFactor;
  }
  return tensor(values, shape, dtype);
}
async function readToLength(reader, initialData, length) {
  let data = new Uint8Array(initialData);
  while (data.byteLength < length) {
    const { done, value } = await reader.read();
    if (done && value == null) {
      const missing = length - data.byteLength;
      throw new Error(`Reader is done but ${missing} bytes are still expected`);
    }
    const newData = new Uint8Array(data.length + value.byteLength);
    newData.set(data, 0);
    newData.set(new Uint8Array(value), data.length);
    data = newData;
  }
  return data.buffer;
}
async function decodeWeightsStream(weightStream, specs) {
  const tensors = {};
  const reader = weightStream.getReader();
  let data = new ArrayBuffer(0);
  for (const spec of specs) {
    const byteLength = await getWeightBytelengthAsync(spec, async (start2, end) => {
      data = await readToLength(reader, data, end);
      return data.slice(start2, end);
    });
    data = await readToLength(reader, data, byteLength);
    const tensorData = data.slice(0, byteLength);
    data = data.slice(byteLength);
    const weightTensor = decodeWeight(spec, tensorData);
    tensors[spec.name] = weightTensor;
    if (getBackend() === "webgpu") {
      const b = backend();
      if ("uploadToGPU" in b && sizeFromShape(weightTensor.shape) >= env().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")) {
        b.uploadToGPU(weightTensor.dataId);
      }
    }
  }
  return tensors;
}
function concatenateTypedArrays(xs) {
  if (xs === null) {
    throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
  }
  let totalByteLength = 0;
  const normalizedXs = [];
  xs.forEach((x) => {
    totalByteLength += x.byteLength;
    normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
    if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
      throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
    }
  });
  const y = new Uint8Array(totalByteLength);
  let offset = 0;
  normalizedXs.forEach((x) => {
    y.set(new Uint8Array(x.buffer), offset);
    offset += x.byteLength;
  });
  return y.buffer;
}
const useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
function stringByteLength(str) {
  if (useNodeBuffer) {
    return Buffer.byteLength(str, "utf8");
  }
  return new Blob([str]).size;
}
function arrayBufferToBase64String(buffer2) {
  if (useNodeBuffer) {
    return Buffer.from(buffer2).toString("base64");
  }
  const buf = new Uint8Array(buffer2);
  let s = "";
  for (let i = 0, l = buf.length; i < l; i++) {
    s += String.fromCharCode(buf[i]);
  }
  return btoa(s);
}
function base64StringToArrayBuffer(str) {
  if (useNodeBuffer) {
    const buf = Buffer.from(str, "base64");
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  const s = atob(str);
  const buffer2 = new Uint8Array(s.length);
  for (let i = 0; i < s.length; ++i) {
    buffer2.set([s.charCodeAt(i)], i);
  }
  return buffer2.buffer;
}
function concatenateArrayBuffers(buffers) {
  return CompositeArrayBuffer.join(buffers);
}
function basename(path) {
  const SEPARATOR = "/";
  path = path.trim();
  while (path.endsWith(SEPARATOR)) {
    path = path.slice(0, path.length - 1);
  }
  const items = path.split(SEPARATOR);
  return items[items.length - 1];
}
function getModelJSONForModelArtifacts(artifacts, manifest) {
  const result = {
    modelTopology: artifacts.modelTopology,
    format: artifacts.format,
    generatedBy: artifacts.generatedBy,
    convertedBy: artifacts.convertedBy,
    weightsManifest: manifest
  };
  if (artifacts.signature != null) {
    result.signature = artifacts.signature;
  }
  if (artifacts.userDefinedMetadata != null) {
    result.userDefinedMetadata = artifacts.userDefinedMetadata;
  }
  if (artifacts.modelInitializer != null) {
    result.modelInitializer = artifacts.modelInitializer;
  }
  if (artifacts.initializerSignature != null) {
    result.initializerSignature = artifacts.initializerSignature;
  }
  if (artifacts.trainingConfig != null) {
    result.trainingConfig = artifacts.trainingConfig;
  }
  return result;
}
function getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData) {
  const modelArtifacts = {
    modelTopology: modelJSON.modelTopology,
    format: modelJSON.format,
    generatedBy: modelJSON.generatedBy,
    convertedBy: modelJSON.convertedBy
  };
  if (modelJSON.trainingConfig != null) {
    modelArtifacts.trainingConfig = modelJSON.trainingConfig;
  }
  if (modelJSON.weightsManifest != null) {
    if (!weightSpecs) {
      throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    }
    if (!weightData) {
      throw new Error("modelJSON has weightsManifest but weightData is null");
    }
    modelArtifacts.weightSpecs = weightSpecs;
    modelArtifacts.weightData = weightData;
  }
  if (modelJSON.signature != null) {
    modelArtifacts.signature = modelJSON.signature;
  }
  if (modelJSON.userDefinedMetadata != null) {
    modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
  }
  if (modelJSON.modelInitializer != null) {
    modelArtifacts.modelInitializer = modelJSON.modelInitializer;
  }
  if (modelJSON.initializerSignature != null) {
    modelArtifacts.initializerSignature = modelJSON.initializerSignature;
  }
  return modelArtifacts;
}
async function getModelArtifactsForJSON(modelJSON, loadWeights2) {
  let weightSpecs;
  let weightData;
  if (modelJSON.weightsManifest != null) {
    [weightSpecs, weightData] = await loadWeights2(modelJSON.weightsManifest);
  }
  return getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData);
}
function getModelArtifactsInfoForJSON(modelArtifacts) {
  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  }
  return {
    dateSaved: /* @__PURE__ */ new Date(),
    modelTopologyType: "JSON",
    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
    weightDataBytes: modelArtifacts.weightData == null ? 0 : new CompositeArrayBuffer(modelArtifacts.weightData).byteLength
  };
}
function getWeightSpecs(weightsManifest) {
  const weightSpecs = [];
  for (const entry of weightsManifest) {
    weightSpecs.push(...entry.weights);
  }
  return weightSpecs;
}
function computeFloat16MantisaTable() {
  const convertMantissa = (i) => {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      e -= 8388608;
      m <<= 1;
    }
    m &= ~8388608;
    e += 947912704;
    return m | e;
  };
  const mantisaTable = new Uint32Array(2048);
  mantisaTable[0] = 0;
  for (let i = 1; i < 1024; i++) {
    mantisaTable[i] = convertMantissa(i);
  }
  for (let i = 1024; i < 2048; i++) {
    mantisaTable[i] = 939524096 + (i - 1024 << 13);
  }
  return mantisaTable;
}
function computeFloat16ExponentTable() {
  const exponentTable = new Uint32Array(64);
  exponentTable[0] = 0;
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 31; i++) {
    exponentTable[i] = i << 23;
  }
  for (let i = 33; i < 63; i++) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  return exponentTable;
}
function computeFloat16OffsetTable() {
  const offsetTable = new Uint32Array(64);
  for (let i = 0; i < 64; i++) {
    offsetTable[i] = 1024;
  }
  offsetTable[0] = offsetTable[32] = 0;
  return offsetTable;
}
function getFloat16Decoder() {
  const mantisaTable = computeFloat16MantisaTable();
  const exponentTable = computeFloat16ExponentTable();
  const offsetTable = computeFloat16OffsetTable();
  return (quantizedArray) => {
    const buffer2 = new ArrayBuffer(4 * quantizedArray.length);
    const bufferUint32View = new Uint32Array(buffer2);
    for (let index = 0; index < quantizedArray.length; index++) {
      const float16Bits = quantizedArray[index];
      const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
      bufferUint32View[index] = float32Bits;
    }
    return new Float32Array(buffer2);
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class IORouterRegistry {
  constructor() {
    this.saveRouters = [];
    this.loadRouters = [];
  }
  static getInstance() {
    if (IORouterRegistry.instance == null) {
      IORouterRegistry.instance = new IORouterRegistry();
    }
    return IORouterRegistry.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerSaveRouter(saveRouter) {
    IORouterRegistry.getInstance().saveRouters.push(saveRouter);
  }
  /**
   * Register a load-handler router.
   *
   * @param loadRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `load` method defined or `null`.
   */
  static registerLoadRouter(loadRouter) {
    IORouterRegistry.getInstance().loadRouters.push(loadRouter);
  }
  /**
   * Look up IOHandler for saving, given a URL-like string.
   *
   * @param url
   * @returns If only one match is found, an instance of IOHandler with the
   * `save` method defined. If no match is found, `null`.
   * @throws Error, if more than one match is found.
   */
  static getSaveHandlers(url) {
    return IORouterRegistry.getHandlers(url, "save");
  }
  /**
   * Look up IOHandler for loading, given a URL-like string.
   *
   * @param url
   * @param loadOptions Optional, custom load options.
   * @returns All valid handlers for `url`, given the currently registered
   *   handler routers.
   */
  static getLoadHandlers(url, loadOptions) {
    return IORouterRegistry.getHandlers(url, "load", loadOptions);
  }
  static getHandlers(url, handlerType, loadOptions) {
    const validHandlers = [];
    const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
    routers.forEach((router) => {
      const handler = router(url, loadOptions);
      if (handler !== null) {
        validHandlers.push(handler);
      }
    });
    return validHandlers;
  }
}
const registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter);
const registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter);
const getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url);
const getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DATABASE_NAME = "tensorflowjs";
const DATABASE_VERSION = 1;
const MODEL_STORE_NAME = "models_store";
const INFO_STORE_NAME = "model_info_store";
function getIndexedDBFactory() {
  if (!env().getBool("IS_BROWSER")) {
    throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  }
  const theWindow = typeof window === "undefined" ? self : window;
  const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
  if (factory == null) {
    throw new Error("The current browser does not appear to support IndexedDB.");
  }
  return factory;
}
function setUpDatabase(openRequest) {
  const db = openRequest.result;
  db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
  db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
}
class BrowserIndexedDB {
  constructor(modelPath) {
    this.indexedDB = getIndexedDBFactory();
    if (modelPath == null || !modelPath) {
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    }
    return this.databaseAction(this.modelPath, modelArtifacts);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  /**
   * Perform database action to put model artifacts into or read model artifacts
   * from IndexedDB object store.
   *
   * Whether the action is put or get depends on whether `modelArtifacts` is
   * specified. If it is specified, the action will be put; otherwise the action
   * will be get.
   *
   * @param modelPath A unique string path for the model.
   * @param modelArtifacts If specified, it will be the model artifacts to be
   *   stored in IndexedDB.
   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`
   *   of `ModelArtifacts`, if the action is get.
   */
  databaseAction(modelPath, modelArtifacts) {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        if (modelArtifacts == null) {
          const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
          const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
          const getRequest = modelStore.get(this.modelPath);
          getRequest.onsuccess = () => {
            if (getRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
            } else {
              resolve(getRequest.result.modelArtifacts);
            }
          };
          getRequest.onerror = (error) => {
            db.close();
            return reject(getRequest.error);
          };
          modelTx.oncomplete = () => db.close();
        } else {
          modelArtifacts.weightData = CompositeArrayBuffer.join(modelArtifacts.weightData);
          const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          let infoStore = infoTx.objectStore(INFO_STORE_NAME);
          let putInfoRequest;
          try {
            putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
          } catch (error) {
            return reject(error);
          }
          let modelTx;
          putInfoRequest.onsuccess = () => {
            modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            let putModelRequest;
            try {
              putModelRequest = modelStore.put({
                modelPath: this.modelPath,
                modelArtifacts,
                modelArtifactsInfo
              });
            } catch (error) {
              return reject(error);
            }
            putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
            putModelRequest.onerror = (error) => {
              infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const deleteInfoRequest = infoStore.delete(this.modelPath);
              deleteInfoRequest.onsuccess = () => {
                db.close();
                return reject(putModelRequest.error);
              };
              deleteInfoRequest.onerror = (error2) => {
                db.close();
                return reject(putModelRequest.error);
              };
            };
          };
          putInfoRequest.onerror = (error) => {
            db.close();
            return reject(putInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        }
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
}
BrowserIndexedDB.URL_SCHEME = "indexeddb://";
const indexedDBRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(indexedDBRouter);
IORouterRegistry.registerLoadRouter(indexedDBRouter);
function browserIndexedDB(modelPath) {
  return new BrowserIndexedDB(modelPath);
}
function maybeStripScheme$1(key) {
  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
}
class BrowserIndexedDBManager {
  constructor() {
    this.indexedDB = getIndexedDBFactory();
  }
  async listModels() {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const tx = db.transaction(INFO_STORE_NAME, "readonly");
        const store = tx.objectStore(INFO_STORE_NAME);
        const getAllInfoRequest = store.getAll();
        getAllInfoRequest.onsuccess = () => {
          const out = {};
          for (const item of getAllInfoRequest.result) {
            out[item.modelPath] = item.modelArtifactsInfo;
          }
          resolve(out);
        };
        getAllInfoRequest.onerror = (error) => {
          db.close();
          return reject(getAllInfoRequest.error);
        };
        tx.oncomplete = () => db.close();
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
  async removeModel(path) {
    path = maybeStripScheme$1(path);
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
        const infoStore = infoTx.objectStore(INFO_STORE_NAME);
        const getInfoRequest = infoStore.get(path);
        let modelTx;
        getInfoRequest.onsuccess = () => {
          if (getInfoRequest.result == null) {
            db.close();
            return reject(new Error(`Cannot find model with path '${path}' in IndexedDB.`));
          } else {
            const deleteInfoRequest = infoStore.delete(path);
            const deleteModelData = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const deleteModelRequest = modelStore.delete(path);
              deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
              deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
            };
            deleteInfoRequest.onsuccess = deleteModelData;
            deleteInfoRequest.onerror = (error) => {
              deleteModelData();
              db.close();
              return reject(getInfoRequest.error);
            };
          }
        };
        getInfoRequest.onerror = (error) => {
          db.close();
          return reject(getInfoRequest.error);
        };
        infoTx.oncomplete = () => {
          if (modelTx == null) {
            db.close();
          } else {
            modelTx.oncomplete = () => db.close();
          }
        };
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PATH_SEPARATOR = "/";
const PATH_PREFIX = "tensorflowjs_models";
const INFO_SUFFIX = "info";
const MODEL_TOPOLOGY_SUFFIX = "model_topology";
const WEIGHT_SPECS_SUFFIX = "weight_specs";
const WEIGHT_DATA_SUFFIX = "weight_data";
const MODEL_METADATA_SUFFIX = "model_metadata";
function getModelKeys(path) {
  return {
    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
    modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
  };
}
function removeItems(keys) {
  for (const key of Object.values(keys)) {
    window.localStorage.removeItem(key);
  }
}
function getModelPathFromKey(key) {
  const items = key.split(PATH_SEPARATOR);
  if (items.length < 3) {
    throw new Error(`Invalid key format: ${key}`);
  }
  return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme(key) {
  return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
}
class BrowserLocalStorage {
  constructor(modelPath) {
    if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
      throw new Error("The current environment does not support local storage.");
    }
    this.LS = window.localStorage;
    if (modelPath == null || !modelPath) {
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
    this.keys = getModelKeys(this.modelPath);
  }
  /**
   * Save model artifacts to browser local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @param modelArtifacts The model artifacts to be stored.
   * @returns An instance of SaveResult.
   */
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    } else {
      const topology = JSON.stringify(modelArtifacts.modelTopology);
      const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
      const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
      const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
        this.LS.setItem(this.keys.topology, topology);
        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
        this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(weightBuffer));
        const metadata = {
          format: modelArtifacts.format,
          generatedBy: modelArtifacts.generatedBy,
          convertedBy: modelArtifacts.convertedBy,
          signature: modelArtifacts.signature != null ? modelArtifacts.signature : void 0,
          userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : void 0,
          modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : void 0,
          initializerSignature: modelArtifacts.initializerSignature != null ? modelArtifacts.initializerSignature : void 0,
          trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : void 0
        };
        this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
        return { modelArtifactsInfo };
      } catch (err) {
        removeItems(this.keys);
        throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
      }
    }
  }
  /**
   * Load a model from local storage.
   *
   * See the documentation to `browserLocalStorage` for details on the saved
   * artifacts.
   *
   * @returns The loaded model (if loading succeeds).
   */
  async load() {
    const info = JSON.parse(this.LS.getItem(this.keys.info));
    if (info == null) {
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    }
    if (info.modelTopologyType !== "JSON") {
      throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    }
    const out = {};
    const topology = JSON.parse(this.LS.getItem(this.keys.topology));
    if (topology == null) {
      throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
    }
    out.modelTopology = topology;
    const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (weightSpecs == null) {
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
    }
    out.weightSpecs = weightSpecs;
    const metadataString = this.LS.getItem(this.keys.modelMetadata);
    if (metadataString != null) {
      const metadata = JSON.parse(metadataString);
      out.format = metadata.format;
      out.generatedBy = metadata.generatedBy;
      out.convertedBy = metadata.convertedBy;
      if (metadata.signature != null) {
        out.signature = metadata.signature;
      }
      if (metadata.userDefinedMetadata != null) {
        out.userDefinedMetadata = metadata.userDefinedMetadata;
      }
      if (metadata.modelInitializer != null) {
        out.modelInitializer = metadata.modelInitializer;
      }
      if (metadata.initializerSignature != null) {
        out.initializerSignature = metadata.initializerSignature;
      }
      if (metadata.trainingConfig != null) {
        out.trainingConfig = metadata.trainingConfig;
      }
    }
    const weightDataBase64 = this.LS.getItem(this.keys.weightData);
    if (weightDataBase64 == null) {
      throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
    }
    out.weightData = base64StringToArrayBuffer(weightDataBase64);
    return out;
  }
}
BrowserLocalStorage.URL_SCHEME = "localstorage://";
const localStorageRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
      return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(localStorageRouter);
IORouterRegistry.registerLoadRouter(localStorageRouter);
function browserLocalStorage(modelPath) {
  return new BrowserLocalStorage(modelPath);
}
class BrowserLocalStorageManager {
  constructor() {
    assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
    assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
    this.LS = window.localStorage;
  }
  async listModels() {
    const out = {};
    const prefix2 = PATH_PREFIX + PATH_SEPARATOR;
    const suffix = PATH_SEPARATOR + INFO_SUFFIX;
    for (let i = 0; i < this.LS.length; ++i) {
      const key = this.LS.key(i);
      if (key.startsWith(prefix2) && key.endsWith(suffix)) {
        const modelPath = getModelPathFromKey(key);
        out[modelPath] = JSON.parse(this.LS.getItem(key));
      }
    }
    return out;
  }
  async removeModel(path) {
    path = maybeStripScheme(path);
    const keys = getModelKeys(path);
    if (this.LS.getItem(keys.info) == null) {
      throw new Error(`Cannot find model at path '${path}'`);
    }
    const info = JSON.parse(this.LS.getItem(keys.info));
    removeItems(keys);
    return info;
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const URL_SCHEME_SUFFIX = "://";
class ModelStoreManagerRegistry {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    if (ModelStoreManagerRegistry.instance == null) {
      ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();
    }
    return ModelStoreManagerRegistry.instance;
  }
  /**
   * Register a save-handler router.
   *
   * @param saveRouter A function that maps a URL-like string onto an instance
   * of `IOHandler` with the `save` method defined or `null`.
   */
  static registerManager(scheme, manager) {
    assert(scheme != null, () => "scheme must not be undefined or null.");
    if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
      scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
    }
    assert(scheme.length > 0, () => "scheme must not be an empty string.");
    const registry = ModelStoreManagerRegistry.getInstance();
    assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
    registry.managers[scheme] = manager;
  }
  static getManager(scheme) {
    const manager = ModelStoreManagerRegistry.getInstance().managers[scheme];
    if (manager == null) {
      throw new Error(`Cannot find model manager for scheme '${scheme}'`);
    }
    return manager;
  }
  static getSchemes() {
    return Object.keys(ModelStoreManagerRegistry.getInstance().managers);
  }
}
function parseURL(url) {
  if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
    throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);
  }
  return {
    scheme: url.split(URL_SCHEME_SUFFIX)[0],
    path: url.split(URL_SCHEME_SUFFIX)[1]
  };
}
async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
  assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
  const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
  assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
  assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) load handlers for source URL ${sourceURL}.`);
  const loadHandler = loadHandlers[0];
  const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
  assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination URL ${destURL}.`);
  assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) save handlers for destination URL ${destURL}.`);
  const saveHandler = saveHandlers[0];
  const sourceScheme = parseURL(sourceURL).scheme;
  const sourcePath = parseURL(sourceURL).path;
  const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
  const modelArtifacts = await loadHandler.load();
  if (deleteSource && sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  const saveResult = await saveHandler.save(modelArtifacts);
  if (deleteSource && !sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  return saveResult.modelArtifactsInfo;
}
async function listModels() {
  const schemes = ModelStoreManagerRegistry.getSchemes();
  const out = {};
  for (const scheme of schemes) {
    const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
    for (const path in schemeOut) {
      const url = scheme + URL_SCHEME_SUFFIX + path;
      out[url] = schemeOut[path];
    }
  }
  return out;
}
async function removeModel(url) {
  const schemeAndPath = parseURL(url);
  const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
  return manager.removeModel(schemeAndPath.path);
}
async function copyModel(sourceURL, destURL) {
  const deleteSource = false;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}
async function moveModel(sourceURL, destURL) {
  const deleteSource = true;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class PlatformBrowser {
  constructor() {
    this.messageName = "setTimeoutCustom";
    this.functionRefs = [];
    this.handledMessageCount = 0;
    this.hasEventListener = false;
  }
  fetch(path, init) {
    return fetch(path, init);
  }
  now() {
    return performance.now();
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
    }
    if (this.textEncoder == null) {
      this.textEncoder = new TextEncoder();
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    return new TextDecoder(encoding).decode(bytes);
  }
  // If the setTimeout nesting level is greater than 5 and timeout is less
  // than 4ms, timeout will be clamped to 4ms, which hurts the perf.
  // Interleaving window.postMessage and setTimeout will trick the browser and
  // avoid the clamp.
  setTimeoutCustom(functionRef, delay2) {
    if (typeof window === "undefined" || !env().getBool("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(functionRef, delay2);
      return;
    }
    this.functionRefs.push(functionRef);
    setTimeout(() => {
      window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
    }, delay2);
    if (!this.hasEventListener) {
      this.hasEventListener = true;
      window.addEventListener("message", (event) => {
        if (event.source === window && event.data.name === this.messageName) {
          event.stopPropagation();
          const functionRef2 = this.functionRefs[event.data.index];
          functionRef2();
          this.handledMessageCount++;
          if (this.handledMessageCount === this.functionRefs.length) {
            this.functionRefs = [];
            this.handledMessageCount = 0;
          }
        }
      }, true);
    }
  }
  isTypedArray(a) {
    return isTypedArrayBrowser(a);
  }
}
if (env().get("IS_BROWSER")) {
  env().setPlatform("browser", new PlatformBrowser());
  try {
    ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());
  } catch (err) {
  }
  try {
    ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());
  } catch (err) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const getNodeFetch = {
  // tslint:disable-next-line:no-require-imports
  importFetch: () => require("node-fetch")
};
let systemFetch;
class PlatformNode {
  constructor() {
    this.util = require("util");
    this.textEncoder = new this.util.TextEncoder();
  }
  fetch(path, requestInits) {
    if (env().global.fetch != null) {
      return env().global.fetch(path, requestInits);
    }
    if (systemFetch == null) {
      systemFetch = getNodeFetch.importFetch();
    }
    return systemFetch(path, requestInits);
  }
  now() {
    const time2 = process.hrtime();
    return time2[0] * 1e3 + time2[1] / 1e6;
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    if (bytes.length === 0) {
      return "";
    }
    return new this.util.TextDecoder(encoding).decode(bytes);
  }
  isTypedArray(a) {
    return this.util.types.isFloat32Array(a) || this.util.types.isInt32Array(a) || this.util.types.isUint8Array(a) || this.util.types.isUint8ClampedArray(a);
  }
}
if (env().get("IS_NODE") && !env().get("IS_BROWSER")) {
  env().setPlatform("node", new PlatformNode());
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function buffer(shape, dtype = "float32", values) {
  dtype = dtype || "float32";
  assertNonNegativeIntegerDimensions(shape);
  return new TensorBuffer(shape, dtype, values);
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cast_(x, dtype) {
  const $x = convertToTensor(x, "x", "cast");
  if (!isValidDtype(dtype)) {
    throw new Error(`Failed to cast to unknown dtype ${dtype}`);
  }
  if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
    throw new Error("Only strings can be casted to strings");
  }
  const inputs = { x: $x };
  const attrs = { dtype };
  return ENGINE.runKernel(Cast, inputs, attrs);
}
const cast = /* @__PURE__ */ op({ cast_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function clone_(x) {
  const $x = convertToTensor(x, "x", "clone", "string_or_numeric");
  const inputs = { x: $x };
  return ENGINE.runKernel(Identity, inputs);
}
const clone = /* @__PURE__ */ op({ clone_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function print(x, verbose = false) {
  console.log(x.toString(verbose));
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
getOrMakeEngine();
const opHandler = {
  buffer,
  cast,
  clone,
  print
};
setOpHandler(opHandler);
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function add_(a, b) {
  let $a = convertToTensor(a, "a", "add");
  let $b = convertToTensor(b, "b", "add");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Add, inputs);
}
const add = /* @__PURE__ */ op({ add_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function floorDiv_(a, b) {
  let $a = convertToTensor(a, "a", "floorDiv");
  let $b = convertToTensor(b, "b", "floorDiv");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(FloorDiv, inputs);
}
const floorDiv = /* @__PURE__ */ op({ floorDiv_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function div_(a, b) {
  let $a = convertToTensor(a, "a", "div");
  let $b = convertToTensor(b, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "int32" && $b.dtype === "int32") {
    return floorDiv($a, $b);
  }
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(RealDiv, inputs, attrs);
}
const div = /* @__PURE__ */ op({ div_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mul_(a, b) {
  let $a = convertToTensor(a, "a", "mul");
  let $b = convertToTensor(b, "b", "mul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Multiply, inputs);
}
const mul = /* @__PURE__ */ op({ mul_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function abs_(x) {
  const $x = convertToTensor(x, "x", "abs");
  if ($x.dtype === "complex64") {
    const inputs = { x: $x };
    return ENGINE.runKernel(ComplexAbs, inputs);
  } else {
    const inputs = { x: $x };
    return ENGINE.runKernel(Abs, inputs);
  }
}
const abs = /* @__PURE__ */ op({ abs_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function acos_(x) {
  const $x = convertToTensor(x, "x", "acos");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acos, inputs);
}
const acos = /* @__PURE__ */ op({ acos_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function acosh_(x) {
  const $x = convertToTensor(x, "x", "acosh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acosh, inputs);
}
const acosh = /* @__PURE__ */ op({ acosh_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function addN_(tensors) {
  assert(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
  assert(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${tensors.length}`);
  const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "addN"));
  const firstTensor = $tensors[0];
  $tensors.forEach((t) => {
    if (t.dtype !== firstTensor.dtype) {
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }
  });
  $tensors.forEach((t) => {
    if (!arraysEqual$1(t.shape, firstTensor.shape)) {
      throw new Error("All tensors passed to tf.addN() must have the same shape");
    }
  });
  const inputs = $tensors;
  return ENGINE.runKernel(AddN, inputs);
}
const addN = /* @__PURE__ */ op({ addN_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function all_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "all", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(All, inputs, attrs);
}
const all = /* @__PURE__ */ op({ all_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function any_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "any", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Any, inputs, attrs);
}
const any = /* @__PURE__ */ op({ any_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function argMax_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "argMax");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMax, inputs, attrs);
}
const argMax = /* @__PURE__ */ op({ argMax_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function argMin_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "argMin");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMin, inputs, attrs);
}
const argMin = /* @__PURE__ */ op({ argMin_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function asin_(x) {
  const $x = convertToTensor(x, "x", "asin");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asin, inputs);
}
const asin = /* @__PURE__ */ op({ asin_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function asinh_(x) {
  const $x = convertToTensor(x, "x", "asinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asinh, inputs);
}
const asinh = /* @__PURE__ */ op({ asinh_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function atan_(x) {
  const $x = convertToTensor(x, "x", "atan");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atan, inputs);
}
const atan = /* @__PURE__ */ op({ atan_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function atan2_(a, b) {
  let $a = convertToTensor(a, "a", "atan2");
  let $b = convertToTensor(b, "b", "atan2");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Atan2, inputs);
}
const atan2 = /* @__PURE__ */ op({ atan2_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function atanh_(x) {
  const $x = convertToTensor(x, "x", "atanh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atanh, inputs);
}
const atanh = /* @__PURE__ */ op({ atanh_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function computeDilation2DInfo(inputShape, filterShape, strides, pad2, dataFormat = "NHWC", dilations) {
  const inputChannels = inputShape[3];
  const $filterShape = [...filterShape, inputChannels];
  const $dataFormat = convertConv2DDataFormat(dataFormat);
  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad2, null, null, $dataFormat);
}
function computePool2DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "channelsLast") {
  const [filterHeight, filterWidth] = parseTupleParam(filterSize);
  let filterShape;
  if (dataFormat === "channelsLast") {
    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
  } else if (dataFormat === "channelsFirst") {
    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, false, dataFormat);
}
function computePool3DInfo(inShape, filterSize, strides, dilations, pad2, roundingMode, dataFormat = "NDHWC") {
  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
  let filterShape;
  let $dataFormat;
  if (dataFormat === "NDHWC") {
    $dataFormat = "channelsLast";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
  } else if (dataFormat === "NCDHW") {
    $dataFormat = "channelsFirst";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, false, $dataFormat, roundingMode);
}
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad2, roundingMode, depthwise = false, dataFormat = "channelsLast") {
  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideHeight, strideWidth] = parseTupleParam(strides);
  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inHeight,
    inWidth,
    inChannels,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideHeight,
    strideWidth,
    filterHeight,
    filterWidth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeConv3DInfo(inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast", roundingMode) {
  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inDepth,
    inHeight,
    inWidth,
    inChannels,
    outDepth,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideDepth,
    strideHeight,
    strideWidth,
    filterDepth,
    filterHeight,
    filterWidth,
    effectiveFilterDepth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationDepth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputRows = inShape[0];
  const inputCols = inShape[1];
  const outputRows = round$2((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  const outputCols = round$2((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  return [outputRows, outputCols];
}
function computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
  }
  const outShape = [0, 0, 0, outChannels];
  for (let index = 0; index < 3; index++) {
    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
      outShape[index] = round$2((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1, roundingMode);
    }
  }
  return outShape;
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function parseTupleParam(param) {
  if (typeof param === "number") {
    return [param, param, param];
  }
  if (param.length === 2) {
    return [param[0], param[1], 1];
  }
  return param;
}
function parse3TupleParam(param) {
  return typeof param === "number" ? [param, param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
  if (dilation <= 1) {
    return filterSize;
  }
  return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad2, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
  let padInfo;
  let outHeight;
  let outWidth;
  if (typeof pad2 === "number") {
    const padType = pad2 === 0 ? "VALID" : "NUMBER";
    padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, type: padType };
    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad2, roundingMode);
    outHeight = outShape[0];
    outWidth = outShape[1];
  } else if (pad2 === "same") {
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, type: "SAME" };
  } else if (pad2 === "valid") {
    padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else if (typeof pad2 === "object") {
    const top = dataFormat === "channelsLast" ? pad2[1][0] : pad2[2][0];
    const bottom = dataFormat === "channelsLast" ? pad2[1][1] : pad2[2][1];
    const left = dataFormat === "channelsLast" ? pad2[2][0] : pad2[3][0];
    const right = dataFormat === "channelsLast" ? pad2[2][1] : pad2[3][1];
    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
    padInfo = { top, bottom, left, right, type: padType };
    outHeight = round$2((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
    outWidth = round$2((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
  } else {
    throw Error(`Unknown padding parameter: ${pad2}`);
  }
  return { padInfo, outHeight, outWidth };
}
function get3DPadAndOutInfo(pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
  let padInfo;
  let outDepth;
  let outHeight;
  let outWidth;
  if (pad2 === "valid") {
    pad2 = 0;
  }
  if (typeof pad2 === "number") {
    const padType = pad2 === 0 ? "VALID" : "NUMBER";
    padInfo = {
      top: pad2,
      bottom: pad2,
      left: pad2,
      right: pad2,
      front: pad2,
      back: pad2,
      type: padType
    };
    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad2, roundingMode);
    outDepth = outShape[0];
    outHeight = outShape[1];
    outWidth = outShape[2];
  } else if (pad2 === "same") {
    outDepth = Math.ceil(inDepth / strideDepth);
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
    const front = Math.floor(padAlongDepth / 2);
    const back = padAlongDepth - front;
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, front, back, type: "SAME" };
  } else {
    throw Error(`Unknown padding parameter: ${pad2}`);
  }
  return { padInfo, outDepth, outHeight, outWidth };
}
function round$2(value, roundingMode) {
  if (!roundingMode) {
    return Math.trunc(value);
  }
  switch (roundingMode) {
    case "round":
      return Math.round(value);
    case "ceil":
      return Math.ceil(value);
    case "floor":
      return Math.floor(value);
    default:
      throw new Error(`Unknown roundingMode ${roundingMode}`);
  }
}
function tupleValuesAreOne(param) {
  const [dimA, dimB, dimC] = parseTupleParam(param);
  return dimA === 1 && dimB === 1 && dimC === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function stridesOrDilationsArePositive(values) {
  return parseTupleParam(values).every((value) => value > 0);
}
function convertConv2DDataFormat(dataFormat) {
  if (dataFormat === "NHWC") {
    return "channelsLast";
  } else if (dataFormat === "NCHW") {
    return "channelsFirst";
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
}
function checkPadOnDimRoundingMode(opDesc, pad2, dimRoundingMode) {
  if (dimRoundingMode != null) {
    if (typeof pad2 === "string") {
      throw Error(`Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
    } else if (typeof pad2 === "number") {
      assert(isInt(pad2), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${pad2}.`);
    } else if (typeof pad2 === "object") {
      pad2.forEach((p) => {
        p.forEach((v) => {
          assert(isInt(v), () => `Error in ${opDesc}: pad must be an integer when using dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);
        });
      });
    } else {
      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad2}`);
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reshape_(x, shape) {
  const $x = convertToTensor(x, "x", "reshape", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = { shape };
  return ENGINE.runKernel(Reshape, inputs, attrs);
}
const reshape = /* @__PURE__ */ op({ reshape_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function avgPool_(x, filterSize, strides, pad2, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "avgPool", "float32");
  const dilations = 1;
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
  checkPadOnDimRoundingMode("avgPool", pad2, dimRoundingMode);
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
  let res = ENGINE.runKernel(AvgPool, inputs, attrs);
  res = cast(res, $x.dtype);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const avgPool = /* @__PURE__ */ op({ avgPool_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function avgPool3d_(x, filterSize, strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x, "x", "avgPool3d", "float32");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
  assert(typeof strides === "number" && strides > 0 || Array.isArray(strides) && strides[0] > 0 && strides[1] > 0 && strides[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${strides}'`);
  checkPadOnDimRoundingMode("avgPool3d", pad2, dimRoundingMode);
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
  let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
  res = cast(res, x5D.dtype);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
const avgPool3d = /* @__PURE__ */ op({ avgPool3d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function concat_(tensors, axis = 0) {
  assert(tensors.length >= 1, () => "Pass at least one tensor to concat");
  const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
  if ($tensors[0].dtype === "complex64") {
    $tensors.forEach((tensor2) => {
      if (tensor2.dtype !== "complex64") {
        throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor2.dtype}. `);
      }
    });
  }
  if ($tensors.length === 1) {
    return clone($tensors[0]);
  }
  const inputs = $tensors;
  const attr = { axis };
  return ENGINE.runKernel(Concat, inputs, attr);
}
const concat = /* @__PURE__ */ op({ concat_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function matMul_(a, b, transposeA = false, transposeB = false) {
  let $a = convertToTensor(a, "a", "matMul");
  let $b = convertToTensor(b, "b", "matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  const attrs = { transposeA, transposeB };
  return ENGINE.runKernel(BatchMatMul, inputs, attrs);
}
const matMul$1 = /* @__PURE__ */ op({ matMul_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sigmoid_(x) {
  const $x = convertToTensor(x, "x", "sigmoid", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sigmoid, inputs);
}
const sigmoid = /* @__PURE__ */ op({ sigmoid_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice", "string_or_numeric");
  if ($x.rank === 0) {
    throw new Error("Slicing scalar is not possible");
  }
  const inputs = { x: $x };
  const attrs = { begin, size };
  return ENGINE.runKernel(Slice, inputs, attrs);
}
const slice = /* @__PURE__ */ op({ slice_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tanh_(x) {
  const $x = convertToTensor(x, "x", "tanh", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tanh, inputs);
}
const tanh = /* @__PURE__ */ op({ tanh_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
  const $forgetBias = convertToTensor(forgetBias, "forgetBias", "basicLSTMCell");
  const $lstmKernel = convertToTensor(lstmKernel, "lstmKernel", "basicLSTMCell");
  const $lstmBias = convertToTensor(lstmBias, "lstmBias", "basicLSTMCell");
  const $data = convertToTensor(data, "data", "basicLSTMCell");
  const $c = convertToTensor(c, "c", "basicLSTMCell");
  const $h = convertToTensor(h, "h", "basicLSTMCell");
  const combined = concat([$data, $h], 1);
  const weighted = matMul$1(combined, $lstmKernel);
  const res = add(weighted, $lstmBias);
  const batchSize = res.shape[0];
  const sliceCols = res.shape[1] / 4;
  const sliceSize = [batchSize, sliceCols];
  const i = slice(res, [0, 0], sliceSize);
  const j = slice(res, [0, sliceCols], sliceSize);
  const f = slice(res, [0, sliceCols * 2], sliceSize);
  const o = slice(res, [0, sliceCols * 3], sliceSize);
  const newC = add(mul(sigmoid(i), tanh(j)), mul($c, sigmoid(add($forgetBias, f))));
  const newH = mul(tanh(newC), sigmoid(o));
  return [newC, newH];
}
const basicLSTMCell = /* @__PURE__ */ op({ basicLSTMCell_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function batchToSpaceND_(x, blockShape, crops) {
  const $x = convertToTensor(x, "x", "batchToSpaceND");
  const prod2 = blockShape.reduce((a, b) => a * b);
  assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
  assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
  assert($x.shape[0] % prod2 === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of the elements of blockShape ${blockShape.join(" * ")} === ${prod2}`);
  const inputs = { x: $x };
  const attrs = { blockShape, crops };
  return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
}
const batchToSpaceND = /* @__PURE__ */ op({ batchToSpaceND_ });
function xAs4D(x) {
  let x4D;
  if (x.rank === 0 || x.rank === 1) {
    x4D = reshape(x, [1, 1, 1, x.size]);
  } else if (x.rank === 2) {
    x4D = reshape(x, [1, 1, x.shape[0], x.shape[1]]);
  } else if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  } else {
    x4D = x;
  }
  return x4D;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function batchNorm_(x, mean2, variance, offset, scale2, varianceEpsilon) {
  if (varianceEpsilon == null) {
    varianceEpsilon = 1e-3;
  }
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean2, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale2 != null) {
    $scale = convertToTensor(scale2, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks.");
  assert($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks.");
  assert($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
  const x4D = xAs4D($x);
  const inputs = {
    x: x4D,
    scale: $scale,
    offset: $offset,
    mean: $mean,
    variance: $variance
  };
  const attrs = { varianceEpsilon };
  const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
  return reshape(res, $x.shape);
}
const batchNorm = /* @__PURE__ */ op({ batchNorm_ });
function batchNorm2d_(x, mean2, variance, offset, scale2, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean2, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale2 != null) {
    $scale = convertToTensor(scale2, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${$x.rank}.`);
  assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
const batchNorm2d = /* @__PURE__ */ op({ batchNorm2d_ });
function batchNorm3d_(x, mean2, variance, offset, scale2, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean2, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale2 != null) {
    $scale = convertToTensor(scale2, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${$x.rank}.`);
  assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
const batchNorm3d = /* @__PURE__ */ op({ batchNorm3d_ });
function batchNorm4d_(x, mean2, variance, offset, scale2, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean2, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale2 != null) {
    $scale = convertToTensor(scale2, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${$x.rank}.`);
  assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${$mean.rank}.`);
  assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
const batchNorm4d = /* @__PURE__ */ op({ batchNorm4d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bincount_(x, weights, size) {
  const $x = convertToTensor(x, "x", "bincount");
  const $weights = convertToTensor(weights, "weights", "bincount");
  assert($x.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${$x.dtype}`);
  assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size };
  return ENGINE.runKernel(Bincount, inputs, attrs);
}
const bincount = /* @__PURE__ */ op({ bincount_ });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bitwiseAnd_(x, y) {
  const $x = convertToTensor(x, "x", "bitwiseAnd");
  const $y = convertToTensor(y, "y", "bitwiseAnd");
  if (!arraysEqual$1($x.shape, $y.shape)) {
    throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${$x.shape}, y: ${$y.shape}`);
  }
  if ($x.dtype !== "int32" || $y.dtype !== "int32") {
    throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${$x.dtype} and type of y: ${$y.dtype}`);
  }
  const inputs = { a: $x, b: $y };
  return ENGINE.runKernel(BitwiseAnd, inputs);
}
const bitwiseAnd = /* @__PURE__ */ op({ bitwiseAnd_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function broadcastArgs_(s0, s1) {
  const shape1Input = convertToTensor(s0, "s0", "broadcastArgs", "int32");
  const shape2Input = convertToTensor(s1, "s1", "broadcastArgs", "int32");
  if (shape1Input.rank !== 1) {
    throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${shape1Input.rank}`);
  }
  if (shape2Input.rank !== 1) {
    throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${shape2Input.rank}`);
  }
  const inputs = { s0: shape1Input, s1: shape2Input };
  return ENGINE.runKernel(BroadcastArgs, inputs);
}
const broadcastArgs = /* @__PURE__ */ op({ broadcastArgs_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function broadcastTo_(x, shape) {
  let input = convertToTensor(x, "broadcastTo", "x");
  const xShape = input.shape;
  assertNonNegativeIntegerDimensions(shape);
  if (shape.length < input.rank) {
    throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
  }
  if (shape.length > input.rank) {
    const newShape = input.shape.slice();
    while (newShape.length < shape.length) {
      newShape.unshift(1);
    }
    input = reshape(input, newShape);
  }
  const inputShape = input.shape;
  const reps = Array.from(shape);
  for (let i = shape.length - 1; i >= 0; i--) {
    if (inputShape[i] === shape[i]) {
      reps[i] = 1;
    } else if (input.shape[i] !== 1) {
      throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
    }
  }
  const axes = reps.map((n, i) => n > 1 ? i : -1).filter((i) => i >= 0);
  if (axes.length === 0) {
    return clone(input);
  }
  const inputs = { x: input };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
const broadcastTo = /* @__PURE__ */ op({ broadcastTo_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ceil_(x) {
  const $x = convertToTensor(x, "x", "ceil", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Ceil, inputs);
}
const ceil = /* @__PURE__ */ op({ ceil_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fill(shape, value, dtype) {
  assertNonNegativeIntegerDimensions(shape);
  dtype = dtype || inferDtype(value);
  const attrs = { shape, value, dtype };
  return ENGINE.runKernel(Fill, {}, attrs);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function clipByValue_(x, clipValueMin, clipValueMax) {
  const $x = convertToTensor(x, "x", "clipByValue");
  assert(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be less than or equal to max (${clipValueMax}).`);
  if (clipValueMin === clipValueMax) {
    return fill($x.shape, clipValueMin, $x.dtype);
  }
  const inputs = { x: $x };
  const attrs = { clipValueMin, clipValueMax };
  return ENGINE.runKernel(ClipByValue, inputs, attrs);
}
const clipByValue = /* @__PURE__ */ op({ clipByValue_ });
function concat1d_(tensors) {
  return concat(
    tensors,
    0
    /* axis */
  );
}
const concat1d = /* @__PURE__ */ op({ concat1d_ });
function concat2d_(tensors, axis) {
  return concat(tensors, axis);
}
const concat2d = /* @__PURE__ */ op({ concat2d_ });
function concat3d_(tensors, axis) {
  return concat(tensors, axis);
}
const concat3d = /* @__PURE__ */ op({ concat3d_ });
function concat4d_(tensors, axis) {
  return concat(tensors, axis);
}
const concat4d = /* @__PURE__ */ op({ concat4d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function conv2d_(x, filter2, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv2d", "float32");
  const $filter = convertToTensor(filter2, "filter", "conv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  checkPadOnDimRoundingMode("conv2d", pad2, dimRoundingMode);
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  assert(stridesOrDilationsArePositive(dilations), () => "Error in conv2D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(strides), () => "Error in conv2D: Strides should be larger than 0.");
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
  const res = ENGINE.runKernel(Conv2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const conv2d$1 = /* @__PURE__ */ op({ conv2d_ });
function conv1d_(x, filter2, stride, pad2, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv1d");
  const $filter = convertToTensor(filter2, "filter", "conv1d");
  let x3D = $x;
  let reshapedTo3D = false;
  if ($x.rank === 2) {
    reshapedTo3D = true;
    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);
  }
  assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
  assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${$filter.rank}.`);
  checkPadOnDimRoundingMode("conv1d", pad2, dimRoundingMode);
  assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match input depth for filter ${$filter.shape[1]}.`);
  assert(eitherStridesOrDilationsAreOne(stride, dilation), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${stride} and dilation '${dilation}'`);
  assert(stridesOrDilationsArePositive(dilation), () => "Error in conv1D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(stride), () => "Error in conv1D: Stride should be larger than 0.");
  assert(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
  const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
  const strides = [1, stride];
  const dilations = [1, dilation];
  const conv2dDataFormat = "NHWC";
  const res = conv2d$1(input4D, filter4D, strides, pad2, conv2dDataFormat, dilations, dimRoundingMode);
  if (reshapedTo3D) {
    return reshape(res, [res.shape[2], res.shape[3]]);
  }
  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);
}
const conv1d = /* @__PURE__ */ op({ conv1d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function conv2DBackpropInput_(xShape, dy, filter2, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
  assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape4D = xShape;
  let dy4D = dy;
  let reshapedTo4D = false;
  if (dy.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    xShape4D = [1, xShape[0], xShape[1], xShape[2]];
  }
  assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${xShape4D.length}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${dy4D.rank}`);
  assert(filter2.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${filter2.rank}`);
  const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filter2.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter2.shape[2]}.`);
  assert(outDepth === filter2.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter2.shape[3]}.`);
  checkPadOnDimRoundingMode("conv2dDerInput", pad2, dimRoundingMode);
  const inputs = { dy: dy4D, filter: filter2 };
  const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, inputShape: xShape4D };
  const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const conv2DBackpropInput = /* @__PURE__ */ op({ conv2DBackpropInput_ });
function conv2dTranspose_(x, filter2, outputShape, strides, pad2, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv2dTranspose");
  const $filter = convertToTensor(filter2, "filter", "conv2dTranspose");
  return conv2DBackpropInput(outputShape, $x, $filter, strides, pad2, "NHWC", dimRoundingMode);
}
const conv2dTranspose = /* @__PURE__ */ op({ conv2dTranspose_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function conv3d_(x, filter2, strides, pad2, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
  const $x = convertToTensor(x, "x", "conv3d");
  const $filter = convertToTensor(filter2, "filter", "conv3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
  assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${$filter.rank}.`);
  assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match input depth for filter ${$filter.shape[3]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  assert(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
  assert(stridesOrDilationsArePositive(dilations), () => "Error in conv3D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(strides), () => "Error in conv3D: Strides should be larger than 0.");
  const inputs = { x: x5D, filter: $filter };
  const attrs = { strides, pad: pad2, dataFormat, dilations };
  const res = ENGINE.runKernel(Conv3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
const conv3d = /* @__PURE__ */ op({ conv3d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function conv3DBackpropInput_(xShape, dy, filter2, strides, pad2) {
  assert(xShape.length === dy.rank, () => `Length of inShape (${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape5D = xShape;
  let dy5D = dy;
  let reshapedTo5D = false;
  if (dy.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
    xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
  }
  const inDepth = xShape5D[4];
  const outDepth = dy5D.shape[4];
  assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${xShape5D.length}.`);
  assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${dy5D.rank}`);
  assert(filter2.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${filter2.rank}`);
  assert(inDepth === filter2.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must match input depth for filter ${filter2.shape[3]}.`);
  assert(outDepth === filter2.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must match output depth for filter ${filter2.shape[4]}.`);
  const inputs = { dy: dy5D, filter: filter2 };
  const attrs = { pad: pad2, strides, inputShape: xShape5D };
  const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
const conv3DBackpropInput = /* @__PURE__ */ op({ conv3DBackpropInput_ });
function conv3dTranspose_(x, filter2, outputShape, strides, pad2) {
  const $x = convertToTensor(x, "x", "conv3dTranspose");
  const $filter = convertToTensor(filter2, "filter", "conv3dTranspose");
  return conv3DBackpropInput(outputShape, $x, $filter, strides, pad2);
}
const conv3dTranspose = /* @__PURE__ */ op({ conv3dTranspose_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cos_(x) {
  const $x = convertToTensor(x, "x", "cos", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cos, inputs);
}
const cos = /* @__PURE__ */ op({ cos_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cosh_(x) {
  const $x = convertToTensor(x, "x", "cosh", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cosh, inputs);
}
const cosh = /* @__PURE__ */ op({ cosh_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cumprod_(x, axis = 0, exclusive = false, reverse2 = false) {
  const $x = convertToTensor(x, "x", "cumprod");
  const inputs = { x: $x };
  const attrs = { axis, exclusive, reverse: reverse2 };
  return ENGINE.runKernel(Cumprod, inputs, attrs);
}
const cumprod = /* @__PURE__ */ op({ cumprod_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cumsum_(x, axis = 0, exclusive = false, reverse2 = false) {
  const $x = convertToTensor(x, "x", "cumsum");
  const inputs = { x: $x };
  const attrs = { axis, exclusive, reverse: reverse2 };
  return ENGINE.runKernel(Cumsum, inputs, attrs);
}
const cumsum = /* @__PURE__ */ op({ cumsum_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function denseBincount_(x, weights, size, binaryOutput = false) {
  const $x = convertToTensor(x, "x", "denseBincount");
  const $weights = convertToTensor(weights, "weights", "denseBincount");
  assert($x.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${$x.dtype}`);
  assert($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${$x.rank}.`);
  assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${$x.shape}, weights shape: ${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size, binaryOutput };
  return ENGINE.runKernel(DenseBincount, inputs, attrs);
}
const denseBincount = /* @__PURE__ */ op({ denseBincount_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthToSpace_(x, blockSize, dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "depthToSpace", "float32");
  const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
  assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
  assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
  assert(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
  const inputs = { x: $x };
  const attrs = { blockSize, dataFormat };
  return ENGINE.runKernel(DepthToSpace, inputs, attrs);
}
const depthToSpace = /* @__PURE__ */ op({ depthToSpace_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthwiseConv2d_(x, filter2, strides, pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
  const $filter = convertToTensor(filter2, "filter", "depthwiseConv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  const inChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert(inChannels === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels (${inChannels}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
  checkPadOnDimRoundingMode("depthwiseConv2d", pad2, dimRoundingMode);
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad2, dataFormat, dilations, dimRoundingMode };
  const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const depthwiseConv2d$1 = /* @__PURE__ */ op({ depthwiseConv2d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function diag_(x) {
  const $x = convertToTensor(x, "x", "diag");
  const inputs = { x: $x };
  return ENGINE.runKernel(Diag, inputs);
}
const diag = /* @__PURE__ */ op({ diag_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dilation2d_(x, filter2, strides, pad2, dilations = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "dilation2d");
  const $filter = convertToTensor(filter2, "filter", "dilation2d");
  assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${$x.rank}.`);
  assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${$filter.rank}.`);
  assert(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${dataFormat}`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    reshapedTo4D = true;
  }
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${x4D.shape[3]} vs ${$filter.shape[2]}`);
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad: pad2, dilations };
  const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const dilation2d = /* @__PURE__ */ op({ dilation2d_ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getBroadcastDims(inShape, outShape) {
  const inRank = inShape.length;
  const dims = [];
  for (let i = 0; i < inRank; i++) {
    const dim = inRank - 1 - i;
    const a = inShape[dim] || 1;
    const b = outShape[outShape.length - 1 - i] || 1;
    if (b > 1 && a === 1) {
      dims.unshift(dim);
    }
  }
  return dims;
}
function getReductionAxes(inShape, outShape) {
  const result = [];
  for (let i = 0; i < outShape.length; i++) {
    const inDim = inShape[inShape.length - i - 1];
    const outAxis = outShape.length - i - 1;
    const outDim = outShape[outAxis];
    if (inDim == null || inDim === 1 && outDim > 1) {
      result.unshift(outAxis);
    }
  }
  return result;
}
function assertAndGetBroadcastShape(shapeA, shapeB) {
  const l = Math.max(shapeA.length, shapeB.length);
  const result = new Array(l);
  for (let i = 0; i < l; i++) {
    let a = shapeA[shapeA.length - i - 1];
    if (a == null) {
      a = 1;
    }
    let b = shapeB[shapeB.length - i - 1];
    if (b == null) {
      b = 1;
    }
    if (a === 1) {
      result[l - i - 1] = b;
    } else if (b === 1) {
      result[l - i - 1] = a;
    } else if (a !== b) {
      const errMsg = `Operands could not be broadcast together with shapes ${shapeA} and ${shapeB}.`;
      throw Error(errMsg);
    } else {
      result[l - i - 1] = a;
    }
  }
  return result;
}
const broadcast_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertAndGetBroadcastShape,
  getBroadcastDims,
  getReductionAxes
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function equal_(a, b) {
  let $a = convertToTensor(a, "a", "equal", "string_or_numeric");
  let $b = convertToTensor(b, "b", "equal", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Equal, inputs);
}
const equal = /* @__PURE__ */ op({ equal_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function where_(condition, a, b) {
  const $a = convertToTensor(a, "a", "where");
  const $b = convertToTensor(b, "b", "where");
  const $condition = convertToTensor(condition, "condition", "where", "bool");
  const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
  const $broadcastedCondition = broadcastTo($condition, broadcastShape);
  const $broadcastedA = broadcastTo($a, broadcastShape);
  const $broadcastedB = broadcastTo($b, broadcastShape);
  const inputs = {
    condition: $broadcastedCondition,
    t: $broadcastedA,
    e: $broadcastedB
  };
  return ENGINE.runKernel(Select, inputs);
}
const where = /* @__PURE__ */ op({ where_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zerosLike_(x) {
  const $x = convertToTensor(x, "x", "zerosLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(ZerosLike, inputs);
}
const zerosLike = /* @__PURE__ */ op({ zerosLike_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function divNoNan_(a, b) {
  let $a = convertToTensor(a, "a", "div");
  let $b = convertToTensor(b, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  const divResult = div($a, $b);
  const zeros2 = zerosLike(divResult);
  const bEqualsZero = equal($b, zeros2);
  return where(bEqualsZero, zeros2, divResult);
}
const divNoNan = /* @__PURE__ */ op({ divNoNan_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dot_(t1, t2) {
  const $t1 = convertToTensor(t1, "t1", "dot");
  const $t2 = convertToTensor(t2, "t2", "dot");
  assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${$t1.rank} and ${$t2.rank}.`);
  const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
  const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
  assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ${t1Inner} and ${t2Inner}.`);
  if ($t1.rank === 1 && $t2.rank === 1) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul$1(t12D, t22D);
    return reshape(t1t2, []);
  } else if ($t1.rank === 1 && $t2.rank === 2) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul$1(t12D, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else if ($t1.rank === 2 && $t2.rank === 1) {
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul$1($t1, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else {
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul$1($t1, t22D);
    return t1t2;
  }
}
const dot = /* @__PURE__ */ op({ dot_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function einsum_(equation, ...tensors) {
  const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "einsum"));
  const attrs = { equation };
  return ENGINE.runKernel(Einsum, $tensors, attrs);
}
const einsum = /* @__PURE__ */ op({ einsum_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function elu_(x) {
  const $x = convertToTensor(x, "x", "elu", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Elu, inputs);
}
const elu = /* @__PURE__ */ op({ elu_ });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ensureShape_(x, shape) {
  const $x = convertToTensor(x, "x", "ensureShape", "string_or_numeric");
  if (!arraysEqualWithNull($x.shape, shape)) {
    throw new Error(`EnsureShape: Shape of tensor ${$x.shape} is not compatible with expected shape ${shape}`);
  }
  return x;
}
const ensureShape = /* @__PURE__ */ op({ ensureShape_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function erf_(x) {
  let $x = convertToTensor(x, "x", "erf");
  assert($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
  if ($x.dtype === "int32") {
    $x = cast($x, "float32");
  }
  const inputs = { x: $x };
  return ENGINE.runKernel(Erf, inputs);
}
const erf = /* @__PURE__ */ op({ erf_ });
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function axesAreInnerMostDims(axes, rank) {
  for (let i = 0; i < axes.length; ++i) {
    if (axes[axes.length - i - 1] !== rank - 1 - i) {
      return false;
    }
  }
  return true;
}
function combineLocations(outputLoc, reduceLoc, axes) {
  const rank = outputLoc.length + reduceLoc.length;
  const loc = [];
  let outIdx = 0;
  let reduceIdx = 0;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      loc.push(outputLoc[outIdx++]);
    } else {
      loc.push(reduceLoc[reduceIdx++]);
    }
  }
  return loc;
}
function computeOutAndReduceShapes(aShape, axes) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      outShape.push(aShape[dim]);
    }
  }
  const reduceShape = axes.map((dim) => aShape[dim]);
  return [outShape, reduceShape];
}
function expandShapeToKeepDim(shape, axes) {
  const reduceSubShape = axes.map((x) => 1);
  return combineLocations(shape, reduceSubShape, axes);
}
function assertAxesAreInnerMostDims(msg, axes, rank) {
  assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. Got axes ${axes} and rank-${rank} input.`);
}
function getAxesPermutation(axes, rank) {
  if (axesAreInnerMostDims(axes, rank)) {
    return null;
  }
  const result = [];
  for (let i = 0; i < rank; ++i) {
    if (axes.indexOf(i) === -1) {
      result.push(i);
    }
  }
  axes.forEach((axis) => result.push(axis));
  return result;
}
function getUndoAxesPermutation(axes) {
  return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
}
function getInnerMostAxes(numAxes, rank) {
  const res = [];
  for (let i = rank - numAxes; i < rank; ++i) {
    res.push(i);
  }
  return res;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function max_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "max");
  const inputs = { x: $x };
  const attrs = { reductionIndices: axis, keepDims };
  return ENGINE.runKernel(Max, inputs, attrs);
}
const max = /* @__PURE__ */ op({ max_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function min_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "min");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Min, inputs, attrs);
}
const min = /* @__PURE__ */ op({ min_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pow_(base, exp2) {
  let $base = convertToTensor(base, "base", "pow");
  let $exp = convertToTensor(exp2, "exp", "pow");
  [$base, $exp] = makeTypesMatch($base, $exp);
  const inputs = { a: $base, b: $exp };
  return ENGINE.runKernel(Pow, inputs);
}
const pow = /* @__PURE__ */ op({ pow_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function scalar(value, dtype) {
  if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
    throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  }
  if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
    throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  }
  const shape = [];
  const inferredShape = [];
  return makeTensor(value, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sqrt_(x) {
  const $x = convertToTensor(x, "x", "sqrt", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sqrt, inputs);
}
const sqrt = /* @__PURE__ */ op({ sqrt_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function square_(x) {
  const $x = convertToTensor(x, "x", "square");
  const attrs = {};
  return ENGINE.runKernel("Square", { x: $x }, attrs);
}
const square = /* @__PURE__ */ op({ square_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sum_(x, axis = null, keepDims = false) {
  let $x = convertToTensor(x, "x", "sum");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Sum, inputs, attrs);
}
const sum = /* @__PURE__ */ op({ sum_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function norm_(x, ord = "euclidean", axis = null, keepDims = false) {
  x = convertToTensor(x, "x", "norm");
  const norm2 = normImpl(x, ord, axis);
  let keepDimsShape = norm2.shape;
  if (keepDims) {
    const axes = parseAxisParam(axis, x.shape);
    keepDimsShape = expandShapeToKeepDim(norm2.shape, axes);
  }
  return reshape(norm2, keepDimsShape);
}
function normImpl(x, p, axis = null) {
  if (x.rank === 0) {
    return abs(x);
  }
  if (x.rank !== 1 && axis === null) {
    return normImpl(reshape(x, [-1]), p, axis);
  }
  if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
    if (p === 1) {
      return sum(abs(x), axis);
    }
    if (p === Infinity) {
      return max(abs(x), axis);
    }
    if (p === -Infinity) {
      return min(abs(x), axis);
    }
    if (p === "euclidean" || p === 2) {
      return sqrt(sum(pow(abs(x), scalar(2, "int32")), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p}`);
  }
  if (Array.isArray(axis) && axis.length === 2) {
    if (p === 1) {
      return max(sum(abs(x), axis[0]), axis[1] - 1);
    }
    if (p === Infinity) {
      return max(sum(abs(x), axis[1]), axis[0]);
    }
    if (p === -Infinity) {
      return min(sum(abs(x), axis[1]), axis[0]);
    }
    if (p === "fro" || p === "euclidean") {
      return sqrt(sum(square(x), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p}`);
  }
  throw new Error(`Error in norm: invalid axis: ${axis}`);
}
const norm = /* @__PURE__ */ op({ norm_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function euclideanNorm_(x, axis = null, keepDims = false) {
  return norm(x, "euclidean", axis, keepDims);
}
const euclideanNorm = /* @__PURE__ */ op({ euclideanNorm_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function exp_(x) {
  const $x = convertToTensor(x, "x", "exp");
  const inputs = { x: $x };
  return ENGINE.runKernel(Exp, inputs);
}
const exp = /* @__PURE__ */ op({ exp_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function expandDims_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "expandDims", "string_or_numeric");
  assert(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
  const inputs = { input: $x };
  const attrs = { dim: axis };
  return ENGINE.runKernel(ExpandDims, inputs, attrs);
}
const expandDims = /* @__PURE__ */ op({ expandDims_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function expm1_(x) {
  const $x = convertToTensor(x, "x", "expm1");
  const inputs = { x: $x };
  return ENGINE.runKernel(Expm1, inputs);
}
const expm1 = /* @__PURE__ */ op({ expm1_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tile_(x, reps) {
  const $x = convertToTensor(x, "x", "tile", "string_or_numeric");
  assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} must match length of reps ${reps}.`);
  const inputs = { x: $x };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
const tile = /* @__PURE__ */ op({ tile_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function eye_(numRows, numColumns, batchShape, dtype = "float32") {
  if (numColumns == null) {
    numColumns = numRows;
  }
  const buff = buffer([numRows, numColumns], dtype);
  const n = numRows <= numColumns ? numRows : numColumns;
  for (let i = 0; i < n; ++i) {
    buff.set(1, i, i);
  }
  const out = reshape(buff.toTensor(), [numRows, numColumns]);
  if (batchShape == null) {
    return out;
  } else {
    if (batchShape.length === 1) {
      return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
    } else if (batchShape.length === 2) {
      return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
    } else if (batchShape.length === 3) {
      return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
        batchShape[0],
        batchShape[1],
        batchShape[2],
        1,
        1
      ]);
    } else {
      throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${batchShape.length}D.`);
    }
  }
}
const eye = /* @__PURE__ */ op({ eye_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function floor_(x) {
  const $x = convertToTensor(x, "x", "floor", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Floor, inputs);
}
const floor = /* @__PURE__ */ op({ floor_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gather_(x, indices, axis = 0, batchDims = 0) {
  const $x = convertToTensor(x, "x", "gather");
  const $indices = convertToTensor(indices, "indices", "gather", "int32");
  const inputs = { x: $x, indices: $indices };
  const attrs = { axis, batchDims };
  return ENGINE.runKernel(GatherV2, inputs, attrs);
}
const gather = /* @__PURE__ */ op({ gather_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function greater_(a, b) {
  let $a = convertToTensor(a, "a", "greater", "string_or_numeric");
  let $b = convertToTensor(b, "b", "greater", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Greater, inputs);
}
const greater = /* @__PURE__ */ op({ greater_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function greaterEqual_(a, b) {
  let $a = convertToTensor(a, "a", "greaterEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "greaterEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(GreaterEqual, inputs);
}
const greaterEqual = /* @__PURE__ */ op({ greaterEqual_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function imag_(input) {
  const $input = convertToTensor(input, "input", "imag");
  const inputs = { input: $input };
  return ENGINE.runKernel(Imag, inputs);
}
const imag = /* @__PURE__ */ op({ imag_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isFinite_(x) {
  const $x = convertToTensor(x, "x", "isFinite");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsFinite, inputs);
}
const isFinite$1 = /* @__PURE__ */ op({ isFinite_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isInf_(x) {
  const $x = convertToTensor(x, "x", "isInf");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsInf, inputs);
}
const isInf = /* @__PURE__ */ op({ isInf_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function isNaN_(x) {
  const $x = convertToTensor(x, "x", "isNaN");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsNan, inputs);
}
const isNaN$1 = /* @__PURE__ */ op({ isNaN_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function leakyRelu_(x, alpha2 = 0.2) {
  const $x = convertToTensor(x, "x", "leakyRelu");
  const inputs = { x: $x };
  const attrs = { alpha: alpha2 };
  return ENGINE.runKernel(LeakyRelu, inputs, attrs);
}
const leakyRelu = /* @__PURE__ */ op({ leakyRelu_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function less_(a, b) {
  let $a = convertToTensor(a, "a", "less", "string_or_numeric");
  let $b = convertToTensor(b, "b", "less", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Less, inputs);
}
const less = /* @__PURE__ */ op({ less_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lessEqual_(a, b) {
  let $a = convertToTensor(a, "a", "lessEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "lessEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LessEqual, inputs);
}
const lessEqual = /* @__PURE__ */ op({ lessEqual_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function linspace(start2, stop2, num) {
  if (num <= 0) {
    throw new Error("The number of values should be positive.");
  }
  const attrs = { start: start2, stop: stop2, num };
  return ENGINE.runKernel(LinSpace, {}, attrs);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha2 = 1, beta = 0.5) {
  const $x = convertToTensor(x, "x", "localResponseNormalization");
  assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
  assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${depthRadius}.`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  const inputs = { x: x4D };
  const attrs = { depthRadius, bias, alpha: alpha2, beta };
  const res = ENGINE.runKernel(LRN, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  } else {
    return res;
  }
}
const localResponseNormalization = /* @__PURE__ */ op({ localResponseNormalization_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function log_(x) {
  const $x = convertToTensor(x, "x", "log", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log, inputs);
}
const log = /* @__PURE__ */ op({ log_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function log1p_(x) {
  const $x = convertToTensor(x, "x", "log1p");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log1p, inputs);
}
const log1p = /* @__PURE__ */ op({ log1p_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function grad(f) {
  assert(isFunction(f), () => "The f passed in grad(f) must be a function");
  return (x, dy) => {
    const $x = convertToTensor(x, "x", "tf.grad", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grad") : null;
    return ENGINE.tidy(() => {
      const { value, grads: grads2 } = ENGINE.gradients(() => f($x), [$x], $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)");
      }
      checkGrads(grads2);
      return grads2[0];
    });
  };
}
function grads(f) {
  assert(isFunction(f), () => "The f passed in grads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
    const $args = convertToTensorArray(args, "args", "tf.grads", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grads") : null;
    return ENGINE.tidy(() => {
      const { value, grads: grads2 } = ENGINE.gradients(() => f(...$args), $args, $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
      }
      checkGrads(grads2);
      return grads2;
    });
  };
}
function valueAndGrad(f) {
  assert(isFunction(f), () => "The f passed in valueAndGrad(f) must be a function");
  return (x, dy) => {
    assert(x instanceof Tensor, () => "The x passed in valueAndGrad(f)(x) must be a tensor");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    const { grads: grads2, value } = ENGINE.gradients(() => f(x), [x], dy);
    checkGrads(grads2);
    return { grad: grads2[0], value };
  };
}
function valueAndGrads(f) {
  assert(isFunction(f), () => "The f passed in valueAndGrads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args) && args.every((arg) => arg instanceof Tensor), () => "The args passed in valueAndGrads(f)(args) must be array of tensors");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    const res = ENGINE.gradients(() => f(...args), args, dy);
    if (dy != null) {
      assertShapesMatch(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])");
    }
    checkGrads(res.grads);
    return res;
  };
}
function variableGrads(f, varList) {
  assert(isFunction(f), () => "The f passed in variableGrads(f) must be a function");
  assert(varList == null || Array.isArray(varList) && varList.every((v) => v instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
  const specifiedVarList = varList != null;
  if (!specifiedVarList) {
    varList = [];
    for (const varName in ENGINE.registeredVariables) {
      varList.push(ENGINE.registeredVariables[varName]);
    }
  }
  const specifiedNonTrainable = specifiedVarList ? varList.filter((variable2) => !variable2.trainable) : null;
  const originalVarCount = varList.length;
  varList = varList.filter((variable2) => variable2.trainable);
  assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${originalVarCount} variables is trainable.`);
  const allowNoGradients = true;
  const { value, grads: grads2 } = ENGINE.gradients(f, varList, null, allowNoGradients);
  assert(grads2.some((g) => g != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().");
  assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${value.rank} tensor`);
  const namedGrads = {};
  varList.forEach((v, i) => {
    if (grads2[i] != null) {
      namedGrads[v.name] = grads2[i];
    }
  });
  if (specifiedNonTrainable != null) {
    specifiedNonTrainable.forEach((v) => namedGrads[v.name] = null);
  }
  return { value, grads: namedGrads };
}
function customGrad(f) {
  return ENGINE.customGrad(f);
}
function checkGrads(grads2) {
  const numNullGradients = grads2.filter((g) => g == null).length;
  if (numNullGradients > 0) {
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function neg_(x) {
  const $x = convertToTensor(x, "x", "neg");
  const inputs = { x: $x };
  return ENGINE.runKernel(Neg, inputs);
}
const neg = /* @__PURE__ */ op({ neg_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function softplus_(x) {
  const $x = convertToTensor(x, "x", "softplus");
  const inputs = { x: $x };
  return ENGINE.runKernel(Softplus, inputs);
}
const softplus = /* @__PURE__ */ op({ softplus_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logSigmoid_(x) {
  const $x = convertToTensor(x, "x", "logSigmoid");
  const customOp = customGrad((x2) => {
    const value = neg(softplus(neg(x2)));
    const gradFunc = (dy) => {
      const derX = mul(dy, sigmoid(neg(x2)));
      return derX;
    };
    return { value, gradFunc };
  });
  return customOp($x);
}
const logSigmoid = /* @__PURE__ */ op({ logSigmoid_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sub_(a, b) {
  let $a = convertToTensor(a, "a", "sub");
  let $b = convertToTensor(b, "b", "sub");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Sub, inputs);
}
const sub = /* @__PURE__ */ op({ sub_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logSoftmax_(logits, axis = -1) {
  const $logits = convertToTensor(logits, "logits", "logSoftmax");
  if (axis === -1) {
    axis = $logits.rank - 1;
  }
  if (axis !== $logits.rank - 1) {
    throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and axis was ${axis}`);
  }
  const customOp = customGrad((logits2, save) => {
    const keepDims = true;
    const xMax = max(logits2, axis, true);
    const shifted = sub(logits2, xMax);
    const value = sub(cast(shifted, "float32"), log(sum(exp(shifted), axis, keepDims)));
    save([value]);
    const gradFunc = (dy, saved) => {
      const [value2] = saved;
      const keepDims2 = true;
      const softmax2 = exp(value2);
      return sub(dy, mul(sum(dy, axis, keepDims2), softmax2));
    };
    return { value, gradFunc };
  });
  return customOp($logits);
}
const logSoftmax = /* @__PURE__ */ op({ logSoftmax_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logSumExp_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "logSumExp");
  const axes = parseAxisParam(axis, $x.shape);
  const xMax = max(
    $x,
    axes,
    true
    /* keepDims */
  );
  const a = sub($x, xMax);
  const b = exp(a);
  const c = sum(b, axes);
  const d = log(c);
  const res = add(reshape(xMax, d.shape), d);
  if (keepDims) {
    const newShape = expandShapeToKeepDim(res.shape, axes);
    return reshape(res, newShape);
  }
  return res;
}
const logSumExp = /* @__PURE__ */ op({ logSumExp_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logicalAnd_(a, b) {
  const $a = convertToTensor(a, "a", "logicalAnd", "bool");
  const $b = convertToTensor(b, "b", "logicalAnd", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalAnd, inputs);
}
const logicalAnd = /* @__PURE__ */ op({ logicalAnd_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logicalNot_(x) {
  const $x = convertToTensor(x, "x", "logicalNot", "bool");
  const inputs = { x: $x };
  return ENGINE.runKernel(LogicalNot, inputs);
}
const logicalNot = /* @__PURE__ */ op({ logicalNot_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logicalOr_(a, b) {
  const $a = convertToTensor(a, "a", "logicalOr", "bool");
  const $b = convertToTensor(b, "b", "logicalOr", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalOr, inputs);
}
const logicalOr = /* @__PURE__ */ op({ logicalOr_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logicalXor_(a, b) {
  const $a = convertToTensor(a, "a", "logicalXor", "bool");
  const $b = convertToTensor(b, "b", "logicalXor", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));
}
const logicalXor = /* @__PURE__ */ op({ logicalXor_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const INT32_MAX = 2147483648;
function searchSorted_(sortedSequence, values, side = "left") {
  const $sortedSequence = convertToTensor(sortedSequence, "sortedSequence", "searchSorted");
  const $values = convertToTensor(values, "values", "searchSorted");
  const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];
  const valuesSize = $values.shape[$values.shape.length - 1];
  const $sortedSequence2D = reshape($sortedSequence, [-1, sequenceSize]);
  const $values2D = reshape($values, [-1, valuesSize]);
  if ($sortedSequence2D.rank < 2) {
    throw new Error(`Sorted input argument must be at least 2-dimensional`);
  }
  if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {
    throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);
  }
  if (sizeFromShape($values2D.shape) >= INT32_MAX) {
    throw new Error(`values tensor size must less than ${INT32_MAX}`);
  }
  if ($sortedSequence2D.shape[1] >= INT32_MAX) {
    throw new Error(`trailing dim_size must less than ${INT32_MAX} for int32 output type, was ${$sortedSequence2D.shape[1]}`);
  }
  const inputs = {
    sortedSequence: $sortedSequence2D,
    values: $values2D
  };
  const attrs = { side };
  return ENGINE.runKernel(SearchSorted, inputs, attrs);
}
const searchSorted = /* @__PURE__ */ op({ searchSorted_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function lowerBound(sortedSequence, values) {
  return searchSorted(sortedSequence, values, "left");
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function maxPool_(x, filterSize, strides, pad2, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "maxPool");
  const dilations = 1;
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  checkPadOnDimRoundingMode("maxPool", pad2, dimRoundingMode);
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad: pad2, dimRoundingMode };
  const res = ENGINE.runKernel(MaxPool, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const maxPool = /* @__PURE__ */ op({ maxPool_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad2, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x, "x", "maxPool3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${dataFormat}`);
  checkPadOnDimRoundingMode("maxPool3d", pad2, dimRoundingMode);
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad: pad2, dimRoundingMode, dataFormat };
  const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
const maxPool3d = /* @__PURE__ */ op({ maxPool3d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function maxPoolWithArgmax_(x, filterSize, strides, pad2, includeBatchInIndex = false) {
  const $x = convertToTensor(x, "x", "maxPoolWithArgmax");
  const inputs = { x: $x };
  const attrs = { filterSize, strides, pad: pad2, includeBatchInIndex };
  const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
  return { result: result[0], indexes: result[1] };
}
const maxPoolWithArgmax = /* @__PURE__ */ op({ maxPoolWithArgmax_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function maximum_(a, b) {
  let $a = convertToTensor(a, "a", "maximum");
  let $b = convertToTensor(b, "b", "maximum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Maximum, inputs);
}
const maximum = /* @__PURE__ */ op({ maximum_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mean_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "mean");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Mean, inputs, attrs);
}
const mean = /* @__PURE__ */ op({ mean_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function zeros(shape, dtype = "float32") {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype === "complex64") {
    const real2 = zeros(shape, "float32");
    const imag2 = zeros(shape, "float32");
    return complex(real2, imag2);
  }
  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ones(shape, dtype = "float32") {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype === "complex64") {
    const real2 = ones(shape, "float32");
    const imag2 = zeros(shape, "float32");
    return complex(real2, imag2);
  }
  const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function meshgrid(x, y, { indexing = "xy" } = {}) {
  if (indexing !== "xy" && indexing !== "ij") {
    throw new TypeError(`${indexing} is not a valid third argument to meshgrid`);
  }
  if (x === void 0) {
    return [];
  }
  let $x = convertToTensor(x, "x", "meshgrid", x instanceof Tensor ? x.dtype : "float32");
  if (y === void 0) {
    return [$x];
  }
  let $y = convertToTensor(y, "y", "meshgrid", y instanceof Tensor ? y.dtype : "float32");
  const w = sizeFromShape($x.shape);
  const h = sizeFromShape($y.shape);
  if (indexing === "xy") {
    $x = reshape($x, [1, -1]);
    $y = reshape($y, [-1, 1]);
    return [
      matMul$1(ones([h, 1], $x.dtype), $x),
      matMul$1($y, ones([1, w], $y.dtype))
    ];
  }
  $x = reshape($x, [-1, 1]);
  $y = reshape($y, [1, -1]);
  return [
    matMul$1($x, ones([1, h], $x.dtype)),
    matMul$1(ones([w, 1], $y.dtype), $y)
  ];
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function minimum_(a, b) {
  let $a = convertToTensor(a, "a", "minimum");
  let $b = convertToTensor(b, "b", "minimum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Minimum, inputs);
}
const minimum = /* @__PURE__ */ op({ minimum_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mirrorPad_(x, paddings, mode) {
  assert(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${mode}.`);
  const $x = convertToTensor(x, "x", "mirrorPad");
  if ($x.rank === 0) {
    throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
  }
  assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. Got ${paddings.length}.`);
  const shapeOffset = mode === "reflect" ? 1 : 0;
  for (let i = 0; i < $x.rank; i++) {
    assert(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
    assert(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset && paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal to ${$x.shape[i] - shapeOffset} or less than 0 for input of shape ${$x.shape}`);
  }
  const attrs = { paddings, mode };
  const inputs = { x: $x };
  return ENGINE.runKernel(MirrorPad, inputs, attrs);
}
const mirrorPad = /* @__PURE__ */ op({ mirrorPad_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mod_(a, b) {
  let $a = convertToTensor(a, "a", "mod");
  let $b = convertToTensor(b, "b", "mod");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Mod, inputs);
}
const mod = /* @__PURE__ */ op({ mod_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function moments_(x, axis = null, keepDims = false) {
  x = convertToTensor(x, "x", "moments");
  const axes = parseAxisParam(axis, x.shape);
  const xMean = mean(x, axes, keepDims);
  let keepDimsShape = xMean.shape;
  if (!keepDims) {
    keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
  }
  const devSquared = square(sub(cast(x, "float32"), reshape(xMean, keepDimsShape)));
  const variance = mean(devSquared, axes, keepDims);
  return { mean: xMean, variance };
}
const moments = /* @__PURE__ */ op({ moments_ });
function multiRNNCell_(lstmCells, data, c, h) {
  const $data = convertToTensor(data, "data", "multiRNNCell");
  const $c = convertToTensorArray(c, "c", "multiRNNCell");
  const $h = convertToTensorArray(h, "h", "multiRNNCell");
  let input = $data;
  const newStates = [];
  for (let i = 0; i < lstmCells.length; i++) {
    const output = lstmCells[i](input, $c[i], $h[i]);
    newStates.push(output[0]);
    newStates.push(output[1]);
    input = output[1];
  }
  const newC = [];
  const newH = [];
  for (let i = 0; i < newStates.length; i += 2) {
    newC.push(newStates[i]);
    newH.push(newStates[i + 1]);
  }
  return [newC, newH];
}
const multiRNNCell = /* @__PURE__ */ op({ multiRNNCell_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function multinomial_(logits, numSamples, seed, normalized = false) {
  const $logits = convertToTensor(logits, "logits", "multinomial");
  const numOutcomes = $logits.size;
  const origRank = $logits.rank;
  if (numOutcomes < 2) {
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${numOutcomes}.`);
  }
  if (origRank > 2) {
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
  }
  seed = seed || Math.random();
  const logits2D = origRank === 1 ? reshape($logits, [1, -1]) : $logits;
  const inputs = { logits: logits2D };
  const attrs = { numSamples, seed, normalized };
  const res = ENGINE.runKernel(Multinomial, inputs, attrs);
  return origRank === 1 ? reshape(res, [res.size]) : res;
}
const multinomial = /* @__PURE__ */ op({ multinomial_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function notEqual_(a, b) {
  let $a = convertToTensor(a, "a", "notEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "notEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(NotEqual, inputs);
}
const notEqual = /* @__PURE__ */ op({ notEqual_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function oneHot_(indices, depth, onValue = 1, offValue = 0, dtype = "int32") {
  if (depth < 2) {
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
  }
  const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
  const inputs = { indices: $indices };
  const attrs = { dtype, depth, onValue, offValue };
  return ENGINE.runKernel(OneHot, inputs, attrs);
}
const oneHot = /* @__PURE__ */ op({ oneHot_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function onesLike_(x) {
  const $x = convertToTensor(x, "x", "onesLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(OnesLike, inputs);
}
const onesLike = /* @__PURE__ */ op({ onesLike_ });
function outerProduct_(v1, v2) {
  const $v1 = convertToTensor(v1, "v1", "outerProduct");
  const $v2 = convertToTensor(v2, "v2", "outerProduct");
  assert($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${$v1.rank} and ${$v2.rank}.`);
  const v12D = reshape($v1, [-1, 1]);
  const v22D = reshape($v2, [1, -1]);
  return matMul$1(v12D, v22D);
}
const outerProduct = /* @__PURE__ */ op({ outerProduct_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pad_(x, paddings, constantValue = 0) {
  const $x = convertToTensor(x, "x", "pad");
  if ($x.rank === 0) {
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  }
  const attrs = { paddings, constantValue };
  const inputs = { x: $x };
  return ENGINE.runKernel(PadV2, inputs, attrs);
}
const pad = /* @__PURE__ */ op({ pad_ });
function pad1d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
  return pad(x, [paddings], constantValue);
}
const pad1d = /* @__PURE__ */ op({ pad1d_ });
function pad2d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
const pad2d = /* @__PURE__ */ op({ pad2d_ });
function pad3d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
const pad3d = /* @__PURE__ */ op({ pad3d_ });
function pad4d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
const pad4d = /* @__PURE__ */ op({ pad4d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function spaceToBatchND_(x, blockShape, paddings) {
  const $x = convertToTensor(x, "x", "spaceToBatchND");
  assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
  assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
  assert($x.shape.reduce((a, b, i) => {
    if (i > 0 && i <= blockShape.length) {
      return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
    }
    return a;
  }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
  const inputs = { x: $x };
  const attrs = { blockShape, paddings };
  return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
}
const spaceToBatchND = /* @__PURE__ */ op({ spaceToBatchND_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function pool_(input, windowShape, poolingType, pad2, dilations, strides, dimRoundingMode) {
  if (dilations == null) {
    dilations = [1, 1];
  }
  if (strides == null) {
    strides = 1;
  }
  if (pad2 === 0) {
    pad2 = "valid";
  }
  const $x = convertToTensor(input, "x", "maxPool");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in pool: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad2);
  const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
  let basePadding;
  if (pad2 === "same") {
    basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
  } else {
    basePadding = [[0, 0], [0, 0]];
  }
  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
  const convertedPad = isDilationOne ? pad2 : "valid";
  const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
  const forwardOp = poolingType === "avg" ? () => avgPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode) : () => maxPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode);
  const y = forwardOp();
  const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
  const padStart = basePadding.map((b) => b[0]);
  const origPadEnd = basePadding.map((b) => b[1]);
  const fullInputShape = inputShape.concat(padStart, origPadEnd);
  const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
  const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);
  const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);
  const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);
  return [paddings, crops];
}
function withSpaceToBatchBasePaddings(filterShape, dilation) {
  const dilatedFilterShape = filterShape.map((s, i) => {
    return s + (s - 1) * (dilation[i] - 1);
  });
  const padExtraShape = dilatedFilterShape.map((s) => s - 1);
  const padExtraStart = padExtraShape.map((s) => Math.floor(s / 2));
  const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
  return padExtraShape.map((_, i) => {
    return [padExtraStart[i], padExtraEnd[i]];
  });
}
const pool = /* @__PURE__ */ op({ pool_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function prelu_(x, alpha2) {
  const $x = convertToTensor(x, "x", "prelu");
  const $alpha = convertToTensor(alpha2, "alpha", "prelu");
  const inputs = { x: $x, alpha: $alpha };
  return ENGINE.runKernel(Prelu, inputs);
}
const prelu = /* @__PURE__ */ op({ prelu_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function prod_(x, axis = null, keepDims = false) {
  let $x = convertToTensor(x, "x", "prod");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Prod, inputs, attrs);
}
const prod = /* @__PURE__ */ op({ prod_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {
  const $paramsNestedSplits = paramsNestedSplits.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedGather", "int32"));
  const $paramsDenseValues = convertToTensor(paramsDenseValues, "paramsDenseValues", "raggedGather");
  const $indices = convertToTensor(indices, "indices", "raggedGather", "int32");
  const inputs = {
    paramsNestedSplits: $paramsNestedSplits,
    paramsDenseValues: $paramsDenseValues,
    indices: $indices
  };
  const attrs = { outputRaggedRank };
  const result = ENGINE.runKernel(RaggedGather, inputs, attrs);
  return {
    outputNestedSplits: result.slice(0, result.length - 1),
    outputDenseValues: result[result.length - 1]
  };
}
const raggedGather = /* @__PURE__ */ op({ raggedGather_ });
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function raggedRange_(starts, limits, deltas) {
  const $starts = convertToTensor(starts, "starts", "raggedRange");
  const $limits = convertToTensor(limits, "limits", "raggedRange", $starts.dtype);
  const $deltas = convertToTensor(deltas, "deltas", "raggedRange", $starts.dtype);
  const inputs = {
    starts: $starts,
    limits: $limits,
    deltas: $deltas
  };
  const result = ENGINE.runKernel(RaggedRange, inputs);
  return {
    rtNestedSplits: result[0],
    rtDenseValues: result[1]
  };
}
const raggedRange = /* @__PURE__ */ op({ raggedRange_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
  const $shape = convertToTensor(shape, "shape", "raggedTensorToTensor", "int32");
  const $values = convertToTensor(values, "values", "raggedTensorToTensor");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "raggedTensorToTensor", $values.dtype);
  const $rowPartitionTensors = rowPartitionTensors.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedTensorToTensor", "int32"));
  const inputs = {
    shape: $shape,
    values: $values,
    defaultValue: $defaultValue,
    rowPartitionTensors: $rowPartitionTensors
  };
  const attrs = { rowPartitionTypes };
  return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
}
const raggedTensorToTensor = /* @__PURE__ */ op({ raggedTensorToTensor_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rand_(shape, randFunction, dtype) {
  assertNonNegativeIntegerDimensions(shape);
  const size = sizeFromShape(shape);
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  for (let i = 0; i < size; i++) {
    values[i] = randFunction();
  }
  return ENGINE.makeTensor(values, shape, dtype);
}
const rand = /* @__PURE__ */ op({ rand_ });
var alea$1 = { exports: {} };
var alea = alea$1.exports;
var hasRequiredAlea;
function requireAlea() {
  if (hasRequiredAlea) return alea$1.exports;
  hasRequiredAlea = 1;
  (function(module) {
    (function(global2, module2, define) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.alea = impl;
      }
    })(
      alea,
      module
    );
  })(alea$1);
  return alea$1.exports;
}
var xor128$1 = { exports: {} };
var xor128 = xor128$1.exports;
var hasRequiredXor128;
function requireXor128() {
  if (hasRequiredXor128) return xor128$1.exports;
  hasRequiredXor128 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xor128 = impl;
      }
    })(
      xor128,
      module
    );
  })(xor128$1);
  return xor128$1.exports;
}
var xorwow$1 = { exports: {} };
var xorwow = xorwow$1.exports;
var hasRequiredXorwow;
function requireXorwow() {
  if (hasRequiredXorwow) return xorwow$1.exports;
  hasRequiredXorwow = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xorwow = impl;
      }
    })(
      xorwow,
      module
    );
  })(xorwow$1);
  return xorwow$1.exports;
}
var xorshift7$1 = { exports: {} };
var xorshift7 = xorshift7$1.exports;
var hasRequiredXorshift7;
function requireXorshift7() {
  if (hasRequiredXorshift7) return xorshift7$1.exports;
  hasRequiredXorshift7 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X2 = me.x, i = me.i, t, v;
          t = X2[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X2[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X2[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X2[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X2[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X2[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, X2 = [];
          if (seed2 === (seed2 | 0)) {
            X2[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X2[j & 7] = X2[j & 7] << 15 ^ seed2.charCodeAt(j) + X2[j + 1 & 7] << 13;
            }
          }
          while (X2.length < 8) X2.push(0);
          for (j = 0; j < 8 && X2[j] === 0; ++j) ;
          if (j == 8) X2[7] = -1;
          else X2[j];
          me2.x = X2;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xorshift7 = impl;
      }
    })(
      xorshift7,
      module
    );
  })(xorshift7$1);
  return xorshift7$1.exports;
}
var xor4096$1 = { exports: {} };
var xor4096 = xor4096$1.exports;
var hasRequiredXor4096;
function requireXor4096() {
  if (hasRequiredXor4096) return xor4096$1.exports;
  hasRequiredXor4096 = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X2 = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X2[i + 34 & 127];
          t = X2[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X2[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X2 = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0) w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X2[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X2[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X2[i + 34 & 127];
            t = X2[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X2[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X2;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.xor4096 = impl;
      }
    })(
      xor4096,
      // window object or global
      module
    );
  })(xor4096$1);
  return xor4096$1.exports;
}
var tychei$1 = { exports: {} };
var tychei = tychei$1.exports;
var hasRequiredTychei;
function requireTychei() {
  if (hasRequiredTychei) return tychei$1.exports;
  hasRequiredTychei = 1;
  (function(module) {
    (function(global2, module2, define) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else {
        this.tychei = impl;
      }
    })(
      tychei,
      module
    );
  })(tychei$1);
  return tychei$1.exports;
}
var seedrandom$2 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var seedrandom$1 = seedrandom$2.exports;
var hasRequiredSeedrandom$1;
function requireSeedrandom$1() {
  if (hasRequiredSeedrandom$1) return seedrandom$2.exports;
  hasRequiredSeedrandom$1 = 1;
  (function(module) {
    (function(global2, pool2, math2) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten2(
          options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool2);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math2[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math2,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count2) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count2--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      function flatten2(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten2(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser2 = global2.navigator, plugins = browser2 && browser2.plugins;
          return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool2)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math2.random(), pool2);
      if (module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = require$$0;
        } catch (ex) {
        }
      } else {
        math2["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : seedrandom$1,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  })(seedrandom$2);
  return seedrandom$2.exports;
}
var seedrandom;
var hasRequiredSeedrandom;
function requireSeedrandom() {
  if (hasRequiredSeedrandom) return seedrandom;
  hasRequiredSeedrandom = 1;
  var alea2 = requireAlea();
  var xor1282 = requireXor128();
  var xorwow2 = requireXorwow();
  var xorshift72 = requireXorshift7();
  var xor40962 = requireXor4096();
  var tychei2 = requireTychei();
  var sr = requireSeedrandom$1();
  sr.alea = alea2;
  sr.xor128 = xor1282;
  sr.xorwow = xorwow2;
  sr.xorshift7 = xorshift72;
  sr.xor4096 = xor40962;
  sr.tychei = tychei2;
  seedrandom = sr;
  return seedrandom;
}
var seedrandomExports = requireSeedrandom();
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TEST_EPSILON_FLOAT32 = 1e-3;
const TEST_EPSILON_FLOAT16 = 0.1;
function expectArraysClose(actual, expected, epsilon) {
  if (epsilon == null) {
    epsilon = testEpsilon();
  }
  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));
}
function testEpsilon() {
  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
}
function expectArraysPredicate(actual, expected, predicate) {
  let checkClassType = true;
  if (isTypedArray(actual) || isTypedArray(expected)) {
    checkClassType = false;
  }
  if (isTypedArray(actual) && isTypedArray(expected)) {
    checkClassType = true;
  }
  if (checkClassType) {
    const aType = actual.constructor.name;
    const bType = expected.constructor.name;
    if (aType !== bType) {
      throw new Error(`Arrays are of different type. Actual: ${aType}. Expected: ${bType}`);
    }
  }
  if (Array.isArray(actual) && Array.isArray(expected)) {
    const actualShape = inferShape(actual);
    const expectedShape = inferShape(expected);
    if (!arraysEqual$1(actualShape, expectedShape)) {
      throw new Error(`Arrays have different shapes. Actual: [${actualShape}]. Expected: [${expectedShape}]`);
    }
  }
  const actualFlat = isTypedArray(actual) ? actual : flatten$1(actual);
  const expectedFlat = isTypedArray(expected) ? expected : flatten$1(expected);
  if (actualFlat.length !== expectedFlat.length) {
    throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs expected: ${expectedFlat.length}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
  }
  for (let i = 0; i < expectedFlat.length; ++i) {
    const a = actualFlat[i];
    const e = expectedFlat[i];
    if (!predicate(a, e)) {
      throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.
Actual:   ${actualFlat}.
Expected: ${expectedFlat}.`);
    }
  }
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function expectPromiseToFail(fn, done) {
  fn().then(() => done.fail(), () => done());
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function expectArraysEqual(actual, expected) {
  const exp2 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {
    return expectArraysPredicate(actual, exp2, (a, b) => a == b);
  }
  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));
}
function expectNumbersClose(a, e, epsilon) {
  if (epsilon == null) {
    epsilon = testEpsilon();
  }
  if (!areClose(a, e, epsilon)) {
    throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);
  }
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function areClose(a, e, epsilon) {
  if (!isFinite(a) && !isFinite(e)) {
    return true;
  }
  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
    return false;
  }
  return true;
}
function expectValuesInRange(actual, low, high) {
  for (let i = 0; i < actual.length; i++) {
    if (actual[i] < low || actual[i] > high) {
      throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);
    }
  }
}
function expectArrayBuffersEqual(actual, expected) {
  const actualArray = new Float32Array(actual);
  const expectedArray = new Float32Array(expected);
  if (actualArray.length !== expectedArray.length) {
    throw new Error(`Expected ArrayBuffer to be of length ${expectedArray.length}, but it was ${actualArray.length}`);
  }
  for (let i = 0; i < expectedArray.length; i++) {
    if (actualArray[i] !== expectedArray[i]) {
      throw new Error(`Expected ArrayBuffer value at ${i} to be ${expectedArray[i]} but got ${actualArray[i]} instead`);
    }
  }
}
function encodeStrings(a) {
  for (let i = 0; i < a.length; i++) {
    const val = a[i];
    if (Array.isArray(val)) {
      encodeStrings(val);
    } else {
      a[i] = encodeString(val);
    }
  }
  return a;
}
function createVideoElement(source) {
  const video = document.createElement("video");
  if ("playsInline" in video) {
    video.playsInline = true;
  }
  video.muted = true;
  video.loop = true;
  video.style.position = "fixed";
  video.style.left = "0px";
  video.style.top = "0px";
  video.preload = "auto";
  video.appendChild(source);
  return new Promise((resolve) => {
    video.addEventListener("loadeddata", (_) => resolve(video));
    video.load();
  });
}
async function play(video) {
  await video.play();
  if ("requestVideoFrameCallback" in video) {
    await new Promise((resolve) => {
      video.requestVideoFrameCallback(resolve);
    });
  }
}
const test_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TEST_EPSILON_FLOAT16,
  createVideoElement,
  encodeStrings,
  expectArrayBuffersEqual,
  expectArraysClose,
  expectArraysEqual,
  expectNumbersClose,
  expectPromiseToFail,
  expectValuesInRange,
  play,
  testEpsilon
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MPRandGauss {
  constructor(mean2, stdDeviation, dtype, truncated, seed) {
    this.mean = mean2;
    this.stdDev = stdDeviation;
    this.dtype = dtype;
    this.nextVal = NaN;
    this.truncated = truncated;
    if (this.truncated) {
      this.upper = this.mean + this.stdDev * 2;
      this.lower = this.mean - this.stdDev * 2;
    }
    const seedValue = seed ? seed : Math.random();
    this.random = seedrandomExports.alea(seedValue.toString());
  }
  /** Returns next sample from a Gaussian distribution. */
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const value = this.nextVal;
      this.nextVal = NaN;
      return value;
    }
    let resultX, resultY;
    let isValid = false;
    while (!isValid) {
      let v1, v2, s;
      do {
        v1 = 2 * this.random() - 1;
        v2 = 2 * this.random() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s === 0);
      const mul2 = Math.sqrt(-2 * Math.log(s) / s);
      resultX = this.mean + this.stdDev * v1 * mul2;
      resultY = this.mean + this.stdDev * v2 * mul2;
      if (!this.truncated || this.isValidTruncated(resultX)) {
        isValid = true;
      }
    }
    if (!this.truncated || this.isValidTruncated(resultY)) {
      this.nextVal = this.convertValue(resultY);
    }
    return this.convertValue(resultX);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(value) {
    if (this.dtype == null || this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
  /** Returns true if less than 2-standard-deviations from the mean. */
  isValidTruncated(value) {
    return value <= this.upper && value >= this.lower;
  }
}
class RandGamma {
  constructor(alpha2, beta, dtype, seed) {
    this.alpha = alpha2;
    this.beta = 1 / beta;
    this.dtype = dtype;
    const seedValue = seed ? seed : Math.random();
    this.randu = seedrandomExports.alea(seedValue.toString());
    this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
    if (alpha2 < 1) {
      this.d = alpha2 + 2 / 3;
    } else {
      this.d = alpha2 - 1 / 3;
    }
    this.c = 1 / Math.sqrt(9 * this.d);
  }
  /** Returns next sample from a gamma distribution. */
  nextValue() {
    let x2, v0, v1, x, u, v;
    while (true) {
      do {
        x = this.randn.nextValue();
        v = 1 + this.c * x;
      } while (v <= 0);
      v *= v * v;
      x2 = x * x;
      v0 = 1 - 0.331 * x2 * x2;
      v1 = 0.5 * x2 + this.d * (1 - v + Math.log(v));
      u = this.randu();
      if (u < v0 || Math.log(u) < v1) {
        break;
      }
    }
    v = 1 / this.beta * this.d * v;
    if (this.alpha < 1) {
      v *= Math.pow(this.randu(), 1 / this.alpha);
    }
    return this.convertValue(v);
  }
  /** Handles proper rounding for non-floating-point numbers. */
  convertValue(value) {
    if (this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
}
class UniformRandom {
  constructor(min2 = 0, max2 = 1, dtype, seed) {
    this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
    this.min = min2;
    this.range = max2 - min2;
    this.dtype = dtype;
    if (seed == null) {
      seed = Math.random();
    }
    if (typeof seed === "number") {
      seed = seed.toString();
    }
    if (!this.canReturnFloat() && this.range <= 1) {
      throw new Error(`The difference between ${min2} - ${max2} <= 1 and dtype is not float`);
    }
    this.random = seedrandomExports.alea(seed);
  }
  convertValue(value) {
    if (this.canReturnFloat()) {
      return value;
    }
    return Math.round(value);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function randomGamma_(shape, alpha2, beta = 1, dtype = "float32", seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (beta == null) {
    beta = 1;
  }
  if (dtype == null) {
    dtype = "float32";
  }
  if (dtype !== "float32" && dtype !== "int32") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const rgamma = new RandGamma(alpha2, beta, dtype, seed);
  const res = buffer(shape, dtype);
  for (let i = 0; i < res.values.length; i++) {
    res.values[i] = rgamma.nextValue();
  }
  return res.toTensor();
}
const randomGamma = /* @__PURE__ */ op({ randomGamma_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function randomNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const randGauss = new MPRandGauss(mean2, stdDev, dtype, false, seed);
  const res = buffer(shape, dtype);
  for (let i = 0; i < res.values.length; i++) {
    res.values[i] = randGauss.nextValue();
  }
  return res.toTensor();
}
const randomNormal = /* @__PURE__ */ op({ randomNormal_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function randomStandardNormal_(shape, dtype, seed) {
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  return randomNormal(shape, 0, 1, dtype, seed);
}
const randomStandardNormal = /* @__PURE__ */ op({ randomStandardNormal_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
  assertNonNegativeIntegerDimensions(shape);
  const res = buffer(shape, dtype);
  const random = new UniformRandom(minval, maxval, null, seed);
  for (let i = 0; i < res.values.length; i++) {
    res.values[i] = random.nextValue();
  }
  return res.toTensor();
}
const randomUniform = /* @__PURE__ */ op({ randomUniform_ });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function randomUniformInt_(shape, minval, maxval, seed) {
  return randomUniform(shape, minval, maxval, "int32", seed);
}
const randomUniformInt = /* @__PURE__ */ op({ randomUniformInt_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function range(start2, stop2, step2 = 1, dtype = "float32") {
  if (step2 === 0) {
    throw new Error("Cannot have a step of zero");
  }
  const attrs = { start: start2, stop: stop2, step: step2, dtype };
  return ENGINE.runKernel(Range, {}, attrs);
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function real_(input) {
  const $input = convertToTensor(input, "input", "real");
  const inputs = { input: $input };
  return ENGINE.runKernel(Real, inputs);
}
const real = /* @__PURE__ */ op({ real_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reciprocal_(x) {
  const $x = convertToTensor(x, "x", "reciprocal");
  const inputs = { x: $x };
  return ENGINE.runKernel(Reciprocal, inputs);
}
const reciprocal = /* @__PURE__ */ op({ reciprocal_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function relu_(x) {
  const $x = convertToTensor(x, "x", "relu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu, inputs);
}
const relu = /* @__PURE__ */ op({ relu_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function relu6_(x) {
  const $x = convertToTensor(x, "x", "relu6");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu6, inputs);
}
const relu6 = /* @__PURE__ */ op({ relu6_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reverse_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  const inputs = { x: $x };
  const attrs = { dims: axis };
  return ENGINE.runKernel(Reverse, inputs, attrs);
}
const reverse = /* @__PURE__ */ op({ reverse_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reverse1d_(x) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
  return reverse($x, 0);
}
const reverse1d = /* @__PURE__ */ op({ reverse1d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reverse2d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
const reverse2d = /* @__PURE__ */ op({ reverse2d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reverse3d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
const reverse3d = /* @__PURE__ */ op({ reverse3d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function reverse4d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
const reverse4d = /* @__PURE__ */ op({ reverse4d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function round_(x) {
  const $x = convertToTensor(x, "x", "round");
  const inputs = { x: $x };
  return ENGINE.runKernel(Round, inputs);
}
const round$1 = /* @__PURE__ */ op({ round_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rsqrt_(x) {
  const $x = convertToTensor(x, "x", "rsqrt", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Rsqrt, inputs);
}
const rsqrt = /* @__PURE__ */ op({ rsqrt_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function selu_(x) {
  const $x = convertToTensor(x, "x", "selu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Selu, inputs);
}
const selu = /* @__PURE__ */ op({ selu_ });
function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad2, dilation = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "separableConv2d");
  const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
  const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  if (dataFormat === "NCHW") {
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
  }
  assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${$pointwiseFilter.shape[0]}.`);
  assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
  const inChannels = $depthwiseFilter.shape[2];
  const channelMultiplier = $depthwiseFilter.shape[3];
  assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${inChannels * channelMultiplier}, but got ${$pointwiseFilter.shape[2]}.`);
  const depthwise = depthwiseConv2d$1(x4D, $depthwiseFilter, strides, pad2, dataFormat, dilation);
  const pointwiseStride = 1;
  const res = conv2d$1(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const separableConv2d = /* @__PURE__ */ op({ separableConv2d_ });
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function setdiff1dAsync_(x, y) {
  const $x = convertToTensor(x, "x", "setdiff1d");
  const $y = convertToTensor(y, "y", "setdiff1d");
  assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
  assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
  assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
  const xVals = await $x.data();
  const yVals = await $y.data();
  const ySet = new Set(yVals);
  let outputSize = 0;
  for (let i = 0; i < xVals.length; i++) {
    if (!ySet.has(xVals[i])) {
      outputSize++;
    }
  }
  const buffer2 = new TensorBuffer([outputSize], $x.dtype);
  const indices = new TensorBuffer([outputSize], "int32");
  for (let i = 0, p = 0; i < xVals.length; i++) {
    if (!ySet.has(xVals[i])) {
      buffer2.values[p] = xVals[i];
      indices.values[p] = i;
      p++;
    }
  }
  return [buffer2.toTensor(), indices.toTensor()];
}
const setdiff1dAsync = setdiff1dAsync_;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sign_(x) {
  const $x = convertToTensor(x, "x", "sign");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sign, inputs);
}
const sign = /* @__PURE__ */ op({ sign_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sin_(x) {
  const $x = convertToTensor(x, "x", "sin", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sin, inputs);
}
const sin = /* @__PURE__ */ op({ sin_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sinh_(x) {
  const $x = convertToTensor(x, "x", "sinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sinh, inputs);
}
const sinh = /* @__PURE__ */ op({ sinh_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice1d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice1d");
  assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, [begin], [size]);
}
const slice1d = /* @__PURE__ */ op({ slice1d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice2d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice2d");
  assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
const slice2d = /* @__PURE__ */ op({ slice2d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice3d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice3d");
  assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
const slice3d = /* @__PURE__ */ op({ slice3d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function slice4d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice4d");
  assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
const slice4d = /* @__PURE__ */ op({ slice4d_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function softmax_(logits, dim = -1) {
  const $logits = convertToTensor(logits, "logits", "softmax", "float32");
  if (dim === -1) {
    dim = $logits.rank - 1;
  }
  if (dim !== $logits.rank - 1) {
    throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${$logits.rank} and dim was ${dim}`);
  }
  const inputs = { logits: $logits };
  const attrs = { dim };
  return ENGINE.runKernel(Softmax, inputs, attrs);
}
const softmax = /* @__PURE__ */ op({ softmax_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fft_(input) {
  assert(input.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${input.dtype}.`);
  const inputs = { input };
  return ENGINE.runKernel(FFT, inputs);
}
const fft = /* @__PURE__ */ op({ fft_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function ifft_(input) {
  assert(input.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${input.dtype}.`);
  const inputs = { input };
  return ENGINE.runKernel(IFFT, inputs);
}
const ifft = /* @__PURE__ */ op({ ifft_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function irfft_(input) {
  const innerDimensionSize = input.shape[input.shape.length - 1];
  const batch = input.size / innerDimensionSize;
  let ret;
  if (innerDimensionSize <= 2) {
    const complexInput = reshape(input, [batch, innerDimensionSize]);
    ret = ifft(complexInput);
  } else {
    const outputShape = [batch, 2 * (innerDimensionSize - 1)];
    const realInput = reshape(real(input), [batch, innerDimensionSize]);
    const imagInput = reshape(imag(input), [batch, innerDimensionSize]);
    const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
    const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
    const r = concat([realInput, realConjugate], 1);
    const i = concat([imagInput, imagConjugate], 1);
    const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);
    ret = ifft(complexInput);
  }
  ret = real(ret);
  if (input.rank === 3 && input.shape[0] !== 0) {
    const temp = ret;
    const batch2 = input.shape[0];
    ret = reshape(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
    temp.dispose();
  }
  return ret;
}
const irfft = /* @__PURE__ */ op({ irfft_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function split_(x, numOrSizeSplits, axis = 0) {
  const $x = convertToTensor(x, "x", "split");
  const inputs = { x: $x };
  const attr = { numOrSizeSplits, axis };
  return ENGINE.runKernel(SplitV, inputs, attr);
}
const split$1 = /* @__PURE__ */ op({ split_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rfft_(input, fftLength) {
  assert(input.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input.dtype}`);
  let innerDimensionSize = input.shape[input.shape.length - 1];
  const batch = input.size / innerDimensionSize;
  let adjustedInput;
  if (fftLength != null && fftLength < innerDimensionSize) {
    const begin = input.shape.map((v) => 0);
    const size = input.shape.map((v) => v);
    size[input.shape.length - 1] = fftLength;
    adjustedInput = slice(input, begin, size);
    innerDimensionSize = fftLength;
  } else if (fftLength != null && fftLength > innerDimensionSize) {
    const zerosShape = input.shape.map((v) => v);
    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);
    innerDimensionSize = fftLength;
  } else {
    adjustedInput = input;
  }
  const zerosInput = zerosLike(adjustedInput);
  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
  const ret = fft(complexInput);
  const half2 = Math.floor(innerDimensionSize / 2) + 1;
  const realValues = real(ret);
  const imagValues = imag(ret);
  const realComplexConjugate = split$1(realValues, [half2, innerDimensionSize - half2], realValues.shape.length - 1);
  const imagComplexConjugate = split$1(imagValues, [half2, innerDimensionSize - half2], imagValues.shape.length - 1);
  const outputShape = adjustedInput.shape.slice();
  outputShape[adjustedInput.shape.length - 1] = half2;
  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
}
const rfft = /* @__PURE__ */ op({ rfft_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function squaredDifference_(a, b) {
  let $a = convertToTensor(a, "a", "squaredDifference");
  let $b = convertToTensor(b, "b", "squaredDifference");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(SquaredDifference, inputs, attrs);
}
const squaredDifference = /* @__PURE__ */ op({ squaredDifference_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function squeeze_(x, axis) {
  const $x = convertToTensor(x, "x", "squeeze", "string_or_numeric");
  return reshape($x, squeezeShape($x.shape, axis).newShape);
}
const squeeze = /* @__PURE__ */ op({ squeeze_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stack_(tensors, axis = 0) {
  const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
  assert($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
  if ($tensors.length > 0) {
    assert(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
  }
  const inputs = $tensors;
  const attrs = { axis };
  return ENGINE.runKernel(Pack, inputs, attrs);
}
const stack = /* @__PURE__ */ op({ stack_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function step_(x, alpha2 = 0) {
  const $x = convertToTensor(x, "x", "step");
  const inputs = { x: $x };
  const attrs = { alpha: alpha2 };
  return ENGINE.runKernel(Step, inputs, attrs);
}
const step = /* @__PURE__ */ op({ step_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
  const $x = convertToTensor(x, "x", "stridedSlice", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = {
    begin,
    end,
    strides,
    beginMask,
    endMask,
    ellipsisMask,
    newAxisMask,
    shrinkAxisMask
  };
  return ENGINE.runKernel(StridedSlice, inputs, attrs);
}
const stridedSlice = /* @__PURE__ */ op({ stridedSlice_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tan_(x) {
  const $x = convertToTensor(x, "x", "tan", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tan, inputs);
}
const tan = /* @__PURE__ */ op({ tan_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor1d(values, dtype) {
  assertNonNull(values);
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 1) {
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  }
  const shape = null;
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor2d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 2) {
    throw new Error("tensor2d() requires shape to have two numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 2 && inferredShape.length !== 1) {
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor3d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 3) {
    throw new Error("tensor3d() requires shape to have three numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 3 && inferredShape.length !== 1) {
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor4d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 4) {
    throw new Error("tensor4d() requires shape to have four numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 4 && inferredShape.length !== 1) {
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor5d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 5) {
    throw new Error("tensor5d() requires shape to have five numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 5 && inferredShape.length !== 1) {
    throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensor6d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 6) {
    throw new Error("tensor6d() requires shape to have six numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 6 && inferredShape.length !== 1) {
    throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
  }
  shape = shape || inferredShape;
  return makeTensor(values, shape, inferredShape, dtype);
}
function validateUpdateShape(shape, indices, updates) {
  const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
  const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
  const shapeError = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${updates.shape}, indices.shape: ${indices.shape}, shape: ${shape}, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
  if (updates.rank < batchDim) {
    throw new Error(shapeError + ` update.rank < ${batchDim}. `);
  }
  if (shape.length < sliceDim + (updates.rank - batchDim)) {
    throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
  }
  if (updates.rank !== batchDim + shape.length - sliceDim) {
    throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
  }
  for (let d = 0; d < batchDim; ++d) {
    if (updates.shape[d] !== indices.shape[d]) {
      throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
    }
  }
  for (let d = 0; d < updates.rank - batchDim; ++d) {
    if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
      throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
    }
  }
}
function validateInput$1(updates, indices, shape) {
  if (indices.rank < 1) {
    throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${indices.rank}.`);
  }
  if (updates.rank < 1) {
    throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${updates.rank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
  }
  if (shape.length < 1) {
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
  }
  if (shape.length === 0) {
    if (indices.size === 0) {
      throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
    }
    if (updates.size === 0) {
      throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
    }
  }
  validateUpdateShape(shape, indices, updates);
}
function calculateShapes(updates, indices, shape) {
  const indicesRank = indices.shape.length;
  const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
  const totalNd = shape.length;
  let sliceSize = 1;
  for (let i = sliceRank; i < totalNd; ++i) {
    sliceSize *= shape[i];
  }
  const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
  const outputSize = sizeFromShape(shape);
  return { sliceRank, numUpdates, sliceSize, strides, outputSize };
}
const scatter_nd_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  calculateShapes,
  validateInput: validateInput$1,
  validateUpdateShape
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function tensorScatterUpdate_(tensor2, indices, updates) {
  const $tensor = convertToTensor(tensor2, "tensor", "tensorScatterupdate");
  const $indices = convertToTensor(indices, "indices", "tensorScatterupdate", "int32");
  const $updates = convertToTensor(updates, "updates", "tensorScatterupdate");
  validateInput$1($updates, $indices, $tensor.shape);
  if ($tensor.dtype !== $updates.dtype) {
    throw new Error(`tensor and updates must have the same dtype, instead they are ${$tensor.dtype} and ${$updates.dtype}.`);
  }
  const inputs = {
    tensor: $tensor,
    indices: $indices,
    updates: $updates
  };
  const attrs = {};
  return ENGINE.runKernel(TensorScatterUpdate, inputs, attrs);
}
const tensorScatterUpdate = op({ tensorScatterUpdate_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function topk_(x, k = 1, sorted = true) {
  const $x = convertToTensor(x, "x", "topk");
  if ($x.rank === 0) {
    throw new Error("topk() expects the input to be of rank 1 or higher");
  }
  const lastDim = $x.shape[$x.shape.length - 1];
  if (k < 0) {
    throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);
  }
  if (k > lastDim) {
    throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) but got ${k}`);
  }
  const inputs = { x: $x };
  const attrs = { k, sorted };
  const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
  return { values, indices };
}
const topk = /* @__PURE__ */ op({ topk_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function truncatedNormal_(shape, mean2 = 0, stdDev = 1, dtype, seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type $ { dtype }`);
  }
  const randGauss = new MPRandGauss(mean2, stdDev, dtype, true, seed);
  const res = buffer(shape, dtype);
  for (let i = 0; i < res.values.length; i++) {
    res.values[i] = randGauss.nextValue();
  }
  return res.toTensor();
}
const truncatedNormal = /* @__PURE__ */ op({ truncatedNormal_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function unique_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "unique", "string_or_numeric");
  assert($x.rank > 0, () => "The input tensor must be at least 1D");
  const inputs = { x: $x };
  const attrs = { axis };
  const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
  return { values, indices };
}
const unique = /* @__PURE__ */ op({ unique_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function unsortedSegmentSum_(x, segmentIds, numSegments) {
  const $x = convertToTensor(x, "x", "unsortedSegmentSum");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
  assert(isInt(numSegments), () => "numSegments must be of dtype int");
  const inputs = { x: $x, segmentIds: $segmentIds };
  const attrs = { numSegments };
  return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
}
const unsortedSegmentSum = /* @__PURE__ */ op({ unsortedSegmentSum_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function unstack_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "unstack", "string_or_numeric");
  assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
  const inputs = { value: $x };
  const attrs = { axis };
  return ENGINE.runKernel(Unpack, inputs, attrs);
}
const unstack = /* @__PURE__ */ op({ unstack_ });
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function upperBound(sortedSequence, values) {
  return searchSorted(sortedSequence, values, "right");
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function variable(initialValue, trainable = true, name, dtype) {
  return ENGINE.makeVariable(initialValue, trainable, name, dtype);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function whereImpl(condShape, condVals) {
  const indices = [];
  for (let i = 0; i < condVals.length; i++) {
    if (condVals[i]) {
      indices.push(i);
    }
  }
  const inBuffer = buffer(condShape, "int32");
  const out = buffer([indices.length, condShape.length], "int32");
  for (let i = 0; i < indices.length; i++) {
    const loc = inBuffer.indexToLoc(indices[i]);
    const offset = i * condShape.length;
    out.values.set(loc, offset);
  }
  return out.toTensor();
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function whereAsync_(condition) {
  const $condition = convertToTensor(condition, "condition", "whereAsync", "bool");
  const vals = await $condition.data();
  const res = whereImpl($condition.shape, vals);
  if (condition !== $condition) {
    $condition.dispose();
  }
  return res;
}
const whereAsync = whereAsync_;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function booleanMaskAsync_(tensor2, mask, axis) {
  const $tensor = convertToTensor(tensor2, "tensor", "boolMask");
  const $mask = convertToTensor(mask, "mask", "boolMask", "bool");
  const axisFrom = axis == null ? 0 : axis;
  const maskDim = $mask.rank;
  const tensorShape = $tensor.shape;
  assert(maskDim > 0, () => "mask cannot be scalar");
  assertShapesMatch(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
  let leadingSize = 1;
  for (let i = axisFrom; i < axisFrom + maskDim; i++) {
    leadingSize *= tensorShape[i];
  }
  const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
  const reshapedTensor = reshape($tensor, targetTensorShape);
  const reshapedMask = reshape($mask, [-1]);
  const positivePositions = await whereAsync(reshapedMask);
  const indices = squeeze(positivePositions, [1]);
  const res = gather(reshapedTensor, indices, axisFrom);
  if (tensor2 !== $tensor) {
    $tensor.dispose();
  }
  if (mask !== $mask) {
    $mask.dispose();
  }
  indices.dispose();
  reshapedTensor.dispose();
  reshapedMask.dispose();
  positivePositions.dispose();
  return res;
}
const booleanMaskAsync = booleanMaskAsync_;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function transpose_(x, perm, conjugate) {
  const $x = convertToTensor(x, "x", "transpose");
  if (perm == null) {
    perm = $x.shape.map((s, i) => i).reverse();
  }
  assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} must match length of perm ${perm}.`);
  perm.forEach((axis) => {
    assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1} but got ${perm}`);
  });
  if ($x.rank <= 1) {
    return $x.clone();
  }
  const inputs = { x: $x };
  const attrs = { perm };
  if ($x.dtype === "complex64") {
    return tidy(() => {
      let $real = real($x);
      let $imag = imag($x);
      $real = ENGINE.runKernel(Transpose, { x: $real }, attrs);
      $imag = ENGINE.runKernel(Transpose, { x: $imag }, attrs);
      if (conjugate) {
        $imag = neg($imag);
      }
      return complex($real, $imag);
    });
  }
  return ENGINE.runKernel(Transpose, inputs, attrs);
}
const transpose = /* @__PURE__ */ op({ transpose_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function movingAverage_(v, x, decay, step2, zeroDebias = true) {
  const $v = convertToTensor(v, "v", "movingAverage");
  const $x = convertToTensor(x, "x", "movingAverage");
  const $decay = convertToTensor(decay, "decay", "movingAverage");
  assertTypesMatch($v, $x);
  assert(arraysEqual$1($v.shape, $x.shape), () => "Shape mismatch in v and x");
  const one = scalar(1);
  const oneMinusDecay = sub(one, $decay);
  let update2 = mul(sub($x, $v), oneMinusDecay);
  if (zeroDebias) {
    assert(step2 != null, () => "When using zeroDebias: true, step is required.");
    const $step = convertToTensor(step2, "step", "movingAverage");
    update2 = div(update2, sub(one, pow($decay, $step)));
  }
  return add($v, update2);
}
const movingAverage = /* @__PURE__ */ op({ movingAverage_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function scatterND_(indices, updates, shape) {
  assertNonNegativeIntegerDimensions(shape);
  const $indices = convertToTensor(indices, "indices", "scatterND", "int32");
  const $updates = convertToTensor(updates, "updates", "scatterND");
  validateInput$1($updates, $indices, shape);
  const inputs = { indices: $indices, updates: $updates };
  const attrs = { shape };
  return ENGINE.runKernel(ScatterNd, inputs, attrs);
}
const scatterND = /* @__PURE__ */ op({ scatterND_ });
function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {
  if (sparseIndices.dtype !== "int32") {
    throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${sparseIndices.dtype}.`);
  }
  if (sparseIndices.rank > 2) {
    throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${sparseIndices.shape}.`);
  }
  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
  if (outputShape.length !== numDims) {
    throw new Error(`outputShape has incorrect number of elements:, ${outputShape.length}, should be: ${numDims}.`);
  }
  const numValues = sparseValues.size;
  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
    throw new Error(`sparseValues has incorrect shape ${sparseValues.shape}, should be [] or [${numElems}]`);
  }
  if (sparseValues.dtype !== defaultValues.dtype) {
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
  assertNonNegativeIntegerDimensions(outputShape);
  const $sparseIndices = convertToTensor(sparseIndices, "sparseIndices", "sparseToDense", "int32");
  const $sparseValues = convertToTensor(sparseValues, "sparseValues", "sparseToDense", "string_or_numeric");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
  validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);
  const inputs = {
    sparseIndices: $sparseIndices,
    sparseValues: $sparseValues,
    defaultValue: $defaultValue
  };
  const attrs = { outputShape };
  return ENGINE.runKernel(SparseToDense, inputs, attrs);
}
const sparseToDense = /* @__PURE__ */ op({ sparseToDense_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gatherND_(x, indices) {
  const $indices = convertToTensor(indices, "indices", "gatherND", "int32");
  const $x = convertToTensor(x, "x", "gatherND", "string_or_numeric");
  const inputs = { params: $x, indices: $indices };
  return ENGINE.runKernel(GatherNd, inputs);
}
const gatherND = /* @__PURE__ */ op({ gatherND_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getNoiseShape(x, noiseShape) {
  if (noiseShape == null) {
    return x.shape.slice();
  }
  if (arraysEqual$1(x.shape, noiseShape)) {
    return noiseShape;
  }
  if (x.shape.length === noiseShape.length) {
    const newDimension = [];
    for (let i = 0; i < x.shape.length; i++) {
      if (noiseShape[i] == null && x.shape[i] != null) {
        newDimension.push(x.shape[i]);
      } else {
        newDimension.push(noiseShape[i]);
      }
    }
    return newDimension;
  }
  return noiseShape;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function dropout_(x, rate, noiseShape, seed) {
  const $x = convertToTensor(x, "x", "dropout");
  assert($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${$x.dtype} tensor instead.`);
  assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
  if (rate === 0) {
    return x instanceof Tensor ? $x.clone() : $x;
  }
  const $noiseShape = getNoiseShape($x, noiseShape);
  const keepProb = 1 - rate;
  const multiplier = div(floor(add(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
  return mul($x, multiplier);
}
const dropout = /* @__PURE__ */ op({ dropout_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function enclosingPowerOfTwo(value) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
}
function cosineWindow(windowLength, a, b) {
  const even = 1 - windowLength % 2;
  const newValues = new Float32Array(windowLength);
  for (let i = 0; i < windowLength; ++i) {
    const cosArg = 2 * Math.PI * i / (windowLength + even - 1);
    newValues[i] = a - b * Math.cos(cosArg);
  }
  return tensor1d(newValues, "float32");
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function inTopKAsync_(predictions, targets, k = 1) {
  const $predictions = convertToTensor(predictions, "predictions", "inTopK");
  const $targets = convertToTensor(targets, "targets", "inTopK");
  assert($predictions.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${$predictions.rank}`);
  assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${$predictions.rank} and targets rank ${$targets.rank}`);
  assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, except the last dimension.`);
  const lastDim = $predictions.shape[$predictions.shape.length - 1];
  assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${lastDim}), but got ${k}`);
  const predictionsVals = await $predictions.data();
  const targetsVals = await $targets.data();
  const [batch, size] = [predictionsVals.length / lastDim, lastDim];
  const precision = getTypedArrayFromDType("bool", batch);
  for (let b = 0; b < batch; b++) {
    const offset = b * size;
    const vals = predictionsVals.subarray(offset, offset + size);
    const valAndInd = [];
    for (let i = 0; i < vals.length; i++) {
      valAndInd.push({ value: vals[i], index: i });
    }
    valAndInd.sort((a, b2) => b2.value - a.value);
    precision[b] = 0;
    for (let i = 0; i < k; i++) {
      if (valAndInd[i].index === targetsVals[b]) {
        precision[b] = 1;
        break;
      }
    }
  }
  if (predictions !== $predictions) {
    $predictions.dispose();
  }
  if (targets !== $targets) {
    $targets.dispose();
  }
  return tensor(precision, $targets.shape, "bool");
}
const inTopKAsync = inTopKAsync_;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function conv2DBackpropFilter_(x, dy, filterShape, strides, pad2, dataFormat = "NHWC", dimRoundingMode) {
  let x4D = x;
  if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  }
  let dy4D = dy;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${x4D.shape}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${dy4D.shape}.`);
  assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${filterShape}.`);
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must match input depth in filter (${filterShape[2]}.`);
  assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must match output depth for filter (${filterShape[3]}).`);
  checkPadOnDimRoundingMode("conv2dDerFilter", pad2, dimRoundingMode);
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad2, dataFormat, dimRoundingMode, filterShape };
  return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
}
const conv2DBackpropFilter = /* @__PURE__ */ op({ conv2DBackpropFilter_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getFusedDyActivation(dy, y, activation) {
  if (activation == null || activation === "linear") {
    return dy;
  }
  if (activation === "relu") {
    return mul(dy, step(y));
  }
  throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
}
function getFusedBiasGradient(bias, dyActivation) {
  let res = dyActivation;
  const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
  if (reduceAxes.length > 0) {
    res = sum(res, reduceAxes);
  }
  return reshape(res, bias.shape);
}
function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
  if (activation === "linear") {
    return x;
  } else if (activation === "relu") {
    return relu(x);
  } else if (activation === "elu") {
    return elu(x);
  } else if (activation === "relu6") {
    return relu6(x);
  } else if (activation === "prelu") {
    return prelu(x, preluActivationWeights);
  } else if (activation === "leakyrelu") {
    return leakyRelu(x, leakyreluAlpha);
  } else if (activation === "sigmoid") {
    return sigmoid(x);
  }
  throw new Error(`Unknown fused activation ${activation}.`);
}
const shouldFuse = (gradientDepth, activation) => {
  const gradientMode = gradientDepth > 0;
  return !gradientMode || activation === "linear";
};
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fusedConv2d_({ x, filter: filter2, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
  activation = activation || "linear";
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    assert(dataFormat === "NHWC", () => `Error in fused conv2d: got dataFormat of ${dataFormat} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
    let result = conv2d$1(x, filter2, strides, pad2, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x, "x", "conv2d", "float32");
  const $filter = convertToTensor(filter2, "filter", "conv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  checkPadOnDimRoundingMode("fused conv2d", pad2, dimRoundingMode);
  const inputChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad2, dimRoundingMode);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    if (dataFormat === "NHWC") {
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    } else {
      assert($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${$bias.shape.length}.`);
      assert($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels || $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not compatible with the number of output channels (${convInfo.outChannels})`);
    }
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    const alphaShape = preluActivationWeights.shape;
    assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${alphaShape.length}.`);
    if (alphaShape.length === 1) {
      assert(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the number of output channels (${convInfo.outChannels}).`);
    } else if (alphaShape.length === 3) {
      try {
        assertAndGetBroadcastShape(alphaShape, convInfo.outShape);
      } catch (e) {
        const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) is not compatible with the output shape of the conv2d (${convInfo.outShape}).`;
        throw Error(errMsg);
      }
    }
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
  }
  const grad2 = (dy, saved) => {
    assert(dataFormat === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
    const [$filter2, x4D2, y, $bias2] = saved;
    const dyActivation = getFusedDyActivation(dy, y, activation);
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${dilations}'`);
    const xDer = conv2DBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad2);
    const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad2);
    const der = [xDer, filterDer];
    if ($bias2 != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      der.push(biasDer);
    }
    return der;
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad2,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter3, save) => {
      let res = (
        // tslint:disable-next-line: no-unnecessary-type-assertion
        ENGINE.runKernel(FusedConv2D, inputs, attrs)
      );
      save([filter3, x4D2, res]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter3, bias2, save) => {
      let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
      save([filter3, x4D2, res, bias2]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
const conv2d = /* @__PURE__ */ op({ fusedConv2d_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthwiseConv2dNativeBackpropFilter_(x, dy, filterShape, strides, pad2, dilations = [1, 1], dimRoundingMode) {
  let x4D = x;
  if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  }
  let dy4D = dy;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad2, dimRoundingMode, dilations, filterShape };
  return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
}
const depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function depthwiseConv2dNativeBackpropInput_(xShape, dy, filter2, strides, pad2, dilations = [1, 1], dimRoundingMode) {
  let dy4D = dy;
  let reshapedTo4D = false;
  if (dy.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
  }
  const inputs = { dy: dy4D, filter: filter2 };
  const attrs = { strides, pad: pad2, dimRoundingMode, dilations, inputShape: xShape };
  const res = (
    // tslint:disable-next-line: no-unnecessary-type-assertion
    ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs)
  );
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fusedDepthwiseConv2d_({ x, filter: filter2, strides, pad: pad2, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    let result = depthwiseConv2d$1(x, filter2, strides, pad2, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
  const $filter = convertToTensor(filter2, "filter", "depthwiseConv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${$filter.rank}.`);
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${x4D.shape[3]}) must match the inChannels dimension in filter ${$filter.shape[2]}.`);
  if (dilations == null) {
    dilations = [1, 1];
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${strides} and dilations '${dilations}'`);
  checkPadOnDimRoundingMode("fused depthwiseConv2d", pad2, dimRoundingMode);
  const convInfo = computeConv2DInfo(
    x4D.shape,
    $filter.shape,
    strides,
    dilations,
    pad2,
    dimRoundingMode,
    true
    /* depthwise */
  );
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
  }
  const grad2 = (dy, saved) => {
    assert(tupleValuesAreOne(dilations), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${dilations}'`);
    const [$filter2, x4D2, y, bias2] = saved;
    const dyActivation = getFusedDyActivation(dy, y, activation);
    const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad2, dilations, dimRoundingMode);
    const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad2, dilations, dimRoundingMode);
    if (bias2 != null) {
      const biasDer = getFusedBiasGradient($bias, dyActivation);
      return [xDer, filterDer, biasDer];
    }
    return [xDer, filterDer];
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad2,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter3, save) => {
      let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter3, x4D2, res]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter3, bias2, save) => {
      let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter3, x4D2, res, bias2]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
const depthwiseConv2d = /* @__PURE__ */ op({ fusedDepthwiseConv2d_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = "linear", preluActivationWeights, leakyreluAlpha = 0.2 }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    let result = matMul$1(a, b, transposeA, transposeB);
    if (bias != null) {
      result = add(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  let $a = convertToTensor(a, "a", "fused matMul");
  let $b = convertToTensor(b, "b", "fused matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
  const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
  const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
  const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
  const outerDimsA = $a.shape.slice(0, -2);
  const outerDimsB = $b.shape.slice(0, -2);
  const batchDimA = sizeFromShape(outerDimsA);
  const batchDimB = sizeFromShape(outerDimsB);
  assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (${innerShapeB}) of Tensors with shapes ${$a.shape} and ${$b.shape} and transposeA=${transposeA} and transposeB=${transposeB} must match.`);
  const outShapeOuterDims = assertAndGetBroadcastShape($a.shape.slice(0, -2), $b.shape.slice(0, -2));
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  const a3D = transposeA ? reshape($a, [batchDimA, innerShapeA, outerShapeA]) : reshape($a, [batchDimA, outerShapeA, innerShapeA]);
  const b3D = transposeB ? reshape($b, [batchDimB, outerShapeB, innerShapeB]) : reshape($b, [batchDimB, innerShapeB, outerShapeB]);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused matMul");
    [$bias] = makeTypesMatch($bias, $a);
    assertAndGetBroadcastShape(outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
  }
  const grad2 = (dy, saved) => {
    const [a3D2, b3D2, y, $bias2] = saved;
    const dyActivation = getFusedDyActivation(reshape(dy, y.shape), y, activation);
    let aDer;
    let bDer;
    if (!transposeA && !transposeB) {
      aDer = matMul$1(dyActivation, b3D2, false, true);
      bDer = matMul$1(a3D2, dyActivation, true, false);
    } else if (!transposeA && transposeB) {
      aDer = matMul$1(dyActivation, b3D2, false, false);
      bDer = matMul$1(dyActivation, a3D2, true, false);
    } else if (transposeA && !transposeB) {
      aDer = matMul$1(b3D2, dyActivation, false, true);
      bDer = matMul$1(a3D2, dyActivation, false, false);
    } else {
      aDer = matMul$1(b3D2, dyActivation, true, true);
      bDer = matMul$1(dyActivation, a3D2, true, true);
    }
    if (bias != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      return [aDer, bDer, biasDer];
    } else {
      return [aDer, bDer];
    }
  };
  const inputs = {
    a: a3D,
    b: b3D,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = { transposeA, transposeB, activation, leakyreluAlpha };
  if (bias == null) {
    const customOp = customGrad((a3D2, b3D2, save) => {
      const res = (
        // tslint:disable-next-line: no-unnecessary-type-assertion
        ENGINE.runKernel(_FusedMatMul, inputs, attrs)
      );
      save([a3D2, b3D2, res]);
      return { value: reshape(res, outShape), gradFunc: grad2 };
    });
    return customOp(a3D, b3D);
  } else {
    const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
      const res = (
        // tslint:disable-next-line: no-unnecessary-type-assertion
        ENGINE.runKernel(_FusedMatMul, inputs, attrs)
      );
      save([a3D2, b3D2, res, $bias2]);
      return { value: reshape(res, outShape), gradFunc: grad2 };
    });
    return customOpWithBias(a3D, b3D, $bias);
  }
}
const matMul = /* @__PURE__ */ op({ fusedMatMul_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const fused_ops = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  conv2d,
  depthwiseConv2d,
  matMul
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hammingWindow_(windowLength) {
  return cosineWindow(windowLength, 0.54, 0.46);
}
const hammingWindow = /* @__PURE__ */ op({ hammingWindow_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function hannWindow_(windowLength) {
  return cosineWindow(windowLength, 0.5, 0.5);
}
const hannWindow = /* @__PURE__ */ op({ hannWindow_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function frame_(signal2, frameLength, frameStep, padEnd = false, padValue = 0) {
  let start2 = 0;
  const output = [];
  while (start2 + frameLength <= signal2.size) {
    output.push(slice(signal2, start2, frameLength));
    start2 += frameStep;
  }
  if (padEnd) {
    while (start2 < signal2.size) {
      const padLen = start2 + frameLength - signal2.size;
      const pad2 = concat([
        slice(signal2, start2, frameLength - padLen),
        fill([padLen], padValue)
      ]);
      output.push(pad2);
      start2 += frameStep;
    }
  }
  if (output.length === 0) {
    return tensor2d([], [0, frameLength]);
  }
  return reshape(concat(output), [output.length, frameLength]);
}
const frame = /* @__PURE__ */ op({ frame_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stft_(signal2, frameLength, frameStep, fftLength, windowFn = hannWindow) {
  if (fftLength == null) {
    fftLength = enclosingPowerOfTwo(frameLength);
  }
  const framedSignal = frame(signal2, frameLength, frameStep);
  const windowedSignal = mul(framedSignal, windowFn(frameLength));
  return rfft(windowedSignal, fftLength);
}
const stft = /* @__PURE__ */ op({ stft_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function cropAndResize_(image2, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
  const $image = convertToTensor(image2, "image", "cropAndResize");
  const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
  const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
  const numBoxes = $boxes.shape[0];
  assert($image.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${$image.rank}.`);
  assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] but had shape ${$boxes.shape}.`);
  assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] but had shape ${$boxes.shape}.`);
  assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${cropSize.length}.`);
  assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
  assert(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
  const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
  const attrs = { method, extrapolationValue, cropSize };
  const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
  return res;
}
const cropAndResize = /* @__PURE__ */ op({ cropAndResize_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function flipLeftRight_(image2) {
  const $image = convertToTensor(image2, "image", "flipLeftRight", "float32");
  assert($image.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
  return res;
}
const flipLeftRight = /* @__PURE__ */ op({ flipLeftRight_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function grayscaleToRGB_(image2) {
  const $image = convertToTensor(image2, "image", "grayscaleToRGB");
  const lastDimsIdx = $image.rank - 1;
  const lastDims = $image.shape[lastDimsIdx];
  assert($image.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${$image.rank}.`);
  assert(lastDims === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${lastDims}.`);
  const reps = new Array($image.rank);
  reps.fill(1, 0, lastDimsIdx);
  reps[lastDimsIdx] = 3;
  return tile($image, reps);
}
const grayscaleToRGB = /* @__PURE__ */ op({ grayscaleToRGB_ });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rgbToGrayscale_(image2) {
  const $image = convertToTensor(image2, "image", "RGBToGrayscale");
  const lastDimsIdx = $image.rank - 1;
  const lastDims = $image.shape[lastDimsIdx];
  assert($image.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${$image.rank}.`);
  assert(lastDims === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${lastDims}.`);
  const origDtype = $image.dtype;
  const fltImage = cast($image, "float32");
  const rgbWeights = tensor1d([0.2989, 0.587, 0.114]);
  let grayFloat;
  switch ($image.rank) {
    case 2:
      grayFloat = einsum("ij,j->i", fltImage, rgbWeights);
      break;
    case 3:
      grayFloat = einsum("ijk,k->ij", fltImage, rgbWeights);
      break;
    case 4:
      grayFloat = einsum("ijkl,l->ijk", fltImage, rgbWeights);
      break;
    case 5:
      grayFloat = einsum("ijklm,m->ijkl", fltImage, rgbWeights);
      break;
    case 6:
      grayFloat = einsum("ijklmn,n->ijklm", fltImage, rgbWeights);
      break;
    default:
      throw new Error("Not a valid tensor rank.");
  }
  grayFloat = expandDims(grayFloat, -1);
  return cast(grayFloat, origDtype);
}
const rgbToGrayscale = /* @__PURE__ */ op({ rgbToGrayscale_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function rotateWithOffset_(image2, radians, fillValue = 0, center = 0.5) {
  const $image = convertToTensor(image2, "image", "rotateWithOffset", "float32");
  assert($image.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const attrs = { radians, fillValue, center };
  const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
  return res;
}
const rotateWithOffset = /* @__PURE__ */ op({ rotateWithOffset_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  if (iouThreshold == null) {
    iouThreshold = 0.5;
  }
  if (scoreThreshold == null) {
    scoreThreshold = Number.NEGATIVE_INFINITY;
  }
  if (softNmsSigma == null) {
    softNmsSigma = 0;
  }
  const numBoxes = boxes.shape[0];
  maxOutputSize = Math.min(maxOutputSize, numBoxes);
  assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
  assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
  assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
  assert(scores.rank === 1, () => "scores must be a 1D tensor");
  assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, but was ${scores.shape[0]}`);
  assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
  return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression", "float32");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression", "float32");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
  return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
}
const nonMaxSuppression = /* @__PURE__ */ op({ nonMaxSuppression_ });
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function binaryInsert(arr, element, comparator) {
  const index = binarySearch(arr, element, comparator);
  const insertionPoint = index < 0 ? -(index + 1) : index;
  arr.splice(insertionPoint, 0, element);
}
function binarySearch(arr, target, comparator) {
  return binarySearch_(arr, target, comparator || defaultComparator);
}
function defaultComparator(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function binarySearch_(arr, target, comparator) {
  let left = 0;
  let right = arr.length;
  let middle = 0;
  let found = false;
  while (left < right) {
    middle = left + (right - left >>> 1);
    const compareResult = comparator(target, arr[middle]);
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      found = !compareResult;
    }
  }
  return found ? left : -left - 1;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
  return nonMaxSuppressionImpl_(
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    0
    /* softNmsSigma */
  );
}
function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
  return nonMaxSuppressionImpl_(
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    0,
    false,
    padToMaxOutputSize,
    true
    /* returnValidOutputs */
  );
}
function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  return nonMaxSuppressionImpl_(
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    softNmsSigma,
    true
    /* returnScoresTensor */
  );
}
function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
  const candidates = [];
  for (let i = 0; i < scores.length; i++) {
    if (scores[i] > scoreThreshold) {
      candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
    }
  }
  candidates.sort(ascendingComparator);
  const scale2 = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
  const selectedIndices = [];
  const selectedScores = [];
  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
    const candidate = candidates.pop();
    const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
    if (originalScore < scoreThreshold) {
      break;
    }
    let ignoreCandidate = false;
    for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {
      const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
      if (iou >= iouThreshold) {
        ignoreCandidate = true;
        break;
      }
      candidate.score = candidate.score * suppressWeight(iouThreshold, scale2, iou);
      if (candidate.score <= scoreThreshold) {
        break;
      }
    }
    candidate.suppressBeginIndex = selectedIndices.length;
    if (!ignoreCandidate) {
      if (candidate.score === originalScore) {
        selectedIndices.push(boxIndex);
        selectedScores.push(candidate.score);
      } else if (candidate.score > scoreThreshold) {
        binaryInsert(candidates, candidate, ascendingComparator);
      }
    }
  }
  const validOutputs = selectedIndices.length;
  const elemsToPad = maxOutputSize - validOutputs;
  if (padToMaxOutputSize && elemsToPad > 0) {
    selectedIndices.push(...new Array(elemsToPad).fill(0));
    selectedScores.push(...new Array(elemsToPad).fill(0));
  }
  const result = { selectedIndices };
  if (returnScoresTensor) {
    result["selectedScores"] = selectedScores;
  }
  if (returnValidOutputs) {
    result["validOutputs"] = validOutputs;
  }
  return result;
}
function intersectionOverUnion(boxes, i, j) {
  const iCoord = boxes.subarray(i * 4, i * 4 + 4);
  const jCoord = boxes.subarray(j * 4, j * 4 + 4);
  const yminI = Math.min(iCoord[0], iCoord[2]);
  const xminI = Math.min(iCoord[1], iCoord[3]);
  const ymaxI = Math.max(iCoord[0], iCoord[2]);
  const xmaxI = Math.max(iCoord[1], iCoord[3]);
  const yminJ = Math.min(jCoord[0], jCoord[2]);
  const xminJ = Math.min(jCoord[1], jCoord[3]);
  const ymaxJ = Math.max(jCoord[0], jCoord[2]);
  const xmaxJ = Math.max(jCoord[1], jCoord[3]);
  const areaI = (ymaxI - yminI) * (xmaxI - xminI);
  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
  if (areaI <= 0 || areaJ <= 0) {
    return 0;
  }
  const intersectionYmin = Math.max(yminI, yminJ);
  const intersectionXmin = Math.max(xminI, xminJ);
  const intersectionYmax = Math.min(ymaxI, ymaxJ);
  const intersectionXmax = Math.min(xmaxI, xmaxJ);
  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
  return intersectionArea / (areaI + areaJ - intersectionArea);
}
function suppressWeight(iouThreshold, scale2, iou) {
  const weight = Math.exp(scale2 * iou * iou);
  return iou <= iouThreshold ? weight : 0;
}
function ascendingComparator(c12, c22) {
  return c12.score - c22.score || c12.score === c22.score && c22.boxIndex - c12.boxIndex;
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return tensor1d(selectedIndices, "int32");
}
const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
  return { selectedIndices: result[0], selectedScores: result[1] };
}
const nonMaxSuppressionWithScore = /* @__PURE__ */ op({ nonMaxSuppressionWithScore_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    selectedScores: tensor1d(selectedScores)
  };
}
const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck(
    $boxes,
    $scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    null
    /* softNmsSigma */
  );
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = {
    maxOutputSize: $maxOutputSize,
    iouThreshold: $iouThreshold,
    scoreThreshold: $scoreThreshold,
    padToMaxOutputSize
  };
  const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
  return { selectedIndices: result[0], validOutputs: result[1] };
}
const nonMaxSuppressionPadded = /* @__PURE__ */ op({ nonMaxSuppressionPadded_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck(
    $boxes,
    $scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    null
    /* softNmsSigma */
  );
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    validOutputs: scalar(validOutputs, "int32")
  };
}
const nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeBilinear");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${$images.rank}.`);
  assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${size}.`);
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size };
  const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const resizeBilinear = /* @__PURE__ */ op({ resizeBilinear_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${$images.rank}.`);
  assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${size}.`);
  assert($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size };
  const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
const resizeNearestNeighbor = /* @__PURE__ */ op({ resizeNearestNeighbor_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function threshold_(image2, method = "binary", inverted = false, threshValue = 0.5) {
  const $image = convertToTensor(image2, "image", "threshold");
  const RED_INTENCITY_COEF = 0.2989;
  const GREEN_INTENCITY_COEF = 0.587;
  const BLUE_INTENCITY_COEF = 0.114;
  const totalPixelsInImage = $image.shape[0] * $image.shape[1];
  let $threshold = mul(tensor1d([threshValue]), 255);
  let r, g, b, grayscale;
  assert($image.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${$image.rank}.`);
  assert($image.shape[2] === 3 || $image.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${$image.shape[2]}.`);
  assert($image.dtype === "int32" || $image.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${$image.dtype}.`);
  assert(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
  if ($image.shape[2] === 3) {
    [r, g, b] = split$1($image, [1, 1, 1], -1);
    const $r = mul(r, RED_INTENCITY_COEF);
    const $g = mul(g, GREEN_INTENCITY_COEF);
    const $b = mul(b, BLUE_INTENCITY_COEF);
    grayscale = add(add($r, $g), $b);
  } else {
    grayscale = image2;
  }
  if (method === "otsu") {
    const $histogram = bincount(cast(round$1(grayscale), "int32"), tensor([]), 256);
    $threshold = otsu($histogram, totalPixelsInImage);
  }
  const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
  const result = cast(mul(invCondition, 255), "int32");
  return result;
}
function otsu(histogram, total) {
  let bestThresh = tensor1d([-1]);
  let bestInBetVar = tensor1d([0]);
  let cInBetVar = tensor1d([0]);
  let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
  for (let index = 0; index < histogram.size - 1; index++) {
    classFirst = slice(histogram, 0, index + 1);
    classSecond = slice(histogram, index + 1);
    weightForeground = div(sum(classFirst), total);
    weightBack = div(sum(classSecond), total);
    const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));
    meanFirst = div(meanFirstDivA, sum(classFirst));
    const meanSecFill = fill(classSecond.shape, classFirst.size);
    const meanSecAdd = add(range(0, classSecond.size), meanSecFill);
    const meanSecMul = mul(classSecond, meanSecAdd);
    meanSec = div(sum(meanSecMul), sum(classSecond));
    const cInBetVarSubA = sub(meanFirst, meanSec);
    const cInBetVarSubB = sub(meanFirst, meanSec);
    const cInBetVarMul = mul(weightForeground, weightBack);
    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
    const condition = greater(cInBetVar, bestInBetVar);
    bestInBetVar = where(condition, cInBetVar, bestInBetVar);
    bestThresh = where(condition, tensor1d([index]), bestThresh);
  }
  return bestThresh;
}
const threshold = /* @__PURE__ */ op({ threshold_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function transform_(image2, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
  const $image = convertToTensor(image2, "image", "transform", "float32");
  const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
  assert($image.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${$image.rank}.`);
  assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
  assert(outputShape == null || outputShape.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${outputShape}.`);
  const inputs = { image: $image, transforms: $transforms };
  const attrs = { interpolation, fillMode, fillValue, outputShape };
  return ENGINE.runKernel(Transform, inputs, attrs);
}
const transform = /* @__PURE__ */ op({ transform_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function bandPart_(a, numLower, numUpper) {
  const $a = convertToTensor(a, "a", "bandPart");
  assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
  const shape = $a.shape;
  const [M, N] = $a.shape.slice(-2);
  let $numLower;
  let $numUpper;
  if (typeof numLower === "number") {
    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert(numLower <= M, () => `bandPart(): numLower (${numLower}) must not be greater than the number of rows (${M}).`);
    $numLower = convertToTensor(numLower < 0 ? M : numLower, "numLower", "bandPart");
  } else {
    assert(numLower.dtype === "int32", () => `bandPart(): numLower's dtype must be an int32.`);
    $numLower = where(less(numLower, 0), M, minimum(numLower, M));
  }
  if (typeof numUpper === "number") {
    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    assert(numUpper <= N, () => `bandPart(): numUpper (${numUpper}) must not be greater than the number of columns (${N}).`);
    $numUpper = convertToTensor(numUpper < 0 ? N : numUpper, "numUpper", "bandPart");
  } else {
    assert(numUpper.dtype === "int32", () => `bandPart(): numUpper's dtype must be an int32.`);
    $numUpper = where(less(numUpper, 0), N, minimum(numUpper, N));
  }
  const i = reshape(range(0, M, 1, "int32"), [-1, 1]);
  const j = range(0, N, 1, "int32");
  const ij = sub(i, j);
  const inBand = logicalAnd(lessEqual(ij, $numLower), greaterEqual(ij, neg($numUpper)));
  const zero = zeros([M, N], $a.dtype);
  return reshape(stack(unstack(reshape($a, [-1, M, N])).map((mat) => where(inBand, mat, zero))), shape);
}
const bandPart = /* @__PURE__ */ op({ bandPart_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function gramSchmidt_(xs) {
  let inputIsTensor2D;
  if (Array.isArray(xs)) {
    inputIsTensor2D = false;
    assert(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
    const dim = xs[0].shape[0];
    for (let i = 1; i < xs.length; ++i) {
      assert(xs[i].shape[0] === dim, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${xs[i].shape[0]} vs. ${dim})`);
    }
  } else {
    inputIsTensor2D = true;
    xs = split$1(xs, xs.shape[0], 0).map((x) => squeeze(x, [0]));
  }
  assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds number of dimensions (${xs[0].shape[0]}).`);
  const ys = [];
  const xs1d = xs;
  for (let i = 0; i < xs.length; ++i) {
    ys.push(ENGINE.tidy(() => {
      let x = xs1d[i];
      if (i > 0) {
        for (let j = 0; j < i; ++j) {
          const proj = mul(sum(mul(ys[j], x)), ys[j]);
          x = sub(x, proj);
        }
      }
      return div(x, norm(x, "euclidean"));
    }));
  }
  if (inputIsTensor2D) {
    return stack(ys, 0);
  } else {
    return ys;
  }
}
const gramSchmidt = /* @__PURE__ */ op({ gramSchmidt_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function qr_(x, fullMatrices = false) {
  assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
  if (x.rank === 2) {
    return qr2d(x, fullMatrices);
  } else {
    const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev) => value * prev);
    const x2ds = unstack(reshape(x, [
      outerDimsProd,
      x.shape[x.shape.length - 2],
      x.shape[x.shape.length - 1]
    ]), 0);
    const q2ds = [];
    const r2ds = [];
    x2ds.forEach((x2d) => {
      const [q2d, r2d] = qr2d(x2d, fullMatrices);
      q2ds.push(q2d);
      r2ds.push(r2d);
    });
    const q = reshape(stack(q2ds, 0), x.shape);
    const r = reshape(stack(r2ds, 0), x.shape);
    return [q, r];
  }
}
function qr2d(x, fullMatrices = false) {
  return ENGINE.tidy(() => {
    assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
    const m = x.shape[0];
    const n = x.shape[1];
    let q = eye(m);
    let r = clone(x);
    const one2D = tensor2d([[1]], [1, 1]);
    let w = clone(one2D);
    const iters = m >= n ? n : m;
    for (let j = 0; j < iters; ++j) {
      const rTemp = r;
      const wTemp = w;
      const qTemp = q;
      [w, r, q] = ENGINE.tidy(() => {
        const rjEnd1 = slice(r, [j, j], [m - j, 1]);
        const normX = norm(rjEnd1);
        const rjj = slice(r, [j, j], [1, 1]);
        const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
        const u1 = sub(rjj, mul(s, normX));
        const wPre = div(rjEnd1, u1);
        if (wPre.shape[0] === 1) {
          w = clone(one2D);
        } else {
          w = concat([
            one2D,
            slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
          ], 0);
        }
        const tau = neg(div(matMul$1(s, u1), normX));
        const rjEndAll = slice(r, [j, 0], [m - j, n]);
        const tauTimesW = mul(tau, w);
        const wT = transpose(w);
        if (j === 0) {
          r = sub(rjEndAll, matMul$1(tauTimesW, matMul$1(wT, rjEndAll)));
        } else {
          const rTimesTau = sub(rjEndAll, matMul$1(tauTimesW, matMul$1(wT, rjEndAll)));
          r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);
        }
        const tawTimesWT = transpose(tauTimesW);
        const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);
        if (j === 0) {
          q = sub(qAllJEnd, matMul$1(matMul$1(qAllJEnd, w), tawTimesWT));
        } else {
          const qTimesTau = sub(qAllJEnd, matMul$1(matMul$1(qAllJEnd, w), tawTimesWT));
          q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);
        }
        return [w, r, q];
      });
      dispose([rTemp, wTemp, qTemp]);
    }
    if (!fullMatrices && m > n) {
      q = slice(q, [0, 0], [m, n]);
      r = slice(r, [0, 0], [n, n]);
    }
    return [q, r];
  });
}
const qr = /* @__PURE__ */ op({ qr_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var Reduction;
(function(Reduction2) {
  Reduction2[Reduction2["NONE"] = 0] = "NONE";
  Reduction2[Reduction2["MEAN"] = 1] = "MEAN";
  Reduction2[Reduction2["SUM"] = 2] = "SUM";
  Reduction2[Reduction2["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(Reduction || (Reduction = {}));
function computeWeightedLoss_(losses2, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $losses = convertToTensor(losses2, "losses", "computeWeightedLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "computeWeightedLoss");
  }
  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);
  if (reduction2 === Reduction.NONE) {
    return weightedLoss;
  }
  if (reduction2 === Reduction.SUM) {
    return sum(weightedLoss);
  }
  if (reduction2 === Reduction.MEAN) {
    if ($weights == null) {
      return mean(weightedLoss);
    } else {
      const broadcastFactor = $losses.size / $weights.size;
      const result = div(sum(weightedLoss), sum($weights));
      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;
    }
  }
  if (reduction2 === Reduction.SUM_BY_NONZERO_WEIGHTS) {
    if ($weights == null) {
      return div(sum(weightedLoss), scalar($losses.size));
    } else {
      const broadcastedWeights = mul($weights, ones($losses.shape));
      const numNonZeros = cast(sum(notEqual(broadcastedWeights, scalar(0))), "float32");
      return div(sum(weightedLoss), numNonZeros);
    }
  }
  throw Error(`Unknown reduction: ${reduction2}`);
}
const computeWeightedLoss = /* @__PURE__ */ op({ computeWeightedLoss_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function absoluteDifference_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "absoluteDifference");
  const $predictions = convertToTensor(predictions, "predictions", "absoluteDifference");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "absoluteDifference");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
  const losses2 = abs(sub($labels, $predictions));
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const absoluteDifference = /* @__PURE__ */ op({ absoluteDifference_ });
function cosineDistance_(labels, predictions, axis, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "cosineDistance");
  const $predictions = convertToTensor(predictions, "predictions", "cosineDistance");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "cosineDistance");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in cosineDistance: ");
  const one = scalar(1);
  const losses2 = sub(one, sum(mul($labels, $predictions), axis, true));
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const cosineDistance = /* @__PURE__ */ op({ cosineDistance_ });
function hingeLoss_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $labels = convertToTensor(labels, "labels", "hingeLoss");
  const $predictions = convertToTensor(predictions, "predictions", "hingeLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "hingeLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in hingeLoss: ");
  const one = scalar(1);
  $labels = sub(mul(scalar(2), $labels), one);
  const losses2 = relu(sub(one, mul($labels, $predictions)));
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const hingeLoss = /* @__PURE__ */ op({ hingeLoss_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function huberLoss_(labels, predictions, weights, delta = 1, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "huberLoss");
  const $predictions = convertToTensor(predictions, "predictions", "huberLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "huberLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in huberLoss: ");
  const deltaScalar = scalar(delta);
  const error = abs(sub($predictions, $labels));
  const quadratic = minimum(error, deltaScalar);
  const linear = sub(error, quadratic);
  const losses2 = add(mul(scalar(0.5), square(quadratic)), mul(deltaScalar, linear));
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const huberLoss = /* @__PURE__ */ op({ huberLoss_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function logLoss_(labels, predictions, weights, epsilon = 1e-7, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "logLoss");
  const $predictions = convertToTensor(predictions, "predictions", "logLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "logLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in logLoss: ");
  const one = scalar(1);
  const epsilonScalar = scalar(epsilon);
  const l1 = neg(mul($labels, log(add($predictions, epsilonScalar))));
  const l2 = mul(sub(one, $labels), log(add(sub(one, $predictions), epsilonScalar)));
  const losses2 = sub(l1, l2);
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const logLoss = /* @__PURE__ */ op({ logLoss_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function meanSquaredError_(labels, predictions, weights, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "meanSquaredError");
  const $predictions = convertToTensor(predictions, "predictions", "meanSquaredError");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "meanSquaredError");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
  const losses2 = squaredDifference($labels, $predictions);
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const meanSquaredError = /* @__PURE__ */ op({ meanSquaredError_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sigmoidCrossEntropyWithLogits_(labels, logits) {
  const $labels = convertToTensor(labels, "labels", "sigmoidCrossEntropyWithLogits");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropyWithLogits");
  assertShapesMatch($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const maxOutput = relu($logits);
  const outputXTarget = mul($logits, $labels);
  const sigmoidOutput = log1p(exp(neg(abs($logits))));
  return add(sub(maxOutput, outputXTarget), sigmoidOutput);
}
function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $multiClassLabels = convertToTensor(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "sigmoidCrossEntropy");
  }
  assertShapesMatch($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const half2 = scalar(0.5);
    $multiClassLabels = add(mul($multiClassLabels, sub(one, labelSmoothingScalar)), mul(half2, labelSmoothingScalar));
  }
  const losses2 = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const sigmoidCrossEntropy = /* @__PURE__ */ op({ sigmoidCrossEntropy_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
  if (dim === -1) {
    dim = logits.rank - 1;
  }
  if (dim !== logits.rank - 1) {
    throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${logits.rank} and dim was ${dim}`);
  }
  const customOp = customGrad((labels2, logits2, save) => {
    const keepDims = true;
    const lse = logSumExp(logits2, [dim], keepDims);
    const logResult = sub(cast(logits2, "float32"), lse);
    save([labels2, logResult]);
    const costVector = neg(mul(logResult, labels2));
    const value = sum(costVector, [dim]);
    const gradFunc = (dy, saved) => {
      const [labels3, logResult2] = saved;
      const dyShape = expandShapeToKeepDim(dy.shape, [dim]);
      return [
        mul(reshape(dy, dyShape), sub(cast(labels3, "float32"), exp(logResult2))),
        mul(reshape(dy, dyShape), sub(exp(logResult2), cast(labels3, "float32")))
      ];
    };
    return { value, gradFunc };
  });
  return customOp(labels, logits);
}
function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction2 = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $onehotLabels = convertToTensor(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "softmaxCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "softmaxCrossEntropy");
  }
  assertShapesMatch($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const numClasses = scalar($onehotLabels.shape[1]);
    $onehotLabels = add(mul($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
  }
  const losses2 = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
  return computeWeightedLoss(losses2, $weights, reduction2);
}
const softmaxCrossEntropy = /* @__PURE__ */ op({ softmaxCrossEntropy_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
  const $indices = convertToTensor(indices, "indices", "sparseFillEmptyRows", "int32");
  const $values = convertToTensor(values, "values", "sparseFillEmptyRows");
  const $denseShape = convertToTensor(denseShape, "denseShape", "sparseFillEmptyRows", "int32");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
  if ($indices.rank !== 2) {
    throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
  }
  if ($values.rank !== 1) {
    throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
  }
  if ($denseShape.rank !== 1) {
    throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
  }
  if ($defaultValue.rank !== 0) {
    throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
  }
  const inputs = {
    indices: $indices,
    values: $values,
    denseShape: $denseShape,
    defaultValue: $defaultValue
  };
  const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
  return {
    outputIndices: result[0],
    outputValues: result[1],
    emptyRowIndicator: result[2],
    reverseIndexMap: result[3]
  };
}
const sparseFillEmptyRows = /* @__PURE__ */ op({ sparseFillEmptyRows_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sparseReshape_(inputIndices, inputShape, newShape) {
  const $inputIndices = convertToTensor(inputIndices, "inputIndices", "sparseReshape", "int32");
  const $inputShape = convertToTensor(inputShape, "inputShape", "sparseReshape", "int32");
  const $newShape = convertToTensor(newShape, "newShape", "sparseReshape", "int32");
  if ($inputIndices.rank !== 2) {
    throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
  }
  if ($inputShape.rank !== 1) {
    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
  }
  if ($newShape.rank !== 1) {
    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
  }
  const inputs = {
    inputIndices: $inputIndices,
    inputShape: $inputShape,
    newShape: $newShape
  };
  const result = ENGINE.runKernel(SparseReshape, inputs);
  return { outputIndices: result[0], outputShape: result[1] };
}
const sparseReshape = /* @__PURE__ */ op({ sparseReshape_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sparseSegmentMean_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentMean");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentMean", "int32");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentMean", "int32");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentMean, inputs);
}
const sparseSegmentMean = /* @__PURE__ */ op({ sparseSegmentMean_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function sparseSegmentSum_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentSum");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentSum", "int32");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentSum", "int32");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentSum, inputs);
}
const sparseSegmentSum = /* @__PURE__ */ op({ sparseSegmentSum_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
  const $data = convertToTensor(data, "data", "stringNGrams", "string");
  if ($data.dtype !== "string") {
    throw new Error("Data must be of datatype string");
  }
  if ($data.shape.length !== 1) {
    throw new Error(`Data must be a vector, saw: ${$data.shape}`);
  }
  const $dataSplits = convertToTensor(dataSplits, "dataSplits", "stringNGrams");
  if ($dataSplits.dtype !== "int32") {
    throw new Error("Data splits must be of datatype int32");
  }
  const attrs = {
    separator,
    nGramWidths,
    leftPad,
    rightPad: rightPad2,
    padWidth,
    preserveShortSequences
  };
  const inputs = { data: $data, dataSplits: $dataSplits };
  const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
  return { nGrams: result[0], nGramsSplits: result[1] };
}
const stringNGrams = /* @__PURE__ */ op({ stringNGrams_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stringSplit_(input, delimiter, skipEmpty = true) {
  const $input = convertToTensor(input, "input", "stringSplit", "string");
  const $delimiter = convertToTensor(delimiter, "delimiter", "stringSplit", "string");
  if ($input.rank !== 1) {
    throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
  }
  if ($delimiter.rank !== 0) {
    throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
  }
  const attrs = { skipEmpty };
  const inputs = { input: $input, delimiter: $delimiter };
  const result = ENGINE.runKernel(StringSplit, inputs, attrs);
  return { indices: result[0], values: result[1], shape: result[2] };
}
const stringSplit = /* @__PURE__ */ op({ stringSplit_ });
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function stringToHashBucketFast_(input, numBuckets) {
  const $input = convertToTensor(input, "input", "stringToHashBucketFast", "string");
  const attrs = { numBuckets };
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const inputs = { input: $input };
  return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
}
const stringToHashBucketFast = /* @__PURE__ */ op({ stringToHashBucketFast_ });
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function staticRegexReplace_(input, pattern, rewrite, replaceGlobal = true) {
  const $input = convertToTensor(input, "input", "staticRegexReplace", "string");
  const attrs = { pattern, rewrite, replaceGlobal };
  return ENGINE.runKernel(StaticRegexReplace, { x: $input }, attrs);
}
const staticRegexReplace = /* @__PURE__ */ op({ staticRegexReplace_ });
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const spectral$1 = {
  fft,
  ifft,
  rfft,
  irfft
};
const signal = {
  hammingWindow,
  hannWindow,
  frame,
  stft
};
const image$1 = {
  flipLeftRight,
  grayscaleToRGB,
  resizeNearestNeighbor,
  resizeBilinear,
  rgbToGrayscale,
  rotateWithOffset,
  cropAndResize,
  nonMaxSuppression,
  nonMaxSuppressionAsync,
  nonMaxSuppressionWithScore,
  nonMaxSuppressionWithScoreAsync,
  nonMaxSuppressionPadded,
  nonMaxSuppressionPaddedAsync,
  threshold,
  transform
};
const linalg = {
  bandPart,
  gramSchmidt,
  qr
};
const losses = {
  absoluteDifference,
  computeWeightedLoss,
  cosineDistance,
  hingeLoss,
  huberLoss,
  logLoss,
  meanSquaredError,
  sigmoidCrossEntropy,
  softmaxCrossEntropy
};
const sparse$1 = {
  sparseFillEmptyRows,
  sparseReshape,
  sparseSegmentMean,
  sparseSegmentSum
};
const string$1 = {
  stringNGrams,
  stringSplit,
  stringToHashBucketFast,
  staticRegexReplace
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const GLOBAL_CUSTOM_OBJECT = /* @__PURE__ */ new Map();
const GLOBAL_CUSTOM_NAMES = /* @__PURE__ */ new Map();
class Serializable {
  /**
   * Return the class name for this class to use in serialization contexts.
   *
   * Generally speaking this will be the same thing that constructor.name
   * would have returned.  However, the class name needs to be robust
   * against minification for serialization/deserialization to work properly.
   *
   * There's also places such as initializers.VarianceScaling, where
   * implementation details between different languages led to different
   * class hierarchies and a non-leaf node is used for serialization purposes.
   */
  getClassName() {
    return this.constructor.className;
  }
  /**
   * Creates an instance of T from a ConfigDict.
   *
   * This works for most descendants of serializable.  A few need to
   * provide special handling.
   * @param cls A Constructor for the class to instantiate.
   * @param config The Configuration for the object.
   */
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2);
  }
}
class SerializationMap {
  constructor() {
    this.classNameMap = {};
  }
  /**
   * Returns the singleton instance of the map.
   */
  static getMap() {
    if (SerializationMap.instance == null) {
      SerializationMap.instance = new SerializationMap();
    }
    return SerializationMap.instance;
  }
  /**
   * Registers the class as serializable.
   */
  static register(cls) {
    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
  }
}
function registerClass(cls, pkg, name) {
  assert(cls.className != null, () => `Class being registered does not have the static className property defined.`);
  assert(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, which is disallowed.`);
  if (typeof pkg === "undefined") {
    pkg = "Custom";
  }
  if (typeof name === "undefined") {
    name = cls.className;
  }
  const className = name;
  const registerName = pkg + ">" + className;
  SerializationMap.register(cls);
  GLOBAL_CUSTOM_OBJECT.set(registerName, cls);
  GLOBAL_CUSTOM_NAMES.set(cls, registerName);
  return cls;
}
function getRegisteredName(cls) {
  if (GLOBAL_CUSTOM_NAMES.has(cls)) {
    return GLOBAL_CUSTOM_NAMES.get(cls);
  } else {
    return cls.className;
  }
}
const serialization = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Serializable,
  SerializationMap,
  getRegisteredName,
  registerClass
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class Optimizer extends Serializable {
  /**
   * Executes `f()` and minimizes the scalar output of `f()` by computing
   * gradients of y with respect to the list of trainable variables provided by
   * `varList`. If no list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to minimize.
   * @param returnCost Whether to return the scalar cost value produced by
   * executing `f()`.
   * @param varList An optional list of variables to update. If specified, only
   * the trainable variables in varList will be updated by minimize. Defaults to
   * all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  minimize(f, returnCost = false, varList) {
    const { value, grads: grads2 } = this.computeGradients(f, varList);
    if (varList != null) {
      const gradArray = varList.map((v) => ({ name: v.name, tensor: grads2[v.name] }));
      this.applyGradients(gradArray);
    } else {
      this.applyGradients(grads2);
    }
    dispose(grads2);
    if (returnCost) {
      return value;
    } else {
      value.dispose();
      return null;
    }
  }
  /**
   * The number of iterations that this optimizer instance has been invoked for.
   */
  get iterations() {
    if (this.iterations_ == null) {
      this.iterations_ = 0;
    }
    return this.iterations_;
  }
  incrementIterations() {
    this.iterations_ = this.iterations + 1;
  }
  /**
   * Executes f() and computes the gradient of the scalar output of f() with
   * respect to the list of trainable variables provided by `varList`. If no
   * list is provided, it defaults to all trainable variables.
   *
   * @param f The function to execute and whose output to use for computing
   * gradients with respect to variables.
   * @param varList An optional list of variables to compute gradients with
   * respect to. If specified, only the trainable variables in varList will have
   * gradients computed with respect to. Defaults to all trainable variables.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers'}
   */
  computeGradients(f, varList) {
    return variableGrads(f, varList);
  }
  /**
   * Dispose the variables (if any) owned by this optimizer instance.
   */
  dispose() {
    if (this.iterations_ != null) {
      dispose(this.iterations_);
    }
  }
  async saveIterations() {
    if (this.iterations_ == null) {
      this.iterations_ = 0;
    }
    return {
      name: "iter",
      // TODO(cais): Use 'int64' type when available.
      tensor: scalar(this.iterations_, "int32")
    };
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for this optimizer yet.");
  }
  async setWeights(weightValues) {
    throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
  }
  /**
   * Extract the first element of the weight values and set it
   * as the iterations counter variable of this instance of optimizer.
   *
   * @param weightValues
   * @returns Weight values with the first element consumed and excluded.
   */
  async extractIterations(weightValues) {
    this.iterations_ = (await weightValues[0].tensor.data())[0];
    return weightValues.slice(1);
  }
}
Object.defineProperty(Optimizer, Symbol.hasInstance, {
  value: (instance) => {
    return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
  }
});
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AdadeltaOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "Adadelta";
  }
  constructor(learningRate, rho, epsilon = null) {
    super();
    this.learningRate = learningRate;
    this.rho = rho;
    this.epsilon = epsilon;
    this.accumulatedGrads = [];
    this.accumulatedUpdates = [];
    if (epsilon == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i) => {
      const value = ENGINE.registeredVariables[name];
      const trainable = false;
      if (this.accumulatedGrads[i] == null) {
        this.accumulatedGrads[i] = {
          originalName: `${name}/accum_grad`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedUpdates[i] == null) {
        this.accumulatedUpdates[i] = {
          originalName: `${name}/accum_var`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedGrad = this.accumulatedGrads[i].variable;
      const accumulatedUpdate = this.accumulatedUpdates[i].variable;
      tidy(() => {
        const newAccumulatedGrad = add(mul(accumulatedGrad, this.rho), mul(square(gradient), 1 - this.rho));
        const updates = mul(div(sqrt(add(accumulatedUpdate, this.epsilon)), sqrt(add(accumulatedGrad, this.epsilon))), gradient);
        const newAccumulatedUpdate = add(mul(accumulatedUpdate, this.rho), mul(square(updates), 1 - this.rho));
        accumulatedGrad.assign(newAccumulatedGrad);
        accumulatedUpdate.assign(newAccumulatedUpdate);
        const newValue = add(mul(updates, -this.learningRate), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedUpdates != null) {
      dispose(this.accumulatedGrads.map((v) => v.variable));
      dispose(this.accumulatedUpdates.map((v) => v.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
    return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const variableCount = weightValues.length / 2;
    const trainable = false;
    this.accumulatedGrads = weightValues.slice(0, variableCount).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
    this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "rho": this.rho,
      "epsilon": this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["rho"], config2["epsilon"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AdagradOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "Adagrad";
  }
  constructor(learningRate, initialAccumulatorValue = 0.1) {
    super();
    this.learningRate = learningRate;
    this.initialAccumulatorValue = initialAccumulatorValue;
    this.accumulatedGrads = [];
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i) => {
      const value = ENGINE.registeredVariables[name];
      if (this.accumulatedGrads[i] == null) {
        const trainable = false;
        this.accumulatedGrads[i] = {
          originalName: `${name}/accumulator`,
          variable: tidy(() => fill(value.shape, this.initialAccumulatorValue).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedGrad = this.accumulatedGrads[i].variable;
      tidy(() => {
        const newAccumulatedGrad = add(accumulatedGrad, square(gradient));
        accumulatedGrad.assign(newAccumulatedGrad);
        const newValue = add(mul(div(gradient, sqrt(add(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedGrads != null) {
      dispose(this.accumulatedGrads.map((v) => v.variable));
    }
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulatedGrads.map((v) => ({ name: v.originalName, tensor: v.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const trainable = false;
    this.accumulatedGrads = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "initialAccumulatorValue": this.initialAccumulatorValue
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["initialAccumulatorValue"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AdamOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "Adam";
  }
  constructor(learningRate, beta1, beta2, epsilon = null) {
    super();
    this.learningRate = learningRate;
    this.beta1 = beta1;
    this.beta2 = beta2;
    this.epsilon = epsilon;
    this.accumulatedFirstMoment = [];
    this.accumulatedSecondMoment = [];
    tidy(() => {
      this.accBeta1 = scalar(beta1).variable();
      this.accBeta2 = scalar(beta2).variable();
    });
    if (epsilon == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
    tidy(() => {
      const oneMinusAccBeta1 = sub(1, this.accBeta1);
      const oneMinusAccBeta2 = sub(1, this.accBeta2);
      varNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedFirstMoment[i] == null) {
          this.accumulatedFirstMoment[i] = {
            originalName: `${name}/m`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedSecondMoment[i] == null) {
          this.accumulatedSecondMoment[i] = {
            originalName: `${name}/v`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const firstMoment = this.accumulatedFirstMoment[i].variable;
        const secondMoment = this.accumulatedSecondMoment[i].variable;
        const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
        const newSecondMoment = add(mul(secondMoment, this.beta2), mul(square(gradient), 1 - this.beta2));
        const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
        const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
        firstMoment.assign(newFirstMoment);
        secondMoment.assign(newSecondMoment);
        const newValue = add(mul(div(biasCorrectedFirstMoment, add(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
        value.assign(newValue);
      });
      this.accBeta1.assign(mul(this.accBeta1, this.beta1));
      this.accBeta2.assign(mul(this.accBeta2, this.beta2));
    });
    this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose();
    this.accBeta2.dispose();
    if (this.accumulatedFirstMoment != null) {
      dispose(this.accumulatedFirstMoment.map((v) => v.variable));
    }
    if (this.accumulatedSecondMoment != null) {
      dispose(this.accumulatedSecondMoment.map((v) => v.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
    return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    tidy(() => {
      this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
      this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
    });
    const variableCount = weightValues.length / 2;
    const trainable = false;
    this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
    this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "beta1": this.beta1,
      "beta2": this.beta2,
      "epsilon": this.epsilon
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["beta1"], config2["beta2"], config2["epsilon"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class AdamaxOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "Adamax";
  }
  constructor(learningRate, beta1, beta2, epsilon = null, decay = 0) {
    super();
    this.learningRate = learningRate;
    this.beta1 = beta1;
    this.beta2 = beta2;
    this.epsilon = epsilon;
    this.decay = decay;
    this.accumulatedFirstMoment = [];
    this.accumulatedWeightedInfNorm = [];
    tidy(() => {
      this.iteration = scalar(0).variable();
      this.accBeta1 = scalar(beta1).variable();
    });
    if (epsilon == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    tidy(() => {
      const oneMinusAccBeta1 = sub(1, this.accBeta1);
      const lr = div(-this.learningRate, add(mul(this.iteration, this.decay), 1));
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedFirstMoment[i] == null) {
          this.accumulatedFirstMoment[i] = {
            originalName: `${name}/m`,
            variable: zerosLike(value).variable(trainable)
          };
        }
        if (this.accumulatedWeightedInfNorm[i] == null) {
          this.accumulatedWeightedInfNorm[i] = {
            originalName: `${name}/v`,
            variable: zerosLike(value).variable(trainable)
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const firstMoment = this.accumulatedFirstMoment[i].variable;
        const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;
        const newFirstMoment = add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
        const ut0 = mul(weightedInfNorm, this.beta2);
        const ut1 = abs(gradient);
        const newWeightedInfNorm = maximum(ut0, ut1);
        firstMoment.assign(newFirstMoment);
        weightedInfNorm.assign(newWeightedInfNorm);
        const newValue = add(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add(newWeightedInfNorm, this.epsilon))), value);
        value.assign(newValue);
      });
      this.iteration.assign(add(this.iteration, 1));
      this.accBeta1.assign(mul(this.accBeta1, this.beta1));
    });
    this.incrementIterations();
  }
  dispose() {
    this.accBeta1.dispose();
    this.iteration.dispose();
    if (this.accumulatedFirstMoment != null) {
      dispose(this.accumulatedFirstMoment.map((v) => v.variable));
    }
    if (this.accumulatedWeightedInfNorm != null) {
      dispose(this.accumulatedWeightedInfNorm.map((v) => v.variable));
    }
  }
  async getWeights() {
    throw new Error("getWeights() is not implemented for Adamax yet.");
  }
  async setWeights(weightValues) {
    throw new Error("setWeights() is not implemented for Adamax yet.");
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "beta1": this.beta1,
      "beta2": this.beta2,
      "epsilon": this.epsilon,
      "decay": this.decay
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["beta1"], config2["beta2"], config2["epsilon"], config2["decay"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class SGDOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "SGD";
  }
  constructor(learningRate) {
    super();
    this.learningRate = learningRate;
    this.setLearningRate(learningRate);
  }
  applyGradients(variableGradients) {
    const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
    varNames.forEach((name, i) => {
      const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const value = ENGINE.registeredVariables[name];
      tidy(() => {
        const newValue = add(mul(this.c, gradient), value);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  /**
   * Sets the learning rate of the optimizer.
   */
  setLearningRate(learningRate) {
    this.learningRate = learningRate;
    if (this.c != null) {
      this.c.dispose();
    }
    this.c = keep(scalar(-learningRate));
  }
  dispose() {
    this.c.dispose();
  }
  async getWeights() {
    return [await this.saveIterations()];
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    if (weightValues.length !== 0) {
      throw new Error("SGD optimizer does not have settable weights.");
    }
  }
  getConfig() {
    return { "learningRate": this.learningRate };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class MomentumOptimizer extends SGDOptimizer {
  /** @nocollapse */
  // Name matters for Python compatibility.
  static get className() {
    return "Momentum";
  }
  constructor(learningRate, momentum, useNesterov = false) {
    super(learningRate);
    this.learningRate = learningRate;
    this.momentum = momentum;
    this.useNesterov = useNesterov;
    this.accumulations = [];
    this.m = scalar(this.momentum);
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i) => {
      const value = ENGINE.registeredVariables[name];
      if (this.accumulations[i] == null) {
        const trainable = false;
        this.accumulations[i] = {
          originalName: `${name}/momentum`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const accumulation = this.accumulations[i].variable;
      const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      tidy(() => {
        let newValue;
        const newAccumulation = add(mul(this.m, accumulation), gradient);
        if (this.useNesterov) {
          newValue = add(mul(this.c, add(gradient, mul(newAccumulation, this.m))), value);
        } else {
          newValue = add(mul(this.c, newAccumulation), value);
        }
        accumulation.assign(newAccumulation);
        value.assign(newValue);
      });
    });
    this.incrementIterations();
  }
  dispose() {
    this.m.dispose();
    if (this.accumulations != null) {
      dispose(this.accumulations.map((v) => v.variable));
    }
  }
  /**
   * Sets the momentum of the optimizer.
   *
   * @param momentum
   */
  setMomentum(momentum) {
    this.momentum = momentum;
  }
  async getWeights() {
    return [await this.saveIterations()].concat(this.accumulations.map((v) => ({ name: v.originalName, tensor: v.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const trainable = false;
    this.accumulations = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "momentum": this.momentum,
      "useNesterov": this.useNesterov
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["momentum"], config2["useNesterov"]);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class RMSPropOptimizer extends Optimizer {
  /** @nocollapse */
  static get className() {
    return "RMSProp";
  }
  constructor(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
    super();
    this.learningRate = learningRate;
    this.decay = decay;
    this.momentum = momentum;
    this.epsilon = epsilon;
    this.accumulatedMeanSquares = [];
    this.accumulatedMoments = [];
    this.accumulatedMeanGrads = [];
    this.centered = centered;
    if (epsilon == null) {
      this.epsilon = ENGINE.backend.epsilon();
    }
    if (learningRate == null) {
      throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
    }
  }
  applyGradients(variableGradients) {
    const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
    variableNames.forEach((name, i) => {
      const value = ENGINE.registeredVariables[name];
      const trainable = false;
      if (this.accumulatedMeanSquares[i] == null) {
        this.accumulatedMeanSquares[i] = {
          originalName: `${name}/rms`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedMoments[i] == null) {
        this.accumulatedMoments[i] = {
          originalName: `${name}/momentum`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      if (this.accumulatedMeanGrads[i] == null && this.centered) {
        this.accumulatedMeanGrads[i] = {
          originalName: `${name}/mg`,
          variable: tidy(() => zerosLike(value).variable(trainable))
        };
      }
      const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
      if (gradient == null) {
        return;
      }
      const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
      const accumulatedMoments = this.accumulatedMoments[i].variable;
      tidy(() => {
        const newAccumulatedMeanSquare = add(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
        if (this.centered) {
          const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
          const newAccumulatedMeanGrad = add(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
          const gradContribution = div(mul(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add(square(newAccumulatedMeanGrad), this.epsilon))));
          const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), gradContribution);
          accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
          accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
          accumulatedMoments.assign(newAccumulatedMoments);
          const newValue = sub(value, newAccumulatedMoments);
          value.assign(newValue);
        } else {
          const newAccumulatedMeanSquare2 = add(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
          const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt(add(newAccumulatedMeanSquare2, this.epsilon))));
          accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
          accumulatedMoments.assign(newAccumulatedMoments);
          const newValue = sub(value, newAccumulatedMoments);
          value.assign(newValue);
        }
      });
    });
    this.incrementIterations();
  }
  dispose() {
    if (this.accumulatedMeanSquares != null) {
      dispose(this.accumulatedMeanSquares.map((v) => v.variable));
    }
    if (this.accumulatedMeanGrads != null && this.centered) {
      dispose(this.accumulatedMeanGrads.map((v) => v.variable));
    }
    if (this.accumulatedMoments != null) {
      dispose(this.accumulatedMoments.map((v) => v.variable));
    }
  }
  async getWeights() {
    const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
    if (this.centered) {
      variables.push(...this.accumulatedMeanGrads);
    }
    return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
  }
  async setWeights(weightValues) {
    weightValues = await this.extractIterations(weightValues);
    const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
    const trainable = false;
    this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
    this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
      originalName: v.name,
      variable: v.tensor.variable(trainable)
    }));
    if (this.centered) {
      this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
  }
  getConfig() {
    return {
      "learningRate": this.learningRate,
      "decay": this.decay,
      "momentum": this.momentum,
      "epsilon": this.epsilon,
      "centered": this.centered
    };
  }
  /** @nocollapse */
  static fromConfig(cls, config2) {
    return new cls(config2["learningRate"], config2["decay"], config2["momentum"], config2["epsilon"], config2["centered"]);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OPTIMIZERS = [
  AdadeltaOptimizer,
  AdagradOptimizer,
  AdamOptimizer,
  AdamaxOptimizer,
  MomentumOptimizer,
  RMSPropOptimizer,
  SGDOptimizer
];
function registerOptimizers() {
  for (const optimizer of OPTIMIZERS) {
    registerClass(optimizer);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const DEFAULT_FILE_NAME_PREFIX = "model";
const DEFAULT_JSON_EXTENSION_NAME = ".json";
const DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin";
function defer(f) {
  return new Promise((resolve) => setTimeout(resolve)).then(f);
}
class BrowserDownloads {
  constructor(fileNamePrefix) {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    }
    if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
      fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
    }
    if (fileNamePrefix == null || fileNamePrefix.length === 0) {
      fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
    }
    this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
    this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
  }
  async save(modelArtifacts) {
    if (typeof document === "undefined") {
      throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    }
    const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
    const weightsURL = window.URL.createObjectURL(new Blob([weightBuffer], { type: "application/octet-stream" }));
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    } else {
      const weightsManifest = [{
        paths: ["./" + this.weightDataFileName],
        weights: modelArtifacts.weightSpecs
      }];
      const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
      const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      jsonAnchor.download = this.modelJsonFileName;
      jsonAnchor.href = modelJsonURL;
      await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
      if (modelArtifacts.weightData != null) {
        const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        weightDataAnchor.download = this.weightDataFileName;
        weightDataAnchor.href = weightsURL;
        await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
    }
  }
}
BrowserDownloads.URL_SCHEME = "downloads://";
class BrowserFiles {
  constructor(files) {
    if (files == null || files.length < 1) {
      throw new Error(`When calling browserFiles, at least 1 file is required, but received ${files}`);
    }
    this.jsonFile = files[0];
    this.weightsFiles = files.slice(1);
  }
  async load() {
    return new Promise((resolve, reject) => {
      const jsonReader = new FileReader();
      jsonReader.onload = (event) => {
        const modelJSON = JSON.parse(event.target.result);
        const modelTopology = modelJSON.modelTopology;
        if (modelTopology == null) {
          reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        const weightsManifest = modelJSON.weightsManifest;
        if (weightsManifest == null) {
          reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          resolve({ modelTopology });
          return;
        }
        const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
        resolve(modelArtifactsPromise);
      };
      jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);
      jsonReader.readAsText(this.jsonFile);
    });
  }
  loadWeights(weightsManifest) {
    const weightSpecs = [];
    const paths = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
      paths.push(...entry.paths);
    }
    const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
    const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
    return Promise.all(promises).then((buffers) => [weightSpecs, buffers]);
  }
  loadWeightsFile(path, file) {
    return new Promise((resolve, reject) => {
      const weightFileReader = new FileReader();
      weightFileReader.onload = (event) => {
        const weightData = event.target.result;
        resolve(weightData);
      };
      weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
      weightFileReader.readAsArrayBuffer(file);
    });
  }
  /**
   * Check the compatibility between weights manifest and weight files.
   */
  checkManifestAndWeightFiles(manifest) {
    const basenames = [];
    const fileNames = this.weightsFiles.map((file) => basename(file.name));
    const pathToFile = {};
    for (const group of manifest) {
      group.paths.forEach((path) => {
        const pathBasename = basename(path);
        if (basenames.indexOf(pathBasename) !== -1) {
          throw new Error(`Duplicate file basename found in weights manifest: '${pathBasename}'`);
        }
        basenames.push(pathBasename);
        if (fileNames.indexOf(pathBasename) === -1) {
          throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
        } else {
          pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
        }
      });
    }
    if (basenames.length !== this.weightsFiles.length) {
      throw new Error(`Mismatch in the number of files in weights manifest (${basenames.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
    }
    return pathToFile;
  }
}
const browserDownloadsRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
      return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
function browserDownloads(fileNamePrefix = "model") {
  return new BrowserDownloads(fileNamePrefix);
}
function browserFiles(files) {
  return new BrowserFiles(files);
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
  checkPromises(promises);
  startFraction = startFraction == null ? 0 : startFraction;
  endFraction = endFraction == null ? 1 : endFraction;
  checkFraction(startFraction, endFraction);
  let resolvedPromise = 0;
  const registerMonitor = (promise) => {
    promise.then((value) => {
      const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
      onProgress(fraction);
      return value;
    });
    return promise;
  };
  function checkPromises(promises2) {
    assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
  }
  function checkFraction(startFraction2, endFraction2) {
    assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${startFraction2}`);
    assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${endFraction2}`);
    assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but got startFraction ${startFraction2} and endFraction ${endFraction2}`);
  }
  return Promise.all(promises.map(registerMonitor));
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
  if (loadOptions == null) {
    loadOptions = {};
  }
  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
  const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
  const fetchStartFraction = 0;
  const fetchEndFraction = 0.5;
  const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
  const bufferPromises = responses.map((response) => response.arrayBuffer());
  const bufferStartFraction = 0.5;
  const bufferEndFraction = 1;
  const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
  return buffers;
}
function streamWeights(fetchURLs, loadOptions) {
  var _a2;
  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
  let fetchIndex = 0;
  let chunkReader;
  (_a2 = loadOptions.onProgress) === null || _a2 === void 0 ? void 0 : _a2.call(loadOptions, 0);
  return new ReadableStream({
    pull: async (controller) => {
      var _a3;
      while (fetchIndex < fetchURLs.length) {
        if (!chunkReader) {
          const body = (await fetchFunc(fetchURLs[fetchIndex], loadOptions.requestInit, { isBinary: true })).body;
          chunkReader = body.getReader();
        }
        const { done, value } = await chunkReader.read();
        if (done) {
          fetchIndex++;
          chunkReader = void 0;
          (_a3 = loadOptions.onProgress) === null || _a3 === void 0 ? void 0 : _a3.call(loadOptions, fetchIndex / fetchURLs.length);
          continue;
        }
        controller.enqueue(value);
        return;
      }
      controller.close();
    }
  });
}
async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
  const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
  const loadWeights2 = weightsLoaderFactory(fetchWeights);
  return loadWeights2(manifest, filePathPrefix, weightNames);
}
function weightsLoaderFactory(fetchWeightsFunction) {
  return async (manifest, filePathPrefix = "", weightNames) => {
    const groupIndicesToFetchMap = manifest.map(() => false);
    const groupWeightsToFetch = {};
    const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
    const allManifestWeightNames = [];
    manifest.forEach((manifestGroupConfig, groupIndex) => {
      let groupOffset = 0;
      manifestGroupConfig.weights.forEach((weightsEntry) => {
        const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
        const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
        const enqueueWeightsForFetchingFn = () => {
          groupIndicesToFetchMap[groupIndex] = true;
          if (groupWeightsToFetch[groupIndex] == null) {
            groupWeightsToFetch[groupIndex] = [];
          }
          groupWeightsToFetch[groupIndex].push({
            manifestEntry: weightsEntry,
            groupOffset,
            sizeBytes: weightsBytes
          });
        };
        if (weightNames != null) {
          weightNames.forEach((weightName, weightIndex) => {
            if (weightName === weightsEntry.name) {
              enqueueWeightsForFetchingFn();
              weightsFound[weightIndex] = true;
            }
          });
        } else {
          enqueueWeightsForFetchingFn();
        }
        allManifestWeightNames.push(weightsEntry.name);
        groupOffset += weightsBytes;
      });
    });
    if (!weightsFound.every((found) => found)) {
      const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);
      throw new Error(`Could not find weights in manifest with names: ${weightsNotFound.join(", ")}. 
Manifest JSON has weights with names: ${allManifestWeightNames.join(", ")}.`);
    }
    const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {
      if (shouldFetch) {
        accumulator.push(i);
      }
      return accumulator;
    }, []);
    const fetchUrls = [];
    groupIndicesToFetch.forEach((i) => {
      manifest[i].paths.forEach((filepath) => {
        const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
        fetchUrls.push(fetchUrl);
      });
    });
    const buffers = await fetchWeightsFunction(fetchUrls);
    const weightsTensorMap = {};
    let bufferIndexOffset = 0;
    groupIndicesToFetch.forEach((i) => {
      const numBuffers = manifest[i].paths.length;
      const weightsBuffer = new CompositeArrayBuffer(buffers.slice(bufferIndexOffset, bufferIndexOffset + numBuffers));
      const weightsEntries = groupWeightsToFetch[i];
      weightsEntries.forEach((weightsEntry) => {
        const byteBuffer = weightsBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
        const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
        for (const name in nameToTensorMap) {
          weightsTensorMap[name] = nameToTensorMap[name];
        }
      });
      bufferIndexOffset += numBuffers;
    });
    return weightsTensorMap;
  };
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const OCTET_STREAM_MIME_TYPE = "application/octet-stream";
const JSON_TYPE = "application/json";
class HTTPRequest {
  constructor(path, loadOptions) {
    this.DEFAULT_METHOD = "POST";
    if (loadOptions == null) {
      loadOptions = {};
    }
    this.weightPathPrefix = loadOptions.weightPathPrefix;
    this.weightUrlConverter = loadOptions.weightUrlConverter;
    if (loadOptions.fetchFunc != null) {
      assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
      this.fetch = loadOptions.fetchFunc;
    } else {
      this.fetch = env().platform.fetch;
    }
    assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or empty.");
    if (Array.isArray(path)) {
      assert(path.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${path.length}).`);
    }
    this.path = path;
    if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    }
    this.requestInit = loadOptions.requestInit || {};
    this.loadOptions = loadOptions;
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    }
    const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    init.body = new FormData();
    const weightsManifest = [{
      paths: ["./model.weights.bin"],
      weights: modelArtifacts.weightSpecs
    }];
    const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
    init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
    if (modelArtifacts.weightData != null) {
      const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
      init.body.append("model.weights.bin", new Blob([weightBuffer], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
    }
    const response = await this.fetch(this.path, init);
    if (response.ok) {
      return {
        modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
        responses: [response]
      };
    } else {
      throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${response.status}.`);
    }
  }
  async loadModelJSON() {
    const modelConfigRequest = await this.fetch(this.path, this.requestInit);
    if (!modelConfigRequest.ok) {
      throw new Error(`Request to ${this.path} failed with status code ${modelConfigRequest.status}. Please verify this URL points to the model JSON of the model to load.`);
    }
    let modelJSON;
    try {
      modelJSON = await modelConfigRequest.json();
    } catch (e) {
      let message = `Failed to parse model JSON of response from ${this.path}.`;
      if (this.path.endsWith(".pb")) {
        message += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.";
      } else {
        message += " Please make sure the server is serving valid JSON for this request.";
      }
      throw new Error(message);
    }
    const modelTopology = modelJSON.modelTopology;
    const weightsManifest = modelJSON.weightsManifest;
    if (modelTopology == null && weightsManifest == null) {
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
    }
    return modelJSON;
  }
  /**
   * Load model artifacts via HTTP request(s).
   *
   * See the documentation to `tf.io.http` for details on the saved
   * artifacts.
   *
   * @returns The loaded model artifacts (if loading succeeds).
   */
  async load() {
    if (this.loadOptions.streamWeights) {
      return this.loadStream();
    }
    const modelJSON = await this.loadModelJSON();
    return getModelArtifactsForJSON(modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));
  }
  async loadStream() {
    const modelJSON = await this.loadModelJSON();
    const fetchURLs = await this.getWeightUrls(modelJSON.weightsManifest);
    const weightSpecs = getWeightSpecs(modelJSON.weightsManifest);
    const stream = () => streamWeights(fetchURLs, this.loadOptions);
    return Object.assign(Object.assign({}, modelJSON), { weightSpecs, getWeightStream: stream });
  }
  async getWeightUrls(weightsManifest) {
    const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
    const [prefix2, suffix] = parseUrl(weightPath);
    const pathPrefix = this.weightPathPrefix || prefix2;
    const fetchURLs = [];
    const urlPromises = [];
    for (const weightsGroup of weightsManifest) {
      for (const path of weightsGroup.paths) {
        if (this.weightUrlConverter != null) {
          urlPromises.push(this.weightUrlConverter(path));
        } else {
          fetchURLs.push(pathPrefix + path + suffix);
        }
      }
    }
    if (this.weightUrlConverter) {
      fetchURLs.push(...await Promise.all(urlPromises));
    }
    return fetchURLs;
  }
  async loadWeights(weightsManifest) {
    const fetchURLs = await this.getWeightUrls(weightsManifest);
    const weightSpecs = getWeightSpecs(weightsManifest);
    const buffers = await loadWeightsAsArrayBuffer(fetchURLs, this.loadOptions);
    return [weightSpecs, buffers];
  }
}
HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
function parseUrl(url) {
  const lastSlash = url.lastIndexOf("/");
  const lastSearchParam = url.lastIndexOf("?");
  const prefix2 = url.substring(0, lastSlash);
  const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
  return [prefix2 + "/", suffix];
}
function isHTTPScheme(url) {
  return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
}
const httpRouter = (url, loadOptions) => {
  if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
    return null;
  } else {
    let isHTTP = true;
    if (Array.isArray(url)) {
      isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
    } else {
      isHTTP = isHTTPScheme(url);
    }
    if (isHTTP) {
      return http(url, loadOptions);
    }
  }
  return null;
};
IORouterRegistry.registerSaveRouter(httpRouter);
IORouterRegistry.registerLoadRouter(httpRouter);
function http(path, loadOptions) {
  return new HTTPRequest(path, loadOptions);
}
function browserHTTPRequest(path, loadOptions) {
  return http(path, loadOptions);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class PassthroughLoader {
  constructor(modelArtifacts) {
    this.modelArtifacts = modelArtifacts;
  }
  load() {
    return this.modelArtifacts;
  }
}
class PassthroughSaver {
  constructor(saveHandler) {
    this.saveHandler = saveHandler;
  }
  save(modelArtifacts) {
    return this.saveHandler(modelArtifacts);
  }
}
class PassthroughAsync {
  constructor(handler) {
    if (handler.load) {
      this.load = () => Promise.resolve(handler.load());
    }
    if (handler.save) {
      this.save = (modelArtifacts) => Promise.resolve(handler.save(modelArtifacts));
    }
  }
}
function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
  const args = arguments;
  return new PassthroughAsync(fromMemorySync(...args));
}
function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {
  if (arguments.length === 1) {
    const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
    if (isModelArtifacts) {
      return new PassthroughLoader(modelArtifacts);
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
      return new PassthroughLoader({ modelTopology: modelArtifacts });
    }
  } else {
    console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");
    return new PassthroughLoader({
      modelTopology: modelArtifacts,
      weightSpecs,
      weightData,
      trainingConfig
    });
  }
}
function withSaveHandler(saveHandler) {
  return new PassthroughSaver(saveHandler);
}
function withSaveHandlerSync(saveHandler) {
  return new PassthroughSaver(saveHandler);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const io = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeArrayBuffer,
  browserFiles,
  browserHTTPRequest,
  concatenateArrayBuffers,
  copyModel,
  decodeWeights,
  decodeWeightsStream,
  encodeWeights,
  fromMemory,
  fromMemorySync,
  getLoadHandlers,
  getModelArtifactsForJSON,
  getModelArtifactsForJSONSync,
  getModelArtifactsInfoForJSON,
  getSaveHandlers,
  getWeightSpecs,
  http,
  isHTTPScheme,
  listModels,
  loadWeights,
  moveModel,
  registerLoadRouter,
  registerSaveRouter,
  removeModel,
  weightsLoaderFactory,
  withSaveHandler,
  withSaveHandlerSync
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function confusionMatrix_(labels, predictions, numClasses) {
  const $labels = convertToTensor(labels, "labels", "confusionMatrix");
  const $predictions = convertToTensor(predictions, "predictions", "confusionMatrix");
  assert(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), () => `If provided, numClasses must be a positive integer, but got ${numClasses}`);
  assert($labels.rank === 1, () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);
  assert($predictions.rank === 1, () => `Expected the rank of predictions to be 1, but got ${$predictions.rank}`);
  assert($labels.shape[0] === $predictions.shape[0], () => `Mismatch in the number of examples: ${$labels.shape[0]} vs. ${$predictions.shape[0]}. Labels and predictions should have the same number of elements.`);
  assert(numClasses > 0 && Number.isInteger(numClasses), () => `numClasses is required to be a positive integer, but got ${numClasses}`);
  const oneHotLabels = oneHot(cast($labels, "int32"), numClasses);
  const oneHotPredictions = oneHot(cast($predictions, "int32"), numClasses);
  const oneHotLabelsT = transpose(oneHotLabels);
  const product = matMul$1(oneHotLabelsT, oneHotPredictions);
  return cast(product, "int32");
}
const confusionMatrix = /* @__PURE__ */ op({ confusionMatrix_ });
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const math = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  confusionMatrix
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
let fromPixels2DContext;
let hasToPixelsWarned = false;
function fromPixels_(pixels, numChannels = 3) {
  if (numChannels > 4) {
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  }
  if (pixels == null) {
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  }
  let isPixelData2 = false;
  let isImageData = false;
  let isVideo = false;
  let isImage = false;
  let isCanvasLike = false;
  let isImageBitmap = false;
  if (pixels.data instanceof Uint8Array) {
    isPixelData2 = true;
  } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
    isImageData = true;
  } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
    isVideo = true;
  } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
    isImage = true;
  } else if (pixels.getContext != null) {
    isCanvasLike = true;
  } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
    isImageBitmap = true;
  } else {
    throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${pixels.constructor.name}`);
  }
  const kernel = getKernel(FromPixels, ENGINE.backendName);
  if (kernel != null) {
    const inputs = { pixels };
    const attrs = { numChannels };
    return ENGINE.runKernel(FromPixels, inputs, attrs);
  }
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  let vals;
  if (isCanvasLike) {
    vals = // tslint:disable-next-line:no-any
    pixels.getContext("2d").getImageData(0, 0, width, height).data;
  } else if (isImageData || isPixelData2) {
    vals = pixels.data;
  } else if (isImage || isVideo || isImageBitmap) {
    if (fromPixels2DContext == null) {
      if (typeof document === "undefined") {
        if (typeof OffscreenCanvas !== "undefined" && typeof OffscreenCanvasRenderingContext2D !== "undefined") {
          fromPixels2DContext = new OffscreenCanvas(1, 1).getContext("2d");
        } else {
          throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
        }
      } else {
        fromPixels2DContext = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
      }
    }
    fromPixels2DContext.canvas.width = width;
    fromPixels2DContext.canvas.height = height;
    fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
    vals = fromPixels2DContext.getImageData(0, 0, width, height).data;
  }
  let values;
  if (numChannels === 4) {
    values = new Int32Array(vals);
  } else {
    const numPixels = width * height;
    values = new Int32Array(numPixels * numChannels);
    for (let i = 0; i < numPixels; i++) {
      for (let channel = 0; channel < numChannels; ++channel) {
        values[i * numChannels + channel] = vals[i * 4 + channel];
      }
    }
  }
  const outShape = [height, width, numChannels];
  return tensor3d(values, outShape, "int32");
}
function isPixelData(pixels) {
  return pixels != null && pixels.data instanceof Uint8Array;
}
function isImageBitmapFullySupported() {
  return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
}
function isNonEmptyPixels(pixels) {
  return pixels != null && pixels.width !== 0 && pixels.height !== 0;
}
function canWrapPixelsToImageBitmap(pixels) {
  return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
}
async function fromPixelsAsync(pixels, numChannels = 3) {
  let inputs = null;
  if (env().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)) {
    let imageBitmap;
    try {
      imageBitmap = await createImageBitmap(pixels, { premultiplyAlpha: "none" });
    } catch (e) {
      imageBitmap = null;
    }
    if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
      inputs = imageBitmap;
    } else {
      inputs = pixels;
    }
  } else {
    inputs = pixels;
  }
  return fromPixels_(inputs, numChannels);
}
function validateImgTensor(img) {
  if (img.rank !== 2 && img.rank !== 3) {
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${img.rank}.`);
  }
  const depth = img.rank === 2 ? 1 : img.shape[2];
  if (depth > 4 || depth === 2) {
    throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${depth}`);
  }
  if (img.dtype !== "float32" && img.dtype !== "int32") {
    throw new Error(`Unsupported type for toPixels: ${img.dtype}. Please use float32 or int32 tensors.`);
  }
}
function validateImageOptions(imageOptions) {
  const alpha2 = (imageOptions === null || imageOptions === void 0 ? void 0 : imageOptions.alpha) || 1;
  if (alpha2 > 1 || alpha2 < 0) {
    throw new Error(`Alpha value ${alpha2} is suppoed to be in range [0 - 1].`);
  }
}
async function toPixels(img, canvas) {
  let $img = convertToTensor(img, "img", "toPixels");
  if (!(img instanceof Tensor)) {
    const originalImgTensor = $img;
    $img = cast(originalImgTensor, "int32");
    originalImgTensor.dispose();
  }
  validateImgTensor($img);
  const [height, width] = $img.shape.slice(0, 2);
  const depth = $img.rank === 2 ? 1 : $img.shape[2];
  const data = await $img.data();
  const multiplier = $img.dtype === "float32" ? 255 : 1;
  const bytes = new Uint8ClampedArray(width * height * 4);
  for (let i = 0; i < height * width; ++i) {
    const rgba2 = [0, 0, 0, 255];
    for (let d = 0; d < depth; d++) {
      const value = data[i * depth + d];
      if ($img.dtype === "float32") {
        if (value < 0 || value > 1) {
          throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${value}.`);
        }
      } else if ($img.dtype === "int32") {
        if (value < 0 || value > 255) {
          throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${value}.`);
        }
      }
      if (depth === 1) {
        rgba2[0] = value * multiplier;
        rgba2[1] = value * multiplier;
        rgba2[2] = value * multiplier;
      } else {
        rgba2[d] = value * multiplier;
      }
    }
    const j = i * 4;
    bytes[j + 0] = Math.round(rgba2[0]);
    bytes[j + 1] = Math.round(rgba2[1]);
    bytes[j + 2] = Math.round(rgba2[2]);
    bytes[j + 3] = Math.round(rgba2[3]);
  }
  if (canvas != null) {
    if (!hasToPixelsWarned) {
      const kernel = getKernel(Draw, ENGINE.backendName);
      if (kernel != null) {
        console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead.");
        hasToPixelsWarned = true;
      }
    }
    canvas.width = width;
    canvas.height = height;
    const ctx2 = canvas.getContext("2d");
    const imageData = new ImageData(bytes, width, height);
    ctx2.putImageData(imageData, 0, 0);
  }
  if ($img !== img) {
    $img.dispose();
  }
  return bytes;
}
function draw(image2, canvas, options) {
  let $img = convertToTensor(image2, "img", "draw");
  if (!(image2 instanceof Tensor)) {
    const originalImgTensor = $img;
    $img = cast(originalImgTensor, "int32");
    originalImgTensor.dispose();
  }
  validateImgTensor($img);
  validateImageOptions(options === null || options === void 0 ? void 0 : options.imageOptions);
  const inputs = { image: $img };
  const attrs = { canvas, options };
  ENGINE.runKernel(Draw, inputs, attrs);
}
const fromPixels = /* @__PURE__ */ op({ fromPixels_ });
const browser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  draw,
  fromPixels,
  fromPixelsAsync,
  toPixels
}, Symbol.toStringTag, { value: "Module" }));
function prepareAndValidate(tensor2, indices) {
  const tensorRank = tensor2.shape.length;
  const indicesRank = indices.shape.length;
  if (tensorRank < 1) {
    throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${tensorRank}.`);
  }
  if (indicesRank < 1) {
    throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${indicesRank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${indices.dtype}.`);
  }
  if (indices.shape[indicesRank - 1] > tensorRank) {
    throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
  }
  if (sizeFromShape(tensor2.shape) === 0) {
    throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${tensor2.shape}.`);
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  let nResult = 1;
  for (let i = 0; i < indicesShape.length - 1; ++i) {
    nResult *= indicesShape[i];
  }
  const inputShape = tensor2.shape;
  const resultShape = indicesShape.slice();
  resultShape.pop();
  let sliceSize = 1;
  for (let i = sliceRank; i < tensorRank; ++i) {
    sliceSize *= inputShape[i];
    resultShape.push(inputShape[i]);
  }
  const strides = [
    ...computeStrides(tensor2.shape).map((stride) => stride / sliceSize),
    1
  ].slice(0, sliceRank);
  return [resultShape, nResult, sliceSize, strides];
}
const gather_nd_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  prepareAndValidate
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const NEW_AXIS = -2;
const SHRINK_AXIS = -1;
function assertParamsValid(input, begin, size) {
  const inputRank = input.shape.length;
  assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must match the rank of the array (${inputRank}).`);
  assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must match the rank of the array (${inputRank}).`);
  for (let i = 0; i < inputRank; ++i) {
    assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] (${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
  }
}
function maskToAxes(mask) {
  const axes = [];
  let axis = 0;
  while (mask > 0) {
    if (mask & 1) {
      axes.push(axis);
    }
    mask /= 2;
    axis++;
  }
  return axes;
}
function computeOutShape$2(begin, end, strides) {
  const size = [];
  for (let axis = 0; axis < begin.length; axis++) {
    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
  }
  return size;
}
function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
  const newStrides = [...strides];
  for (let i = newStrides.length; i < inputShape.length; i++) {
    newStrides.push(1);
  }
  for (let i = 0; i < numElidedAxes; i++) {
    if (i === 0) {
      newStrides[ellipsisInsertionIndex] = 1;
    } else {
      newStrides.splice(
        ellipsisInsertionIndex,
        0,
        1
        /* element to add */
      );
      newStrides.pop();
    }
  }
  return newStrides;
}
function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
  if (normalizedAxis <= ellipsisInsertionIndex) {
    return normalizedAxis;
  }
  return normalizedAxis - (numElidedAxes - 1);
}
function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
  const elidedAxes = [];
  for (let i = 0; i < numElidedAxes; i++) {
    elidedAxes.push(ellipsisInsertionIndex + i);
  }
  return elidedAxes;
}
function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
  const inputRank = inputShape.length;
  let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
  if (ellipsisAxes.length && numInterpolatedAxes > 0) {
    const fullIndex = ellipsisAxes[0];
    const numElidedAxes = numInterpolatedAxes + 1;
    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
  } else {
    for (let axis = 0; axis < inputRank; axis++) {
      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
    }
  }
  return {
    begin: normalizedBegin,
    end: normalizedEnd,
    strides: normalizedStrides
  };
}
function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = 0;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalBegin[originalAxis];
      if (beginMask & 1 << originalAxis) {
        originalValue = 0;
      }
      newIndices[axis] = originalValue;
    }
  }
  return newIndices;
}
function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0; axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = Number.MAX_SAFE_INTEGER;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalEnd[originalAxis];
      if (endMask & 1 << originalAxis) {
        originalValue = Number.MAX_SAFE_INTEGER;
      }
      newIndices[axis] = originalValue;
    }
  }
  for (let i = 0; i < newIndices.length; i++) {
    const axisSize = inputShape[i];
    if (newIndices[i] < 0) {
      newIndices[i] += axisSize;
    }
    newIndices[i] = clamp$2(0, newIndices[i], inputShape[i]);
  }
  return newIndices;
}
function stridesForAxis(strides, axis, ellipsisMask) {
  let stride = strides[axis];
  if (ellipsisMask & 1 << axis || stride == null) {
    stride = 1;
  }
  return stride;
}
function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
  let start2 = startIndices[axis];
  const stride = strides[axis] || 1;
  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start2 == null) {
    if (stride > 0) {
      start2 = Number.MIN_SAFE_INTEGER;
    } else {
      start2 = Number.MAX_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (start2 < 0) {
    start2 += axisSize;
  }
  start2 = clamp$2(0, start2, axisSize - 1);
  return start2;
}
function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
  let stop2 = stopIndices[axis];
  const stride = strides[axis] || 1;
  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop2 == null) {
    if (stride > 0) {
      stop2 = Number.MAX_SAFE_INTEGER;
    } else {
      stop2 = Number.MIN_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (stop2 < 0) {
    stop2 += axisSize;
  }
  if (stride > 0) {
    stop2 = clamp$2(0, stop2, axisSize);
  } else {
    stop2 = clamp$2(-1, stop2, axisSize - 1);
  }
  return stop2;
}
function isSliceContinous(shape, begin, size) {
  let firstNonOneAxis = size.length;
  for (let i = 0; i < size.length; i++) {
    if (size[i] > 1) {
      firstNonOneAxis = i;
      break;
    }
  }
  for (let i = firstNonOneAxis + 1; i < size.length; i++) {
    if (begin[i] > 0 || size[i] !== shape[i]) {
      return false;
    }
  }
  return true;
}
function computeFlatOffset(begin, strides) {
  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
  for (let i = 0; i < begin.length - 1; i++) {
    flatOffset += begin[i] * strides[i];
  }
  return flatOffset;
}
function parseSliceParams(x, begin, size) {
  let begin_;
  const xRank = x.shape.length;
  if (typeof begin === "number") {
    begin_ = [begin, ...new Array(xRank - 1).fill(0)];
  } else if (begin.length < xRank) {
    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
  } else {
    begin_ = begin.slice();
  }
  begin_.forEach((d) => {
    assert(d !== -1, () => "slice() does not support negative begin indexing.");
  });
  let size_;
  if (size == null) {
    size_ = new Array(xRank).fill(-1);
  } else if (typeof size === "number") {
    size_ = [size, ...new Array(xRank - 1).fill(-1)];
  } else if (size.length < xRank) {
    size_ = size.concat(new Array(xRank - size.length).fill(-1));
  } else {
    size_ = size;
  }
  size_ = size_.map((d, i) => {
    if (d >= 0) {
      return d;
    } else {
      assert(d === -1, () => `Negative size values should be exactly -1 but got ${d} for the slice() size at index ${i}.`);
      return x.shape[i] - begin_[i];
    }
  });
  return [begin_, size_];
}
function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
  let stridesNonNull;
  if (strides == null) {
    stridesNonNull = new Array(begin.length);
    stridesNonNull.fill(1);
  } else {
    stridesNonNull = strides;
  }
  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {
    throw new Error("Multiple ellipses in slice is not allowed.");
  }
  let ellipsisSeen = false;
  const sparseSpec = {
    dims: stridesNonNull.length,
    numAddAxisAfterEllipsis: 0,
    begin: begin.slice(),
    end: end.slice(),
    strides: stridesNonNull.slice(),
    beginMask,
    endMask,
    ellipsisMask,
    newAxisMask,
    shrinkAxisMask
  };
  for (let i = 0; i < sparseSpec.dims; i++) {
    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {
      sparseSpec.numAddAxisAfterEllipsis++;
    }
    if (1 << i & ellipsisMask) {
      ellipsisSeen = true;
    }
  }
  if (!ellipsisSeen) {
    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
    sparseSpec.dims++;
  }
  const denseSpec = {
    dims: xShape.length,
    beginMask: 0,
    endMask: 0,
    beginValid: false,
    endValid: false
  };
  buildDenseSpec(sparseSpec, denseSpec);
  let isIdentity = true;
  let sliceDim0 = true;
  let isSimpleSlice = true;
  const processingShape = [];
  const finalShape = [];
  for (let i = 0; i < xShape.length; ++i) {
    if (denseSpec.strides[i] === 0) {
      throw Error(`strides[${i}] must be non-zero`);
    }
    const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);
    const dimI = xShape[i];
    if (dimI === -1) {
      processingShape.push(shrinkI ? 1 : -1);
      continue;
    }
    const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];
    const validRange = [
      denseSpec.strides[i] > 0 ? 0 : -1,
      denseSpec.strides[i] > 0 ? dimI : dimI - 1
    ];
    if (shrinkI && denseSpec.strides[i] <= 0) {
      throw Error("only stride 1 allowed on non-range indexing.");
    }
    isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;
    const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);
    if (denseSpec.beginValid && denseSpec.endValid) {
      if (shrinkI) {
        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];
        denseSpec.begin[i] = xFwd;
        denseSpec.end[i] = denseSpec.begin[i] + 1;
        if (xFwd < 0 || xFwd >= dimI) {
          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);
        }
      } else {
        denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);
        denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);
      }
      const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;
      isIdentity = isIdentity && takeAllInDimension;
      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);
    } else {
      isIdentity = isIdentity && (denseSpec.strides[i] === 1 && beginAndEndMasked);
      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);
    }
    let intervalLength;
    let knownInterval = false;
    if (denseSpec.beginValid && denseSpec.endValid) {
      intervalLength = denseSpec.end[i] - denseSpec.begin[i];
      knownInterval = true;
    } else if (shrinkI) {
      intervalLength = 1;
      knownInterval = true;
    } else if (beginAndEndMasked) {
      if (dimI >= 0) {
        if (denseSpec.strides[i] < 0) {
          intervalLength = -dimI;
        } else {
          intervalLength = dimI;
        }
        knownInterval = true;
      }
    }
    if (knownInterval) {
      let sizeI;
      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {
        sizeI = 0;
      } else {
        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);
      }
      processingShape.push(sizeI);
    } else {
      processingShape.push(-1);
    }
  }
  for (let denseDim = 0; denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {
    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
    if (gatherIndex >= 0) {
      finalShape.push(processingShape[gatherIndex]);
    } else if (gatherIndex === NEW_AXIS) {
      finalShape.push(1);
    }
  }
  const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);
  return {
    finalShapeSparse,
    finalShape,
    isIdentity,
    sliceDim0,
    isSimpleSlice,
    begin: denseSpec.begin,
    end: denseSpec.end,
    strides: denseSpec.strides
  };
}
function buildDenseSpec(sparse2, dense) {
  dense.beginMask = 0;
  dense.endMask = 0;
  dense.shrinkAxisMask = 0;
  let fullIndex = 0;
  dense.beginValid = sparse2.begin != null;
  dense.endValid = sparse2.end != null;
  dense.begin = new Array(dense.dims);
  dense.end = new Array(dense.dims);
  dense.strides = new Array(dense.dims);
  dense.finalShapeGatherIndices = [];
  dense.finalShapeGatherIndicesSparse = [];
  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);
  for (let i = 0; i < sparse2.dims; i++) {
    if (1 << i & sparse2.ellipsisMask) {
      const nextIndex = Math.min(dense.dims - (sparse2.dims - i) + 1 + sparse2.numAddAxisAfterEllipsis, dense.dims);
      for (; fullIndex < nextIndex; fullIndex++) {
        dense.begin[fullIndex] = 0;
        dense.end[fullIndex] = 0;
        dense.strides[fullIndex] = 1;
        dense.beginMask |= 1 << fullIndex;
        dense.endMask |= 1 << fullIndex;
        dense.finalShapeGatherIndices.push(fullIndex);
        dense.finalShapeGatherIndicesSparse.push(-1);
        dense.inputShapeGatherIndicesSparse[fullIndex] = i;
      }
    } else if (1 << i & sparse2.newAxisMask) {
      dense.finalShapeGatherIndices.push(NEW_AXIS);
      dense.finalShapeGatherIndicesSparse.push(-1);
    } else {
      if (fullIndex === dense.begin.length) {
        throw Error(`Index out of range using input dim ${fullIndex}; input has only ${dense.dims} dims, ${dense.begin.length}.`);
      }
      if (sparse2.begin != null) {
        dense.begin[fullIndex] = sparse2.begin[i];
      }
      if (sparse2.end != null) {
        dense.end[fullIndex] = sparse2.end[i];
      }
      dense.strides[fullIndex] = sparse2.strides[i];
      if (sparse2.beginMask & 1 << i) {
        dense.beginMask |= 1 << fullIndex;
      }
      if (sparse2.endMask & 1 << i) {
        dense.endMask |= 1 << fullIndex;
      }
      if (sparse2.shrinkAxisMask & 1 << i) {
        dense.finalShapeGatherIndices.push(SHRINK_AXIS);
        dense.finalShapeGatherIndicesSparse.push(-1);
        dense.shrinkAxisMask |= 1 << fullIndex;
      } else {
        dense.finalShapeGatherIndices.push(fullIndex);
        dense.finalShapeGatherIndicesSparse.push(i);
      }
      dense.inputShapeGatherIndicesSparse[fullIndex] = i;
      fullIndex++;
    }
  }
}
function canonical(x, c, strideI, dimI, masks, validRange) {
  if (masks[c]) {
    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];
  } else {
    const xFwd = x < 0 ? dimI + x : x;
    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
  }
}
const slice_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assertParamsValid,
  computeFlatOffset,
  computeOutShape: computeOutShape$2,
  getNormalizedAxes,
  isSliceContinous,
  maskToAxes,
  parseSliceParams,
  sliceInfo,
  startForAxis,
  startIndicesWithElidedDims,
  stopForAxis,
  stopIndicesWithElidedDims,
  stridesForAxis,
  stridesWithElidedDims
}, Symbol.toStringTag, { value: "Module" }));
/** @license See the LICENSE file. */
const version = "4.22.0";
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OptimizerConstructors {
  /**
   * Constructs a `tf.SGDOptimizer` that uses stochastic gradient descent.
   *
   * ```js
   * // Fit a quadratic function by learning the coefficients a, b, c.
   * const xs = tf.tensor1d([0, 1, 2, 3]);
   * const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);
   *
   * const a = tf.scalar(Math.random()).variable();
   * const b = tf.scalar(Math.random()).variable();
   * const c = tf.scalar(Math.random()).variable();
   *
   * // y = a * x^2 + b * x + c.
   * const f = x => a.mul(x.square()).add(b.mul(x)).add(c);
   * const loss = (pred, label) => pred.sub(label).square().mean();
   *
   * const learningRate = 0.01;
   * const optimizer = tf.train.sgd(learningRate);
   *
   * // Train the model.
   * for (let i = 0; i < 10; i++) {
   *   optimizer.minimize(() => loss(f(xs), ys));
   * }
   *
   * // Make predictions.
   * console.log(
   *     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);
   * const preds = f(xs).dataSync();
   * preds.forEach((pred, i) => {
   *   console.log(`x: ${i}, pred: ${pred}`);
   * });
   * ```
   *
   * @param learningRate The learning rate to use for the SGD algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static sgd(learningRate) {
    return new SGDOptimizer(learningRate);
  }
  /**
   * Constructs a `tf.MomentumOptimizer` that uses momentum gradient
   * descent.
   *
   * See
   * [http://proceedings.mlr.press/v28/sutskever13.pdf](
   * http://proceedings.mlr.press/v28/sutskever13.pdf)
   *
   * @param learningRate The learning rate to use for the Momentum gradient
   * descent algorithm.
   * @param momentum The momentum to use for the momentum gradient descent
   * algorithm.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static momentum(learningRate, momentum, useNesterov = false) {
    return new MomentumOptimizer(learningRate, momentum, useNesterov);
  }
  /**
   * Constructs a `tf.RMSPropOptimizer` that uses RMSProp gradient
   * descent. This implementation uses plain momentum and is not centered
   * version of RMSProp.
   *
   * See
   * [http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](
   * http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)
   *
   * @param learningRate The learning rate to use for the RMSProp gradient
   * descent algorithm.
   * @param decay The discounting factor for the history/coming gradient.
   * @param momentum The momentum to use for the RMSProp gradient descent
   * algorithm.
   * @param epsilon Small value to avoid zero denominator.
   * @param centered If true, gradients are normalized by the estimated
   * variance of the gradient.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
    return new RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
  }
  /**
   * Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adam gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adam(learningRate = 1e-3, beta1 = 0.9, beta2 = 0.999, epsilon = null) {
    return new AdamOptimizer(learningRate, beta1, beta2, epsilon);
  }
  /**
   * Constructs a `tf.AdadeltaOptimizer` that uses the Adadelta algorithm.
   * See [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)
   *
   * @param learningRate The learning rate to use for the Adadelta gradient
   * descent algorithm.
   * @param rho The learning rate decay over each update.
   * @param epsilon A constant epsilon used to better condition the grad
   * update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adadelta(learningRate = 1e-3, rho = 0.95, epsilon = null) {
    return new AdadeltaOptimizer(learningRate, rho, epsilon);
  }
  /**
   * Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.
   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)
   *
   * @param learningRate The learning rate to use for the Adamax gradient
   * descent algorithm.
   * @param beta1 The exponential decay rate for the 1st moment estimates.
   * @param beta2 The exponential decay rate for the 2nd moment estimates.
   * @param epsilon A small constant for numerical stability.
   * @param decay The learning rate decay over each update.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adamax(learningRate = 2e-3, beta1 = 0.9, beta2 = 0.999, epsilon = null, decay = 0) {
    return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
  }
  /**
   * Constructs a `tf.AdagradOptimizer` that uses the Adagrad algorithm.
   * See
   * [http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](
   * http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)
   * or
   * [http://ruder.io/optimizing-gradient-descent/index.html#adagrad](
   * http://ruder.io/optimizing-gradient-descent/index.html#adagrad)
   *
   * @param learningRate The learning rate to use for the Adagrad gradient
   * descent algorithm.
   * @param initialAccumulatorValue Starting value for the accumulators, must be
   * positive.
   *
   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}
   */
  static adagrad(learningRate, initialAccumulatorValue = 0.1) {
    return new AdagradOptimizer(learningRate, initialAccumulatorValue);
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const train = OptimizerConstructors;
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const delayCallback = (() => {
  if (typeof requestAnimationFrame !== "undefined") {
    return requestAnimationFrame;
  } else if (typeof setImmediate !== "undefined") {
    return setImmediate;
  }
  return (f) => f();
})();
function nextFrame() {
  return new Promise((resolve) => delayCallback(() => resolve()));
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function assertParamsConsistent(shapes, axis) {
  const rank = shapes[0].length;
  shapes.forEach((shape, i) => {
    assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same as the rank of the rest (${rank})`);
  });
  assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
  const firstShape = shapes[0];
  shapes.forEach((shape, i) => {
    for (let r = 0; r < rank; r++) {
      assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) does not match the shape of the rest (${firstShape}) along the non-concatenated axis ${i}.`);
    }
  });
}
function computeOutShape$1(shapes, axis) {
  const outputShape = shapes[0].slice();
  for (let i = 1; i < shapes.length; i++) {
    outputShape[axis] += shapes[i][axis];
  }
  return outputShape;
}
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var RowPartitionType;
(function(RowPartitionType2) {
  RowPartitionType2[RowPartitionType2["FIRST_DIM_SIZE"] = 0] = "FIRST_DIM_SIZE";
  RowPartitionType2[RowPartitionType2["VALUE_ROWIDS"] = 1] = "VALUE_ROWIDS";
  RowPartitionType2[RowPartitionType2["ROW_LENGTHS"] = 2] = "ROW_LENGTHS";
  RowPartitionType2[RowPartitionType2["ROW_SPLITS"] = 3] = "ROW_SPLITS";
  RowPartitionType2[RowPartitionType2["ROW_LIMITS"] = 4] = "ROW_LIMITS";
  RowPartitionType2[RowPartitionType2["ROW_STARTS"] = 5] = "ROW_STARTS";
})(RowPartitionType || (RowPartitionType = {}));
function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {
  let outputShape = new Array();
  if (valueShape == null && shape == null) {
    return outputShape;
  }
  if (shape == null) {
    while (outputShape.length < raggedRank + valueShape.length) {
      outputShape.push(-1);
    }
  } else {
    outputShape = shape.slice();
  }
  if (valueShape == null) {
    return outputShape;
  }
  if (raggedRank + valueShape.length !== outputShape.length) {
    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);
  }
  for (let i = 1; i < valueShape.length; ++i) {
    const valueDim = valueShape[i];
    const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];
    const outputShapeDim = outputShape[outputShapeDimIndex];
    if (valueDim >= 0) {
      if (outputShapeDim >= 0) {
        if (outputShapeDim !== valueDim) {
          throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);
        }
      } else {
        outputShape[outputShapeDimIndex] = valueDim;
      }
    }
  }
  return outputShape;
}
function getRowPartitionTypesHelper(rowPartitionTypeStrings) {
  const stringToType = {
    "FIRST_DIM_SIZE": RowPartitionType.FIRST_DIM_SIZE,
    "VALUE_ROWIDS": RowPartitionType.VALUE_ROWIDS,
    "ROW_LENGTHS": RowPartitionType.ROW_LENGTHS,
    "ROW_SPLITS": RowPartitionType.ROW_SPLITS,
    "ROW_LIMITS": RowPartitionType.ROW_LIMITS,
    "ROW_STARTS": RowPartitionType.ROW_STARTS
  };
  const result = [];
  for (const typeStr of rowPartitionTypeStrings) {
    if (typeStr in stringToType) {
      result.push(stringToType[typeStr]);
    } else {
      break;
    }
  }
  return result;
}
function getRaggedRank(rowPartitionTypes) {
  if (rowPartitionTypes.length === 0) {
    return 0;
  }
  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {
    return rowPartitionTypes.length - 1;
  }
  return rowPartitionTypes.length;
}
function validateDefaultValueShape(defaultValueShape, valueShape) {
  if (defaultValueShape == null || valueShape == null) {
    return;
  }
  const defaultNDims = defaultValueShape.length;
  const valuesNDims = valueShape.length;
  if (defaultNDims >= valuesNDims) {
    throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);
  }
  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {
    const defaultDim = defaultValueShape[i];
    const valueDim = valueShape[i + 1];
    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {
      throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);
    }
  }
}
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
  if (inSize <= PARALLELIZE_THRESHOLD) {
    return inSize;
  }
  return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getImageCenter(center, imageHeight, imageWidth) {
  const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
  const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
  return [centerX, centerY];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getReshaped(inputShape, blockShape, prod2, batchToSpace = true) {
  let reshaped = [];
  if (batchToSpace) {
    reshaped = reshaped.concat(blockShape.slice(0));
    reshaped.push(inputShape[0] / prod2);
    reshaped = reshaped.concat(inputShape.slice(1));
  } else {
    reshaped = reshaped.concat(inputShape[0]);
    const spatialLength = blockShape.length;
    for (let i = 0; i < spatialLength; ++i) {
      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
    }
    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
  }
  return reshaped;
}
function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
  const permuted = [];
  if (batchToSpace) {
    permuted.push(blockShapeRank);
    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {
      if (i <= 2 * blockShapeRank) {
        permuted.push(i);
        permuted.push(i - (blockShapeRank + 1));
      } else {
        permuted.push(i);
      }
    }
  } else {
    const permutedBeforeBatch = [];
    const permutedAfterBatch = [];
    for (let i = 1; i < reshapedRank; ++i) {
      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
        permutedAfterBatch.push(i);
      } else {
        permutedBeforeBatch.push(i);
      }
    }
    permuted.push(...permutedBeforeBatch);
    permuted.push(0);
    permuted.push(...permutedAfterBatch);
  }
  return permuted;
}
function getReshapedPermuted(inputShape, blockShape, prod2, batchToSpace = true) {
  const reshapedPermuted = [];
  if (batchToSpace) {
    reshapedPermuted.push(inputShape[0] / prod2);
  } else {
    reshapedPermuted.push(inputShape[0] * prod2);
  }
  for (let i = 1; i < inputShape.length; ++i) {
    if (i <= blockShape.length) {
      if (batchToSpace) {
        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
      } else {
        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
      }
    } else {
      reshapedPermuted.push(inputShape[i]);
    }
  }
  return reshapedPermuted;
}
function getSliceBeginCoords(crops, blockShape) {
  const sliceBeginCoords = [0];
  for (let i = 0; i < blockShape; ++i) {
    sliceBeginCoords.push(crops[i][0]);
  }
  return sliceBeginCoords;
}
function getSliceSize(uncroppedShape, crops, blockShape) {
  const sliceSize = uncroppedShape.slice(0, 1);
  for (let i = 0; i < blockShape; ++i) {
    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
  }
  return sliceSize;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const SELU_SCALEALPHA = 1.7580993408473768;
const SELU_SCALE = 1.0507009873554805;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ERF_P = 0.3275911;
const ERF_A1 = 0.254829592;
const ERF_A2 = -0.284496736;
const ERF_A3 = 1.421413741;
const ERF_A4 = -1.453152027;
const ERF_A5 = 1.061405429;
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function mergeRealAndImagArrays(real2, imag2) {
  if (real2.length !== imag2.length) {
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:${real2.length}, imag: ${imag2.length}.`);
  }
  const result = new Float32Array(real2.length * 2);
  for (let i = 0; i < result.length; i += 2) {
    result[i] = real2[i / 2];
    result[i + 1] = imag2[i / 2];
  }
  return result;
}
function splitRealAndImagArrays(complex2) {
  const real2 = new Float32Array(complex2.length / 2);
  const imag2 = new Float32Array(complex2.length / 2);
  for (let i = 0; i < complex2.length; i += 2) {
    real2[i / 2] = complex2[i];
    imag2[i / 2] = complex2[i + 1];
  }
  return { real: real2, imag: imag2 };
}
function complexWithEvenIndex(complex2) {
  const len = Math.ceil(complex2.length / 4);
  const real2 = new Float32Array(len);
  const imag2 = new Float32Array(len);
  for (let i = 0; i < complex2.length; i += 4) {
    real2[Math.floor(i / 4)] = complex2[i];
    imag2[Math.floor(i / 4)] = complex2[i + 1];
  }
  return { real: real2, imag: imag2 };
}
function complexWithOddIndex(complex2) {
  const len = Math.floor(complex2.length / 4);
  const real2 = new Float32Array(len);
  const imag2 = new Float32Array(len);
  for (let i = 2; i < complex2.length; i += 4) {
    real2[Math.floor(i / 4)] = complex2[i];
    imag2[Math.floor(i / 4)] = complex2[i + 1];
  }
  return { real: real2, imag: imag2 };
}
function getComplexWithIndex(complex2, index) {
  const real2 = complex2[index * 2];
  const imag2 = complex2[index * 2 + 1];
  return { real: real2, imag: imag2 };
}
function assignToTypedArray(data, real2, imag2, index) {
  data[index * 2] = real2;
  data[index * 2 + 1] = imag2;
}
function exponents(n, inverse) {
  const real2 = new Float32Array(n / 2);
  const imag2 = new Float32Array(n / 2);
  for (let i = 0; i < Math.ceil(n / 2); i++) {
    const x = (inverse ? 2 : -2) * Math.PI * (i / n);
    real2[i] = Math.cos(x);
    imag2[i] = Math.sin(x);
  }
  return { real: real2, imag: imag2 };
}
function exponent(k, n, inverse) {
  const x = (inverse ? 2 : -2) * Math.PI * (k / n);
  const real2 = Math.cos(x);
  const imag2 = Math.sin(x);
  return { real: real2, imag: imag2 };
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ARROW = "->";
const ARROW_REGEX = /->/g;
const COMMA = ",";
const ELLIPSIS = "...";
function decodeEinsumEquation(equation, numTensors) {
  equation = equation.replace(/\s/g, "");
  const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
  if (numArrows < 1) {
    throw new Error("Equations without an arrow are not supported.");
  } else if (numArrows > 1) {
    throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
  }
  const [inputString, outputString] = equation.split(ARROW);
  assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
  const inputTerms = inputString.split(COMMA);
  const numInputs = inputTerms.length;
  if (numTensors !== numInputs) {
    throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
  }
  if (numInputs > 2) {
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  }
  const allDims = [];
  for (let i = 0; i < outputString.length; ++i) {
    const dimName = outputString[i];
    if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
      throw new Error(`Output subscripts contain the label ${dimName} not present in the input subscripts.`);
    }
    if (allDims.indexOf(dimName) === -1) {
      allDims.push(dimName);
    }
  }
  for (let i = 0; i < inputString.length; ++i) {
    const dimName = inputString[i];
    if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
      allDims.push(dimName);
    }
  }
  const idDims = new Array(inputTerms.length);
  for (let i = 0; i < numInputs; ++i) {
    if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
      throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. Support for duplicate axes in input is not implemented yet.`);
    }
    idDims[i] = [];
    for (let j = 0; j < inputTerms[i].length; ++j) {
      idDims[i].push(allDims.indexOf(inputTerms[i][j]));
    }
  }
  const numDims = allDims.length;
  const numOutDims = outputString.length;
  const summedDims = [];
  for (let i = numOutDims; i < numDims; ++i) {
    summedDims.push(i);
  }
  return { allDims, summedDims, idDims };
}
function getEinsumPermutation(nDims, idDims) {
  let permutationIndices = new Array(nDims);
  permutationIndices.fill(-1);
  for (let i = 0; i < idDims.length; ++i) {
    permutationIndices[idDims[i]] = i;
  }
  const expandDims2 = [];
  for (let i = 0; i < nDims; ++i) {
    if (permutationIndices[i] === -1) {
      expandDims2.push(i);
    }
  }
  permutationIndices = permutationIndices.filter((d) => d !== -1);
  return { permutationIndices, expandDims: expandDims2 };
}
function checkEinsumDimSizes(nDims, idDims, tensors) {
  const dimSizes = new Array(nDims);
  for (let i = 0; i < tensors.length; ++i) {
    const shape = tensors[i].shape;
    for (let j = 0; j < idDims[i].length; ++j) {
      if (dimSizes[idDims[i][j]] === void 0) {
        dimSizes[idDims[i][j]] = shape[j];
      } else {
        assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} of input shaped ${JSON.stringify(shape)}, but got dimension ${shape[j]}`);
      }
    }
  }
}
function getEinsumComputePath(summedDims, idDims) {
  const path = summedDims;
  const steps2 = [];
  let nSteps = 0;
  if (summedDims.length === 0) {
    path.push(-1);
  }
  nSteps = summedDims.length + 1;
  for (let i = 0; i < nSteps; ++i) {
    steps2.push([]);
  }
  const computedTermIndices = [];
  for (let i = 0; i < path.length; ++i) {
    const summedDim = path[i];
    const termIndices = findTermsWithDim(idDims, summedDim);
    for (const termIndex of termIndices) {
      if (computedTermIndices.indexOf(termIndex) === -1) {
        steps2[i].push(termIndex);
        computedTermIndices.push(termIndex);
      }
    }
  }
  return { path, steps: steps2 };
}
function isIdentityPermutation(perm) {
  return perm.every((dim, index) => dim === index);
}
function findTermsWithDim(idDims, dim) {
  const termIndices = [];
  for (let i = 0; i < idDims.length; ++i) {
    if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
      termIndices.push(i);
    }
  }
  return termIndices;
}
function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
  let splitSizes = [];
  if (typeof numOrSizeSplits === "number") {
    assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
    splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
  } else {
    const numOfNegs = numOrSizeSplits.reduce((count2, value) => {
      if (value === -1) {
        count2 += 1;
      }
      return count2;
    }, 0);
    assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
    const negIndex = numOrSizeSplits.indexOf(-1);
    if (negIndex !== -1) {
      const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
      numOrSizeSplits[negIndex] = x.shape[axis] - total;
    }
    assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
    splitSizes = numOrSizeSplits;
  }
  return splitSizes;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesLength) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${indicesLength}`;
}
function getSparseFillEmptyRowsNegativeIndexErrorMessage(index, value) {
  return `indices(${index}, 0) is invalid: ${value} < 0`;
}
function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(index, value, limit) {
  return `indices(${index}, 0) is invalid: ${value} >= ${limit}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(dim1, dim2) {
  return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;
}
function getSparseReshapeNegativeOutputDimErrorMessage(dim, value) {
  return `size ${dim} must be non-negative, not ${value}`;
}
function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape) {
  const inputSize = sizeFromShape(inputShape);
  const outputSize = sizeFromShape(outputShape);
  return `Input to reshape is a SparseTensor with ${inputSize}
  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;
}
function getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape) {
  const inputSize = sizeFromShape(inputShape);
  const outputSize = sizeFromShape(outputShape);
  return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;
}
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {
  return `segment ids must be >= 0`;
}
function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {
  return `segment ids are not increasing`;
}
function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(segmentId, outputRows) {
  return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;
}
function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(index, indexValue, inputRows) {
  return `Bad: indices[${index}] == ${indexValue} out of range [0, ${inputRows})`;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function segOpComputeOptimalWindowSize(inSize, numSegments) {
  let done = false;
  let res;
  if (inSize <= PARALLELIZE_THRESHOLD) {
    res = inSize;
    done = true;
  } else {
    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }
  while (!done) {
    if (res > numSegments || res === inSize) {
      done = true;
    } else {
      res = nearestDivisor(inSize, res + 1);
    }
  }
  return res;
}
function computeOutShape(aShape, axis, numSegments) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0; dim < rank; dim++) {
    if (dim !== axis) {
      outShape.push(aShape[dim]);
    } else {
      outShape.push(numSegments);
    }
  }
  return outShape;
}
function collectGatherOpShapeInfo(x, indices, axis, batchDims) {
  const indicesRank = indices.shape.length;
  const xRank = x.shape.length;
  if (batchDims !== 0) {
    if (batchDims < -indicesRank || batchDims > indicesRank) {
      throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
    }
  }
  if (batchDims < 0) {
    batchDims += indicesRank;
  }
  if (batchDims > xRank) {
    throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
  }
  if (axis < batchDims) {
    throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
  }
  for (let i = 0; i < batchDims; ++i) {
    if (x.shape[i] !== indices.shape[i]) {
      throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
    }
  }
  const dimSize = x.shape[axis];
  const outputShape = [];
  let batchSize = 1;
  let outerSize = 1;
  let sliceSize = 1;
  for (let i = 0; i < batchDims; ++i) {
    outputShape.push(x.shape[i]);
    batchSize *= x.shape[i];
  }
  for (let i = batchDims; i < axis; i++) {
    outputShape.push(x.shape[i]);
    outerSize *= x.shape[i];
  }
  for (let i = batchDims; i < indicesRank; i++) {
    outputShape.push(indices.shape[i]);
  }
  for (let i = axis + 1; i < xRank; i++) {
    outputShape.push(x.shape[i]);
    sliceSize *= x.shape[i];
  }
  return { batchSize, sliceSize, outerSize, dimSize, outputShape };
}
const segment_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  collectGatherOpShapeInfo,
  computeOutShape,
  segOpComputeOptimalWindowSize
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fromUint8ToStringArray(vals) {
  try {
    return vals.map((val) => decodeString(val));
  } catch (err) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
  }
}
function fromStringArrayToUint8(strings) {
  return strings.map((s) => encodeString(s));
}
const backend_util = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERF_A1,
  ERF_A2,
  ERF_A3,
  ERF_A4,
  ERF_A5,
  ERF_P,
  PARALLELIZE_THRESHOLD,
  get RowPartitionType() {
    return RowPartitionType;
  },
  SELU_SCALE,
  SELU_SCALEALPHA,
  applyActivation,
  assertAndGetBroadcastShape,
  assertAxesAreInnerMostDims,
  assertParamsConsistent,
  assignToTypedArray,
  axesAreInnerMostDims,
  calculateShapes,
  checkEinsumDimSizes,
  checkPadOnDimRoundingMode,
  combineLocations,
  combineRaggedTensorToTensorShapes,
  complexWithEvenIndex,
  complexWithOddIndex,
  computeConv2DInfo,
  computeConv3DInfo,
  computeDefaultPad,
  computeDilation2DInfo,
  computeOptimalWindowSize,
  computeOutAndReduceShapes,
  computeOutShape: computeOutShape$1,
  computePool2DInfo,
  computePool3DInfo,
  convertConv2DDataFormat,
  decodeEinsumEquation,
  eitherStridesOrDilationsAreOne,
  expandShapeToKeepDim,
  exponent,
  exponents,
  fromStringArrayToUint8,
  fromUint8ToStringArray,
  getAxesPermutation,
  getBroadcastDims,
  getComplexWithIndex,
  getEinsumComputePath,
  getEinsumPermutation,
  getFusedBiasGradient,
  getFusedDyActivation,
  getImageCenter,
  getInnerMostAxes,
  getPermuted,
  getRaggedRank,
  getReductionAxes,
  getReshaped,
  getReshapedPermuted,
  getRowPartitionTypesHelper,
  getSliceBeginCoords,
  getSliceSize,
  getSparseFillEmptyRowsIndicesDenseShapeMismatch,
  getSparseFillEmptyRowsNegativeIndexErrorMessage,
  getSparseFillEmptyRowsOutOfRangeIndexErrorMessage,
  getSparseReshapeEmptyTensorZeroOutputDimErrorMessage,
  getSparseReshapeInputOutputMismatchErrorMessage,
  getSparseReshapeInputOutputMultipleErrorMessage,
  getSparseReshapeMultipleNegativeOneOutputDimErrorMessage,
  getSparseReshapeNegativeOutputDimErrorMessage,
  getSparseSegmentReductionIndicesOutOfRangeErrorMessage,
  getSparseSegmentReductionNegativeSegmentIdsErrorMessage,
  getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage,
  getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage,
  getUndoAxesPermutation,
  isIdentityPermutation,
  log: log$1,
  mergeRealAndImagArrays,
  prepareAndValidate,
  prepareSplitSize,
  segment_util,
  shouldFuse,
  slice_util,
  splitRealAndImagArrays,
  stridesOrDilationsArePositive,
  tupleValuesAreOne,
  upcastType,
  validateDefaultValueShape,
  validateInput: validateInput$1,
  validateUpdateShape,
  warn
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const kernel_impls = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nonMaxSuppressionV3Impl,
  nonMaxSuppressionV4Impl,
  nonMaxSuppressionV5Impl,
  whereImpl
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
registerOptimizers();
const tf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs,
  Acos,
  Acosh,
  AdadeltaOptimizer,
  AdagradOptimizer,
  AdamOptimizer,
  AdamaxOptimizer,
  Add,
  AddN,
  All,
  Any,
  ArgMax,
  ArgMin,
  Asin,
  Asinh,
  Atan,
  Atan2,
  Atanh,
  AvgPool,
  AvgPool3D,
  AvgPool3DGrad,
  AvgPoolGrad,
  BatchMatMul,
  BatchToSpaceND,
  Bincount,
  BitwiseAnd,
  BroadcastArgs,
  BroadcastTo,
  Cast,
  Ceil,
  ClipByValue,
  Complex,
  ComplexAbs,
  Concat,
  Conv2D,
  Conv2DBackpropFilter,
  Conv2DBackpropInput,
  Conv3D,
  Conv3DBackpropFilterV2,
  Conv3DBackpropInputV2,
  Cos,
  Cosh,
  CropAndResize,
  Cumprod,
  Cumsum,
  DataStorage,
  DenseBincount,
  DepthToSpace,
  DepthwiseConv2dNative,
  DepthwiseConv2dNativeBackpropFilter,
  DepthwiseConv2dNativeBackpropInput,
  Diag,
  Dilation2D,
  Dilation2DBackpropFilter,
  Dilation2DBackpropInput,
  Draw,
  get ENV() {
    return ENV$2;
  },
  Einsum,
  Elu,
  EluGrad,
  Environment,
  Equal,
  Erf,
  Exp,
  ExpandDims,
  Expm1,
  FFT,
  Fill,
  FlipLeftRight,
  Floor,
  FloorDiv,
  FromPixels,
  FusedBatchNorm,
  FusedConv2D,
  FusedDepthwiseConv2D,
  GatherNd,
  GatherV2,
  Greater,
  GreaterEqual,
  IFFT,
  Identity,
  Imag,
  IsFinite,
  IsInf,
  IsNan,
  KernelBackend,
  LRN,
  LRNGrad,
  LeakyRelu,
  Less,
  LessEqual,
  LinSpace,
  Log,
  Log1p,
  LogSoftmax,
  LogicalAnd,
  LogicalNot,
  LogicalOr,
  LogicalXor,
  LowerBound,
  MatrixBandPart,
  Max,
  MaxPool,
  MaxPool3D,
  MaxPool3DGrad,
  MaxPoolGrad,
  MaxPoolWithArgmax,
  Maximum,
  Mean,
  Min,
  Minimum,
  MirrorPad,
  Mod,
  MomentumOptimizer,
  Multinomial,
  Multiply,
  Neg,
  NonMaxSuppressionV3,
  NonMaxSuppressionV4,
  NonMaxSuppressionV5,
  NotEqual,
  OP_SCOPE_SUFFIX,
  OneHot,
  OnesLike,
  Optimizer,
  OptimizerConstructors,
  Pack,
  PadV2,
  Pool,
  Pow,
  Prelu,
  Prod,
  RMSPropOptimizer,
  RaggedGather,
  RaggedRange,
  RaggedTensorToTensor,
  Range,
  get Rank() {
    return Rank;
  },
  Real,
  RealDiv,
  Reciprocal,
  get Reduction() {
    return Reduction;
  },
  Relu,
  Relu6,
  Reshape,
  ResizeBilinear,
  ResizeBilinearGrad,
  ResizeNearestNeighbor,
  ResizeNearestNeighborGrad,
  Reverse,
  RotateWithOffset,
  Round,
  Rsqrt,
  SGDOptimizer,
  ScatterNd,
  SearchSorted,
  Select,
  Selu,
  Sigmoid,
  Sign,
  Sin,
  Sinh,
  Slice,
  Softmax,
  Softplus,
  SpaceToBatchND,
  SparseFillEmptyRows,
  SparseReshape,
  SparseSegmentMean,
  SparseSegmentSum,
  SparseToDense,
  SplitV,
  Sqrt,
  Square,
  SquaredDifference,
  StaticRegexReplace,
  Step,
  StridedSlice,
  StringNGrams,
  StringSplit,
  StringToHashBucketFast,
  Sub,
  Sum,
  Tan,
  Tanh,
  Tensor,
  TensorBuffer,
  TensorScatterUpdate,
  Tile,
  TopK,
  Transform,
  Transpose,
  Unique,
  Unpack,
  UnsortedSegmentSum,
  UpperBound,
  Variable,
  ZerosLike,
  _FusedMatMul,
  abs,
  acos,
  acosh,
  add,
  addN,
  all,
  any,
  argMax,
  argMin,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  avgPool,
  avgPool3d,
  backend,
  backend_util,
  basicLSTMCell,
  batchNorm,
  batchNorm2d,
  batchNorm3d,
  batchNorm4d,
  batchToSpaceND,
  bincount,
  bitwiseAnd,
  booleanMaskAsync,
  broadcastArgs,
  broadcastTo,
  broadcast_util,
  browser,
  buffer,
  cast,
  ceil,
  clipByValue,
  clone,
  complex,
  concat,
  concat1d,
  concat2d,
  concat3d,
  concat4d,
  conv1d,
  conv2d: conv2d$1,
  conv2dTranspose,
  conv3d,
  conv3dTranspose,
  copyRegisteredKernels,
  cos,
  cosh,
  cosineWindow,
  cumprod,
  cumsum,
  customGrad,
  denseBincount,
  deprecationWarn,
  depthToSpace,
  depthwiseConv2d: depthwiseConv2d$1,
  device_util,
  diag,
  dilation2d,
  disableDeprecationWarnings,
  dispose,
  disposeVariables,
  div,
  divNoNan,
  dot,
  dropout,
  einsum,
  elu,
  enableDebugMode,
  enableProdMode,
  enclosingPowerOfTwo,
  engine,
  ensureShape,
  env,
  equal,
  erf,
  euclideanNorm,
  exp,
  expandDims,
  expm1,
  eye,
  fft,
  fill,
  findBackend,
  findBackendFactory,
  floor,
  floorDiv,
  fused: fused_ops,
  gather,
  gatherND,
  gather_util: gather_nd_util,
  getBackend,
  getGradient,
  getKernel,
  getKernelsForBackend,
  grad,
  grads,
  greater,
  greaterEqual,
  ifft,
  imag,
  image: image$1,
  inTopKAsync,
  io,
  irfft,
  isFinite: isFinite$1,
  isInf,
  isNaN: isNaN$1,
  keep,
  kernel_impls,
  leakyRelu,
  less,
  lessEqual,
  linalg,
  linspace,
  localResponseNormalization,
  log,
  log1p,
  logSigmoid,
  logSoftmax,
  logSumExp,
  logicalAnd,
  logicalNot,
  logicalOr,
  logicalXor,
  losses,
  lowerBound,
  matMul: matMul$1,
  math,
  max,
  maxPool,
  maxPool3d,
  maxPoolWithArgmax,
  maximum,
  mean,
  memory,
  meshgrid,
  min,
  minimum,
  mirrorPad,
  mod,
  moments,
  movingAverage,
  mul,
  multiRNNCell,
  multinomial,
  neg,
  nextFrame,
  norm,
  notEqual,
  oneHot,
  ones,
  onesLike,
  op,
  outerProduct,
  pad,
  pad1d,
  pad2d,
  pad3d,
  pad4d,
  pool,
  pow,
  prelu,
  print,
  prod,
  profile,
  raggedGather,
  raggedRange,
  raggedTensorToTensor,
  rand,
  randomGamma,
  randomNormal,
  randomStandardNormal,
  randomUniform,
  randomUniformInt,
  range,
  ready,
  real,
  reciprocal,
  registerBackend,
  registerGradient,
  registerKernel,
  relu,
  relu6,
  removeBackend,
  reshape,
  reverse,
  reverse1d,
  reverse2d,
  reverse3d,
  reverse4d,
  rfft,
  round: round$1,
  rsqrt,
  scalar,
  scatterND,
  scatter_util: scatter_nd_util,
  searchSorted,
  selu,
  separableConv2d,
  serialization,
  setBackend,
  setPlatform,
  setdiff1dAsync,
  sigmoid,
  sign,
  signal,
  sin,
  sinh,
  slice,
  slice1d,
  slice2d,
  slice3d,
  slice4d,
  slice_util,
  softmax,
  softplus,
  spaceToBatchND,
  sparse: sparse$1,
  sparseToDense,
  spectral: spectral$1,
  split: split$1,
  sqrt,
  square,
  squaredDifference,
  squeeze,
  stack,
  step,
  stridedSlice,
  string: string$1,
  sub,
  sum,
  sumOutType,
  tan,
  tanh,
  tensor,
  tensor1d,
  tensor2d,
  tensor3d,
  tensor4d,
  tensor5d,
  tensor6d,
  tensorScatterUpdate,
  tensor_util,
  test_util,
  tidy,
  tile,
  time,
  topk,
  train,
  transpose,
  truncatedNormal,
  unique,
  unregisterGradient,
  unregisterKernel,
  unsortedSegmentSum,
  unstack,
  upcastType,
  upperBound,
  util,
  valueAndGrad,
  valueAndGrads,
  variable,
  variableGrads,
  version_core: version,
  where,
  whereAsync,
  zeros,
  zerosLike
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const ENV = env();
ENV.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (debugValue) => {
  if (debugValue) {
    console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
  }
});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var DataType;
(function(DataType2) {
  DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
  DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
  DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
  DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
  DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
  DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
  DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
  DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
  DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
  DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
  DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
  DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
  DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
  DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
  DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
  DataType2[DataType2["DT_QINT16"] = 15] = "DT_QINT16";
  DataType2[DataType2["DT_QUINT16"] = 16] = "DT_QUINT16";
  DataType2[DataType2["DT_UINT16"] = 17] = "DT_UINT16";
  DataType2[DataType2["DT_COMPLEX128"] = 18] = "DT_COMPLEX128";
  DataType2[DataType2["DT_HALF"] = 19] = "DT_HALF";
  DataType2[DataType2["DT_RESOURCE"] = 20] = "DT_RESOURCE";
  DataType2[DataType2["DT_VARIANT"] = 21] = "DT_VARIANT";
  DataType2[DataType2["DT_UINT32"] = 22] = "DT_UINT32";
  DataType2[DataType2["DT_UINT64"] = 23] = "DT_UINT64";
  DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
  DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
  DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
  DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
  DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
  DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
  DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
  DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
  DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
  DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
  DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
  DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
  DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
  DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
  DataType2[DataType2["DT_QINT16_REF"] = 115] = "DT_QINT16_REF";
  DataType2[DataType2["DT_QUINT16_REF"] = 116] = "DT_QUINT16_REF";
  DataType2[DataType2["DT_UINT16_REF"] = 117] = "DT_UINT16_REF";
  DataType2[DataType2["DT_COMPLEX128_REF"] = 118] = "DT_COMPLEX128_REF";
  DataType2[DataType2["DT_HALF_REF"] = 119] = "DT_HALF_REF";
  DataType2[DataType2["DT_RESOURCE_REF"] = 120] = "DT_RESOURCE_REF";
  DataType2[DataType2["DT_VARIANT_REF"] = 121] = "DT_VARIANT_REF";
  DataType2[DataType2["DT_UINT32_REF"] = 122] = "DT_UINT32_REF";
  DataType2[DataType2["DT_UINT64_REF"] = 123] = "DT_UINT64_REF";
})(DataType || (DataType = {}));
var SaverDef;
(function(SaverDef2) {
  (function(CheckpointFormatVersion) {
    CheckpointFormatVersion[CheckpointFormatVersion["LEGACY"] = 0] = "LEGACY";
    CheckpointFormatVersion[CheckpointFormatVersion["V1"] = 1] = "V1";
    CheckpointFormatVersion[CheckpointFormatVersion["V2"] = 2] = "V2";
  })(SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
})(SaverDef || (SaverDef = {}));
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const CUSTOM_OPS = {};
function getRegisteredOp(name) {
  return CUSTOM_OPS[name];
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getParamValue(paramName, node, tensorMap, context2, resourceManager) {
  const inputParam = node.inputParams[paramName];
  if (inputParam && inputParam.inputIndexStart !== void 0) {
    const start2 = inputParam.inputIndexStart;
    const end = inputParam.inputIndexEnd === 0 ? void 0 : inputParam.inputIndexEnd === void 0 ? start2 + 1 : inputParam.inputIndexEnd;
    const shiftedStart = start2 < 0 ? node.inputNames.length + start2 : start2;
    if (inputParam.type === "tensor") {
      return getTensor(node.inputNames[shiftedStart], tensorMap, context2, resourceManager);
    }
    if (inputParam.type === "tensors") {
      const inputs = node.inputs.slice(start2, end);
      const inputNames = node.inputNames.slice(start2, end).filter((_name, index) => {
        var _a2;
        return ((_a2 = inputs[index]) === null || _a2 === void 0 ? void 0 : _a2.op) !== "NoOp";
      });
      return inputNames.map((name) => getTensor(name, tensorMap, context2, resourceManager));
    }
    const tensor2 = getTensor(node.inputNames[shiftedStart], tensorMap, context2, resourceManager);
    const data = tensor2.dataSync();
    return inputParam.type === "number" ? data[0] : toNestedArray(tensor2.shape, data);
  }
  const attrParam = node.attrParams[paramName];
  return attrParam && attrParam.value;
}
function getTensor(name, tensorsMap, context2, resourceManager) {
  const [nodeName, index] = parseNodeName(name, context2);
  if (resourceManager != null) {
    const tensor2 = resourceManager.getHashTableHandleByName(nodeName);
    if (tensor2 != null) {
      return tensor2;
    }
  }
  const contextId = context2.currentContextIds.find((contextId2) => {
    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
  });
  return contextId !== void 0 ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : void 0;
}
function getTensorsForCurrentContext(name, tensorsMap, context2) {
  return tensorsMap[getNodeNameWithContextId(name, context2.currentContextId)];
}
function getNodeNameAndIndex(inputName, context2) {
  const [nodeName, index, outputName] = parseNodeName(inputName, context2);
  return [
    getNodeNameWithContextId(nodeName, context2 && context2.currentContextId),
    index,
    outputName
  ];
}
function getNodeNameWithContextId(name, contextId) {
  return !!contextId ? `${name}-${contextId}` : name;
}
function parseNodeName(name, context2) {
  if (name === "") {
    return ["", 0, void 0];
  }
  const isCacheEnabled = context2 != null && context2.parseNodeNameCache != null;
  if (isCacheEnabled) {
    const cachedResult = context2.parseNodeNameCache.get(name);
    if (cachedResult != null) {
      return cachedResult;
    }
  }
  const parts = name.split(":");
  let result;
  if (parts.length === 1) {
    result = [name, 0, void 0];
  } else {
    const nodeName = parts[0];
    const outputName = parts.length === 3 ? parts[1] : void 0;
    const index = Number(parts[parts.length - 1]);
    result = [nodeName, index, outputName];
  }
  if (isCacheEnabled) {
    context2.parseNodeNameCache.set(name, result);
  }
  return result;
}
function getPadding(node, tensorMap, context2) {
  let pad2 = getParamValue("pad", node, tensorMap, context2);
  if (pad2 === "explicit") {
    pad2 = getParamValue("explicitPaddings", node, tensorMap, context2);
    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let i = 0; i < 4; i++) {
      explicitPadding[i][0] = pad2[i * 2];
      explicitPadding[i][1] = pad2[i * 2 + 1];
    }
    return explicitPadding;
  }
  return pad2;
}
function cloneTensor(tensor2) {
  return tensor2.kept ? tensor2 : clone(tensor2);
}
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$i = [
  {
    "tfOpName": "Add",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "AddV2",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "AddN",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "tensors",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "BiasAdd",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sub",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RealDiv",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Div",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DivNoNan",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FloorDiv",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mul",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Maximum",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Minimum",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Pow",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SquaredDifference",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Mod",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FloorMod",
    "category": "arithmetic",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
];
const arithmetic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$i
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$h = [
  {
    "tfOpName": "Abs",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acos",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asin",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Atan",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Atan2",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "y",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Ceil",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ClipByValue",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "clipValueMin",
        "type": "number"
      },
      {
        "start": 2,
        "name": "clipValueMax",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Complex",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "real",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "imag",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ComplexAbs",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cos",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cosh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Elu",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Exp",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Floor",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Imag",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "outputType",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Neg",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Real",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "outputType",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Prelu",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "alpha",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Relu6",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Selu",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sigmoid",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sin",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sinh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sqrt",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Rsqrt",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Square",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tan",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tanh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Sign",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Round",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Expm1",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Log1p",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reciprocal",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Softplus",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Asinh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Acosh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Atanh",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Erf",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LeakyRelu",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "alpha",
        "name": "alpha",
        "type": "number",
        "defaultValue": 0.2
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "IsNan",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "IsFinite",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "IsInf",
    "category": "basic_math",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
];
const basicMath = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$h
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$g = [
  {
    "tfOpName": "EmptyTensorList",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "elementShape",
        "type": "shape"
      },
      {
        "start": 1,
        "name": "maxNumElements",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "LoopCond",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Switch",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "data",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "pred",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Merge",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "tensors",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Enter",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "frame_name",
        "name": "frameName",
        "type": "string"
      },
      {
        "tfName": "is_constant",
        "name": "isConstant",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Exit",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NextIteration",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorArrayV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "size",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "element_shape",
        "name": "elementShape",
        "type": "shape"
      },
      {
        "tfName": "dynamic_size",
        "name": "dynamicSize",
        "type": "bool"
      },
      {
        "tfName": "clear_after_read",
        "name": "clearAfterRead",
        "type": "bool"
      },
      {
        "tfName": "identical_element_shapes",
        "name": "identicalElementShapes",
        "type": "bool"
      },
      {
        "tfName": "tensor_array_name",
        "name": "name",
        "type": "string"
      }
    ]
  },
  {
    "tfOpName": "TensorArrayWriteV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "index",
        "type": "number"
      },
      {
        "start": 2,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorArrayReadV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "index",
        "type": "number"
      },
      {
        "start": 2,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorArrayGatherV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "element_shape",
        "name": "elementShape",
        "type": "shape"
      }
    ]
  },
  {
    "tfOpName": "TensorArrayScatterV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorArrayConcatV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "element_shape_except0",
        "name": "elementShapeExcept0",
        "type": "shape",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorArraySplitV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "lengths",
        "type": "number[]"
      },
      {
        "start": 3,
        "name": "flowIn",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorArraySizeV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "flowIn",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "TensorArrayCloseV3",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorArrayId",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "StatelessIf",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "cond",
        "type": "tensor"
      },
      {
        "start": 1,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "then_branch",
        "name": "thenBranch",
        "type": "func"
      },
      {
        "tfName": "else_branch",
        "name": "elseBranch",
        "type": "func"
      }
    ]
  },
  {
    "tfOpName": "If",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "cond",
        "type": "tensor"
      },
      {
        "start": 1,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "then_branch",
        "name": "thenBranch",
        "type": "func"
      },
      {
        "tfName": "else_branch",
        "name": "elseBranch",
        "type": "func"
      }
    ]
  },
  {
    "tfOpName": "StatelessWhile",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "cond",
        "name": "cond",
        "type": "func"
      },
      {
        "tfName": "body",
        "name": "body",
        "type": "func"
      }
    ]
  },
  {
    "tfOpName": "While",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "cond",
        "name": "cond",
        "type": "func"
      },
      {
        "tfName": "body",
        "name": "body",
        "type": "func"
      }
    ]
  },
  {
    "tfOpName": "TensorListScatter",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListScatterV2",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "elementShape",
        "type": "shape"
      },
      {
        "start": 3,
        "name": "numElements",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListGather",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListGetItem",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "index",
        "type": "number"
      },
      {
        "start": 2,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListSetItem",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "index",
        "type": "number"
      },
      {
        "start": 2,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListReserve",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "elementShape",
        "type": "shape"
      },
      {
        "start": 1,
        "name": "numElements",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListFromTensor",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListStack",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      },
      {
        "tfName": "num_elements",
        "name": "numElements",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListSplit",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "elementShape",
        "type": "shape"
      },
      {
        "start": 2,
        "name": "lengths",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListConcat",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "element_shape",
        "name": "elementShape",
        "type": "shape"
      },
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListConcatV2",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "element_shape",
        "name": "elementShape",
        "type": "shape"
      },
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListPopBack",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "elementShape",
        "type": "shape"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListPushBack",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "element_dtype",
        "name": "elementDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TensorListLength",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "TensorListResize",
    "category": "control",
    "inputs": [
      {
        "start": 0,
        "name": "tensorListId",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "size",
        "type": "number"
      }
    ]
  }
];
const control = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$g
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$f = [
  {
    "tfOpName": "AvgPool",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "ksize",
        "name": "kernelSize",
        "type": "number[]"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPool",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "ksize",
        "name": "kernelSize",
        "type": "number[]"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": [],
        "notSupported": true
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPoolWithArgmax",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "ksize",
        "name": "kernelSize",
        "type": "number[]"
      },
      {
        "tfName": "include_batch_in_index",
        "name": "includeBatchInIndex",
        "type": "bool"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "AvgPool3D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "ksize",
        "name": "kernelSize",
        "type": "number[]"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MaxPool3D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "ksize",
        "name": "kernelSize",
        "type": "number[]"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Conv1D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "stride",
        "name": "stride",
        "type": "number"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NWC"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "dilation",
        "name": "dilation",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "Conv2D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "useCudnnOnGpu",
        "name": "useCudnnOnGpu",
        "type": "bool"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "_FusedConv2D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      },
      {
        "start": 2,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "num_args",
        "name": "numArgs",
        "type": "number"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "use_cudnn_on_gpu",
        "name": "useCudnnOnGpu",
        "type": "bool",
        "defaultValue": true
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "defaultValue": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-4
      },
      {
        "tfName": "leakyrelu_alpha",
        "name": "leakyreluAlpha",
        "type": "number",
        "defaultValue": 0.2
      }
    ]
  },
  {
    "tfOpName": "Conv2DBackpropInput",
    "category": "convolution",
    "inputs": [
      {
        "start": 2,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      },
      {
        "start": 0,
        "name": "outputShape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2d",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "input",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "DepthwiseConv2dNative",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "input",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "FusedDepthwiseConv2dNative",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      },
      {
        "start": 2,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "num_args",
        "name": "numArgs",
        "type": "number"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]",
        "defaultValue": [
          1,
          1,
          1,
          1
        ]
      },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "explicit_paddings",
        "name": "explicitPaddings",
        "type": "number[]",
        "defaultValue": []
      }
    ]
  },
  {
    "tfOpName": "Conv3D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "defaultValue": "NHWC"
      },
      {
        "tfName": "dilations",
        "name": "dilations",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Dilation2D",
    "category": "convolution",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "filter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "strides",
        "name": "strides",
        "type": "number[]"
      },
      {
        "tfName": "rates",
        "name": "dilations",
        "type": "number[]"
      },
      {
        "tfName": "padding",
        "name": "pad",
        "type": "string"
      }
    ]
  }
];
const convolution = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$f
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$e = [
  {
    "tfOpName": "Fill",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      },
      {
        "start": 1,
        "name": "value",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "LinSpace",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "start",
        "type": "number"
      },
      {
        "start": 1,
        "name": "stop",
        "type": "number"
      },
      {
        "start": 2,
        "name": "num",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "OneHot",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "depth",
        "type": "number"
      },
      {
        "start": 2,
        "name": "onValue",
        "type": "number",
        "defaultValue": 1
      },
      {
        "start": 3,
        "name": "offValue",
        "type": "number",
        "defaultValue": 0
      }
    ],
    "attrs": [
      {
        "tfName": "axis",
        "name": "axis",
        "type": "number",
        "notSupported": true
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "Ones",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "OnesLike",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "RandomStandardNormal",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "seed",
        "name": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "T",
        "name": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RandomUniform",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "minval",
        "name": "minval",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "maxval",
        "name": "maxval",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "seed",
        "name": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfName": "T",
        "name": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "RandomUniformInt",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "minval",
        "name": "minval",
        "type": "number"
      },
      {
        "tfName": "maxval",
        "name": "maxval",
        "type": "number"
      },
      {
        "tfName": "seed",
        "name": "seed",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Range",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "start",
        "type": "number"
      },
      {
        "start": 1,
        "name": "stop",
        "type": "number"
      },
      {
        "start": 2,
        "name": "step",
        "type": "number",
        "defaultValue": 0
      }
    ],
    "attrs": [
      {
        "tfName": "Tidx",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "TruncatedNormal",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "means",
        "name": "mean",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "stddev",
        "name": "stdDev",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfName": "seed",
        "name": "seed",
        "type": "number"
      },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      },
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "T",
        "name": "T",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Zeros",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ZerosLike",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "Multinomial",
    "category": "creation",
    "inputs": [
      {
        "start": 0,
        "name": "logits",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "numSamples",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "seed",
        "name": "seed",
        "type": "number"
      },
      {
        "tfName": "seed2",
        "name": "seed2",
        "type": "number"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      },
      {
        "tfName": "output_dtype",
        "name": "output_dtype",
        "type": "dtype"
      }
    ]
  }
];
const creation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$e
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$d = [
  {
    "tfOpName": "NonMaxSuppressionV2",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "boxes",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scores",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "maxOutputSize",
        "type": "number"
      },
      {
        "start": 3,
        "name": "iouThreshold",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV3",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "boxes",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scores",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "maxOutputSize",
        "type": "number"
      },
      {
        "start": 3,
        "name": "iouThreshold",
        "type": "number"
      },
      {
        "start": 4,
        "name": "scoreThreshold",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV4",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "boxes",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scores",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "maxOutputSize",
        "type": "number"
      },
      {
        "start": 3,
        "name": "iouThreshold",
        "type": "number"
      },
      {
        "start": 4,
        "name": "scoreThreshold",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "T_threshold",
        "name": "threshold",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "pad_to_max_output_size",
        "name": "padToMaxOutputSize",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "NonMaxSuppressionV5",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "boxes",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scores",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "maxOutputSize",
        "type": "number"
      },
      {
        "start": 3,
        "name": "iouThreshold",
        "type": "number"
      },
      {
        "start": 4,
        "name": "scoreThreshold",
        "type": "number"
      },
      {
        "start": 5,
        "name": "softNmsSigma",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Where",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "condition",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ListDiff",
    "category": "dynamic",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "y",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  }
];
const dynamic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$d
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$c = [
  {
    "tfOpName": "LowerBound",
    "category": "evaluation",
    "inputs": [
      {
        "start": 0,
        "name": "sortedSequence",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "values",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "TopKV2",
    "category": "evaluation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "k",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "sorted",
        "name": "sorted",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "UpperBound",
    "category": "evaluation",
    "inputs": [
      {
        "start": 0,
        "name": "sortedSequence",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "values",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Unique",
    "category": "evaluation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "UniqueV2",
    "category": "evaluation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ]
  }
];
const evaluation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$c
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$b = [
  {
    "tfOpName": "PlaceholderWithDefault",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "default",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "shape",
        "name": "shape",
        "type": "shape"
      },
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "Placeholder",
    "category": "graph",
    "attrs": [
      {
        "tfName": "shape",
        "name": "shape",
        "type": "shape"
      },
      {
        "tfName": "dtype",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "Const",
    "category": "graph"
  },
  {
    "tfOpName": "Identity",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "IdentityN",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "x",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Snapshot",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Rank",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Size",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "Shape",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "ShapeN",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "x",
        "type": "tensors"
      }
    ]
  },
  {
    "tfOpName": "Print",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "data",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "message",
        "name": "message",
        "type": "string"
      },
      {
        "tfName": "first_n",
        "name": "firstN",
        "type": "number",
        "notSupported": true
      },
      {
        "tfName": "summarize",
        "name": "summarize",
        "type": "number",
        "defaultValue": 3
      }
    ]
  },
  {
    "tfOpName": "NoOp",
    "category": "graph",
    "inputs": []
  },
  {
    "tfOpName": "StopGradient",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "FakeQuantWithMinMaxVars",
    "category": "graph",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "min",
        "name": "min",
        "type": "number"
      },
      {
        "tfName": "max",
        "name": "max",
        "type": "number"
      }
    ]
  }
];
const graph = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$b
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$a = [
  {
    "tfOpName": "HashTable",
    "category": "hash_table",
    "inputs": [],
    "attrs": [
      {
        "tfName": "shared_name",
        "name": "sharedName",
        "type": "string"
      },
      {
        "tfName": "use_node_name_sharing",
        "name": "useNodeNameSharing",
        "type": "bool"
      },
      {
        "tfName": "key_dtype",
        "name": "keyDType",
        "type": "dtype"
      },
      {
        "tfName": "value_dtype",
        "name": "valueDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "HashTableV2",
    "category": "hash_table",
    "inputs": [],
    "attrs": [
      {
        "tfName": "shared_name",
        "name": "sharedName",
        "type": "string"
      },
      {
        "tfName": "use_node_name_sharing",
        "name": "useNodeNameSharing",
        "type": "bool"
      },
      {
        "tfName": "key_dtype",
        "name": "keyDType",
        "type": "dtype"
      },
      {
        "tfName": "value_dtype",
        "name": "valueDType",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "LookupTableImport",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "values",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "Tin",
        "name": "tIn",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableImportV2",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "values",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "Tin",
        "name": "tIn",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableFind",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "defaultValue",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "Tin",
        "name": "tIn",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableFindV2",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "defaultValue",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "Tin",
        "name": "tIn",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "Tout",
        "name": "tOut",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LookupTableSize",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "LookupTableSizeV2",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "InitializeTable",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "values",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "InitializeTableV2",
    "category": "hash_table",
    "inputs": [
      {
        "start": 0,
        "name": "tableHandle",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "keys",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "values",
        "type": "tensor"
      }
    ]
  }
];
const hashTable = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$a
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$9 = [
  {
    "tfOpName": "ResizeBilinear",
    "category": "image",
    "inputs": [
      {
        "start": 0,
        "name": "images",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "size",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "align_corners",
        "name": "alignCorners",
        "type": "bool"
      },
      {
        "tfName": "half_pixel_centers",
        "name": "halfPixelCenters",
        "type": "bool"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "ResizeNearestNeighbor",
    "category": "image",
    "inputs": [
      {
        "start": 0,
        "name": "images",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "size",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "align_corners",
        "name": "alignCorners",
        "type": "bool"
      },
      {
        "tfName": "half_pixel_centers",
        "name": "halfPixelCenters",
        "type": "bool"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "CropAndResize",
    "category": "image",
    "inputs": [
      {
        "start": 0,
        "name": "image",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "boxes",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "boxInd",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "cropSize",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "method",
        "name": "method",
        "type": "string"
      },
      {
        "tfName": "extrapolation_value",
        "name": "extrapolationValue",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ImageProjectiveTransformV3",
    "category": "image",
    "inputs": [
      {
        "start": 0,
        "name": "images",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "transforms",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "outputShape",
        "type": "number[]"
      },
      {
        "start": 3,
        "name": "fillValue",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "interpolation",
        "name": "interpolation",
        "type": "string"
      },
      {
        "tfName": "fill_mode",
        "name": "fillMode",
        "type": "string"
      }
    ]
  }
];
const image = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$9
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$8 = [
  {
    "tfOpName": "Equal",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "NotEqual",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Greater",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "GreaterEqual",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Less",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LessEqual",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalAnd",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalNot",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LogicalOr",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Select",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "condition",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SelectV2",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "condition",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BitwiseAnd",
    "category": "logical",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "y",
        "type": "tensor"
      }
    ]
  }
];
const logical = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$8
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$7 = [
  {
    "tfOpName": "_FusedMatMul",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      },
      {
        "start": 2,
        "end": 0,
        "name": "args",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "num_args",
        "name": "numArgs",
        "type": "number"
      },
      {
        "tfName": "fused_ops",
        "name": "fusedOps",
        "type": "string[]",
        "defaultValue": []
      },
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-4
      },
      {
        "tfName": "transpose_a",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "transpose_b",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "leakyrelu_alpha",
        "name": "leakyreluAlpha",
        "type": "number",
        "defaultValue": 0.2
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "MatMul",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "transpose_a",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "transpose_b",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BatchMatMul",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "adj_x",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "adj_y",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "BatchMatMulV2",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "b",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "adj_x",
        "name": "transposeA",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "adj_y",
        "name": "transposeB",
        "type": "bool",
        "defaultValue": false
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Transpose",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "perm",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Einsum",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "tensors",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "equation",
        "name": "equation",
        "type": "string"
      },
      {
        "tfName": "N",
        "name": "n",
        "type": "number",
        "defaultValue": 2
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "MatrixBandPart",
    "category": "matrices",
    "inputs": [
      {
        "start": 0,
        "name": "a",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "numLower",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "numUpper",
        "type": "tensor"
      }
    ]
  }
];
const matrices = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$7
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$6 = [
  {
    "tfOpName": "EuclideanNorm",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool",
        "defaultValue": false
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNorm",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scale",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "offset",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "mean",
        "type": "tensor"
      },
      {
        "start": 4,
        "name": "variance",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV2",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scale",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "offset",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "mean",
        "type": "tensor"
      },
      {
        "start": 4,
        "name": "variance",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "FusedBatchNormV3",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "scale",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "offset",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "mean",
        "type": "tensor"
      },
      {
        "start": 4,
        "name": "variance",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "epsilon",
        "name": "epsilon",
        "type": "number",
        "defaultValue": 1e-3
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "LRN",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "depth_radius",
        "name": "radius",
        "type": "number",
        "defaultValue": 5
      },
      {
        "tfName": "bias",
        "name": "bias",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfName": "alpha",
        "name": "alpha",
        "type": "number",
        "defaultValue": 1
      },
      {
        "tfName": "beta",
        "name": "beta",
        "type": "number",
        "defaultValue": 0.5
      }
    ]
  },
  {
    "tfOpName": "Softmax",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "LogSoftmax",
    "category": "normalization",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  }
];
const normalization = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$6
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$5 = [
  {
    "tfOpName": "Bincount",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "size",
        "type": "number"
      },
      {
        "start": 2,
        "name": "weights",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "DenseBincount",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "size",
        "type": "number"
      },
      {
        "start": 2,
        "name": "weights",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "binary_output",
        "name": "binaryOutput",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Max",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Mean",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Min",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Sum",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "All",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Any",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "ArgMax",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "ArgMin",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "Prod",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "keep_dims",
        "name": "keepDims",
        "type": "bool"
      },
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Cumprod",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "exclusive",
        "name": "exclusive",
        "type": "bool"
      },
      {
        "tfName": "reverse",
        "name": "reverse",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "Cumsum",
    "category": "reduction",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "exclusive",
        "name": "exclusive",
        "type": "bool"
      },
      {
        "tfName": "reverse",
        "name": "reverse",
        "type": "bool"
      }
    ]
  }
];
const reduction = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$5
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$4 = [
  {
    "tfOpName": "ConcatV2",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "end": -1,
        "name": "tensors",
        "type": "tensors"
      },
      {
        "start": -1,
        "name": "axis",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "N",
        "name": "n",
        "type": "number",
        "defaultValue": 2
      }
    ]
  },
  {
    "tfOpName": "Concat",
    "category": "slice_join",
    "inputs": [
      {
        "start": 1,
        "end": 0,
        "name": "tensors",
        "type": "tensors"
      },
      {
        "start": 0,
        "name": "axis",
        "type": "number"
      }
    ],
    "attrs": [
      {
        "tfName": "N",
        "name": "n",
        "type": "number",
        "defaultValue": 2
      }
    ]
  },
  {
    "tfOpName": "GatherV2",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ],
    "attrs": [
      {
        "tfName": "batch_dims",
        "name": "batchDims",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Gather",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "validate_indices",
        "name": "validateIndices",
        "type": "bool",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Reverse",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "dims",
        "type": "bool[]"
      }
    ]
  },
  {
    "tfOpName": "ReverseV2",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Slice",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "begin",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "size",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "StridedSlice",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "begin",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "end",
        "type": "number[]"
      },
      {
        "start": 3,
        "name": "strides",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "begin_mask",
        "name": "beginMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "end_mask",
        "name": "endMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "new_axis_mask",
        "name": "newAxisMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "ellipsis_mask",
        "name": "ellipsisMask",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "shrink_axis_mask",
        "name": "shrinkAxisMask",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Pack",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "end": 0,
        "name": "tensors",
        "type": "tensors"
      }
    ],
    "attrs": [
      {
        "tfName": "axis",
        "name": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Unpack",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "axis",
        "name": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "tfName": "num",
        "name": "num",
        "type": "number",
        "defaultValue": 0,
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "Tile",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "reps",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Split",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "axis",
        "type": "number",
        "defaultValue": 0
      },
      {
        "start": 1,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "num_split",
        "name": "numOrSizeSplits",
        "type": "number",
        "defaultValue": 1
      }
    ]
  },
  {
    "tfOpName": "SplitV",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "numOrSizeSplits",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "axis",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "ScatterNd",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "values",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "GatherNd",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "SparseToDense",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "sparseIndices",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "outputShape",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "sparseValues",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "defaultValue",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "validate_indices",
        "name": "validateIndices",
        "type": "bool",
        "defaultValue": false,
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "TensorScatterUpdate",
    "category": "slice_join",
    "inputs": [
      {
        "start": 0,
        "name": "tensor",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "values",
        "type": "tensor"
      }
    ]
  }
];
const sliceJoin = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$4
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$3 = [
  {
    "tfOpName": "SparseFillEmptyRows",
    "category": "sparse",
    "inputs": [
      {
        "start": 0,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "values",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "denseShape",
        "type": "tensor"
      },
      {
        "start": 3,
        "name": "defaultValue",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "SparseReshape",
    "category": "sparse",
    "inputs": [
      {
        "start": 0,
        "name": "inputIndices",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "inputShape",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "newShape",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "T",
        "name": "dtype",
        "type": "dtype",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "SparseSegmentMean",
    "category": "sparse",
    "inputs": [
      {
        "start": 0,
        "name": "data",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "segmentIds",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "SparseSegmentSum",
    "category": "sparse",
    "inputs": [
      {
        "start": 0,
        "name": "data",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "indices",
        "type": "tensor"
      },
      {
        "start": 2,
        "name": "segmentIds",
        "type": "tensor"
      }
    ]
  }
];
const sparse = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$3
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$2 = [
  {
    "tfOpName": "FFT",
    "category": "spectral",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "IFFT",
    "category": "spectral",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ]
  },
  {
    "tfOpName": "RFFT",
    "category": "spectral",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "fft_length",
        "type": "number",
        "notSupported": true
      }
    ]
  },
  {
    "tfOpName": "IRFFT",
    "category": "spectral",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "fft_length",
        "type": "number",
        "notSupported": true
      }
    ]
  }
];
const spectral = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$2
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json$1 = [
  {
    "tfOpName": "StaticRegexReplace",
    "category": "string",
    "inputs": [
      {
        "start": 0,
        "name": "input",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "pattern",
        "name": "pattern",
        "type": "string"
      },
      {
        "tfName": "rewrite",
        "name": "rewrite",
        "type": "string"
      },
      {
        "tfName": "replace_global",
        "name": "replaceGlobal",
        "type": "bool"
      }
    ]
  },
  {
    "tfOpName": "StringNGrams",
    "category": "string",
    "inputs": [
      {
        "start": 0,
        "name": "data",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "dataSplits",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "separator",
        "name": "separator",
        "type": "string"
      },
      {
        "tfName": "ngram_widths",
        "name": "nGramWidths",
        "type": "number[]"
      },
      {
        "tfName": "left_pad",
        "name": "leftPad",
        "type": "string"
      },
      {
        "tfName": "right_pad",
        "name": "rightPad",
        "type": "string"
      },
      {
        "tfName": "pad_width",
        "name": "padWidth",
        "type": "number"
      },
      {
        "tfName": "preserve_short_sequences",
        "name": "preserveShortSequences",
        "type": "bool"
      }
    ],
    "outputs": [
      "ngrams",
      "ngrams_splits"
    ]
  },
  {
    "tfOpName": "StringSplit",
    "category": "string",
    "inputs": [
      {
        "start": 0,
        "name": "input",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "delimiter",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "skip_empty",
        "name": "skipEmpty",
        "type": "bool"
      }
    ],
    "outputs": [
      "indices",
      "values",
      "shape"
    ]
  },
  {
    "tfOpName": "StringToHashBucketFast",
    "category": "string",
    "inputs": [
      {
        "start": 0,
        "name": "input",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "num_buckets",
        "name": "numBuckets",
        "type": "number"
      }
    ]
  }
];
const string = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json: json$1
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const json = [
  {
    "tfOpName": "Cast",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "SrcT",
        "name": "sdtype",
        "type": "dtype",
        "notSupported": true
      },
      {
        "tfName": "DstT",
        "name": "dtype",
        "type": "dtype"
      }
    ]
  },
  {
    "tfOpName": "ExpandDims",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "axis",
        "type": "number"
      }
    ]
  },
  {
    "tfOpName": "MirrorPad",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "padding",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "mode",
        "name": "mode",
        "type": "string"
      }
    ]
  },
  {
    "tfOpName": "Pad",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "padding",
        "type": "number[]"
      }
    ],
    "attrs": [
      {
        "tfName": "constant_value",
        "name": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "PadV2",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "padding",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "constantValue",
        "type": "number",
        "defaultValue": 0
      }
    ]
  },
  {
    "tfOpName": "Reshape",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "EnsureShape",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "shape",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "Squeeze",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "axis",
        "tfDeprecatedName": "squeeze_dims",
        "name": "axis",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "SpaceToBatchND",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "blockShape",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "paddings",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "BatchToSpaceND",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "blockShape",
        "type": "number[]"
      },
      {
        "start": 2,
        "name": "crops",
        "type": "number[]"
      }
    ]
  },
  {
    "tfOpName": "DepthToSpace",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      }
    ],
    "attrs": [
      {
        "tfName": "block_size",
        "name": "blockSize",
        "type": "number"
      },
      {
        "tfName": "data_format",
        "name": "dataFormat",
        "type": "string"
      }
    ]
  },
  {
    "tfOpName": "BroadcastTo",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "x",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "shape",
        "type": "number[]"
      }
    ],
    "attrs": []
  },
  {
    "tfOpName": "BroadcastArgs",
    "category": "transformation",
    "inputs": [
      {
        "start": 0,
        "name": "s0",
        "type": "tensor"
      },
      {
        "start": 1,
        "name": "s1",
        "type": "tensor"
      }
    ],
    "attrs": []
  }
];
const transformation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  json
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class OperationMapper {
  // Singleton instance for the mapper
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  // Loads the op mapping from the JSON file.
  constructor() {
    const ops = [
      arithmetic,
      basicMath,
      control,
      convolution,
      creation,
      dynamic,
      evaluation,
      graph,
      hashTable,
      image,
      logical,
      matrices,
      normalization,
      reduction,
      sliceJoin,
      sparse,
      spectral,
      string,
      transformation
    ];
    const mappersJson = [].concat(...ops.map((op2) => op2.json));
    this.opMappers = mappersJson.reduce((map, mapper) => {
      map[mapper.tfOpName] = mapper;
      return map;
    }, {});
  }
  // Converts the model inference graph from Tensorflow GraphDef to local
  // representation for TensorFlow.js API
  transformGraph(graph2, signature = {}) {
    const tfNodes = graph2.node;
    const placeholders = [];
    const weights = [];
    const initNodes = [];
    const nodes = tfNodes.reduce((map, node) => {
      map[node.name] = this.mapNode(node);
      if (node.op.startsWith("Placeholder")) {
        placeholders.push(map[node.name]);
      } else if (node.op === "Const") {
        weights.push(map[node.name]);
      } else if (node.input == null || node.input.length === 0) {
        initNodes.push(map[node.name]);
      }
      return map;
    }, {});
    let inputs = [];
    const outputs = [];
    let inputNodeNameToKey = {};
    let outputNodeNameToKey = {};
    if (signature != null) {
      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
    }
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node = nodes[key];
      node.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node.inputNames[index] = inputName;
          }
        }
        node.inputs.push(inputNode);
        inputNode.children.push(node);
      });
    });
    if (Object.keys(outputNodeNameToKey).length === 0) {
      allNodes.forEach((key) => {
        const node = nodes[key];
        if (node.children.length === 0) {
          outputs.push(node);
        }
      });
    } else {
      Object.keys(outputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node = nodes[nodeName];
        if (node != null) {
          node.signatureKey = outputNodeNameToKey[name];
          outputs.push(node);
        }
      });
    }
    if (Object.keys(inputNodeNameToKey).length > 0) {
      Object.keys(inputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node = nodes[nodeName];
        if (node) {
          node.signatureKey = inputNodeNameToKey[name];
          inputs.push(node);
        }
      });
    } else {
      inputs = placeholders;
    }
    let functions = {};
    if (graph2.library != null && graph2.library.function != null) {
      functions = graph2.library.function.reduce((functions2, func) => {
        functions2[func.signature.name] = this.mapFunction(func);
        return functions2;
      }, {});
    }
    const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };
    if (initNodes.length > 0) {
      result.initNodes = initNodes;
    }
    return result;
  }
  mapSignatureEntries(entries) {
    return Object.keys(entries || {}).reduce((prev, curr) => {
      prev[entries[curr].name] = curr;
      return prev;
    }, {});
  }
  mapNode(node) {
    const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};
    if (node.attr == null) {
      node.attr = {};
    }
    const newNode = {
      name: node.name,
      op: node.op,
      category: mapper.category,
      inputNames: (node.input || []).map((input) => input.startsWith("^") ? input.slice(1) : input),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: node.attr,
      outputs: mapper.outputs
    };
    if (mapper.inputs != null) {
      newNode.inputParams = mapper.inputs.reduce((map, param) => {
        map[param.name] = {
          type: param.type,
          inputIndexStart: param.start,
          inputIndexEnd: param.end
        };
        return map;
      }, {});
    }
    if (mapper.attrs != null) {
      newNode.attrParams = mapper.attrs.reduce((map, param) => {
        const type = param.type;
        let value = void 0;
        switch (param.type) {
          case "string":
            value = getStringParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "string[]":
            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number":
            value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number[]":
            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool":
            value = getBoolParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool[]":
            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape":
            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape[]":
            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype":
            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype[]":
            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "func":
            value = getFuncParam(node.attr, param.tfName, param.defaultValue);
            if (value === void 0 && !!param.tfDeprecatedName) {
              value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "tensor":
          case "tensors":
            break;
          default:
            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);
        }
        map[param.name] = { value, type };
        return map;
      }, {});
    }
    return newNode;
  }
  // map the TFunctionDef to TFJS graph object
  mapFunction(functionDef) {
    const tfNodes = functionDef.nodeDef;
    const placeholders = [];
    const weights = [];
    let nodes = {};
    if (tfNodes != null) {
      nodes = tfNodes.reduce((map, node) => {
        map[node.name] = this.mapNode(node);
        if (node.op === "Const") {
          weights.push(map[node.name]);
        }
        return map;
      }, {});
    }
    const inputs = [];
    const outputs = [];
    functionDef.signature.inputArg.forEach((arg) => {
      const [nodeName] = getNodeNameAndIndex(arg.name);
      const node = {
        name: nodeName,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: parseDtypeParam(arg.type), type: "dtype" } },
        children: []
      };
      node.signatureKey = arg.name;
      inputs.push(node);
      nodes[nodeName] = node;
    });
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node = nodes[key];
      node.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node.inputNames[index] = inputName;
          }
        }
        node.inputs.push(inputNode);
        inputNode.children.push(node);
      });
    });
    const returnNodeMap = functionDef.ret;
    functionDef.signature.outputArg.forEach((output) => {
      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);
      const node = nodes[nodeName];
      if (node != null) {
        node.defaultOutput = index;
        outputs.push(node);
      }
    });
    const signature = this.mapArgsToSignature(functionDef);
    return { nodes, inputs, outputs, weights, placeholders, signature };
  }
  mapArgsToSignature(functionDef) {
    return {
      methodName: functionDef.signature.name,
      inputs: functionDef.signature.inputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg);
        return map;
      }, {}),
      outputs: functionDef.signature.outputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
        return map;
      }, {})
    };
  }
  mapArgToTensorInfo(arg, nameMap) {
    let name = arg.name;
    if (nameMap != null) {
      name = nameMap[name];
    }
    return { name, dtype: arg.type };
  }
}
function decodeBase64(text) {
  const global2 = env().global;
  if (typeof global2.atob !== "undefined") {
    return global2.atob(text);
  } else if (typeof Buffer !== "undefined") {
    return new Buffer(text, "base64").toString();
  } else {
    throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
  }
}
function parseStringParam(s, keepCase) {
  const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);
  return keepCase ? value : value.toLowerCase();
}
function getStringParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param != null) {
    return parseStringParam(param.s, keepCase);
  }
  return def;
}
function getBoolParam(attrs, name, def) {
  const param = attrs[name];
  return param ? param.b : def;
}
function getNumberParam(attrs, name, def) {
  const param = attrs[name] || {};
  const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
  return typeof value === "number" ? value : parseInt(value, 10);
}
function parseDtypeParam(value) {
  if (typeof value === "string") {
    value = DataType[value];
  }
  switch (value) {
    case DataType.DT_FLOAT:
    case DataType.DT_HALF:
      return "float32";
    case DataType.DT_INT32:
    case DataType.DT_INT64:
    case DataType.DT_INT8:
    case DataType.DT_UINT8:
      return "int32";
    case DataType.DT_BOOL:
      return "bool";
    case DataType.DT_DOUBLE:
      return "float32";
    case DataType.DT_STRING:
      return "string";
    case DataType.DT_COMPLEX64:
    case DataType.DT_COMPLEX128:
      return "complex64";
    default:
      return null;
  }
}
function getFuncParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.func) {
    return param.func.name;
  }
  return def;
}
function getDtypeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.type) {
    return parseDtypeParam(param.type);
  }
  return def;
}
function getDtypeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.type) {
    return param.list.type.map((v) => parseDtypeParam(v));
  }
  return def;
}
function parseTensorShapeParam(shape) {
  if (shape.unknownRank) {
    return void 0;
  }
  if (shape.dim != null) {
    return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
  }
  return [];
}
function getTensorShapeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.shape) {
    return parseTensorShapeParam(param.shape);
  }
  return def;
}
function getNumericArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param) {
    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v) => typeof v === "number" ? v : parseInt(v, 10));
  }
  return def;
}
function getStringArrayParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param && param.list && param.list.s) {
    return param.list.s.map((v) => {
      return parseStringParam(v, keepCase);
    });
  }
  return def;
}
function getTensorShapeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.shape) {
    return param.list.shape.map((v) => {
      return parseTensorShapeParam(v);
    });
  }
  return def;
}
function getBoolArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.b) {
    return param.list.b;
  }
  return def;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class NodeValueImpl {
  constructor(node, tensorMap, context2) {
    this.node = node;
    this.tensorMap = tensorMap;
    this.context = context2;
    this.inputs = [];
    this.attrs = {};
    this.inputs = node.inputNames.map((name) => this.getInput(name));
    if (node.rawAttrs != null) {
      this.attrs = Object.keys(node.rawAttrs).reduce((attrs, key) => {
        attrs[key] = this.getAttr(key);
        return attrs;
      }, {});
    }
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getInput(name) {
    return getTensor(name, this.tensorMap, this.context);
  }
  /**
   * Return the value of the attribute or input param.
   * @param name String: name of attribute or input param.
   */
  getAttr(name, defaultValue) {
    const value = this.node.rawAttrs[name];
    if (value.tensor != null) {
      return getTensor(name, this.tensorMap, this.context);
    }
    if (value.i != null || value.f != null) {
      return getNumberParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.s != null) {
      return getStringParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.b != null) {
      return getBoolParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.shape != null) {
      return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.type != null) {
      return getDtypeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.list != null) {
      if (value.list.i != null || value.list.f != null) {
        return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.s != null) {
        return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.shape != null) {
        return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.b != null) {
        return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.type != null) {
        return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
    }
    return defaultValue;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const tfOps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OP_SCOPE_SUFFIX,
  abs,
  acos,
  acosh,
  add,
  addN,
  all,
  any,
  argMax,
  argMin,
  asin,
  asinh,
  atan,
  atan2,
  atanh,
  avgPool,
  avgPool3d,
  basicLSTMCell,
  batchNorm,
  batchNorm2d,
  batchNorm3d,
  batchNorm4d,
  batchToSpaceND,
  bincount,
  bitwiseAnd,
  booleanMaskAsync,
  broadcastArgs,
  broadcastTo,
  buffer,
  cast,
  ceil,
  clipByValue,
  clone,
  complex,
  concat,
  concat1d,
  concat2d,
  concat3d,
  concat4d,
  conv1d,
  conv2d: conv2d$1,
  conv2dTranspose,
  conv3d,
  conv3dTranspose,
  cos,
  cosh,
  cosineWindow,
  cumprod,
  cumsum,
  denseBincount,
  depthToSpace,
  depthwiseConv2d: depthwiseConv2d$1,
  diag,
  dilation2d,
  div,
  divNoNan,
  dot,
  dropout,
  einsum,
  elu,
  enclosingPowerOfTwo,
  ensureShape,
  equal,
  erf,
  euclideanNorm,
  exp,
  expandDims,
  expm1,
  eye,
  fft,
  fill,
  floor,
  floorDiv,
  fused: fused_ops,
  gather,
  gatherND,
  greater,
  greaterEqual,
  ifft,
  imag,
  image: image$1,
  inTopKAsync,
  irfft,
  isFinite: isFinite$1,
  isInf,
  isNaN: isNaN$1,
  leakyRelu,
  less,
  lessEqual,
  linalg,
  linspace,
  localResponseNormalization,
  log,
  log1p,
  logSigmoid,
  logSoftmax,
  logSumExp,
  logicalAnd,
  logicalNot,
  logicalOr,
  logicalXor,
  losses,
  lowerBound,
  matMul: matMul$1,
  max,
  maxPool,
  maxPool3d,
  maxPoolWithArgmax,
  maximum,
  mean,
  meshgrid,
  min,
  minimum,
  mirrorPad,
  mod,
  moments,
  movingAverage,
  mul,
  multiRNNCell,
  multinomial,
  neg,
  norm,
  notEqual,
  oneHot,
  ones,
  onesLike,
  op,
  outerProduct,
  pad,
  pad1d,
  pad2d,
  pad3d,
  pad4d,
  pool,
  pow,
  prelu,
  print,
  prod,
  raggedGather,
  raggedRange,
  raggedTensorToTensor,
  rand,
  randomGamma,
  randomNormal,
  randomStandardNormal,
  randomUniform,
  randomUniformInt,
  range,
  real,
  reciprocal,
  relu,
  relu6,
  reshape,
  reverse,
  reverse1d,
  reverse2d,
  reverse3d,
  reverse4d,
  rfft,
  round: round$1,
  rsqrt,
  scalar,
  scatterND,
  searchSorted,
  selu,
  separableConv2d,
  setdiff1dAsync,
  sigmoid,
  sign,
  signal,
  sin,
  sinh,
  slice,
  slice1d,
  slice2d,
  slice3d,
  slice4d,
  softmax,
  softplus,
  spaceToBatchND,
  sparse: sparse$1,
  sparseToDense,
  spectral: spectral$1,
  split: split$1,
  sqrt,
  square,
  squaredDifference,
  squeeze,
  stack,
  step,
  stridedSlice,
  string: string$1,
  sub,
  sum,
  tan,
  tanh,
  tensor,
  tensor1d,
  tensor2d,
  tensor3d,
  tensor4d,
  tensor5d,
  tensor6d,
  tensorScatterUpdate,
  tile,
  topk,
  transpose,
  truncatedNormal,
  unique,
  unsortedSegmentSum,
  unstack,
  upperBound,
  variable,
  where,
  whereAsync,
  zeros,
  zerosLike
}, Symbol.toStringTag, { value: "Module" }));
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$k = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add": {
      return [ops.add(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "AddN": {
      return [ops.addN(getParamValue("tensors", node, tensorMap, context2))];
    }
    case "FloorMod":
    case "Mod":
      return [ops.mod(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    case "Mul":
      return [ops.mul(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    case "RealDiv":
    case "Div": {
      return [ops.div(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "DivNoNan": {
      return [ops.divNoNan(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "FloorDiv": {
      return [ops.floorDiv(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Sub": {
      return [ops.sub(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Minimum": {
      return [ops.minimum(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Maximum": {
      return [ops.maximum(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Pow": {
      return [ops.pow(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "SquaredDifference": {
      return [ops.squaredDifference(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$j = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Abs":
    case "ComplexAbs":
      return [ops.abs(getParamValue("x", node, tensorMap, context2))];
    case "Acos":
      return [ops.acos(getParamValue("x", node, tensorMap, context2))];
    case "Acosh":
      return [ops.acosh(getParamValue("x", node, tensorMap, context2))];
    case "Asin":
      return [ops.asin(getParamValue("x", node, tensorMap, context2))];
    case "Asinh":
      return [ops.asinh(getParamValue("x", node, tensorMap, context2))];
    case "Atan":
      return [ops.atan(getParamValue("x", node, tensorMap, context2))];
    case "Atan2":
      return [ops.atan2(getParamValue("x", node, tensorMap, context2), getParamValue("y", node, tensorMap, context2))];
    case "Atanh":
      return [ops.atanh(getParamValue("x", node, tensorMap, context2))];
    case "Ceil":
      return [ops.ceil(getParamValue("x", node, tensorMap, context2))];
    case "Complex":
      return [ops.complex(getParamValue("real", node, tensorMap, context2), getParamValue("imag", node, tensorMap, context2))];
    case "Cos":
      return [ops.cos(getParamValue("x", node, tensorMap, context2))];
    case "Cosh":
      return [ops.cosh(getParamValue("x", node, tensorMap, context2))];
    case "Elu":
      return [ops.elu(getParamValue("x", node, tensorMap, context2))];
    case "Erf":
      return [ops.erf(getParamValue("x", node, tensorMap, context2))];
    case "Exp":
      return [ops.exp(getParamValue("x", node, tensorMap, context2))];
    case "Expm1": {
      return [ops.expm1(getParamValue("x", node, tensorMap, context2))];
    }
    case "Floor":
      return [ops.floor(getParamValue("x", node, tensorMap, context2))];
    case "Log":
      return [ops.log(getParamValue("x", node, tensorMap, context2))];
    case "Log1p": {
      return [ops.log1p(getParamValue("x", node, tensorMap, context2))];
    }
    case "Imag":
      return [ops.imag(getParamValue("x", node, tensorMap, context2))];
    case "Neg":
      return [ops.neg(getParamValue("x", node, tensorMap, context2))];
    case "Reciprocal": {
      return [ops.reciprocal(getParamValue("x", node, tensorMap, context2))];
    }
    case "Real":
      return [ops.real(getParamValue("x", node, tensorMap, context2))];
    case "Relu":
      return [ops.relu(getParamValue("x", node, tensorMap, context2))];
    case "Round": {
      return [ops.round(getParamValue("x", node, tensorMap, context2))];
    }
    case "Selu":
      return [ops.selu(getParamValue("x", node, tensorMap, context2))];
    case "Sigmoid":
      return [ops.sigmoid(getParamValue("x", node, tensorMap, context2))];
    case "Sin":
      return [ops.sin(getParamValue("x", node, tensorMap, context2))];
    case "Sign": {
      return [ops.sign(getParamValue("x", node, tensorMap, context2))];
    }
    case "Sinh": {
      return [ops.sinh(getParamValue("x", node, tensorMap, context2))];
    }
    case "Softplus": {
      return [ops.softplus(getParamValue("x", node, tensorMap, context2))];
    }
    case "Sqrt": {
      return [ops.sqrt(getParamValue("x", node, tensorMap, context2))];
    }
    case "Square": {
      return [ops.square(getParamValue("x", node, tensorMap, context2))];
    }
    case "Tanh": {
      return [ops.tanh(getParamValue("x", node, tensorMap, context2))];
    }
    case "Tan":
      return [ops.tan(getParamValue("x", node, tensorMap, context2))];
    case "ClipByValue":
      return [ops.clipByValue(getParamValue("x", node, tensorMap, context2), getParamValue("clipValueMin", node, tensorMap, context2), getParamValue("clipValueMax", node, tensorMap, context2))];
    case "Relu6":
      return [ops.relu6(getParamValue("x", node, tensorMap, context2))];
    case "Rsqrt":
      return [ops.rsqrt(getTensor(node.inputNames[0], tensorMap, context2))];
    case "LeakyRelu":
      return [ops.leakyRelu(getParamValue("x", node, tensorMap, context2), getParamValue("alpha", node, tensorMap, context2))];
    case "Prelu":
      return [ops.prelu(getParamValue("x", node, tensorMap, context2), getParamValue("alpha", node, tensorMap, context2))];
    case "IsNan":
      return [ops.isNaN(getTensor(node.inputNames[0], tensorMap, context2))];
    case "IsInf":
      return [ops.isInf(getTensor(node.inputNames[0], tensorMap, context2))];
    case "IsFinite":
      return [ops.isFinite(getTensor(node.inputNames[0], tensorMap, context2))];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
  if (typeof shapeA === "number" || typeof shapeB === "number") {
    return;
  }
  assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  for (let i = 0; i < shapeA.length; i++) {
    const dim0 = shapeA[i];
    const dim1 = shapeB[i];
    assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
}
function fullDefinedShape(elementShape) {
  if (typeof elementShape === "number" || elementShape.some((dim) => dim < 0)) {
    return false;
  }
  return true;
}
function inferElementShape(listElementShape, tensors, elementShape) {
  let partialShape = mergeElementShape(listElementShape, elementShape);
  const notfullDefinedShape = !fullDefinedShape(partialShape);
  if (notfullDefinedShape && tensors.length === 0) {
    throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${partialShape}`);
  }
  if (notfullDefinedShape) {
    tensors.forEach((tensor2) => {
      partialShape = mergeElementShape(tensor2.shape, partialShape);
    });
  }
  if (!fullDefinedShape(partialShape)) {
    throw new Error(`Non-fully-defined elementShape: ${partialShape}`);
  }
  return partialShape;
}
function mergeElementShape(elementShapeA, elementShapeB) {
  if (typeof elementShapeA === "number") {
    return elementShapeB;
  }
  if (typeof elementShapeB === "number") {
    return elementShapeA;
  }
  if (elementShapeA.length !== elementShapeB.length) {
    throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);
  }
  const result = [];
  for (let i = 0; i < elementShapeA.length; ++i) {
    const dim0 = elementShapeA[i];
    const dim1 = elementShapeB[i];
    if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
      throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);
    }
    result[i] = dim0 >= 0 ? dim0 : dim1;
  }
  return result;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorArray {
  constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
    this.name = name;
    this.dtype = dtype;
    this.maxSize = maxSize;
    this.elementShape = elementShape;
    this.identicalElementShapes = identicalElementShapes;
    this.dynamicSize = dynamicSize;
    this.clearAfterRead = clearAfterRead;
    this.tensors = [];
    this.closed_ = false;
    this.idTensor = scalar(0);
    keep(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  /**
   * Dispose the tensors and idTensor and mark the TensoryArray as closed.
   */
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor2) => {
      if (keepIds == null || !keepIds.has(tensor2.tensor.id)) {
        tensor2.tensor.dispose();
      }
    });
    this.tensors = [];
    this.closed_ = true;
    this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  /**
   * Read the value at location index in the TensorArray.
   * @param index Number the index to read from.
   */
  read(index) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || index >= this.size()) {
      throw new Error(`Tried to read from index ${index}, but array size is: ${this.size()}`);
    }
    const tensorWithState = this.tensors[index];
    if (tensorWithState.cleared) {
      throw new Error(`TensorArray ${this.name}: Could not read index ${index} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
    }
    if (this.clearAfterRead) {
      tensorWithState.cleared = true;
    }
    tensorWithState.read = true;
    return tensorWithState.tensor;
  }
  /**
   * Helper method to read multiple tensors from the specified indices.
   */
  readMany(indices) {
    return indices.map((index) => this.read(index));
  }
  /**
   * Write value into the index of the TensorArray.
   * @param index number the index to write to.
   * @param tensor
   */
  write(index, tensor2) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || !this.dynamicSize && index >= this.maxSize) {
      throw new Error(`Tried to write to index ${index}, but array is not resizeable and size is: ${this.maxSize}`);
    }
    const t = this.tensors[index] || {};
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index},
          because the value dtype is ${tensor2.dtype}, but TensorArray dtype is ${this.dtype}.`);
    }
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
      this.elementShape = tensor2.shape;
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index}.`);
    if (t.read) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been read.`);
    }
    if (t.written) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been written.`);
    }
    t.tensor = tensor2;
    keep(tensor2);
    t.written = true;
    this.tensors[index] = t;
  }
  /**
   * Helper method to write multiple tensors to the specified indices.
   */
  writeMany(indices, tensors) {
    if (indices.length !== tensors.length) {
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
    }
    indices.forEach((i, index) => this.write(i, tensors[index]));
  }
  /**
   * Return selected values in the TensorArray as a packed Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param [indices] number[] Optional. Taking values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size(). If not specified returns
   *    all tensors in the original order.
   * @param [dtype]
   */
  gather(indices, dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
    }
    if (!indices) {
      indices = [];
      for (let i = 0; i < this.size(); i++) {
        indices.push(i);
      }
    } else {
      indices = indices.slice(0, this.size());
    }
    if (indices.length === 0) {
      return tensor([], [0].concat(this.elementShape));
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
    return stack(tensors, 0);
  }
  /**
   * Return the values in the TensorArray as a concatenated Tensor.
   */
  concat(dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
    }
    if (this.size() === 0) {
      return tensor([], [0].concat(this.elementShape));
    }
    const indices = [];
    for (let i = 0; i < this.size(); i++) {
      indices.push(i);
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
    return concat(tensors, 0);
  }
  /**
   * Scatter the values of a Tensor in specific indices of a TensorArray.
   * @param indices number[] values in [0, max_value). If the
   *    TensorArray is not dynamic, max_value=size().
   * @param tensor Tensor input tensor.
   */
  scatter(indices, tensor2) {
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
    }
    if (indices.length !== tensor2.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
    }
    const maxIndex = Math.max(...indices);
    if (!this.dynamicSize && maxIndex >= this.maxSize) {
      throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
    }
    this.writeMany(indices, unstack(tensor2, 0));
  }
  /**
   * Split the values of a Tensor into the TensorArray.
   * @param length number[] with the lengths to use when splitting value along
   *    its first dimension.
   * @param tensor Tensor, the tensor to split.
   */
  split(length, tensor2) {
    if (tensor2.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor2.dtype}`);
    }
    let totalLength = 0;
    const cumulativeLengths = length.map((len) => {
      totalLength += len;
      return totalLength;
    });
    if (totalLength !== tensor2.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
    }
    if (!this.dynamicSize && length.length !== this.maxSize) {
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), and the TensorArray is not marked as dynamically resizeable`);
    }
    const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
    const tensors = [];
    tidy(() => {
      tensor2 = reshape(tensor2, [1, totalLength, elementPerRow]);
      for (let i = 0; i < length.length; ++i) {
        const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
        const indices2 = [0, previousLength, 0];
        const sizes = [1, length[i], elementPerRow];
        tensors[i] = reshape(slice(tensor2, indices2, sizes), this.elementShape);
      }
      return tensors;
    });
    const indices = [];
    for (let i = 0; i < length.length; i++) {
      indices[i] = i;
    }
    this.writeMany(indices, tensors);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class TensorList {
  get id() {
    return this.idTensor.id;
  }
  /**
   *
   * @param tensors list of tensors
   * @param elementShape shape of each tensor, this can be a single number (any
   * shape is allowed) or partial shape (dim = -1).
   * @param elementDtype data type of each tensor
   * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1
   *   meaning that the size of `tensors` is unbounded.
   */
  constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
    this.tensors = tensors;
    this.elementShape = elementShape;
    this.elementDtype = elementDtype;
    if (tensors != null) {
      tensors.forEach((tensor2) => {
        if (elementDtype !== tensor2.dtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor2.dtype}`);
        }
        assertShapesMatchAllowUndefinedSize(elementShape, tensor2.shape, "TensorList shape mismatch: ");
        keep(tensor2);
      });
    }
    this.idTensor = scalar(0);
    this.maxNumElements = maxNumElements;
    keep(this.idTensor);
  }
  /**
   * Get a new TensorList containing a copy of the underlying tensor container.
   */
  copy() {
    return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
  }
  /**
   * Dispose the tensors and idTensor and clear the tensor list.
   */
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor2) => {
      if (keepIds == null || !keepIds.has(tensor2.id)) {
        tensor2.dispose();
      }
    });
    this.tensors.length = 0;
    this.idTensor.dispose();
  }
  /**
   * The size of the tensors in the tensor list.
   */
  size() {
    return this.tensors.length;
  }
  /**
   * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)
   * tf.Tensor.
   * @param elementShape shape of each tensor
   * @param elementDtype data type of each tensor
   * @param numElements the number of elements to stack
   */
  stack(elementShape, elementDtype, numElements = -1) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (numElements !== -1 && this.tensors.length !== numElements) {
      throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return tidy(() => {
      const reshapedTensors = this.tensors.map((tensor2) => reshape(tensor2, outputElementShape));
      return stack(reshapedTensors, 0);
    });
  }
  /**
   * Pop a tensor from the end of the list.
   * @param elementShape shape of the tensor
   * @param elementDtype data type of the tensor
   */
  popBack(elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (this.size() === 0) {
      throw new Error("Trying to pop from an empty list.");
    }
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    const tensor2 = this.tensors.pop();
    tensor2.kept = false;
    assertShapesMatchAllowUndefinedSize(tensor2.shape, elementShape, "TensorList shape mismatch: ");
    return reshape(tensor2, outputElementShape);
  }
  /**
   * Push a tensor to the end of the list.
   * @param tensor Tensor to be pushed.
   */
  pushBack(tensor2) {
    if (tensor2.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(tensor2.shape, this.elementShape, "TensorList shape mismatch: ");
    if (this.maxNumElements === this.size()) {
      throw new Error(`Trying to push element into a full list.`);
    }
    keep(tensor2);
    this.tensors.push(tensor2);
  }
  /**
   * Update the size of the list.
   * @param size the new size of the list.
   */
  resize(size) {
    if (size < 0) {
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);
    }
    if (this.maxNumElements !== -1 && size > this.maxNumElements) {
      throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);
    }
    const destTensorList = new TensorList([], this.elementShape, this.elementDtype, this.maxNumElements);
    destTensorList.tensors.length = size;
    for (let i = 0; i < Math.min(this.tensors.length, size); ++i) {
      destTensorList.tensors[i] = this.tensors[i];
    }
    return destTensorList;
  }
  /**
   * Retrieve the element at the provided index
   * @param elementShape shape of the tensor
   * @param elementDtype dtype of the tensor
   * @param elementIndex index of the tensor
   */
  getItem(elementIndex, elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || elementIndex > this.tensors.length) {
      throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
    }
    if (this.tensors[elementIndex] == null) {
      throw new Error(`element at index ${elementIndex} is null.`);
    }
    assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return reshape(this.tensors[elementIndex], outputElementShape);
  }
  /**
   * Set the tensor at the index
   * @param elementIndex index of the tensor
   * @param tensor the tensor to be inserted into the list
   */
  setItem(elementIndex, tensor2) {
    if (tensor2.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
      throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor2.shape, "TensorList shape mismatch: ");
    keep(tensor2);
    if (this.tensors[elementIndex] != null) {
      this.tensors[elementIndex].kept = false;
    }
    this.tensors[elementIndex] = tensor2;
  }
  /**
   * Return selected values in the TensorList as a stacked Tensor. All of
   * selected values must have been written and their shapes must all match.
   * @param indices indices of tensors to gather
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  gather(indices, elementDtype, elementShape) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    indices = indices.slice(0, this.size());
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (indices.length === 0) {
      return tensor([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = indices.map((i) => reshape(this.tensors[i], outputElementShape));
      return stack(tensors, 0);
    });
  }
  /**
   * Return the values in the TensorList as a concatenated Tensor.
   * @param elementDtype output tensor dtype
   * @param elementShape output tensor element shape
   */
  concat(elementDtype, elementShape) {
    if (!!elementDtype && elementDtype !== this.elementDtype) {
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (this.size() === 0) {
      return tensor([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = this.tensors.map((t) => reshape(t, outputElementShape));
      return concat(tensors, 0);
    });
  }
}
function fromTensor(tensor2, elementShape, elementDtype) {
  const dtype = tensor2.dtype;
  if (tensor2.shape.length < 1) {
    throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor2.shape}`);
  }
  if (tensor2.dtype !== elementDtype) {
    throw new Error(`Invalid data types; op elements ${tensor2.dtype}, but list elements ${elementDtype}`);
  }
  const tensorElementShape = tensor2.shape.slice(1);
  assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
  const tensorList = unstack(tensor2);
  return new TensorList(tensorList, elementShape, dtype);
}
function reserve(elementShape, elementDtype, numElements, maxNumElements) {
  return new TensorList([], elementShape, elementDtype, maxNumElements);
}
function scatter(tensor2, indices, elementShape, numElements) {
  if (indices.length !== tensor2.shape[0]) {
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor2.shape[0]}`);
  }
  const maxIndex = Math.max(...indices);
  if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
    throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
  }
  const list = new TensorList([], elementShape, tensor2.dtype, numElements);
  const tensors = unstack(tensor2, 0);
  indices.forEach((value, index) => {
    list.setItem(value, tensors[index]);
  });
  return list;
}
function split(tensor2, length, elementShape) {
  let totalLength = 0;
  const cumulativeLengths = length.map((len) => {
    totalLength += len;
    return totalLength;
  });
  if (totalLength !== tensor2.shape[0]) {
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor2.shape}`);
  }
  const shapeWithoutFirstDim = tensor2.shape.slice(1);
  const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
  const elementPerRow = totalLength === 0 ? 0 : tensor2.size / totalLength;
  const tensors = tidy(() => {
    const tensors2 = [];
    tensor2 = reshape(tensor2, [1, totalLength, elementPerRow]);
    for (let i = 0; i < length.length; ++i) {
      const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
      const indices = [0, previousLength, 0];
      const sizes = [1, length[i], elementPerRow];
      tensors2[i] = reshape(slice(tensor2, indices, sizes), outputElementShape);
    }
    tensor2.dispose();
    return tensors2;
  });
  const list = new TensorList([], elementShape, tensor2.dtype, length.length);
  for (let i = 0; i < tensors.length; i++) {
    list.setItem(i, tensors[i]);
  }
  return list;
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$i = async (node, tensorMap, context2) => {
  switch (node.op) {
    case "If":
    case "StatelessIf": {
      const thenFunc = getParamValue("thenBranch", node, tensorMap, context2);
      const elseFunc = getParamValue("elseBranch", node, tensorMap, context2);
      const cond = getParamValue("cond", node, tensorMap, context2);
      const args = getParamValue("args", node, tensorMap, context2);
      const condValue = await cond.data();
      if (condValue[0]) {
        return context2.functionMap[thenFunc].executeFunctionAsync(args, context2.tensorArrayMap, context2.tensorListMap);
      } else {
        return context2.functionMap[elseFunc].executeFunctionAsync(args, context2.tensorArrayMap, context2.tensorListMap);
      }
    }
    case "While":
    case "StatelessWhile": {
      const bodyFunc = getParamValue("body", node, tensorMap, context2);
      const condFunc = getParamValue("cond", node, tensorMap, context2);
      const args = getParamValue("args", node, tensorMap, context2);
      const condResult = await context2.functionMap[condFunc].executeFunctionAsync(args, context2.tensorArrayMap, context2.tensorListMap);
      const argIds = args.map((tensor2) => tensor2.id);
      let condValue = await condResult[0].data();
      condResult.forEach((tensor2) => {
        if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1) {
          tensor2.dispose();
        }
      });
      let result = args;
      while (condValue[0]) {
        const origResult = result;
        result = await context2.functionMap[bodyFunc].executeFunctionAsync(result, context2.tensorArrayMap, context2.tensorListMap);
        const resultIds = result.map((tensor2) => tensor2.id);
        origResult.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
        const condResult2 = await context2.functionMap[condFunc].executeFunctionAsync(result, context2.tensorArrayMap, context2.tensorListMap);
        condValue = await condResult2[0].data();
        condResult2.forEach((tensor2) => {
          if (!tensor2.kept && argIds.indexOf(tensor2.id) === -1 && resultIds.indexOf(tensor2.id) === -1) {
            tensor2.dispose();
          }
        });
      }
      return result;
    }
    case "LoopCond": {
      const pred = getParamValue("pred", node, tensorMap, context2);
      return [cloneTensor(pred)];
    }
    case "Switch": {
      const pred = getParamValue("pred", node, tensorMap, context2);
      let data = getParamValue("data", node, tensorMap, context2);
      if (!data.kept) {
        data = cloneTensor(data);
      }
      return (await pred.data())[0] ? [void 0, data] : [data, void 0];
    }
    case "Merge": {
      const inputName = node.inputNames.find((name) => getTensor(name, tensorMap, context2) !== void 0);
      if (inputName) {
        const data = getTensor(inputName, tensorMap, context2);
        return [cloneTensor(data)];
      }
      return void 0;
    }
    case "Enter": {
      const frameId = getParamValue("frameName", node, tensorMap, context2);
      const data = getParamValue("tensor", node, tensorMap, context2);
      context2.enterFrame(frameId);
      return [cloneTensor(data)];
    }
    case "Exit": {
      const data = getParamValue("tensor", node, tensorMap, context2);
      context2.exitFrame();
      return [cloneTensor(data)];
    }
    case "NextIteration": {
      const data = getParamValue("tensor", node, tensorMap, context2);
      context2.nextIteration();
      return [cloneTensor(data)];
    }
    case "TensorArrayV3": {
      const size = getParamValue("size", node, tensorMap, context2);
      const dtype = getParamValue("dtype", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const dynamicSize = getParamValue("dynamicSize", node, tensorMap, context2);
      const clearAfterRead = getParamValue("clearAfterRead", node, tensorMap, context2);
      const identicalElementShapes = getParamValue("identicalElementShapes", node, tensorMap, context2);
      const name = getParamValue("name", node, tensorMap, context2);
      const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
      context2.addTensorArray(tensorArray);
      return [tensorArray.idTensor, scalar(1)];
    }
    case "TensorArrayWriteV3": {
      const id2 = getParamValue("tensorArrayId", node, tensorMap, context2);
      const index = getParamValue("index", node, tensorMap, context2);
      const writeTensor = getParamValue("tensor", node, tensorMap, context2);
      const writeTensorArray = context2.getTensorArray(id2.id);
      writeTensorArray.write(index, writeTensor);
      return [writeTensorArray.idTensor];
    }
    case "TensorArrayReadV3": {
      const readId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const readIndex = getParamValue("index", node, tensorMap, context2);
      const readTensorArray = context2.getTensorArray(readId.id);
      return [readTensorArray.read(readIndex)];
    }
    case "TensorArrayGatherV3": {
      const gatherId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const gatherIndices = getParamValue("indices", node, tensorMap, context2);
      const gatherDtype = getParamValue("dtype", node, tensorMap, context2);
      const gatherTensorArray = context2.getTensorArray(gatherId.id);
      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
    }
    case "TensorArrayScatterV3": {
      const scatterId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const scatterIndices = getParamValue("indices", node, tensorMap, context2);
      const scatterTensor = getParamValue("tensor", node, tensorMap, context2);
      const scatterTensorArray = context2.getTensorArray(scatterId.id);
      scatterTensorArray.scatter(scatterIndices, scatterTensor);
      return [scatterTensorArray.idTensor];
    }
    case "TensorArrayConcatV3": {
      const concatId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const concatTensorArray = context2.getTensorArray(concatId.id);
      const concatDtype = getParamValue("dtype", node, tensorMap, context2);
      return [concatTensorArray.concat(concatDtype)];
    }
    case "TensorArraySplitV3": {
      const splitId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const splitTensor = getParamValue("tensor", node, tensorMap, context2);
      const lengths = getParamValue("lengths", node, tensorMap, context2);
      const splitTensorArray = context2.getTensorArray(splitId.id);
      splitTensorArray.split(lengths, splitTensor);
      return [splitTensorArray.idTensor];
    }
    case "TensorArraySizeV3": {
      const sizeId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const sizeTensorArray = context2.getTensorArray(sizeId.id);
      return [scalar(sizeTensorArray.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const closeId = getParamValue("tensorArrayId", node, tensorMap, context2);
      const closeTensorArray = context2.getTensorArray(closeId.id);
      closeTensorArray.clearAndClose();
      return [closeTensorArray.idTensor];
    }
    case "TensorListSetItem": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const index = getParamValue("index", node, tensorMap, context2);
      const writeTensor = getParamValue("tensor", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      tensorList.setItem(index, writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListGetItem": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const readIndex = getParamValue("index", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDType = getParamValue("elementDType", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      return [tensorList.getItem(readIndex, elementShape, elementDType)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const scatterIndices = getParamValue("indices", node, tensorMap, context2);
      const scatterTensor = getParamValue("tensor", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const numElements = getParamValue("numElements", node, tensorMap, context2);
      const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
      context2.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context2);
      let numElementsParam;
      if (node.op === "TensorListReserve") {
        numElementsParam = "numElements";
      } else {
        numElementsParam = "maxNumElements";
      }
      const numElements = getParamValue(numElementsParam, node, tensorMap, context2);
      const maxNumElements = node.op === "TensorListReserve" ? -1 : numElements;
      const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);
      context2.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListGather": {
      const gatherId = getParamValue("tensorListId", node, tensorMap, context2);
      const gatherIndices = getParamValue("indices", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context2);
      const tensorList = context2.getTensorList(gatherId.id);
      return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
    }
    case "TensorListStack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context2);
      const numElements = getParamValue("numElements", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      return [tensorList.stack(elementShape, elementDtype, numElements)];
    }
    case "TensorListFromTensor": {
      const tensor2 = getParamValue("tensor", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context2);
      const tensorList = fromTensor(tensor2, elementShape, elementDtype);
      context2.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const concatId = getParamValue("tensorListId", node, tensorMap, context2);
      const tensorList = context2.getTensorList(concatId.id);
      const concatDtype = getParamValue("dtype", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      return [tensorList.concat(concatDtype, elementShape)];
    }
    case "TensorListPushBack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const writeTensor = getParamValue("tensor", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      tensorList.pushBack(writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListPopBack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const elementDType = getParamValue("elementDType", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      return [tensorList.popBack(elementShape, elementDType)];
    }
    case "TensorListSplit": {
      const splitTensor = getParamValue("tensor", node, tensorMap, context2);
      const elementShape = getParamValue("elementShape", node, tensorMap, context2);
      const lengths = getParamValue("lengths", node, tensorMap, context2);
      const tensorList = split(splitTensor, lengths, elementShape);
      context2.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListLength": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const tensorList = context2.getTensorList(idTensor.id);
      return [scalar(tensorList.size(), "int32")];
    }
    case "TensorListResize": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context2);
      const size = getParamValue("size", node, tensorMap, context2);
      const srcTensorList = context2.getTensorList(idTensor.id);
      const destTensorList = srcTensorList.resize(size);
      context2.addTensorList(destTensorList);
      return [destTensorList.idTensor];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function fusedConvAndDepthWiseParams(node, tensorMap, context2) {
  const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context2);
  const isBiasAdd = extraOp === "biasadd";
  const noBiasAdd = !isBiasAdd;
  const isPrelu = activationFunc === "prelu";
  const isBatchNorm = extraOp === "fusedbatchnorm";
  const numArgs = getParamValue("numArgs", node, tensorMap, context2);
  if (isBiasAdd) {
    if (isPrelu && numArgs !== 2) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    }
    if (!isPrelu && isBiasAdd && numArgs !== 1) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
    }
  }
  if (isBatchNorm) {
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  }
  const stride = getParamValue("strides", node, tensorMap, context2);
  const pad2 = getPadding(node, tensorMap, context2);
  const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
  const dilations = getParamValue("dilations", node, tensorMap, context2);
  let [biasArg, preluArg] = getParamValue("args", node, tensorMap, context2);
  if (noBiasAdd) {
    preluArg = biasArg;
    biasArg = void 0;
  }
  const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context2);
  return {
    stride,
    pad: pad2,
    dataFormat,
    dilations,
    biasArg,
    preluArg,
    activationFunc,
    leakyreluAlpha
  };
}
const executeOp$h = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Conv1D": {
      const stride = getParamValue("stride", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
      const dilation = getParamValue("dilation", node, tensorMap, context2);
      return [ops.conv1d(getParamValue("x", node, tensorMap, context2), getParamValue("filter", node, tensorMap, context2), stride, pad2, dataFormat, dilation)];
    }
    case "Conv2D": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getPadding(node, tensorMap, context2);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
      const dilations = getParamValue("dilations", node, tensorMap, context2);
      return [ops.conv2d(getParamValue("x", node, tensorMap, context2), getParamValue("filter", node, tensorMap, context2), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
    }
    case "_FusedConv2D": {
      const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context2);
      return [ops.fused.conv2d({
        x: getParamValue("x", node, tensorMap, context2),
        filter: getParamValue("filter", node, tensorMap, context2),
        strides: [stride[1], stride[2]],
        pad: pad2,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride, pad: pad2, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context2);
      return [ops.fused.depthwiseConv2d({
        x: getParamValue("x", node, tensorMap, context2),
        filter: getParamValue("filter", node, tensorMap, context2),
        strides: [stride[1], stride[2]],
        pad: pad2,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const shape = getParamValue("outputShape", node, tensorMap, context2);
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getPadding(node, tensorMap, context2);
      return [ops.conv2dTranspose(getParamValue("x", node, tensorMap, context2), getParamValue("filter", node, tensorMap, context2), shape, [stride[1], stride[2]], pad2)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getPadding(node, tensorMap, context2);
      const dilations = getParamValue("dilations", node, tensorMap, context2);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
      return [ops.depthwiseConv2d(getParamValue("input", node, tensorMap, context2), getParamValue("filter", node, tensorMap, context2), [stride[1], stride[2]], pad2, dataFormat, [dilations[1], dilations[2]])];
    }
    case "Conv3D": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
      const dilations = getParamValue("dilations", node, tensorMap, context2);
      return [ops.conv3d(getParamValue("x", node, tensorMap, context2), getParamValue("filter", node, tensorMap, context2), [stride[1], stride[2], stride[3]], pad2, dataFormat, [dilations[1], dilations[2], dilations[3]])];
    }
    case "AvgPool": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context2);
      return [ops.avgPool(getParamValue("x", node, tensorMap, context2), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
    }
    case "MaxPool": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context2);
      return [ops.maxPool(getParamValue("x", node, tensorMap, context2), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2)];
    }
    case "MaxPoolWithArgmax": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context2);
      const includeBatchInIndex = getParamValue("includeBatchInIndex", node, tensorMap, context2);
      const { result, indexes } = ops.maxPoolWithArgmax(getParamValue("x", node, tensorMap, context2), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad2, includeBatchInIndex);
      return [result, indexes];
    }
    case "AvgPool3D": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context2);
      return [ops.avgPool3d(getParamValue("x", node, tensorMap, context2), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
    }
    case "MaxPool3D": {
      const stride = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context2);
      return [ops.maxPool3d(getParamValue("x", node, tensorMap, context2), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad2)];
    }
    case "Dilation2D": {
      const strides = getParamValue("strides", node, tensorMap, context2);
      const pad2 = getParamValue("pad", node, tensorMap, context2);
      const dilations = getParamValue("dilations", node, tensorMap, context2);
      const strideHeight = strides[1];
      const strideWidth = strides[2];
      const dilationHeight = dilations[1];
      const dilationWidth = dilations[2];
      return [ops.dilation2d(
        getParamValue("x", node, tensorMap, context2),
        getParamValue("filter", node, tensorMap, context2),
        [strideHeight, strideWidth],
        pad2,
        [dilationHeight, dilationWidth],
        "NHWC"
        /* dataFormat */
      )];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$g = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Fill": {
      const shape = getParamValue("shape", node, tensorMap, context2);
      const dtype = getParamValue("dtype", node, tensorMap, context2);
      const value = getParamValue("value", node, tensorMap, context2);
      return [ops.fill(shape, value, dtype)];
    }
    case "LinSpace": {
      const start2 = getParamValue("start", node, tensorMap, context2);
      const stop2 = getParamValue("stop", node, tensorMap, context2);
      const num = getParamValue("num", node, tensorMap, context2);
      return [ops.linspace(start2, stop2, num)];
    }
    case "Multinomial": {
      const logits = getParamValue("logits", node, tensorMap, context2);
      const numSamples = getParamValue("numSamples", node, tensorMap, context2);
      const seed = getParamValue("seed", node, tensorMap, context2);
      return [ops.multinomial(logits, numSamples, seed)];
    }
    case "OneHot": {
      const indices = getParamValue("indices", node, tensorMap, context2);
      const depth = getParamValue("depth", node, tensorMap, context2);
      const onValue = getParamValue("onValue", node, tensorMap, context2);
      const offValue = getParamValue("offValue", node, tensorMap, context2);
      const dtype = getParamValue("dtype", node, tensorMap, context2);
      return [ops.oneHot(indices, depth, onValue, offValue, dtype)];
    }
    case "Ones": {
      return [ops.ones(getParamValue("shape", node, tensorMap, context2), getParamValue("dtype", node, tensorMap, context2))];
    }
    case "OnesLike": {
      return [ops.onesLike(getParamValue("x", node, tensorMap, context2))];
    }
    case "RandomStandardNormal": {
      return [ops.randomStandardNormal(getParamValue("shape", node, tensorMap, context2), getParamValue("dtype", node, tensorMap, context2), getParamValue("seed", node, tensorMap, context2))];
    }
    case "RandomUniform": {
      return [ops.randomUniform(
        // tslint:disable-next-line:no-any
        getParamValue("shape", node, tensorMap, context2),
        getParamValue("minval", node, tensorMap, context2),
        getParamValue("maxval", node, tensorMap, context2),
        getParamValue("dtype", node, tensorMap, context2)
      )];
    }
    case "RandomUniformInt": {
      return [ops.randomUniformInt(getParamValue("shape", node, tensorMap, context2), getParamValue("minval", node, tensorMap, context2), getParamValue("maxval", node, tensorMap, context2), getParamValue("seed", node, tensorMap, context2))];
    }
    case "Range": {
      const start2 = getParamValue("start", node, tensorMap, context2);
      const stop2 = getParamValue("stop", node, tensorMap, context2);
      const step2 = getParamValue("step", node, tensorMap, context2);
      return [ops.range(start2, stop2, step2, getParamValue("dtype", node, tensorMap, context2))];
    }
    case "TruncatedNormal": {
      const shape = getParamValue("shape", node, tensorMap, context2);
      const mean2 = getParamValue("mean", node, tensorMap, context2);
      const stdDev = getParamValue("stdDev", node, tensorMap, context2);
      const seed = getParamValue("seed", node, tensorMap, context2);
      return [ops.truncatedNormal(shape, mean2, stdDev, getParamValue("dtype", node, tensorMap, context2), seed)];
    }
    case "Zeros": {
      return [ops.zeros(getParamValue("shape", node, tensorMap, context2), getParamValue("dtype", node, tensorMap, context2))];
    }
    case "ZerosLike": {
      return [ops.zerosLike(getParamValue("x", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function nmsParams(node, tensorMap, context2) {
  const boxes = getParamValue("boxes", node, tensorMap, context2);
  const scores = getParamValue("scores", node, tensorMap, context2);
  const maxOutputSize = getParamValue("maxOutputSize", node, tensorMap, context2);
  const iouThreshold = getParamValue("iouThreshold", node, tensorMap, context2);
  const scoreThreshold = getParamValue("scoreThreshold", node, tensorMap, context2);
  const softNmsSigma = getParamValue("softNmsSigma", node, tensorMap, context2);
  return {
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    softNmsSigma
  };
}
const executeOp$f = async (node, tensorMap, context2, resourceManager, ops = tfOps) => {
  switch (node.op) {
    case "NonMaxSuppressionV5": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node, tensorMap, context2);
      const result = await ops.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      return [result.selectedIndices, result.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context2);
      const padToMaxOutputSize = getParamValue("padToMaxOutputSize", node, tensorMap, context2);
      const result = await ops.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
      return [result.selectedIndices, result.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context2);
      return [await ops.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
    }
    case "Where": {
      const condition = ops.cast(getParamValue("condition", node, tensorMap, context2), "bool");
      const result = [await ops.whereAsync(condition)];
      condition.dispose();
      return result;
    }
    case "ListDiff": {
      return ops.setdiff1dAsync(getParamValue("x", node, tensorMap, context2), getParamValue("y", node, tensorMap, context2));
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$e = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "LowerBound": {
      const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context2);
      const values = getParamValue("values", node, tensorMap, context2);
      return [ops.lowerBound(sortedSequence, values)];
    }
    case "TopKV2": {
      const x = getParamValue("x", node, tensorMap, context2);
      const k = getParamValue("k", node, tensorMap, context2);
      const sorted = getParamValue("sorted", node, tensorMap, context2);
      const result = ops.topk(x, k, sorted);
      return [result.values, result.indices];
    }
    case "UpperBound": {
      const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context2);
      const values = getParamValue("values", node, tensorMap, context2);
      return [ops.upperBound(sortedSequence, values)];
    }
    case "Unique": {
      const x = getParamValue("x", node, tensorMap, context2);
      const result = ops.unique(x);
      return [result.values, result.indices];
    }
    case "UniqueV2": {
      const x = getParamValue("x", node, tensorMap, context2);
      const axis = getParamValue("axis", node, tensorMap, context2);
      const result = ops.unique(x, axis);
      return [result.values, result.indices];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$d = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Const": {
      return tensorMap[node.name];
    }
    case "PlaceholderWithDefault":
      const def = getParamValue("default", node, tensorMap, context2);
      return [getTensor(node.name, tensorMap, context2) || def];
    case "Placeholder":
      return [getTensor(node.name, tensorMap, context2)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const data2 = getParamValue("x", node, tensorMap, context2);
      return [cloneTensor(data2)];
    }
    case "IdentityN":
      return getParamValue("x", node, tensorMap, context2).map((t) => cloneTensor(t));
    case "Snapshot":
      const snapshot = getParamValue("x", node, tensorMap, context2);
      return [cloneTensor(snapshot)];
    case "Shape":
      return [ops.tensor1d(getParamValue("x", node, tensorMap, context2).shape, "int32")];
    case "ShapeN":
      return getParamValue("x", node, tensorMap, context2).map((t) => ops.tensor1d(t.shape));
    case "Size":
      return [ops.scalar(getParamValue("x", node, tensorMap, context2).size, "int32")];
    case "Rank":
      return [ops.scalar(getParamValue("x", node, tensorMap, context2).rank, "int32")];
    case "NoOp":
      return [ops.scalar(1)];
    case "Print":
      const input = getParamValue("x", node, tensorMap, context2);
      const data = getParamValue("data", node, tensorMap, context2);
      const message = getParamValue("message", node, tensorMap, context2);
      const summarize = getParamValue("summarize", node, tensorMap, context2);
      console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");
      console.log(message);
      for (let i = 0; i < data.length; i++) {
        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));
      }
      return [input];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class HashTable {
  get id() {
    return this.handle.id;
  }
  /**
   * Constructor of HashTable. Creates a hash table.
   *
   * @param keyDType `dtype` of the table keys.
   * @param valueDType `dtype` of the table values.
   */
  constructor(keyDType, valueDType) {
    this.keyDType = keyDType;
    this.valueDType = valueDType;
    this.handle = scalar(0);
    this.tensorMap = /* @__PURE__ */ new Map();
    keep(this.handle);
  }
  /**
   * Dispose the tensors and handle and clear the hashtable.
   */
  clearAndClose() {
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    this.handle.dispose();
  }
  /**
   * The number of items in the hash table.
   */
  size() {
    return this.tensorMap.size;
  }
  /**
   * The number of items in the hash table as a rank-0 tensor.
   */
  tensorSize() {
    return scalar(this.size(), "int32");
  }
  /**
   * Replaces the contents of the table with the specified keys and values.
   * @param keys Keys to store in the hashtable.
   * @param values Values to store in the hashtable.
   */
  async import(keys, values) {
    this.checkKeyAndValueTensor(keys, values);
    const $keys = await keys.data();
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    return tidy(() => {
      const $values = unstack(values);
      const keysLength = $keys.length;
      const valuesLength = $values.length;
      assert(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ${keysLength} elements, the values has ${valuesLength} elements.`);
      for (let i = 0; i < keysLength; i++) {
        const key = $keys[i];
        const value = $values[i];
        keep(value);
        this.tensorMap.set(key, value);
      }
      return this.handle;
    });
  }
  /**
   * Looks up keys in a hash table, outputs the corresponding values.
   *
   * Performs batch lookups, for every element in the key tensor, `find`
   * stacks the corresponding value into the return tensor.
   *
   * If an element is not present in the table, the given `defaultValue` is
   * used.
   *
   * @param keys Keys to look up. Must have the same type as the keys of the
   *     table.
   * @param defaultValue The scalar `defaultValue` is the value output for keys
   *     not present in the table. It must also be of the same type as the
   *     table values.
   */
  async find(keys, defaultValue) {
    this.checkKeyAndValueTensor(keys, defaultValue);
    const $keys = await keys.data();
    return tidy(() => {
      const result = [];
      for (let i = 0; i < $keys.length; i++) {
        const key = $keys[i];
        const value = this.findWithDefault(key, defaultValue);
        result.push(value);
      }
      return stack(result);
    });
  }
  // tslint:disable-next-line: no-any
  findWithDefault(key, defaultValue) {
    const result = this.tensorMap.get(key);
    return result != null ? result : defaultValue;
  }
  checkKeyAndValueTensor(key, value) {
    if (key.dtype !== this.keyDType) {
      throw new Error(`Expect key dtype ${this.keyDType}, but got ${key.dtype}`);
    }
    if (value.dtype !== this.valueDType) {
      throw new Error(`Expect value dtype ${this.valueDType}, but got ${value.dtype}`);
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$c = async (node, tensorMap, context2, resourceManager) => {
  switch (node.op) {
    case "HashTable":
    case "HashTableV2": {
      const existingTableHandle = resourceManager.getHashTableHandleByName(node.name);
      if (existingTableHandle != null) {
        return [existingTableHandle];
      } else {
        const keyDType = getParamValue("keyDType", node, tensorMap, context2);
        const valueDType = getParamValue("valueDType", node, tensorMap, context2);
        const hashTable2 = new HashTable(keyDType, valueDType);
        resourceManager.addHashTable(node.name, hashTable2);
        return [hashTable2.handle];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context2, resourceManager);
      const keys = getParamValue("keys", node, tensorMap, context2);
      const values = getParamValue("values", node, tensorMap, context2);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [await hashTable2.import(keys, values)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context2, resourceManager);
      const keys = getParamValue("keys", node, tensorMap, context2);
      const defaultValue = getParamValue("defaultValue", node, tensorMap, context2);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [await hashTable2.find(keys, defaultValue)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context2, resourceManager);
      const hashTable2 = resourceManager.getHashTableById(handle.id);
      return [hashTable2.tensorSize()];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$b = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "ResizeBilinear": {
      const images = getParamValue("images", node, tensorMap, context2);
      const size = getParamValue("size", node, tensorMap, context2);
      const alignCorners = getParamValue("alignCorners", node, tensorMap, context2);
      const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context2);
      return [ops.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
    }
    case "ResizeNearestNeighbor": {
      const images = getParamValue("images", node, tensorMap, context2);
      const size = getParamValue("size", node, tensorMap, context2);
      const alignCorners = getParamValue("alignCorners", node, tensorMap, context2);
      const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context2);
      return [ops.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
    }
    case "CropAndResize": {
      const image2 = getParamValue("image", node, tensorMap, context2);
      const boxes = getParamValue("boxes", node, tensorMap, context2);
      const boxInd = getParamValue("boxInd", node, tensorMap, context2);
      const cropSize = getParamValue("cropSize", node, tensorMap, context2);
      const method = getParamValue("method", node, tensorMap, context2);
      const extrapolationValue = getParamValue("extrapolationValue", node, tensorMap, context2);
      return [ops.image.cropAndResize(image2, boxes, boxInd, cropSize, method, extrapolationValue)];
    }
    case "ImageProjectiveTransformV3": {
      const images = getParamValue("images", node, tensorMap, context2);
      const transforms = getParamValue("transforms", node, tensorMap, context2);
      const outputShape = getParamValue("outputShape", node, tensorMap, context2);
      const fillValue = getParamValue("fillValue", node, tensorMap, context2);
      const interpolation = getParamValue("interpolation", node, tensorMap, context2);
      const fillMode = getParamValue("fillMode", node, tensorMap, context2);
      return [ops.image.transform(images, transforms, interpolation.toLowerCase(), fillMode.toLowerCase(), fillValue, outputShape)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$a = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Equal": {
      return [ops.equal(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "NotEqual": {
      return [ops.notEqual(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Greater": {
      return [ops.greater(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "GreaterEqual": {
      return [ops.greaterEqual(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Less": {
      return [ops.less(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "LessEqual": {
      return [ops.lessEqual(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "LogicalAnd": {
      return [ops.logicalAnd(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "LogicalNot": {
      return [ops.logicalNot(getParamValue("a", node, tensorMap, context2))];
    }
    case "LogicalOr": {
      return [ops.logicalOr(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "Select":
    case "SelectV2": {
      return [ops.where(getParamValue("condition", node, tensorMap, context2), getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    case "BitwiseAnd": {
      return [ops.bitwiseAnd(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$9 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [ops.matMul(getParamValue("a", node, tensorMap, context2), getParamValue("b", node, tensorMap, context2), getParamValue("transposeA", node, tensorMap, context2), getParamValue("transposeB", node, tensorMap, context2))];
    case "Einsum":
      return [ops.einsum(getParamValue("equation", node, tensorMap, context2), ...getParamValue("tensors", node, tensorMap, context2))];
    case "Transpose":
      return [ops.transpose(getParamValue("x", node, tensorMap, context2), getParamValue("perm", node, tensorMap, context2))];
    case "_FusedMatMul":
      const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context2);
      const isBiasAdd = extraOp === "biasadd";
      const isPrelu = activationFunc === "prelu";
      const numArgs = getParamValue("numArgs", node, tensorMap, context2);
      const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context2);
      if (isBiasAdd) {
        if (isPrelu && numArgs !== 2) {
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        }
        if (!isPrelu && numArgs !== 1) {
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
        }
      }
      const [biasArg, preluArg] = getParamValue("args", node, tensorMap, context2);
      return [ops.fused.matMul({
        a: getParamValue("a", node, tensorMap, context2),
        b: getParamValue("b", node, tensorMap, context2),
        transposeA: getParamValue("transposeA", node, tensorMap, context2),
        transposeB: getParamValue("transposeB", node, tensorMap, context2),
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    case "MatrixBandPart":
      return [ops.linalg.bandPart(getParamValue("a", node, tensorMap, context2), getParamValue("numLower", node, tensorMap, context2), getParamValue("numUpper", node, tensorMap, context2))];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$8 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "EuclideanNorm":
      return [ops.euclideanNorm(getParamValue("x", node, tensorMap, context2), getParamValue("axis", node, tensorMap, context2), getParamValue("keepDims", node, tensorMap, context2))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2": {
      return [ops.batchNorm(getParamValue("x", node, tensorMap, context2), getParamValue("mean", node, tensorMap, context2), getParamValue("variance", node, tensorMap, context2), getParamValue("offset", node, tensorMap, context2), getParamValue("scale", node, tensorMap, context2), getParamValue("epsilon", node, tensorMap, context2))];
    }
    case "FusedBatchNormV3": {
      return [ops.batchNorm(getParamValue("x", node, tensorMap, context2), getParamValue("mean", node, tensorMap, context2), getParamValue("variance", node, tensorMap, context2), getParamValue("offset", node, tensorMap, context2), getParamValue("scale", node, tensorMap, context2), getParamValue("epsilon", node, tensorMap, context2))];
    }
    case "LRN": {
      return [ops.localResponseNormalization(getParamValue("x", node, tensorMap, context2), getParamValue("radius", node, tensorMap, context2), getParamValue("bias", node, tensorMap, context2), getParamValue("alpha", node, tensorMap, context2), getParamValue("beta", node, tensorMap, context2))];
    }
    case "Softmax": {
      return [ops.softmax(getParamValue("x", node, tensorMap, context2))];
    }
    case "LogSoftmax": {
      return [ops.logSoftmax(getParamValue("x", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$7 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "RaggedGather": {
      const { outputNestedSplits, outputDenseValues } = ops.raggedGather(getParamValue("paramsNestedSplits", node, tensorMap, context2), getParamValue("paramsDenseValues", node, tensorMap, context2), getParamValue("indices", node, tensorMap, context2), getParamValue("outputRaggedRank", node, tensorMap, context2));
      return outputNestedSplits.concat(outputDenseValues);
    }
    case "RaggedRange": {
      const { rtNestedSplits, rtDenseValues } = ops.raggedRange(getParamValue("starts", node, tensorMap, context2), getParamValue("limits", node, tensorMap, context2), getParamValue("splits", node, tensorMap, context2));
      return [rtNestedSplits, rtDenseValues];
    }
    case "RaggedTensorToTensor": {
      return [ops.raggedTensorToTensor(getParamValue("shape", node, tensorMap, context2), getParamValue("values", node, tensorMap, context2), getParamValue("defaultValue", node, tensorMap, context2), getParamValue("rowPartitionTensors", node, tensorMap, context2), getParamValue("rowPartitionTypes", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$6 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Max": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.max(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "Mean": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.mean(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "Min": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.min(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "Sum": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.sum(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "All": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.all(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "Any": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.any(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "ArgMax": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      return [ops.argMax(getParamValue("x", node, tensorMap, context2), axis)];
    }
    case "ArgMin": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      return [ops.argMin(getParamValue("x", node, tensorMap, context2), axis)];
    }
    case "Prod": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const keepDims = getParamValue("keepDims", node, tensorMap, context2);
      return [ops.prod(getParamValue("x", node, tensorMap, context2), axis, keepDims)];
    }
    case "Cumprod": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const exclusive = getParamValue("exclusive", node, tensorMap, context2);
      const reverse2 = getParamValue("reverse", node, tensorMap, context2);
      return [ops.cumprod(getParamValue("x", node, tensorMap, context2), axis, exclusive, reverse2)];
    }
    case "Cumsum": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const exclusive = getParamValue("exclusive", node, tensorMap, context2);
      const reverse2 = getParamValue("reverse", node, tensorMap, context2);
      return [ops.cumsum(getParamValue("x", node, tensorMap, context2), axis, exclusive, reverse2)];
    }
    case "Bincount":
      const x = getParamValue("x", node, tensorMap, context2);
      const weights = getParamValue("weights", node, tensorMap, context2);
      const size = getParamValue("size", node, tensorMap, context2);
      return [ops.bincount(x, weights, size)];
    case "DenseBincount": {
      const x2 = getParamValue("x", node, tensorMap, context2);
      const weights2 = getParamValue("weights", node, tensorMap, context2);
      const size2 = getParamValue("size", node, tensorMap, context2);
      const binaryOutput = getParamValue("binaryOutput", node, tensorMap, context2);
      return [ops.denseBincount(x2, weights2, size2, binaryOutput)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$5 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "ConcatV2":
    case "Concat": {
      const n = getParamValue("n", node, tensorMap, context2);
      const axis = getParamValue("axis", node, tensorMap, context2);
      let inputs = getParamValue("tensors", node, tensorMap, context2);
      inputs = inputs.slice(0, n);
      return [ops.concat(inputs, axis)];
    }
    case "Gather": {
      const input = getParamValue("x", node, tensorMap, context2);
      const indices = getParamValue("indices", node, tensorMap, context2);
      return [ops.gather(input, ops.cast(indices, "int32"), 0)];
    }
    case "GatherV2": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const batchDims = getParamValue("batchDims", node, tensorMap, context2);
      const input = getParamValue("x", node, tensorMap, context2);
      const indices = getParamValue("indices", node, tensorMap, context2);
      return [ops.gather(input, ops.cast(indices, "int32"), axis, batchDims)];
    }
    case "Reverse": {
      const dims = getParamValue("dims", node, tensorMap, context2);
      const axis = [];
      for (let i = 0; i < dims.length; i++) {
        if (dims[i]) {
          axis.push(i);
        }
      }
      const input = getParamValue("x", node, tensorMap, context2);
      return [ops.reverse(input, axis)];
    }
    case "ReverseV2": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const input = getParamValue("x", node, tensorMap, context2);
      return [ops.reverse(input, axis)];
    }
    case "Slice": {
      const begin = getParamValue("begin", node, tensorMap, context2);
      const size = getParamValue("size", node, tensorMap, context2);
      return [ops.slice(getParamValue("x", node, tensorMap, context2), begin, size)];
    }
    case "StridedSlice": {
      const begin = getParamValue("begin", node, tensorMap, context2);
      const end = getParamValue("end", node, tensorMap, context2);
      const strides = getParamValue("strides", node, tensorMap, context2);
      const beginMask = getParamValue("beginMask", node, tensorMap, context2);
      const endMask = getParamValue("endMask", node, tensorMap, context2);
      const ellipsisMask = getParamValue("ellipsisMask", node, tensorMap, context2);
      const newAxisMask = getParamValue("newAxisMask", node, tensorMap, context2);
      const shrinkAxisMask = getParamValue("shrinkAxisMask", node, tensorMap, context2);
      const tensor2 = getParamValue("x", node, tensorMap, context2);
      return [ops.stridedSlice(tensor2, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
    }
    case "Pack": {
      return tidy(() => {
        const axis = getParamValue("axis", node, tensorMap, context2);
        const tensors = getParamValue("tensors", node, tensorMap, context2);
        const shape = tensors[0].shape;
        const squeezedShape = ops.squeeze(tensors[0]).shape;
        const mapped = tensors.map((tensor2) => {
          const sameShape = arraysEqual$1(tensor2.shape, shape);
          if (!sameShape && !arraysEqual$1(ops.squeeze(tensor2).shape, squeezedShape)) {
            throw new Error("the input tensors shape does not match");
          }
          return sameShape ? tensor2 : ops.reshape(tensor2, shape);
        });
        return [ops.stack(mapped, axis)];
      });
    }
    case "Unpack": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const tensor2 = getParamValue("tensor", node, tensorMap, context2);
      return ops.unstack(tensor2, axis);
    }
    case "Tile": {
      const reps = getParamValue("reps", node, tensorMap, context2);
      return [ops.tile(getParamValue("x", node, tensorMap, context2), reps)];
    }
    case "Split":
    case "SplitV": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      const numOrSizeSplits = getParamValue("numOrSizeSplits", node, tensorMap, context2);
      const tensor2 = getParamValue("x", node, tensorMap, context2);
      return ops.split(tensor2, numOrSizeSplits, axis);
    }
    case "ScatterNd": {
      const indices = getParamValue("indices", node, tensorMap, context2);
      const values = getParamValue("values", node, tensorMap, context2);
      const shape = getParamValue("shape", node, tensorMap, context2);
      return [ops.scatterND(indices, values, shape)];
    }
    case "GatherNd": {
      const x = getParamValue("x", node, tensorMap, context2);
      const indices = getParamValue("indices", node, tensorMap, context2);
      return [ops.gatherND(x, indices)];
    }
    case "SparseToDense": {
      const indices = getParamValue("sparseIndices", node, tensorMap, context2);
      const shape = getParamValue("outputShape", node, tensorMap, context2);
      const sparseValues = getParamValue("sparseValues", node, tensorMap, context2);
      const defaultValue = getParamValue("defaultValue", node, tensorMap, context2);
      return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];
    }
    case "TensorScatterUpdate": {
      const indices = getParamValue("indices", node, tensorMap, context2);
      const values = getParamValue("values", node, tensorMap, context2);
      const tensor2 = getParamValue("tensor", node, tensorMap, context2);
      return [ops.tensorScatterUpdate(tensor2, indices, values)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$4 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices, outputValues, emptyRowIndicator, reverseIndexMap } = ops.sparse.sparseFillEmptyRows(getParamValue("indices", node, tensorMap, context2), getParamValue("values", node, tensorMap, context2), getParamValue("denseShape", node, tensorMap, context2), getParamValue("defaultValue", node, tensorMap, context2));
      return [
        outputIndices,
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    case "SparseReshape": {
      const { outputIndices, outputShape } = ops.sparse.sparseReshape(getParamValue("inputIndices", node, tensorMap, context2), getParamValue("inputShape", node, tensorMap, context2), getParamValue("newShape", node, tensorMap, context2));
      return [outputIndices, outputShape];
    }
    case "SparseSegmentMean": {
      const outputData = ops.sparse.sparseSegmentMean(getParamValue("data", node, tensorMap, context2), getParamValue("indices", node, tensorMap, context2), getParamValue("segmentIds", node, tensorMap, context2));
      return [outputData];
    }
    case "SparseSegmentSum": {
      const outputData = ops.sparse.sparseSegmentSum(getParamValue("data", node, tensorMap, context2), getParamValue("indices", node, tensorMap, context2), getParamValue("segmentIds", node, tensorMap, context2));
      return [outputData];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$3 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "FFT": {
      return [ops.fft(getParamValue("x", node, tensorMap, context2))];
    }
    case "IFFT": {
      return [ops.ifft(getParamValue("x", node, tensorMap, context2))];
    }
    case "RFFT": {
      return [ops.rfft(getParamValue("x", node, tensorMap, context2))];
    }
    case "IRFFT": {
      return [ops.irfft(getParamValue("x", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$2 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "StaticRegexReplace": {
      return [ops.string.staticRegexReplace(getParamValue("input", node, tensorMap, context2), getParamValue("pattern", node, tensorMap, context2), getParamValue("rewrite", node, tensorMap, context2), getParamValue("replaceGlobal", node, tensorMap, context2))];
    }
    case "StringNGrams": {
      const { nGrams, nGramsSplits } = ops.string.stringNGrams(getParamValue("data", node, tensorMap, context2), getParamValue("dataSplits", node, tensorMap, context2), getParamValue("separator", node, tensorMap, context2), getParamValue("nGramWidths", node, tensorMap, context2), getParamValue("leftPad", node, tensorMap, context2), getParamValue("rightPad", node, tensorMap, context2), getParamValue("padWidth", node, tensorMap, context2), getParamValue("preserveShortSequences", node, tensorMap, context2));
      return [nGrams, nGramsSplits];
    }
    case "StringSplit": {
      const { indices, values, shape } = ops.string.stringSplit(getParamValue("input", node, tensorMap, context2), getParamValue("delimiter", node, tensorMap, context2), getParamValue("skipEmpty", node, tensorMap, context2));
      return [indices, values, shape];
    }
    case "StringToHashBucketFast": {
      const output = ops.string.stringToHashBucketFast(getParamValue("input", node, tensorMap, context2), getParamValue("numBuckets", node, tensorMap, context2));
      return [output];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const executeOp$1 = (node, tensorMap, context2, ops = tfOps) => {
  switch (node.op) {
    case "Cast": {
      return [ops.cast(getParamValue("x", node, tensorMap, context2), getParamValue("dtype", node, tensorMap, context2))];
    }
    case "ExpandDims": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      return [ops.expandDims(getParamValue("x", node, tensorMap, context2), axis)];
    }
    case "Squeeze": {
      const axis = getParamValue("axis", node, tensorMap, context2);
      return [ops.squeeze(getParamValue("x", node, tensorMap, context2), axis)];
    }
    case "Reshape": {
      return [ops.reshape(getParamValue("x", node, tensorMap, context2), getParamValue("shape", node, tensorMap, context2))];
    }
    case "EnsureShape": {
      return [ops.ensureShape(getParamValue("x", node, tensorMap, context2), getParamValue("shape", node, tensorMap, context2))];
    }
    case "MirrorPad": {
      return [ops.mirrorPad(getParamValue("x", node, tensorMap, context2), getParamValue("padding", node, tensorMap, context2), getParamValue("mode", node, tensorMap, context2))];
    }
    case "PadV2":
    case "Pad": {
      return [ops.pad(getParamValue("x", node, tensorMap, context2), getParamValue("padding", node, tensorMap, context2), getParamValue("constantValue", node, tensorMap, context2))];
    }
    case "SpaceToBatchND": {
      const blockShape = getParamValue("blockShape", node, tensorMap, context2);
      const paddings = getParamValue("paddings", node, tensorMap, context2);
      return [ops.spaceToBatchND(getParamValue("x", node, tensorMap, context2), blockShape, paddings)];
    }
    case "BatchToSpaceND": {
      const blockShape = getParamValue("blockShape", node, tensorMap, context2);
      const crops = getParamValue("crops", node, tensorMap, context2);
      return [ops.batchToSpaceND(getParamValue("x", node, tensorMap, context2), blockShape, crops)];
    }
    case "DepthToSpace": {
      const blockSize = getParamValue("blockSize", node, tensorMap, context2);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context2).toUpperCase();
      return [ops.depthToSpace(getParamValue("x", node, tensorMap, context2), blockSize, dataFormat)];
    }
    case "BroadcastTo": {
      return [ops.broadcastTo(getParamValue("x", node, tensorMap, context2), getParamValue("shape", node, tensorMap, context2))];
    }
    case "BroadcastArgs": {
      return [ops.broadcastArgs(getParamValue("s0", node, tensorMap, context2), getParamValue("s1", node, tensorMap, context2))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function executeOp(node, tensorMap, context2, resourceManager, tidy$1 = tidy) {
  const value = ((node2, tensorMap2, context3) => {
    switch (node2.category) {
      case "arithmetic":
        return tidy$1(() => executeOp$k(node2, tensorMap2, context3));
      case "basic_math":
        return tidy$1(() => executeOp$j(node2, tensorMap2, context3));
      case "control":
        return executeOp$i(node2, tensorMap2, context3);
      case "convolution":
        return tidy$1(() => executeOp$h(node2, tensorMap2, context3));
      case "creation":
        return tidy$1(() => executeOp$g(node2, tensorMap2, context3));
      case "dynamic":
        return executeOp$f(node2, tensorMap2, context3);
      case "evaluation":
        return tidy$1(() => executeOp$e(node2, tensorMap2, context3));
      case "image":
        return tidy$1(() => executeOp$b(node2, tensorMap2, context3));
      case "graph":
        return tidy$1(() => executeOp$d(node2, tensorMap2, context3));
      case "logical":
        return tidy$1(() => executeOp$a(node2, tensorMap2, context3));
      case "matrices":
        return tidy$1(() => executeOp$9(node2, tensorMap2, context3));
      case "normalization":
        return tidy$1(() => executeOp$8(node2, tensorMap2, context3));
      case "ragged":
        return tidy$1(() => executeOp$7(node2, tensorMap2, context3));
      case "reduction":
        return tidy$1(() => executeOp$6(node2, tensorMap2, context3));
      case "slice_join":
        return tidy$1(() => executeOp$5(node2, tensorMap2, context3));
      case "sparse":
        return tidy$1(() => executeOp$4(node2, tensorMap2, context3));
      case "spectral":
        return tidy$1(() => executeOp$3(node2, tensorMap2, context3));
      case "string":
        return tidy$1(() => executeOp$2(node2, tensorMap2, context3));
      case "transformation":
        return tidy$1(() => executeOp$1(node2, tensorMap2, context3));
      case "hash_table":
        return executeOp$c(node2, tensorMap2, context3, resourceManager);
      case "custom":
        const opMapper = getRegisteredOp(node2.op);
        if (opMapper && opMapper.customExecutor) {
          return opMapper.customExecutor(new NodeValueImpl(node2, tensorMap2, context3));
        } else {
          throw TypeError(`Custom op ${node2.op} is not registered.`);
        }
      default:
        throw TypeError(`Unknown op '${node2.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
    }
  })(node, tensorMap, context2);
  if (isPromise(value)) {
    return value.then((data) => [].concat(data));
  }
  return [].concat(value);
}
class ExecutionContext {
  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}, parseNodeNameCache) {
    this.weightMap = weightMap;
    this.tensorArrayMap = tensorArrayMap;
    this.tensorListMap = tensorListMap;
    this.functionMap = functionMap;
    this.parseNodeNameCache = parseNodeNameCache;
    this.rootContext = { id: 0, frameName: "", iterationId: 0 };
    this.contexts = [this.rootContext];
    this.lastId = 0;
    this.generateCurrentContextIds();
  }
  newFrame(id2, frameName) {
    return { id: id2, frameName, iterationId: 0 };
  }
  /**
   * Set the current context
   * @param contexts: ExecutionContextInfo[] the current path of execution
   * frames
   */
  set currentContext(contexts) {
    if (this.contexts !== contexts) {
      this.contexts = contexts;
      this.generateCurrentContextIds();
    }
  }
  get currentContext() {
    return this.contexts;
  }
  /**
   * Returns the current context in string format.
   */
  get currentContextId() {
    return this._currentContextIds[0];
  }
  /**
   * Returns the current context and all parent contexts in string format.
   * This allow access to the nodes in the current and parent frames.
   */
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const names = [];
    for (let i = 0; i < this.contexts.length - 1; i++) {
      const contexts = this.contexts.slice(0, this.contexts.length - i);
      names.push(this.contextIdforContexts(contexts));
    }
    names.push("");
    this._currentContextIds = names;
  }
  contextIdforContexts(contexts) {
    return contexts ? contexts.map((context2) => context2.id === 0 && context2.iterationId === 0 ? "" : `${context2.frameName}-${context2.iterationId}`).join("/") : "";
  }
  /**
   * Enter a new frame, a new context is pushed on the current context list.
   * @param frameId new frame id
   */
  enterFrame(frameId) {
    if (this.contexts) {
      this.lastId++;
      this.contexts = this.contexts.slice();
      this.contexts.push(this.newFrame(this.lastId, frameId));
      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
    }
  }
  /**
   * Exit the current frame, the last context is removed from the current
   * context list.
   */
  exitFrame() {
    if (this.contexts && this.contexts.length > 1) {
      this.contexts = this.contexts.slice();
      this.contexts.splice(-1);
      this.currentContextIds.shift();
    } else {
      throw new Error("Cannot exit frame, the context is empty");
    }
  }
  /**
   * Enter the next iteration of a loop, the iteration id of last context is
   * increased.
   */
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice();
      this.lastId++;
      const context2 = Object.assign({}, this.contexts[this.contexts.length - 1]);
      context2.iterationId += 1;
      context2.id = this.lastId;
      this.contexts.splice(-1, 1, context2);
      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else {
      throw new Error("Cannot increase frame iteration, the context is empty");
    }
  }
  getWeight(name) {
    return this.weightMap[name];
  }
  addTensorArray(tensorArray) {
    this.tensorArrayMap[tensorArray.id] = tensorArray;
  }
  getTensorArray(id2) {
    return this.tensorArrayMap[id2];
  }
  addTensorList(tensorList) {
    this.tensorListMap[tensorList.id] = tensorList;
  }
  getTensorList(id2) {
    return this.tensorListMap[id2];
  }
  dispose(keepIds) {
    for (const key in this.tensorArrayMap) {
      this.tensorArrayMap[key].clearAndClose(keepIds);
    }
    for (const key in this.tensorListMap) {
      this.tensorListMap[key].clearAndClose(keepIds);
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
  const usedNodes = /* @__PURE__ */ new Set();
  const missingInputs = [];
  let dynamicNode = null;
  let syncInputs = null;
  const seen = /* @__PURE__ */ new Set();
  const inputNodeNames = new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));
  initNodes = initNodes || [];
  const initNodeNames = new Set(initNodes.map((node) => parseNodeName(node.name)[0]));
  const frontier = [...outputs];
  while (frontier.length > 0) {
    const node = frontier.pop();
    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
      if (dynamicNode == null) {
        dynamicNode = node;
        syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
      }
    }
    usedNodes.add(node.name);
    if (weightMap[node.name] != null) {
      continue;
    }
    if (inputNodeNames.has(node.name)) {
      continue;
    }
    if (initNodeNames.has(node.name)) {
      continue;
    }
    if (node.inputs.length === 0) {
      missingInputs.push(node.name);
      continue;
    }
    node.inputs.forEach((input) => {
      if (seen.has(input.name)) {
        return;
      }
      seen.add(input.name);
      frontier.push(input);
    });
  }
  return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
}
function getNodesInTopologicalOrder(graph2, executionInfo) {
  const { usedNodes, inputs } = executionInfo;
  const inputNodes = Object.keys(inputs).map((name) => parseNodeName(name)[0]).map((name) => graph2.nodes[name]);
  const initNodes = graph2.initNodes || [];
  const isUsed = (node) => usedNodes.has(typeof node === "string" ? node : node.name);
  function unique2(nodes) {
    return [...new Map(nodes.map((node) => [node.name, node])).values()];
  }
  const predefinedNodes = unique2([
    ...inputNodes,
    ...graph2.weights,
    ...initNodes
  ]).filter(isUsed);
  const allNodes = unique2([
    ...predefinedNodes,
    ...Object.values(graph2.nodes)
  ]).filter(isUsed);
  const nameToNode = new Map(allNodes.map((node) => [node.name, node]));
  const inCounts = {};
  for (const node of allNodes) {
    inCounts[node.name] = inCounts[node.name] || 0;
    for (const child of node.children) {
      if (!isUsed(child)) {
        inCounts[child.name] = Number.POSITIVE_INFINITY;
      }
      inCounts[child.name] = (inCounts[child.name] || 0) + 1;
    }
  }
  const frontier = Object.entries(inCounts).filter(([, inCount]) => inCount === 0).map(([name]) => name);
  const orderedNodeNames = [...frontier];
  while (frontier.length > 0) {
    const nodeName = frontier.pop();
    const node = nameToNode.get(nodeName);
    for (const child of node.children.filter(isUsed)) {
      if (--inCounts[child.name] === 0) {
        orderedNodeNames.push(child.name);
        frontier.push(child.name);
      }
    }
  }
  const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));
  const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);
  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);
  return filteredOrderedNodes;
}
function filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {
  const nameToNode = new Map(orderedNodes.map((node) => [node.name, node]));
  const stack2 = predefinedNodes.map((node) => node.name);
  const predefinedReachableNodeNames = new Set(stack2);
  while (stack2.length > 0) {
    const nodeName = stack2.pop();
    const node = nameToNode.get(nodeName);
    for (const child of node.children) {
      if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {
        continue;
      }
      predefinedReachableNodeNames.add(child.name);
      stack2.push(child.name);
    }
  }
  const filteredOrderedNodes = orderedNodes.filter((node) => predefinedReachableNodeNames.has(node.name));
  return filteredOrderedNodes;
}
class NodesExecutionOrderError extends Error {
  constructor(message) {
    super(`NodesExecutionOrderError: ${message}`);
  }
}
function validateNodesExecutionOrder(orderedNodes, predefinedNodes) {
  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
  const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));
  const isPredefined = (node) => predefinedNodeNames.has(typeof node === "string" ? node : node.name);
  const willBeExecutedNodeNames = new Set(orderedNodes.map((node) => node.name));
  const willBeExecuted = (node) => willBeExecutedNodeNames.has(typeof node === "string" ? node : node.name);
  for (const node of orderedNodes) {
    for (const child of node.children.filter(willBeExecuted)) {
      if (!nodeNameToOrder.has(child.name)) {
        throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);
      }
      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {
        throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);
      }
    }
    if (!isPredefined(node)) {
      for (const input of node.inputs) {
        if (!nodeNameToOrder.has(input.name)) {
          throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);
        }
        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {
          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);
        }
      }
    }
  }
}
function getNodeLiveUntilMap(orderedNodes) {
  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
  const INF_LIFE = Number.MAX_SAFE_INTEGER;
  const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);
  const getSelfLifeSpan = (node) => {
    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];
    if (selfLife == null) {
      return -1;
    }
    return selfLife;
  };
  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {
    return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);
  });
  const liveUntilMap = /* @__PURE__ */ new Map();
  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {
    const liveUntilOrder = liveUntilOrders[nodeOrder];
    if (liveUntilOrder === INF_LIFE) {
      continue;
    }
    const node = orderedNodes[nodeOrder];
    const liveUntilNode = orderedNodes[liveUntilOrder];
    if (!liveUntilMap.has(liveUntilNode.name)) {
      liveUntilMap.set(liveUntilNode.name, []);
    }
    liveUntilMap.get(liveUntilNode.name).push(node);
  }
  return liveUntilMap;
}
const CONTROL_FLOW_OPS = /* @__PURE__ */ new Set([
  "Switch",
  "Merge",
  "Enter",
  "Exit",
  "NextIteration",
  "StatelessIf",
  "StatelessWhile",
  "if",
  "While"
]);
const DYNAMIC_SHAPE_OPS = /* @__PURE__ */ new Set([
  "NonMaxSuppressionV2",
  "NonMaxSuppressionV3",
  "NonMaxSuppressionV5",
  "Where"
]);
const HASH_TABLE_OPS = /* @__PURE__ */ new Set([
  "HashTable",
  "HashTableV2",
  "LookupTableImport",
  "LookupTableImportV2",
  "LookupTableFind",
  "LookupTableFindV2",
  "LookupTableSize",
  "LookupTableSizeV2"
]);
function isControlFlow(node) {
  return CONTROL_FLOW_OPS.has(node.op);
}
function isDynamicShape(node) {
  return DYNAMIC_SHAPE_OPS.has(node.op);
}
function isHashTable(node) {
  return HASH_TABLE_OPS.has(node.op);
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
class GraphExecutor {
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(weightMap) {
    const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor2) => tensor2.id));
    this._weightIds = [].concat(...weightIds);
    this._weightMap = weightMap;
  }
  /**
   * Set `ResourceManager` shared by executors of a model.
   * @param resourceManager: `ResourceManager` of the `GraphModel`.
   */
  set resourceManager(resourceManager) {
    this._resourceManager = resourceManager;
  }
  get inputs() {
    return this._inputs.map((node) => {
      return {
        name: node.name,
        shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
        dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
      };
    });
  }
  get outputs() {
    return this._outputs.map((node) => {
      return {
        name: node.name,
        shape: node.attrParams["shape"] ? node.attrParams["shape"].value : void 0,
        dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : void 0
      };
    });
  }
  get inputNodes() {
    return this._inputs.map((node) => node.signatureKey || node.name);
  }
  get outputNodes() {
    return this._outputs.map((node) => {
      const name = node.signatureKey || node.name;
      return node.defaultOutput ? `${name}:${node.defaultOutput}` : name;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((map, key) => {
      map[key] = this._functions[key].signature;
      return map;
    }, {});
  }
  /**
   *
   * @param graph Graph the model or function graph to be executed.
   * @param parent When building function exector you need to set the parent
   * executor. Since the weights and function executor maps are set at parant
   * level, that function executor can access the function maps and weight maps
   * through the parent.
   */
  constructor(graph2, parent) {
    this.graph = graph2;
    this.parent = parent;
    this.compiledMap = /* @__PURE__ */ new Map();
    this.parseNodeNameCache = /* @__PURE__ */ new Map();
    this._weightMap = {};
    this.SEPARATOR = ",";
    this._functions = {};
    this._functionExecutorMap = {};
    this.keepIntermediateTensors = false;
    this._outputs = graph2.outputs;
    this._inputs = graph2.inputs;
    this._initNodes = graph2.initNodes;
    this._signature = graph2.signature;
    this._functions = graph2.functions;
    if (graph2.functions != null) {
      Object.keys(graph2.functions).forEach((name) => {
        this._functionExecutorMap[name] = new GraphExecutor(graph2.functions[name], this);
      });
    }
  }
  getCompilationKey(inputs, outputs) {
    const sortedInputs = inputs.map((node) => node.name).sort();
    const sortedOutputs = outputs.map((node) => node.name).sort();
    return sortedInputs.join(this.SEPARATOR) + "--" + sortedOutputs.join(this.SEPARATOR);
  }
  /**
   * Compiles the inference graph and returns the minimal set of nodes that are
   * required for execution, in the correct execution order.
   * @returns {Object} compilation The compile result.
   * @returns {Node[]} compilation.orderedNodes Nodes in the correct execution
   *     order.
   * @returns {Map<string, Node[]>} compilation.nodeLiveUntilMap A map from node
   *     to disposable nodes after its execution. That is, for a node `x`,
   *     `nodeLiveUntilMap[x]` indicates all nodes whose intermediate
   *     tensors should be disposed after `x` is executed.
   */
  compile(inputs, outputs) {
    const executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
    const { missingInputs, dynamicNode, syncInputs } = executionInfo;
    if (dynamicNode != null) {
      throw new Error(`This execution contains the node '${dynamicNode.name}', which has the dynamic op '${dynamicNode.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${syncInputs}]`);
    }
    if (missingInputs.length > 0) {
      const outNames = outputs.map((n) => n.name);
      const inNames = Object.keys(inputs);
      throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs [${inNames}]. Missing the following inputs: [${missingInputs}]`);
    }
    const orderedNodes = getNodesInTopologicalOrder(this.graph, executionInfo);
    const nodeLiveUntilMap = getNodeLiveUntilMap(orderedNodes);
    return { orderedNodes, nodeLiveUntilMap };
  }
  cloneAndKeepTensor(tensor2) {
    if (tensor2 == null) {
      return null;
    }
    const clone2 = tensor2.clone();
    keep(clone2);
    return clone2;
  }
  cloneTensorList(tensors) {
    if (!tensors) {
      return null;
    }
    const clonedTensor = tensors.map((tensor2) => {
      return this.cloneAndKeepTensor(tensor2);
    });
    return clonedTensor;
  }
  cloneTensorMap(tensorsMap) {
    return Object.fromEntries(Object.entries(tensorsMap).map(([name, tensorsList]) => {
      return [name, this.cloneTensorList(tensorsList)];
    }));
  }
  /**
   * Executes the inference for given input tensors.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model, if
   * no outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   */
  execute(inputs, outputs) {
    this.disposeIntermediateTensors();
    inputs = this.mapInputs(inputs);
    const names = Object.keys(inputs).sort();
    this.checkInputs(inputs);
    this.checkInputShapeAndType(inputs);
    outputs = this.mapOutputs(outputs);
    this.checkOutputs(outputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputs.map((name) => parseNodeName(name)[0]);
    const outputNodeNameSet = new Set(outputNodeNames);
    let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes.length === 0) {
      outputNodes = this._outputs;
    }
    const compilationKey = this.getCompilationKey(inputNodes, outputNodes);
    let compilation = this.compiledMap.get(compilationKey);
    if (compilation == null) {
      compilation = this.compile(inputs, outputNodes);
      this.compiledMap.set(compilationKey, compilation);
    }
    try {
      this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (e) {
      this.keepIntermediateTensors = false;
      console.warn(e.message);
    }
    const tensorArrayMap = {};
    const tensorListMap = {};
    return tidy(() => {
      const context2 = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
      const tensorsMap = Object.assign({}, this.weightMap);
      if (this.keepIntermediateTensors) {
        this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
      }
      Object.keys(inputs).forEach((name) => {
        const [nodeName, index] = parseNodeName(name, context2);
        const tensors = [];
        tensors[index] = inputs[name];
        tensorsMap[nodeName] = tensors;
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
        }
      });
      const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
      const { orderedNodes, nodeLiveUntilMap } = compilation;
      for (const node of orderedNodes) {
        if (tensorsMap[node.name]) {
          continue;
        }
        const tensors = executeOp(node, tensorsMap, context2, this._resourceManager);
        if (isPromise(tensors)) {
          throw new Error(`The execution of the op '${node.op}' returned a promise. Please use model.executeAsync() instead.`);
        }
        tensorsMap[node.name] = tensors;
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap[node.name] = this.cloneTensorList(tensors);
        }
        this.checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorsMap, context2, tensorsToKeep, outputNodeNameSet, nodeLiveUntilMap.get(node.name));
      }
      if (this.parent == null) {
        context2.dispose(tensorsToKeep);
      }
      return outputs.map((name) => getTensor(name, tensorsMap, context2));
    });
  }
  getFrozenTensorIds(tensorMap) {
    const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor2) => tensor2.id)));
    return new Set(ids);
  }
  checkTensorForDisposal(nodeName, node, tensorMap, context2, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount) {
    if (isControlFlow(node) || outputNodeNameSet.has(nodeName)) {
      return;
    }
    for (const tensor2 of tensorMap[nodeName]) {
      if (tensor2 == null) {
        continue;
      }
      intermediateTensorConsumerCount[tensor2.id] = (intermediateTensorConsumerCount[tensor2.id] || 0) + node.children.length;
    }
    for (const input of node.inputs) {
      if (isControlFlow(input)) {
        continue;
      }
      const tensors = getTensorsForCurrentContext(input.name, tensorMap, context2);
      if (tensors == null) {
        continue;
      }
      for (const tensor2 of tensors) {
        if (!tensor2 || tensor2.kept || tensorsToKeep.has(tensor2.id)) {
          continue;
        }
        const count2 = intermediateTensorConsumerCount[tensor2.id];
        if (count2 === 1) {
          tensor2.dispose();
          delete intermediateTensorConsumerCount[tensor2.id];
        } else if (count2 != null) {
          intermediateTensorConsumerCount[tensor2.id]--;
        }
      }
    }
  }
  checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorMap, context2, tensorsToKeep, outputNodeNameSet, liveUntilNodes) {
    function isNonDisposableNode(node2) {
      return isControlFlow(node2) || outputNodeNameSet.has(node2.name);
    }
    if (isControlFlow(node) || liveUntilNodes == null) {
      return;
    }
    for (const nodeToDispose of liveUntilNodes) {
      if (isNonDisposableNode(nodeToDispose)) {
        continue;
      }
      const tensors = getTensorsForCurrentContext(nodeToDispose.name, tensorMap, context2);
      for (const tensor2 of tensors) {
        if (!tensor2 || tensor2.kept || tensorsToKeep.has(tensor2.id)) {
          continue;
        }
        tensor2.dispose();
      }
    }
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs output node name from the Tensorflow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   */
  async executeAsync(inputs, outputs) {
    return this._executeAsync(inputs, outputs);
  }
  disposeIntermediateTensors() {
    if (!this.clonedTensorsMap) {
      return;
    }
    Object.values(this.clonedTensorsMap).forEach((tensorsList) => {
      for (const tensor2 of tensorsList) {
        if (tensor2 && !tensor2.isDisposed) {
          tensor2.dispose();
        }
      }
    });
    this.clonedTensorsMap = null;
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  /**
   * Executes the inference for given input tensors in Async fashion.
   * @param inputs Tensor map for the model inputs, keyed by the input node
   * names.
   * @param outputs Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Optional. Flag for executing a function.
   * @param tensorArrayMap Optional, global TensorArray map by id. Used for
   * function execution.
   * @param tensorArrayMap Optional global TensorList map by id. Used for
   * function execution.
   */
  async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
    this.disposeIntermediateTensors();
    if (!isFunctionExecution) {
      inputs = this.mapInputs(inputs);
      this.checkInputs(inputs);
      this.checkInputShapeAndType(inputs);
      outputs = this.mapOutputs(outputs);
      this.checkOutputs(outputs);
    }
    try {
      this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (e) {
      this.keepIntermediateTensors = false;
      console.warn(e.message);
    }
    const context2 = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
    if (this.keepIntermediateTensors) {
      this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
    }
    const tensorsMap = await this.executeWithControlFlow(inputs, context2, outputs, isFunctionExecution);
    const results = outputs.map((name) => getTensor(name, tensorsMap, context2));
    const outputIds = results.map((t) => t.id);
    const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
    const keepIds = /* @__PURE__ */ new Set([...outputIds, ...inputIds, ...this.weightIds]);
    Object.values(tensorsMap).forEach((tensorsList) => {
      tensorsList.forEach((tensor2) => {
        if (tensor2 && !tensor2.isDisposed && !keepIds.has(tensor2.id)) {
          tensor2.dispose();
        }
      });
    });
    if (this.parent == null) {
      context2.dispose(keepIds);
    }
    return results;
  }
  async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
    const mappedInputs = inputs.reduce((map, tensor2, index) => {
      map[this.inputs[index].name] = tensor2;
      return map;
    }, {});
    return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
  }
  /**
   * When there are control flow nodes in the graph, the graph execution use
   * ExecutionContext to keep track of the frames and loop iterators.
   * @param inputs placeholder tensors for the graph.
   * @param context the execution context object for current execution.
   * @param outputNames Optional. output node name from the Tensorflow model,
   * if no outputs are specified, the default outputs of the model would be
   * used. You can inspect intermediate nodes of the model by adding them to
   * the outputs array.
   * @param isFunctionExecution Flag for executing a function.
   */
  async executeWithControlFlow(inputs, context2, outputNames, isFunctionExecution) {
    const names = Object.keys(inputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputNames.map((name) => parseNodeName(name)[0]);
    const outputNodeNameSet = new Set(outputNodeNames);
    let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes.length === 0) {
      outputNodes = this._outputs;
    }
    const { usedNodes, missingInputs, dynamicNode, syncInputs } = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes);
    const stack2 = [
      ...inputNodes,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((node) => {
      return { node, contexts: context2.currentContext };
    });
    const tensorsMap = Object.assign({}, this.weightMap);
    Object.keys(inputs).forEach((name) => {
      const [nodeName, index] = parseNodeName(name);
      const tensors = [];
      tensors[index] = inputs[name];
      tensorsMap[nodeName] = tensors;
    });
    const intermediateTensorConsumerCount = {};
    const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
    const added = {};
    while (stack2.length > 0) {
      const promises = this.processStack(inputNodes, stack2, context2, tensorsMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes);
      await Promise.all(promises);
    }
    if (dynamicNode == null && !isFunctionExecution) {
      console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`);
    }
    const missingOutputs = outputNodes.filter((node) => !isControlFlow(node) && !getTensor(node.name, tensorsMap, context2)).map((node) => node.name);
    if (missingOutputs.length > 0) {
      let alternativeMsg = "";
      if (dynamicNode != null) {
        alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${syncInputs}]`;
      }
      throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided inputs [${names}]. Consider providing the following inputs: [${missingInputs}]. ${alternativeMsg}`);
    }
    return tensorsMap;
  }
  processStack(inputNodes, stack2, context2, tensorMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes) {
    const promises = [];
    while (stack2.length > 0) {
      const item = stack2.pop();
      context2.currentContext = item.contexts;
      let nodeName = "";
      if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context2)) {
        [nodeName] = getNodeNameAndIndex(item.node.name, context2);
      }
      if (tensorMap[item.node.name] == null) {
        const tensors = executeOp(item.node, tensorMap, context2, this._resourceManager);
        if (!nodeName) {
          [nodeName] = getNodeNameAndIndex(item.node.name, context2);
        }
        const currentContext = context2.currentContext;
        if (isPromise(tensors)) {
          promises.push(tensors.then((t) => {
            tensorMap[nodeName] = t;
            if (this.keepIntermediateTensors) {
              this.clonedTensorsMap[nodeName] = this.cloneTensorList(t);
            }
            context2.currentContext = currentContext;
            this.checkTensorForDisposal(nodeName, item.node, tensorMap, context2, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
            this.processChildNodes(item.node, stack2, context2, tensorMap, added, usedNodes);
            return t;
          }));
        } else {
          tensorMap[nodeName] = tensors;
          if (this.keepIntermediateTensors) {
            this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
          }
          this.checkTensorForDisposal(nodeName, item.node, tensorMap, context2, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
          this.processChildNodes(item.node, stack2, context2, tensorMap, added, usedNodes);
        }
      } else {
        this.processChildNodes(item.node, stack2, context2, tensorMap, added, usedNodes);
      }
    }
    return promises;
  }
  processChildNodes(node, stack2, context2, tensorMap, added, usedNodes) {
    node.children.forEach((childNode) => {
      const [nodeName] = getNodeNameAndIndex(childNode.name, context2);
      if (added[nodeName] || !usedNodes.has(childNode.name)) {
        return;
      }
      if (childNode.op === "Merge") {
        if (childNode.inputNames.some((name) => {
          return !!getTensor(name, tensorMap, context2);
        })) {
          added[nodeName] = true;
          stack2.push({ contexts: context2.currentContext, node: childNode });
        }
      } else if (childNode.inputNames.every((name) => {
        return !!getTensor(name, tensorMap, context2);
      })) {
        added[nodeName] = true;
        stack2.push({ contexts: context2.currentContext, node: childNode });
      }
    });
  }
  /**
   * Releases the memory used by the weight tensors.
   */
  dispose() {
    Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor2) => tensor2.dispose()));
  }
  checkInputShapeAndType(inputs) {
    Object.keys(inputs).forEach((name) => {
      const input = inputs[name];
      const [nodeName] = parseNodeName(name);
      const node = this.graph.nodes[nodeName];
      if (node.attrParams["shape"] && node.attrParams["shape"].value) {
        const shape = node.attrParams["shape"].value;
        const match = shape.length === input.shape.length && input.shape.every((dim, index) => shape[index] === -1 || shape[index] === dim);
        assert(match, () => `The shape of dict['${node.name}'] provided in model.execute(dict) must be [${shape}], but was [${input.shape}]`);
      }
      if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
        assert(input.dtype === node.attrParams["dtype"].value, () => `The dtype of dict['${node.name}'] provided in model.execute(dict) must be ${node.attrParams["dtype"].value}, but was ${input.dtype}`);
      }
    });
  }
  mapInputs(inputs) {
    var _a2, _b;
    const result = {};
    for (const inputName in inputs) {
      const tensor2 = (_b = (_a2 = this._signature) === null || _a2 === void 0 ? void 0 : _a2.inputs) === null || _b === void 0 ? void 0 : _b[inputName];
      if (tensor2 != null) {
        result[tensor2.name] = inputs[inputName];
      } else {
        result[inputName] = inputs[inputName];
      }
    }
    return result;
  }
  checkInputs(inputs) {
    const notInGraph = Object.keys(inputs).filter((name) => {
      const [nodeName] = parseNodeName(name);
      return this.graph.nodes[nodeName] == null;
    });
    if (notInGraph.length > 0) {
      throw new Error(`The dict provided in model.execute(dict) has keys: [${notInGraph}] that are not part of graph`);
    }
  }
  mapOutputs(outputs) {
    return outputs.map((name) => {
      var _a2, _b;
      const tensor2 = (_b = (_a2 = this._signature) === null || _a2 === void 0 ? void 0 : _a2.outputs) === null || _b === void 0 ? void 0 : _b[name];
      if (tensor2 != null) {
        return tensor2.name;
      }
      return name;
    }, {});
  }
  checkOutputs(outputs) {
    outputs.forEach((name) => {
      const [normalizedName] = parseNodeName(name);
      if (!this.graph.nodes[normalizedName]) {
        throw new Error(`The output '${name}' is not found in the graph`);
      }
    });
  }
}
class ResourceManager {
  constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
    this.hashTableNameToHandle = hashTableNameToHandle;
    this.hashTableMap = hashTableMap;
  }
  /**
   * Register a `HashTable` in the resource manager.
   *
   * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,
   * where id is the table handle tensor's id.
   *
   * @param name Op node name that creates the `HashTable`.
   * @param hashTable The `HashTable` to be added to resource manager.
   */
  addHashTable(name, hashTable2) {
    this.hashTableNameToHandle[name] = hashTable2.handle;
    this.hashTableMap[hashTable2.id] = hashTable2;
  }
  /**
   * Get the table handle by node name.
   * @param name Op node name that creates the `HashTable`. This name is also
   *     used in the inputs list of lookup and import `HashTable` ops.
   */
  getHashTableHandleByName(name) {
    return this.hashTableNameToHandle[name];
  }
  /**
   * Get the actual `HashTable` by its handle tensor's id.
   * @param id The id of the handle tensor.
   */
  getHashTableById(id2) {
    return this.hashTableMap[id2];
  }
  /**
   * Dispose `ResourceManager`, including its hashTables and tensors in them.
   */
  dispose() {
    for (const key in this.hashTableMap) {
      this.hashTableMap[key].clearAndClose();
      delete this.hashTableMap[key];
    }
    for (const name in this.hashTableNameToHandle) {
      this.hashTableNameToHandle[name].dispose();
      delete this.hashTableNameToHandle[name];
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
const TFHUB_SEARCH_PARAM = "?tfjs-format=file";
const DEFAULT_MODEL_NAME = "model.json";
class GraphModel {
  // Returns the version information for the tensorflow model GraphDef.
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  /**
   * @param modelUrl url for the model, or an `io.IOHandler`.
   * @param weightManifestUrl url for the weight file generated by
   * scripts/convert.py script.
   * @param requestOption options for Request, which allows to send credentials
   * and custom headers.
   * @param onProgress Optional, progress callback function, fired periodically
   * before the load is completed.
   */
  constructor(modelUrl, loadOptions = {}, tfio = io) {
    this.modelUrl = modelUrl;
    this.loadOptions = loadOptions;
    this.version = "n/a";
    this.io = tfio;
    if (loadOptions == null) {
      this.loadOptions = {};
    }
    this.resourceManager = new ResourceManager();
  }
  findIOHandler() {
    const path = this.modelUrl;
    if (path.load != null) {
      this.handler = path;
    } else if (this.loadOptions.requestInit != null) {
      this.handler = this.io.browserHTTPRequest(path, this.loadOptions);
    } else {
      const handlers2 = this.io.getLoadHandlers(path, this.loadOptions);
      if (handlers2.length === 0) {
        handlers2.push(this.io.browserHTTPRequest(path, this.loadOptions));
      } else if (handlers2.length > 1) {
        throw new Error(`Found more than one (${handlers2.length}) load handlers for URL '${[path]}'`);
      }
      this.handler = handlers2[0];
    }
  }
  /**
   * Loads the model and weight files, construct the in memory weight map and
   * compile the inference graph.
   */
  load() {
    this.findIOHandler();
    if (this.handler.load == null) {
      throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    }
    const loadResult = this.handler.load();
    if (isPromise(loadResult)) {
      return loadResult.then((artifacts) => {
        if (artifacts.getWeightStream == null) {
          return this.loadSync(artifacts);
        }
        return this.loadStreaming(artifacts);
      });
    }
    return this.loadSync(loadResult);
  }
  /**
   * Synchronously construct the in memory weight map and
   * compile the inference graph.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  loadSync(artifacts) {
    const weightMap = this.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs);
    return this.loadWithWeightMap(artifacts, weightMap);
  }
  async loadStreaming(artifacts) {
    if (artifacts.getWeightStream == null) {
      throw new Error("Model artifacts missing streamWeights function");
    }
    const weightMap = await decodeWeightsStream(artifacts.getWeightStream(), artifacts.weightSpecs);
    return this.loadWithWeightMap(artifacts, weightMap);
  }
  loadWithWeightMap(artifacts, weightMap) {
    this.artifacts = artifacts;
    const graph2 = this.artifacts.modelTopology;
    let signature = this.artifacts.signature;
    if (this.artifacts.userDefinedMetadata != null) {
      const metadata = this.artifacts.userDefinedMetadata;
      if (metadata.signature != null) {
        signature = metadata.signature;
      }
      if (metadata.structuredOutputKeys != null) {
        this.structuredOutputKeys = metadata.structuredOutputKeys;
      }
    }
    this.signature = signature;
    this.version = `${graph2.versions.producer}.${graph2.versions.minConsumer}`;
    this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph2, this.signature));
    this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
    this.executor.resourceManager = this.resourceManager;
    if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
      const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
      this.initializer = new GraphExecutor(initializer);
      this.initializer.weightMap = this.executor.weightMap;
      this.initializer.resourceManager = this.resourceManager;
      this.initializerSignature = artifacts.initializerSignature;
    }
    return true;
  }
  /**
   * Save the configuration and/or weights of the GraphModel.
   *
   * An `IOHandler` is an object that has a `save` method of the proper
   * signature defined. The `save` method manages the storing or
   * transmission of serialized data ("artifacts") that represent the
   * model's topology and weights onto or via a specific medium, such as
   * file downloads, local storage, IndexedDB in the web browser and HTTP
   * requests to a server. TensorFlow.js provides `IOHandler`
   * implementations for a number of frequently used saving mediums, such as
   * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
   * for more details.
   *
   * This method also allows you to refer to certain types of `IOHandler`s
   * as URL-like string shortcuts, such as 'localstorage://' and
   * 'indexeddb://'.
   *
   * Example 1: Save `model`'s topology and weights to browser [local
   * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
   * then load it back.
   *
   * ```js
   * const modelUrl =
   *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
   * const model = await tf.loadGraphModel(modelUrl);
   * const zeros = tf.zeros([1, 224, 224, 3]);
   * model.predict(zeros).print();
   *
   * const saveResults = await model.save('localstorage://my-model-1');
   *
   * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
   * console.log('Prediction from loaded model:');
   * model.predict(zeros).print();
   * ```
   *
   * @param handlerOrURL An instance of `IOHandler` or a URL-like,
   * scheme-based string shortcut for `IOHandler`.
   * @param config Options for saving the model.
   * @returns A `Promise` of `SaveResult`, which summarizes the result of
   * the saving, such as byte sizes of the saved artifacts for the model's
   *   topology and weight values.
   *
   * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
   */
  async save(handlerOrURL, config2) {
    if (typeof handlerOrURL === "string") {
      const handlers2 = this.io.getSaveHandlers(handlerOrURL);
      if (handlers2.length === 0) {
        throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
      } else if (handlers2.length > 1) {
        throw new Error(`Found more than one (${handlers2.length}) save handlers for URL '${handlerOrURL}'`);
      }
      handlerOrURL = handlers2[0];
    }
    if (handlerOrURL.save == null) {
      throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    }
    return handlerOrURL.save(this.artifacts);
  }
  addStructuredOutputNames(outputTensors) {
    if (this.structuredOutputKeys) {
      const outputTensorsArray = outputTensors instanceof Tensor ? [outputTensors] : outputTensors;
      const outputTensorMap = {};
      outputTensorsArray.forEach((outputTensor, i) => outputTensorMap[this.structuredOutputKeys[i]] = outputTensor);
      return outputTensorMap;
    }
    return outputTensors;
  }
  /**
   * Execute the inference for the input tensors.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with multiple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns Inference result tensors. If the model is converted and it
   * originally had structured_outputs in tensorflow, then a NamedTensorMap
   * will be returned matching the structured_outputs. If no structured_outputs
   * are present, the output will be single `tf.Tensor` if the model has single
   * output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  predict(inputs, config2) {
    const outputTensors = this.execute(inputs, this.outputNodes);
    return this.addStructuredOutputNames(outputTensors);
  }
  /**
   * Execute the inference for the input tensors in async fashion, use this
   * method when your model contains control flow ops.
   *
   * @param input The input tensors, when there is single input for the model,
   * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
   * inputs params should be in either `tf.Tensor`[] if the input order is
   * fixed, or otherwise NamedTensorMap format.
   *
   * For model with multiple inputs, we recommend you use NamedTensorMap as the
   * input type, if you use `tf.Tensor`[], the order of the array needs to
   * follow the
   * order of inputNodes array. @see {@link GraphModel.inputNodes}
   *
   * You can also feed any intermediate nodes using the NamedTensorMap as the
   * input type. For example, given the graph
   *    InputNode => Intermediate => OutputNode,
   * you can execute the subgraph Intermediate => OutputNode by calling
   *    model.execute('IntermediateNode' : tf.tensor(...));
   *
   * This is useful for models that uses tf.dynamic_rnn, where the intermediate
   * state needs to be fed manually.
   *
   * For batch inference execution, the tensors for each input need to be
   * concatenated together. For example with mobilenet, the required input shape
   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
   * If we are provide a batched data of 100 images, the input tensor should be
   * in the shape of [100, 244, 244, 3].
   *
   * @param config Prediction configuration for specifying the batch size.
   * Currently the batch size option is ignored for graph model.
   *
   * @returns A Promise of inference result tensors. If the model is converted
   * and it originally had structured_outputs in tensorflow, then a
   * NamedTensorMap will be returned matching the structured_outputs. If no
   * structured_outputs are present, the output will be single `tf.Tensor` if
   * the model has single output node, otherwise Tensor[].
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async predictAsync(inputs, config2) {
    const outputTensors = await this.executeAsync(inputs, this.outputNodes);
    return this.addStructuredOutputNames(outputTensors);
  }
  normalizeInputs(inputs) {
    var _a2;
    if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
      const signatureInputs = (_a2 = this.signature) === null || _a2 === void 0 ? void 0 : _a2.inputs;
      if (signatureInputs != null) {
        for (const input in signatureInputs) {
          const tensor2 = signatureInputs[input];
          if (tensor2.resourceId != null) {
            inputs[input] = this.resourceIdToCapturedInput[tensor2.resourceId];
          }
        }
      }
      return inputs;
    }
    inputs = Array.isArray(inputs) ? inputs : [inputs];
    const numCapturedInputs = Object.keys(this.resourceIdToCapturedInput).length;
    if (inputs.length + numCapturedInputs !== this.inputNodes.length) {
      throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - numCapturedInputs} non-resource placeholders, while there are ${inputs.length} input tensors provided.`);
    }
    let inputIndex = 0;
    return this.inputNodes.reduce((map, inputName) => {
      var _a3, _b, _c;
      const resourceId = (_c = (_b = (_a3 = this.signature) === null || _a3 === void 0 ? void 0 : _a3.inputs) === null || _b === void 0 ? void 0 : _b[inputName]) === null || _c === void 0 ? void 0 : _c.resourceId;
      if (resourceId != null) {
        map[inputName] = this.resourceIdToCapturedInput[resourceId];
      } else {
        map[inputName] = inputs[inputIndex++];
      }
      return map;
    }, {});
  }
  normalizeOutputs(outputs) {
    outputs = outputs || this.outputNodes;
    return !Array.isArray(outputs) ? [outputs] : outputs;
  }
  executeInitializerGraph() {
    if (this.initializer == null) {
      return [];
    }
    if (this.initializerSignature == null) {
      return this.initializer.execute({}, []);
    } else {
      return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
    }
  }
  async executeInitializerGraphAsync() {
    if (this.initializer == null) {
      return [];
    }
    if (this.initializerSignature == null) {
      return this.initializer.executeAsync({}, []);
    } else {
      return this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
    }
  }
  setResourceIdToCapturedInput(outputs) {
    this.resourceIdToCapturedInput = {};
    if (this.initializerSignature) {
      const signatureOutputs = this.initializerSignature.outputs;
      const outputNames = Object.keys(signatureOutputs);
      for (let i = 0; i < outputNames.length; i++) {
        const outputName = outputNames[i];
        const tensorInfo = signatureOutputs[outputName];
        this.resourceIdToCapturedInput[tensorInfo.resourceId] = outputs[i];
      }
    }
  }
  /**
   * Executes inference for the model for given input tensors.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no
   * outputs are specified, the default outputs of the model would be used.
   * You can inspect intermediate nodes of the model by adding them to the
   * outputs array.
   *
   * @returns A single tensor if provided with a single output or no outputs
   * are provided and there is only one default output, otherwise return a
   * tensor array. The order of the tensor array is the same as the outputs
   * if provided, otherwise the order of outputNodes attribute of the model.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  execute(inputs, outputs) {
    if (this.resourceIdToCapturedInput == null) {
      this.setResourceIdToCapturedInput(this.executeInitializerGraph());
    }
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = this.executor.execute(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  /**
   * Executes inference for the model for given input tensors in async
   * fashion, use this method when your model contains control flow ops.
   * @param inputs tensor, tensor array or tensor map of the inputs for the
   * model, keyed by the input node names.
   * @param outputs output node name from the TensorFlow model, if no outputs
   * are specified, the default outputs of the model would be used. You can
   * inspect intermediate nodes of the model by adding them to the outputs
   * array.
   *
   * @returns A Promise of single tensor if provided with a single output or
   * no outputs are provided and there is only one default output, otherwise
   * return a tensor map.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  async executeAsync(inputs, outputs) {
    if (this.resourceIdToCapturedInput == null) {
      this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync());
    }
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = await this.executor.executeAsync(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  /**
   * Get intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  /**
   * Dispose intermediate tensors for model debugging mode (flag
   * KEEP_INTERMEDIATE_TENSORS is true).
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(map) {
    return Object.keys(map).reduce((newMap, key) => {
      newMap[key] = [map[key]];
      return newMap;
    }, {});
  }
  /**
   * Releases the memory used by the weight tensors and resourceManager.
   *
   * @doc {heading: 'Models', subheading: 'Classes'}
   */
  dispose() {
    this.executor.dispose();
    if (this.initializer) {
      this.initializer.dispose();
      if (this.resourceIdToCapturedInput) {
        dispose(this.resourceIdToCapturedInput);
      }
    }
    this.resourceManager.dispose();
  }
}
async function loadGraphModel(modelUrl, options = {}, tfio = io) {
  if (modelUrl == null) {
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  }
  if (options == null) {
    options = {};
  }
  if (options.fromTFHub && typeof modelUrl === "string") {
    modelUrl = getTFHubUrl(modelUrl);
  }
  const model = new GraphModel(modelUrl, options, tfio);
  await model.load();
  return model;
}
function getTFHubUrl(modelUrl) {
  if (!modelUrl.endsWith("/")) {
    modelUrl = modelUrl + "/";
  }
  return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
}
/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step2([n, v]);
    };
  }
  function step2(op2) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op2[1])).done) return t;
      if (y = 0, t) op2 = [op2[0] & 2, t.value];
      switch (op2[0]) {
        case 0:
        case 1:
          t = op2;
          break;
        case 4:
          _.label++;
          return { value: op2[1], done: false };
        case 5:
          _.label++;
          y = op2[1];
          op2 = [0];
          continue;
        case 7:
          op2 = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op2[0] === 3 && (!t || op2[1] > t[0] && op2[1] < t[3])) {
            _.label = op2[1];
            break;
          }
          if (op2[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op2;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op2);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op2 = body.call(thisArg, _);
    } catch (e) {
      op2 = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op2[0] & 5) throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function toFlattenedOneHotPartMap(partHeatmapScores) {
  var numParts = partHeatmapScores.shape[2];
  var partMapLocations = argMax(partHeatmapScores, 2);
  var partMapFlattened = reshape(partMapLocations, [-1]);
  return oneHot(partMapFlattened, numParts);
}
function clipByMask2d(image2, mask) {
  return mul(image2, mask);
}
function toMaskTensor(segmentScores, threshold2) {
  return tidy(function() {
    return cast(greater(segmentScores, scalar(threshold2)), "int32");
  });
}
function decodePartSegmentation(segmentationMask, partHeatmapScores) {
  var _a2 = partHeatmapScores.shape, partMapHeight = _a2[0], partMapWidth = _a2[1], numParts = _a2[2];
  return tidy(function() {
    var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);
    var partNumbers = expandDims(range(0, numParts, 1, "int32"), 1);
    var partMapFlattened = cast(matMul$1(flattenedMap, partNumbers), "int32");
    var partMap = reshape(partMapFlattened, [partMapHeight, partMapWidth]);
    var partMapShiftedUpForClipping = add(partMap, scalar(1, "int32"));
    return sub(clipByMask2d(partMapShiftedUpForClipping, segmentationMask), scalar(1, "int32"));
  });
}
function decodeOnlyPartSegmentation(partHeatmapScores) {
  var _a2 = partHeatmapScores.shape, partMapHeight = _a2[0], partMapWidth = _a2[1], numParts = _a2[2];
  return tidy(function() {
    var flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);
    var partNumbers = expandDims(range(0, numParts, 1, "int32"), 1);
    var partMapFlattened = cast(matMul$1(flattenedMap, partNumbers), "int32");
    return reshape(partMapFlattened, [partMapHeight, partMapWidth]);
  });
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var BaseModel = (
  /** @class */
  function() {
    function BaseModel2(model, outputStride) {
      this.model = model;
      this.outputStride = outputStride;
      var inputShape = this.model.inputs[0].shape;
      assert(inputShape[1] === -1 && inputShape[2] === -1, function() {
        return "Input shape [".concat(inputShape[1], ", ").concat(inputShape[2], "] ") + "must both be equal to or -1";
      });
    }
    BaseModel2.prototype.predict = function(input) {
      var _this = this;
      return tidy(function() {
        var asFloat = _this.preprocessInput(cast(input, "float32"));
        var asBatch = expandDims(asFloat, 0);
        var results = _this.model.predict(asBatch);
        var results3d = results.map(function(y) {
          return squeeze(y, [0]);
        });
        var namedResults = _this.nameOutputResults(results3d);
        return {
          heatmapScores: sigmoid(namedResults.heatmap),
          offsets: namedResults.offsets,
          displacementFwd: namedResults.displacementFwd,
          displacementBwd: namedResults.displacementBwd,
          segmentation: namedResults.segmentation,
          partHeatmaps: namedResults.partHeatmaps,
          longOffsets: namedResults.longOffsets,
          partOffsets: namedResults.partOffsets
        };
      });
    };
    BaseModel2.prototype.dispose = function() {
      this.model.dispose();
    };
    return BaseModel2;
  }()
);
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var MobileNet = (
  /** @class */
  function(_super) {
    __extends(MobileNet2, _super);
    function MobileNet2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MobileNet2.prototype.preprocessInput = function(input) {
      return tidy(function() {
        return sub(div(input, 127.5), 1);
      });
    };
    MobileNet2.prototype.nameOutputResults = function(results) {
      var offsets = results[0], segmentation = results[1], partHeatmaps = results[2], longOffsets = results[3], heatmap = results[4], displacementFwd = results[5], displacementBwd = results[6], partOffsets = results[7];
      return {
        offsets,
        segmentation,
        partHeatmaps,
        longOffsets,
        heatmap,
        displacementFwd,
        displacementBwd,
        partOffsets
      };
    };
    return MobileNet2;
  }(BaseModel)
);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var PART_NAMES = [
  "nose",
  "leftEye",
  "rightEye",
  "leftEar",
  "rightEar",
  "leftShoulder",
  "rightShoulder",
  "leftElbow",
  "rightElbow",
  "leftWrist",
  "rightWrist",
  "leftHip",
  "rightHip",
  "leftKnee",
  "rightKnee",
  "leftAnkle",
  "rightAnkle"
];
var NUM_KEYPOINTS = PART_NAMES.length;
var PART_IDS = PART_NAMES.reduce(function(result, jointName, i) {
  result[jointName] = i;
  return result;
}, {});
var CONNECTED_PART_NAMES = [
  ["leftHip", "leftShoulder"],
  ["leftElbow", "leftShoulder"],
  ["leftElbow", "leftWrist"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["rightHip", "rightShoulder"],
  ["rightElbow", "rightShoulder"],
  ["rightElbow", "rightWrist"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"],
  ["leftShoulder", "rightShoulder"],
  ["leftHip", "rightHip"]
];
var POSE_CHAIN = [
  ["nose", "leftEye"],
  ["leftEye", "leftEar"],
  ["nose", "rightEye"],
  ["rightEye", "rightEar"],
  ["nose", "leftShoulder"],
  ["leftShoulder", "leftElbow"],
  ["leftElbow", "leftWrist"],
  ["leftShoulder", "leftHip"],
  ["leftHip", "leftKnee"],
  ["leftKnee", "leftAnkle"],
  ["nose", "rightShoulder"],
  ["rightShoulder", "rightElbow"],
  ["rightElbow", "rightWrist"],
  ["rightShoulder", "rightHip"],
  ["rightHip", "rightKnee"],
  ["rightKnee", "rightAnkle"]
];
CONNECTED_PART_NAMES.map(function(_a2) {
  var jointNameA = _a2[0], jointNameB = _a2[1];
  return [PART_IDS[jointNameA], PART_IDS[jointNameB]];
});
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function getScale(_a2, _b, padding) {
  var height = _a2[0], width = _a2[1];
  var inputResolutionY = _b[0], inputResolutionX = _b[1];
  var padT = padding.top, padB = padding.bottom, padL = padding.left, padR = padding.right;
  var scaleY = inputResolutionY / (padT + padB + height);
  var scaleX = inputResolutionX / (padL + padR + width);
  return [scaleX, scaleY];
}
function getOffsetPoint(y, x, keypoint, offsets) {
  return {
    y: offsets.get(y, x, keypoint),
    x: offsets.get(y, x, keypoint + NUM_KEYPOINTS)
  };
}
function getImageCoords(part, outputStride, offsets) {
  var heatmapY = part.heatmapY, heatmapX = part.heatmapX, keypoint = part.id;
  var _a2 = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets), y = _a2.y, x = _a2.x;
  return {
    x: part.heatmapX * outputStride + x,
    y: part.heatmapY * outputStride + y
  };
}
function clamp$1(a, min2, max2) {
  if (a < min2) {
    return min2;
  }
  if (a > max2) {
    return max2;
  }
  return a;
}
function squaredDistance(y1, x1, y2, x2) {
  var dy = y2 - y1;
  var dx = x2 - x1;
  return dy * dy + dx * dx;
}
function addVectors(a, b) {
  return { x: a.x + b.x, y: a.y + b.y };
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function computeDistance(embedding, pose, minPartScore) {
  if (minPartScore === void 0) {
    minPartScore = 0.3;
  }
  var distance2 = 0;
  var numKpt = 0;
  for (var p = 0; p < embedding.length; p++) {
    if (pose.keypoints[p].score > minPartScore) {
      numKpt += 1;
      distance2 += Math.pow(embedding[p].x - pose.keypoints[p].position.x, 2) + Math.pow(embedding[p].y - pose.keypoints[p].position.y, 2);
    }
  }
  if (numKpt === 0) {
    distance2 = Infinity;
  } else {
    distance2 = distance2 / numKpt;
  }
  return distance2;
}
function convertToPositionInOuput(position, _a2, _b, stride) {
  var padT = _a2[0], padL = _a2[1];
  var scaleX = _b[0], scaleY = _b[1];
  var y = Math.round(((padT + position.y + 1) * scaleY - 1) / stride);
  var x = Math.round(((padL + position.x + 1) * scaleX - 1) / stride);
  return { x, y };
}
function getEmbedding(location, keypointIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, _a2) {
  var height = _a2[0], width = _a2[1];
  var newLocation = convertToPosition(location);
  var nn = newLocation.y * outputResolutionX + newLocation.x;
  var dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];
  var dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];
  var y = location.y + dy;
  var x = location.x + dx;
  for (var t = 0; t < refineSteps; t++) {
    y = Math.min(y, height - 1);
    x = Math.min(x, width - 1);
    var newPos = convertToPosition({ x, y });
    var nn_1 = newPos.y * outputResolutionX + newPos.x;
    dy = longOffsets[NUM_KEYPOINTS * (2 * nn_1) + keypointIndex];
    dx = longOffsets[NUM_KEYPOINTS * (2 * nn_1 + 1) + keypointIndex];
    y = y + dy;
    x = x + dx;
  }
  return { x, y };
}
function matchEmbeddingToInstance(location, longOffsets, poses, numKptForMatching, _a2, _b, outputResolutionX, _c, stride, refineSteps) {
  var padT = _a2[0], padL = _a2[1];
  var scaleX = _b[0], scaleY = _b[1];
  var height = _c[0], width = _c[1];
  var embed = [];
  var convertToPosition = function(pair) {
    return convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);
  };
  for (var keypointsIndex = 0; keypointsIndex < numKptForMatching; keypointsIndex++) {
    var embedding = getEmbedding(location, keypointsIndex, convertToPosition, outputResolutionX, longOffsets, refineSteps, [height, width]);
    embed.push(embedding);
  }
  var kMin = -1;
  var kMinDist = Infinity;
  for (var k = 0; k < poses.length; k++) {
    var dist = computeDistance(embed, poses[k]);
    if (dist < kMinDist) {
      kMin = k;
      kMinDist = dist;
    }
  }
  return kMin;
}
function getOutputResolution(_a2, stride) {
  var inputResolutionY = _a2[0], inputResolutionX = _a2[1];
  var outputResolutionX = Math.round((inputResolutionX - 1) / stride + 1);
  var outputResolutionY = Math.round((inputResolutionY - 1) / stride + 1);
  return [outputResolutionX, outputResolutionY];
}
function decodeMultipleMasksCPU(segmentation, longOffsets, posesAboveScore, height, width, stride, _a2, padding, refineSteps, numKptForMatching) {
  var inHeight = _a2[0], inWidth = _a2[1];
  if (numKptForMatching === void 0) {
    numKptForMatching = 5;
  }
  var dataArrays = posesAboveScore.map(function(x) {
    return new Uint8Array(height * width).fill(0);
  });
  var padT = padding.top, padL = padding.left;
  var _b = getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];
  var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];
  for (var i = 0; i < height; i += 1) {
    for (var j = 0; j < width; j += 1) {
      var n = i * width + j;
      var prob = segmentation[n];
      if (prob === 1) {
        var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);
        if (kMin >= 0) {
          dataArrays[kMin][n] = 1;
        }
      }
    }
  }
  return dataArrays;
}
function decodeMultiplePartMasksCPU(segmentation, longOffsets, partSegmentaion, posesAboveScore, height, width, stride, _a2, padding, refineSteps, numKptForMatching) {
  var inHeight = _a2[0], inWidth = _a2[1];
  if (numKptForMatching === void 0) {
    numKptForMatching = 5;
  }
  var dataArrays = posesAboveScore.map(function(x) {
    return new Int32Array(height * width).fill(-1);
  });
  var padT = padding.top, padL = padding.left;
  var _b = getScale([height, width], [inHeight, inWidth], padding), scaleX = _b[0], scaleY = _b[1];
  var outputResolutionX = getOutputResolution([inHeight, inWidth], stride)[0];
  for (var i = 0; i < height; i += 1) {
    for (var j = 0; j < width; j += 1) {
      var n = i * width + j;
      var prob = segmentation[n];
      if (prob === 1) {
        var kMin = matchEmbeddingToInstance({ x: j, y: i }, longOffsets, posesAboveScore, numKptForMatching, [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width], stride, refineSteps);
        if (kMin >= 0) {
          dataArrays[kMin][n] = partSegmentaion[n];
        }
      }
    }
  }
  return dataArrays;
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, _a2, padding, refineSteps, minKptScore, maxNumPeople) {
  var inHeight = _a2[0], inWidth = _a2[1];
  var _b = segmentation.shape, origHeight = _b[0], origWidth = _b[1];
  var _c = longOffsets.shape.slice(0, 2), outHeight = _c[0], outWidth = _c[1];
  var shapedLongOffsets = reshape(longOffsets, [outHeight, outWidth, 2, NUM_KEYPOINTS]);
  var poseVals = new Float32Array(maxNumPeople * NUM_KEYPOINTS * 3).fill(0);
  for (var i = 0; i < posesAboveScore.length; i++) {
    var poseOffset = i * NUM_KEYPOINTS * 3;
    var pose = posesAboveScore[i];
    for (var kp = 0; kp < NUM_KEYPOINTS; kp++) {
      var keypoint = pose.keypoints[kp];
      var offset = poseOffset + kp * 3;
      poseVals[offset] = keypoint.score;
      poseVals[offset + 1] = keypoint.position.y;
      poseVals[offset + 2] = keypoint.position.x;
    }
  }
  var _d = getScale([height, width], [inHeight, inWidth], padding), scaleX = _d[0], scaleY = _d[1];
  var posesTensor = tensor(poseVals, [maxNumPeople, NUM_KEYPOINTS, 3]);
  var padT = padding.top, padL = padding.left;
  var program = {
    variableNames: ["segmentation", "longOffsets", "poses"],
    outputShape: [origHeight, origWidth],
    userCode: "\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ".concat(padT, ", ").concat(scaleY, ", ").concat(stride, ");\n      float stridedW = convertToPositionInOutputFloat(\n        w, ").concat(padL, ", ").concat(scaleX, ", ").concat(stride, ");\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ").concat(maxNumPeople, "; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ").concat(NUM_KEYPOINTS, "; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ").concat(refineSteps, "; s++) {\n            int yRounded = round(min(y, float(").concat(height - 1, ")));\n            int xRounded = round(min(x, float(").concat(width - 1, ")));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ").concat(padT, ", ").concat(scaleY, ", ").concat(stride, ");\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ").concat(padL, ", ").concat(scaleX, ", ").concat(stride, ");\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ").concat(minKptScore, ") {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  ")
  };
  var webglBackend = backend();
  return webglBackend.compileAndRun(program, [segmentation, shapedLongOffsets, posesTensor]);
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function toPersonKSegmentation(segmentation, k) {
  return tidy(function() {
    return cast(equal(segmentation, scalar(k)), "int32");
  });
}
function toPersonKPartSegmentation(segmentation, bodyParts, k) {
  return tidy(function() {
    return sub(mul(cast(equal(segmentation, scalar(k)), "int32"), add(bodyParts, 1)), 1);
  });
}
function isWebGlBackend() {
  return getBackend() === "webgl";
}
function decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, stride, _a2, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {
  var inHeight = _a2[0], inWidth = _a2[1];
  if (minPoseScore === void 0) {
    minPoseScore = 0.2;
  }
  if (refineSteps === void 0) {
    refineSteps = 8;
  }
  if (minKeypointScore === void 0) {
    minKeypointScore = 0.3;
  }
  if (maxNumPeople === void 0) {
    maxNumPeople = 10;
  }
  return __awaiter(this, void 0, void 0, function() {
    var posesAboveScore, personSegmentationsData, personSegmentations, segmentationsData, longOffsetsData;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          posesAboveScore = poses.filter(function(pose) {
            return pose.score >= minPoseScore;
          });
          if (!isWebGlBackend()) return [3, 2];
          personSegmentations = tidy(function() {
            var masksTensorInfo = decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);
            var masksTensor = engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);
            return posesAboveScore.map(function(_, k) {
              return toPersonKSegmentation(masksTensor, k);
            });
          });
          return [4, Promise.all(personSegmentations.map(function(mask) {
            return mask.data();
          }))];
        case 1:
          personSegmentationsData = _b.sent();
          personSegmentations.forEach(function(x) {
            return x.dispose();
          });
          return [3, 5];
        case 2:
          return [4, segmentation.data()];
        case 3:
          segmentationsData = _b.sent();
          return [4, longOffsets.data()];
        case 4:
          longOffsetsData = _b.sent();
          personSegmentationsData = decodeMultipleMasksCPU(segmentationsData, longOffsetsData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);
          _b.label = 5;
        case 5:
          return [2, personSegmentationsData.map(function(data, i) {
            return { data, pose: posesAboveScore[i], width, height };
          })];
      }
    });
  });
}
function decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, stride, _a2, padding, minPoseScore, refineSteps, minKeypointScore, maxNumPeople) {
  var inHeight = _a2[0], inWidth = _a2[1];
  if (minPoseScore === void 0) {
    minPoseScore = 0.2;
  }
  if (refineSteps === void 0) {
    refineSteps = 8;
  }
  if (minKeypointScore === void 0) {
    minKeypointScore = 0.3;
  }
  if (maxNumPeople === void 0) {
    maxNumPeople = 10;
  }
  return __awaiter(this, void 0, void 0, function() {
    var posesAboveScore, partSegmentationsByPersonData, partSegmentations, segmentationsData, longOffsetsData, partSegmentaionData;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          posesAboveScore = poses.filter(function(pose) {
            return pose.score >= minPoseScore;
          });
          if (!isWebGlBackend()) return [3, 2];
          partSegmentations = tidy(function() {
            var masksTensorInfo = decodeMultipleMasksWebGl(segmentation, longOffsets, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps, minKeypointScore, maxNumPeople);
            var masksTensor = engine().makeTensorFromDataId(masksTensorInfo.dataId, masksTensorInfo.shape, masksTensorInfo.dtype);
            return posesAboveScore.map(function(_, k) {
              return toPersonKPartSegmentation(masksTensor, partSegmentation, k);
            });
          });
          return [4, Promise.all(partSegmentations.map(function(x) {
            return x.data();
          }))];
        case 1:
          partSegmentationsByPersonData = _b.sent();
          partSegmentations.forEach(function(x) {
            return x.dispose();
          });
          return [3, 6];
        case 2:
          return [4, segmentation.data()];
        case 3:
          segmentationsData = _b.sent();
          return [4, longOffsets.data()];
        case 4:
          longOffsetsData = _b.sent();
          return [4, partSegmentation.data()];
        case 5:
          partSegmentaionData = _b.sent();
          partSegmentationsByPersonData = decodeMultiplePartMasksCPU(segmentationsData, longOffsetsData, partSegmentaionData, posesAboveScore, height, width, stride, [inHeight, inWidth], padding, refineSteps);
          _b.label = 6;
        case 6:
          return [2, partSegmentationsByPersonData.map(function(data, k) {
            return { pose: posesAboveScore[k], data, height, width };
          })];
      }
    });
  });
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function half(k) {
  return Math.floor(k / 2);
}
var MaxHeap = (
  /** @class */
  function() {
    function MaxHeap2(maxSize, getElementValue) {
      this.priorityQueue = new Array(maxSize);
      this.numberOfElements = -1;
      this.getElementValue = getElementValue;
    }
    MaxHeap2.prototype.enqueue = function(x) {
      this.priorityQueue[++this.numberOfElements] = x;
      this.swim(this.numberOfElements);
    };
    MaxHeap2.prototype.dequeue = function() {
      var max2 = this.priorityQueue[0];
      this.exchange(0, this.numberOfElements--);
      this.sink(0);
      this.priorityQueue[this.numberOfElements + 1] = null;
      return max2;
    };
    MaxHeap2.prototype.empty = function() {
      return this.numberOfElements === -1;
    };
    MaxHeap2.prototype.size = function() {
      return this.numberOfElements + 1;
    };
    MaxHeap2.prototype.all = function() {
      return this.priorityQueue.slice(0, this.numberOfElements + 1);
    };
    MaxHeap2.prototype.max = function() {
      return this.priorityQueue[0];
    };
    MaxHeap2.prototype.swim = function(k) {
      while (k > 0 && this.less(half(k), k)) {
        this.exchange(k, half(k));
        k = half(k);
      }
    };
    MaxHeap2.prototype.sink = function(k) {
      while (2 * k <= this.numberOfElements) {
        var j = 2 * k;
        if (j < this.numberOfElements && this.less(j, j + 1)) {
          j++;
        }
        if (!this.less(k, j)) {
          break;
        }
        this.exchange(k, j);
        k = j;
      }
    };
    MaxHeap2.prototype.getValueAt = function(i) {
      return this.getElementValue(this.priorityQueue[i]);
    };
    MaxHeap2.prototype.less = function(i, j) {
      return this.getValueAt(i) < this.getValueAt(j);
    };
    MaxHeap2.prototype.exchange = function(i, j) {
      var t = this.priorityQueue[i];
      this.priorityQueue[i] = this.priorityQueue[j];
      this.priorityQueue[j] = t;
    };
    return MaxHeap2;
  }()
);
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores) {
  var _a2 = scores.shape, height = _a2[0], width = _a2[1];
  var localMaximum = true;
  var yStart = Math.max(heatmapY - localMaximumRadius, 0);
  var yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);
  for (var yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {
    var xStart = Math.max(heatmapX - localMaximumRadius, 0);
    var xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);
    for (var xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {
      if (scores.get(yCurrent, xCurrent, keypointId) > score) {
        localMaximum = false;
        break;
      }
    }
    if (!localMaximum) {
      break;
    }
  }
  return localMaximum;
}
function buildPartWithScoreQueue(scoreThreshold, localMaximumRadius, scores) {
  var _a2 = scores.shape, height = _a2[0], width = _a2[1], numKeypoints = _a2[2];
  var queue = new MaxHeap(height * width * numKeypoints, function(_a3) {
    var score2 = _a3.score;
    return score2;
  });
  for (var heatmapY = 0; heatmapY < height; ++heatmapY) {
    for (var heatmapX = 0; heatmapX < width; ++heatmapX) {
      for (var keypointId = 0; keypointId < numKeypoints; ++keypointId) {
        var score = scores.get(heatmapY, heatmapX, keypointId);
        if (score < scoreThreshold) {
          continue;
        }
        if (scoreIsMaximumInLocalWindow(keypointId, score, heatmapY, heatmapX, localMaximumRadius, scores)) {
          queue.enqueue({ score, part: { heatmapY, heatmapX, id: keypointId } });
        }
      }
    }
  }
  return queue;
}
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var parentChildrenTuples = POSE_CHAIN.map(function(_a2) {
  var parentJoinName = _a2[0], childJoinName = _a2[1];
  return [PART_IDS[parentJoinName], PART_IDS[childJoinName]];
});
var parentToChildEdges = parentChildrenTuples.map(function(_a2) {
  var childJointId = _a2[1];
  return childJointId;
});
var childToParentEdges = parentChildrenTuples.map(function(_a2) {
  var parentJointId = _a2[0];
  return parentJointId;
});
function getDisplacement(edgeId, point, displacements) {
  var numEdges = displacements.shape[2] / 2;
  return {
    y: displacements.get(point.y, point.x, edgeId),
    x: displacements.get(point.y, point.x, numEdges + edgeId)
  };
}
function getStridedIndexNearPoint(point, outputStride, height, width) {
  return {
    y: clamp$1(Math.round(point.y / outputStride), 0, height - 1),
    x: clamp$1(Math.round(point.x / outputStride), 0, width - 1)
  };
}
function traverseToTargetKeypoint(edgeId, sourceKeypoint, targetKeypointId, scoresBuffer, offsets, outputStride, displacements, offsetRefineStep) {
  if (offsetRefineStep === void 0) {
    offsetRefineStep = 2;
  }
  var _a2 = scoresBuffer.shape, height = _a2[0], width = _a2[1];
  var sourceKeypointIndices = getStridedIndexNearPoint(sourceKeypoint.position, outputStride, height, width);
  var displacement = getDisplacement(edgeId, sourceKeypointIndices, displacements);
  var displacedPoint = addVectors(sourceKeypoint.position, displacement);
  var targetKeypoint = displacedPoint;
  for (var i = 0; i < offsetRefineStep; i++) {
    var targetKeypointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);
    var offsetPoint = getOffsetPoint(targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId, offsets);
    targetKeypoint = addVectors({
      x: targetKeypointIndices.x * outputStride,
      y: targetKeypointIndices.y * outputStride
    }, { x: offsetPoint.x, y: offsetPoint.y });
  }
  var targetKeyPointIndices = getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);
  var score = scoresBuffer.get(targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);
  return { position: targetKeypoint, part: PART_NAMES[targetKeypointId], score };
}
function decodePose(root, scores, offsets, outputStride, displacementsFwd, displacementsBwd) {
  var numParts = scores.shape[2];
  var numEdges = parentToChildEdges.length;
  var instanceKeypoints = new Array(numParts);
  var rootPart = root.part, rootScore = root.score;
  var rootPoint = getImageCoords(rootPart, outputStride, offsets);
  instanceKeypoints[rootPart.id] = {
    score: rootScore,
    part: PART_NAMES[rootPart.id],
    position: rootPoint
  };
  for (var edge = numEdges - 1; edge >= 0; --edge) {
    var sourceKeypointId = parentToChildEdges[edge];
    var targetKeypointId = childToParentEdges[edge];
    if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsBwd);
    }
  }
  for (var edge = 0; edge < numEdges; ++edge) {
    var sourceKeypointId = childToParentEdges[edge];
    var targetKeypointId = parentToChildEdges[edge];
    if (instanceKeypoints[sourceKeypointId] && !instanceKeypoints[targetKeypointId]) {
      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores, offsets, outputStride, displacementsFwd);
    }
  }
  return instanceKeypoints;
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
function withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, _a2, keypointId) {
  var x = _a2.x, y = _a2.y;
  return poses.some(function(_a3) {
    var keypoints = _a3.keypoints;
    var correspondingKeypoint = keypoints[keypointId].position;
    return squaredDistance(y, x, correspondingKeypoint.y, correspondingKeypoint.x) <= squaredNmsRadius;
  });
}
function getInstanceScore(existingPoses, squaredNmsRadius, instanceKeypoints) {
  var notOverlappedKeypointScores = instanceKeypoints.reduce(function(result, _a2, keypointId) {
    var position = _a2.position, score = _a2.score;
    if (!withinNmsRadiusOfCorrespondingPoint(existingPoses, squaredNmsRadius, position, keypointId)) {
      result += score;
    }
    return result;
  }, 0);
  return notOverlappedKeypointScores /= instanceKeypoints.length;
}
var kLocalMaximumRadius = 1;
function decodeMultiplePoses(scoresBuffer, offsetsBuffer, displacementsFwdBuffer, displacementsBwdBuffer, outputStride, maxPoseDetections, scoreThreshold, nmsRadius) {
  if (scoreThreshold === void 0) {
    scoreThreshold = 0.5;
  }
  if (nmsRadius === void 0) {
    nmsRadius = 20;
  }
  var poses = [];
  var queue = buildPartWithScoreQueue(scoreThreshold, kLocalMaximumRadius, scoresBuffer);
  var squaredNmsRadius = nmsRadius * nmsRadius;
  while (poses.length < maxPoseDetections && !queue.empty()) {
    var root = queue.dequeue();
    var rootImageCoords = getImageCoords(root.part, outputStride, offsetsBuffer);
    if (withinNmsRadiusOfCorrespondingPoint(poses, squaredNmsRadius, rootImageCoords, root.part.id)) {
      continue;
    }
    var keypoints = decodePose(root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer, displacementsBwdBuffer);
    var score = getInstanceScore(poses, squaredNmsRadius, keypoints);
    poses.push({ keypoints, score });
  }
  return poses;
}
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var imageNetMean = [-123.15, -115.9, -103.06];
var ResNet = (
  /** @class */
  function(_super) {
    __extends(ResNet2, _super);
    function ResNet2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ResNet2.prototype.preprocessInput = function(input) {
      return add(input, imageNetMean);
    };
    ResNet2.prototype.nameOutputResults = function(results) {
      var displacementBwd = results[0], displacementFwd = results[1], heatmap = results[2], longOffsets = results[3], offsets = results[4], partHeatmaps = results[5], segmentation = results[6], partOffsets = results[7];
      return {
        offsets,
        segmentation,
        partHeatmaps,
        longOffsets,
        heatmap,
        displacementFwd,
        displacementBwd,
        partOffsets
      };
    };
    return ResNet2;
  }(BaseModel)
);
/**
 * @license
 * Copyright 2019 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var RESNET50_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/";
var MOBILENET_BASE_URL = "https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";
function resNet50SavedModel(stride, quantBytes) {
  var graphJson = "model-stride".concat(stride, ".json");
  if (quantBytes === 4) {
    return RESNET50_BASE_URL + "float/" + graphJson;
  } else {
    return RESNET50_BASE_URL + "quant".concat(quantBytes, "/") + graphJson;
  }
}
function mobileNetSavedModel(stride, multiplier, quantBytes) {
  var toStr = { 1: "100", 0.75: "075", 0.5: "050" };
  var graphJson = "model-stride".concat(stride, ".json");
  if (quantBytes === 4) {
    return MOBILENET_BASE_URL + "float/".concat(toStr[multiplier], "/") + graphJson;
  } else {
    return MOBILENET_BASE_URL + "quant".concat(quantBytes, "/").concat(toStr[multiplier], "/") + graphJson;
  }
}
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
var _a;
function getSizeFromImageLikeElement(input) {
  if ("offsetHeight" in input && input.offsetHeight !== 0 && "offsetWidth" in input && input.offsetWidth !== 0) {
    return [input.offsetHeight, input.offsetWidth];
  } else if (input.height != null && input.width != null) {
    return [input.height, input.width];
  } else {
    throw new Error("HTMLImageElement must have height and width attributes set.");
  }
}
function getSizeFromVideoElement(input) {
  if (input.hasAttribute("height") && input.hasAttribute("width")) {
    return [input.height, input.width];
  } else {
    return [input.videoHeight, input.videoWidth];
  }
}
function getInputSize(input) {
  if (typeof HTMLCanvasElement !== "undefined" && input instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && input instanceof OffscreenCanvas || typeof HTMLImageElement !== "undefined" && input instanceof HTMLImageElement) {
    return getSizeFromImageLikeElement(input);
  } else if (typeof ImageData !== "undefined" && input instanceof ImageData) {
    return [input.height, input.width];
  } else if (typeof HTMLVideoElement !== "undefined" && input instanceof HTMLVideoElement) {
    return getSizeFromVideoElement(input);
  } else if (input instanceof Tensor) {
    return [input.shape[0], input.shape[1]];
  } else {
    throw new Error("error: Unknown input type: ".concat(input, "."));
  }
}
function isValidInputResolution(resolution, outputStride) {
  return (resolution - 1) % outputStride === 0;
}
function toValidInputResolution(inputResolution, outputStride) {
  if (isValidInputResolution(inputResolution, outputStride)) {
    return inputResolution;
  }
  return Math.floor(inputResolution / outputStride) * outputStride + 1;
}
var INTERNAL_RESOLUTION_STRING_OPTIONS = {
  low: "low",
  medium: "medium",
  high: "high",
  full: "full"
};
var INTERNAL_RESOLUTION_PERCENTAGES = (_a = {}, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = 0.25, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = 0.5, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = 0.75, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1, _a);
var MIN_INTERNAL_RESOLUTION = 0.1;
var MAX_INTERNAL_RESOLUTION = 2;
function toInternalResolutionPercentage(internalResolution) {
  if (typeof internalResolution === "string") {
    var result = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];
    assert(typeof result === "number", function() {
      return "string value of inputResolution must be one of ".concat(Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS).join(","), " but was ").concat(internalResolution, ".");
    });
    return result;
  } else {
    assert(typeof internalResolution === "number" && internalResolution <= MAX_INTERNAL_RESOLUTION && internalResolution >= MIN_INTERNAL_RESOLUTION, function() {
      return "inputResolution must be a string or number between ".concat(MIN_INTERNAL_RESOLUTION, " and ").concat(MAX_INTERNAL_RESOLUTION, ", but ") + "was ".concat(internalResolution);
    });
    return internalResolution;
  }
}
function toInputResolutionHeightAndWidth(internalResolution, outputStride, _a2) {
  var inputHeight = _a2[0], inputWidth = _a2[1];
  var internalResolutionPercentage = toInternalResolutionPercentage(internalResolution);
  return [
    toValidInputResolution(inputHeight * internalResolutionPercentage, outputStride),
    toValidInputResolution(inputWidth * internalResolutionPercentage, outputStride)
  ];
}
function toInputTensor(input) {
  return input instanceof Tensor ? input : fromPixels(input);
}
function scaleAndCropToInputTensorShape(tensor2, _a2, _b, _c, applySigmoidActivation) {
  var inputTensorHeight = _a2[0], inputTensorWidth = _a2[1];
  var resizedAndPaddedHeight = _b[0], resizedAndPaddedWidth = _b[1];
  var _d = _c[0], padT = _d[0], padB = _d[1], _e = _c[1], padL = _e[0], padR = _e[1];
  return tidy(function() {
    var inResizedAndPadded = image$1.resizeBilinear(tensor2, [resizedAndPaddedHeight, resizedAndPaddedWidth], true);
    {
      inResizedAndPadded = sigmoid(inResizedAndPadded);
    }
    return removePaddingAndResizeBack(inResizedAndPadded, [inputTensorHeight, inputTensorWidth], [[padT, padB], [padL, padR]]);
  });
}
function removePaddingAndResizeBack(resizedAndPadded, _a2, _b) {
  var originalHeight = _a2[0], originalWidth = _a2[1];
  var _c = _b[0], padT = _c[0], padB = _c[1], _d = _b[1], padL = _d[0], padR = _d[1];
  return tidy(function() {
    var batchedImage = expandDims(resizedAndPadded);
    return squeeze(image$1.cropAndResize(batchedImage, [[
      padT / (originalHeight + padT + padB - 1),
      padL / (originalWidth + padL + padR - 1),
      (padT + originalHeight - 1) / (originalHeight + padT + padB - 1),
      (padL + originalWidth - 1) / (originalWidth + padL + padR - 1)
    ]], [0], [originalHeight, originalWidth]), [0]);
  });
}
function padAndResizeTo(input, _a2) {
  var targetH = _a2[0], targetW = _a2[1];
  var _b = getInputSize(input), height = _b[0], width = _b[1];
  var targetAspect = targetW / targetH;
  var aspect = width / height;
  var _c = [0, 0, 0, 0], padT = _c[0], padB = _c[1], padL = _c[2], padR = _c[3];
  if (aspect < targetAspect) {
    padT = 0;
    padB = 0;
    padL = Math.round(0.5 * (targetAspect * height - width));
    padR = Math.round(0.5 * (targetAspect * height - width));
  } else {
    padT = Math.round(0.5 * (1 / targetAspect * width - height));
    padB = Math.round(0.5 * (1 / targetAspect * width - height));
    padL = 0;
    padR = 0;
  }
  var resized = tidy(function() {
    var imageTensor = toInputTensor(input);
    imageTensor = pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);
    return image$1.resizeBilinear(imageTensor, [targetH, targetW]);
  });
  return { resized, padding: { top: padT, left: padL, right: padR, bottom: padB } };
}
function toTensorBuffers3D(tensors) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      return [2, Promise.all(tensors.map(function(tensor2) {
        return tensor2.buffer();
      }))];
    });
  });
}
function scalePose(pose, scaleY, scaleX, offsetY, offsetX) {
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  return {
    score: pose.score,
    keypoints: pose.keypoints.map(function(_a2) {
      var score = _a2.score, part = _a2.part, position = _a2.position;
      return {
        score,
        part,
        position: {
          x: position.x * scaleX + offsetX,
          y: position.y * scaleY + offsetY
        }
      };
    })
  };
}
function scalePoses(poses, scaleY, scaleX, offsetY, offsetX) {
  if (offsetY === void 0) {
    offsetY = 0;
  }
  if (offsetX === void 0) {
    offsetX = 0;
  }
  if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {
    return poses;
  }
  return poses.map(function(pose) {
    return scalePose(pose, scaleY, scaleX, offsetY, offsetX);
  });
}
function scaleAndFlipPoses(poses, _a2, _b, padding, flipHorizontal) {
  var height = _a2[0], width = _a2[1];
  var inputResolutionHeight = _b[0], inputResolutionWidth = _b[1];
  var scaleY = (height + padding.top + padding.bottom) / inputResolutionHeight;
  var scaleX = (width + padding.left + padding.right) / inputResolutionWidth;
  var scaledPoses = scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);
  {
    return scaledPoses;
  }
}
var MOBILENET_V1_CONFIG = {
  architecture: "MobileNetV1",
  outputStride: 16,
  quantBytes: 4,
  multiplier: 0.75
};
var VALID_ARCHITECTURE = ["MobileNetV1", "ResNet50"];
var VALID_STRIDE = {
  "MobileNetV1": [8, 16, 32],
  "ResNet50": [32, 16]
};
var VALID_MULTIPLIER = {
  "MobileNetV1": [0.5, 0.75, 1],
  "ResNet50": [1]
};
var VALID_QUANT_BYTES = [1, 2, 4];
function validateModelConfig(config2) {
  config2 = config2 || MOBILENET_V1_CONFIG;
  if (config2.architecture == null) {
    config2.architecture = "MobileNetV1";
  }
  if (VALID_ARCHITECTURE.indexOf(config2.architecture) < 0) {
    throw new Error("Invalid architecture ".concat(config2.architecture, ". ") + "Should be one of ".concat(VALID_ARCHITECTURE));
  }
  if (config2.outputStride == null) {
    config2.outputStride = 16;
  }
  if (VALID_STRIDE[config2.architecture].indexOf(config2.outputStride) < 0) {
    throw new Error("Invalid outputStride ".concat(config2.outputStride, ". ") + "Should be one of ".concat(VALID_STRIDE[config2.architecture], " ") + "for architecture ".concat(config2.architecture, "."));
  }
  if (config2.multiplier == null) {
    config2.multiplier = 1;
  }
  if (VALID_MULTIPLIER[config2.architecture].indexOf(config2.multiplier) < 0) {
    throw new Error("Invalid multiplier ".concat(config2.multiplier, ". ") + "Should be one of ".concat(VALID_MULTIPLIER[config2.architecture], " ") + "for architecture ".concat(config2.architecture, "."));
  }
  if (config2.quantBytes == null) {
    config2.quantBytes = 4;
  }
  if (VALID_QUANT_BYTES.indexOf(config2.quantBytes) < 0) {
    throw new Error("Invalid quantBytes ".concat(config2.quantBytes, ". ") + "Should be one of ".concat(VALID_QUANT_BYTES, " ") + "for architecture ".concat(config2.architecture, "."));
  }
  return config2;
}
var PERSON_INFERENCE_CONFIG = {
  flipHorizontal: false,
  internalResolution: "medium",
  segmentationThreshold: 0.7,
  maxDetections: 10,
  scoreThreshold: 0.4,
  nmsRadius: 20
};
var MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {
  flipHorizontal: false,
  internalResolution: "medium",
  segmentationThreshold: 0.7,
  maxDetections: 10,
  scoreThreshold: 0.4,
  nmsRadius: 20,
  minKeypointScore: 0.3,
  refineSteps: 10
};
function validatePersonInferenceConfig(config2) {
  var segmentationThreshold = config2.segmentationThreshold, maxDetections = config2.maxDetections, scoreThreshold = config2.scoreThreshold, nmsRadius = config2.nmsRadius;
  if (segmentationThreshold < 0 || segmentationThreshold > 1) {
    throw new Error("segmentationThreshold ".concat(segmentationThreshold, ". ") + "Should be in range [0.0, 1.0]");
  }
  if (maxDetections <= 0) {
    throw new Error("Invalid maxDetections ".concat(maxDetections, ". ") + "Should be > 0");
  }
  if (scoreThreshold < 0 || scoreThreshold > 1) {
    throw new Error("Invalid scoreThreshold ".concat(scoreThreshold, ". ") + "Should be in range [0.0, 1.0]");
  }
  if (nmsRadius <= 0) {
    throw new Error("Invalid nmsRadius ".concat(nmsRadius, "."));
  }
}
function validateMultiPersonInstanceInferenceConfig(config2) {
  var segmentationThreshold = config2.segmentationThreshold, maxDetections = config2.maxDetections, scoreThreshold = config2.scoreThreshold, nmsRadius = config2.nmsRadius, minKeypointScore = config2.minKeypointScore, refineSteps = config2.refineSteps;
  if (segmentationThreshold < 0 || segmentationThreshold > 1) {
    throw new Error("segmentationThreshold ".concat(segmentationThreshold, ". ") + "Should be in range [0.0, 1.0]");
  }
  if (maxDetections <= 0) {
    throw new Error("Invalid maxDetections ".concat(maxDetections, ". ") + "Should be > 0");
  }
  if (scoreThreshold < 0 || scoreThreshold > 1) {
    throw new Error("Invalid scoreThreshold ".concat(scoreThreshold, ". ") + "Should be in range [0.0, 1.0]");
  }
  if (nmsRadius <= 0) {
    throw new Error("Invalid nmsRadius ".concat(nmsRadius, "."));
  }
  if (minKeypointScore < 0 || minKeypointScore > 1) {
    throw new Error("Invalid minKeypointScore ".concat(minKeypointScore, ".") + "Should be in range [0.0, 1.0]");
  }
  if (refineSteps <= 0 || refineSteps > 20) {
    throw new Error("Invalid refineSteps ".concat(refineSteps, ".") + "Should be in range [1, 20]");
  }
}
var BodyPix = (
  /** @class */
  function() {
    function BodyPix2(net) {
      this.baseModel = net;
    }
    BodyPix2.prototype.predictForPersonSegmentation = function(input) {
      var _a2 = this.baseModel.predict(input), segmentation = _a2.segmentation, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd;
      return {
        segmentLogits: segmentation,
        heatmapScores,
        offsets,
        displacementFwd,
        displacementBwd
      };
    };
    BodyPix2.prototype.predictForPersonSegmentationAndPart = function(input) {
      var _a2 = this.baseModel.predict(input), segmentation = _a2.segmentation, partHeatmaps = _a2.partHeatmaps, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd;
      return {
        segmentLogits: segmentation,
        partHeatmapLogits: partHeatmaps,
        heatmapScores,
        offsets,
        displacementFwd,
        displacementBwd
      };
    };
    BodyPix2.prototype.predictForMultiPersonInstanceSegmentationAndPart = function(input) {
      var _a2 = this.baseModel.predict(input), segmentation = _a2.segmentation, longOffsets = _a2.longOffsets, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd, partHeatmaps = _a2.partHeatmaps;
      return {
        segmentLogits: segmentation,
        longOffsets,
        heatmapScores,
        offsets,
        displacementFwd,
        displacementBwd,
        partHeatmaps
      };
    };
    BodyPix2.prototype.segmentPersonActivation = function(input, internalResolution, segmentationThreshold) {
      var _this = this;
      if (segmentationThreshold === void 0) {
        segmentationThreshold = 0.5;
      }
      var _a2 = getInputSize(input), height = _a2[0], width = _a2[1];
      var internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);
      var _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
      var _c = tidy(function() {
        var _a3 = _this.predictForPersonSegmentation(resized), segmentLogits = _a3.segmentLogits, heatmapScores2 = _a3.heatmapScores, offsets2 = _a3.offsets, displacementFwd2 = _a3.displacementFwd, displacementBwd2 = _a3.displacementBwd;
        var _b2 = resized.shape, resizedHeight = _b2[0], resizedWidth = _b2[1];
        var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]]);
        return {
          segmentation: toMaskTensor(squeeze(scaledSegmentScores), segmentationThreshold),
          heatmapScores: heatmapScores2,
          offsets: offsets2,
          displacementFwd: displacementFwd2,
          displacementBwd: displacementBwd2
        };
      }), segmentation = _c.segmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;
      resized.dispose();
      return {
        segmentation,
        heatmapScores,
        offsets,
        displacementFwd,
        displacementBwd,
        padding,
        internalResolutionHeightAndWidth
      };
    };
    BodyPix2.prototype.segmentPerson = function(input, config2) {
      if (config2 === void 0) {
        config2 = PERSON_INFERENCE_CONFIG;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, segmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, result, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              config2 = __assign(__assign({}, PERSON_INFERENCE_CONFIG), config2);
              validatePersonInferenceConfig(config2);
              _a2 = this.segmentPersonActivation(input, config2.internalResolution, config2.segmentationThreshold), segmentation = _a2.segmentation, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd, padding = _a2.padding, internalResolutionHeightAndWidth = _a2.internalResolutionHeightAndWidth;
              _b = segmentation.shape, height = _b[0], width = _b[1];
              return [4, segmentation.data()];
            case 1:
              result = _c.sent();
              segmentation.dispose();
              return [4, toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];
            case 2:
              tensorBuffers = _c.sent();
              scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
              poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config2.maxDetections, config2.scoreThreshold, config2.nmsRadius);
              poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding);
              heatmapScores.dispose();
              offsets.dispose();
              displacementFwd.dispose();
              displacementBwd.dispose();
              return [2, { height, width, data: result, allPoses: poses }];
          }
        });
      });
    };
    BodyPix2.prototype.segmentMultiPerson = function(input, config2) {
      if (config2 === void 0) {
        config2 = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;
        var _this = this;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              config2 = __assign(__assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config2);
              validateMultiPersonInstanceInferenceConfig(config2);
              _a2 = getInputSize(input), height = _a2[0], width = _a2[1];
              internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(config2.internalResolution, this.baseModel.outputStride, [height, width]);
              _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
              _c = tidy(function() {
                var _a3 = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a3.segmentLogits, longOffsets2 = _a3.longOffsets, heatmapScores = _a3.heatmapScores, offsets = _a3.offsets, displacementFwd = _a3.displacementFwd, displacementBwd = _a3.displacementBwd;
                var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]]);
                var scaledLongOffsets;
                {
                  scaledLongOffsets = longOffsets2;
                }
                var segmentation2 = toMaskTensor(squeeze(scaledSegmentScores), config2.segmentationThreshold);
                return {
                  segmentation: segmentation2,
                  longOffsets: scaledLongOffsets,
                  heatmapScoresRaw: heatmapScores,
                  offsetsRaw: offsets,
                  displacementFwdRaw: displacementFwd,
                  displacementBwdRaw: displacementBwd
                };
              }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw;
              return [4, toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];
            case 1:
              tensorBuffers = _d.sent();
              scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
              poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config2.maxDetections, config2.scoreThreshold, config2.nmsRadius);
              poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding);
              return [4, decodePersonInstanceMasks(segmentation, longOffsets, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config2.scoreThreshold, config2.refineSteps, config2.minKeypointScore, config2.maxDetections)];
            case 2:
              instanceMasks = _d.sent();
              resized.dispose();
              segmentation.dispose();
              longOffsets.dispose();
              heatmapScoresRaw.dispose();
              offsetsRaw.dispose();
              displacementFwdRaw.dispose();
              displacementBwdRaw.dispose();
              return [2, instanceMasks];
          }
        });
      });
    };
    BodyPix2.prototype.segmentPersonPartsActivation = function(input, internalResolution, segmentationThreshold) {
      var _this = this;
      if (segmentationThreshold === void 0) {
        segmentationThreshold = 0.5;
      }
      var _a2 = getInputSize(input), height = _a2[0], width = _a2[1];
      var internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(internalResolution, this.baseModel.outputStride, [height, width]);
      var _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
      var _c = tidy(function() {
        var _a3 = _this.predictForPersonSegmentationAndPart(resized), segmentLogits = _a3.segmentLogits, partHeatmapLogits = _a3.partHeatmapLogits, heatmapScores2 = _a3.heatmapScores, offsets2 = _a3.offsets, displacementFwd2 = _a3.displacementFwd, displacementBwd2 = _a3.displacementBwd;
        var _b2 = resized.shape, resizedHeight = _b2[0], resizedWidth = _b2[1];
        var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]]);
        var scaledPartHeatmapScore = scaleAndCropToInputTensorShape(partHeatmapLogits, [height, width], [resizedHeight, resizedWidth], [[padding.top, padding.bottom], [padding.left, padding.right]]);
        var segmentation = toMaskTensor(squeeze(scaledSegmentScores), segmentationThreshold);
        return {
          partSegmentation: decodePartSegmentation(segmentation, scaledPartHeatmapScore),
          heatmapScores: heatmapScores2,
          offsets: offsets2,
          displacementFwd: displacementFwd2,
          displacementBwd: displacementBwd2
        };
      }), partSegmentation = _c.partSegmentation, heatmapScores = _c.heatmapScores, offsets = _c.offsets, displacementFwd = _c.displacementFwd, displacementBwd = _c.displacementBwd;
      resized.dispose();
      return {
        partSegmentation,
        heatmapScores,
        offsets,
        displacementFwd,
        displacementBwd,
        padding,
        internalResolutionHeightAndWidth
      };
    };
    BodyPix2.prototype.segmentPersonParts = function(input, config2) {
      if (config2 === void 0) {
        config2 = PERSON_INFERENCE_CONFIG;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, partSegmentation, heatmapScores, offsets, displacementFwd, displacementBwd, padding, internalResolutionHeightAndWidth, _b, height, width, data, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              config2 = __assign(__assign({}, PERSON_INFERENCE_CONFIG), config2);
              validatePersonInferenceConfig(config2);
              _a2 = this.segmentPersonPartsActivation(input, config2.internalResolution, config2.segmentationThreshold), partSegmentation = _a2.partSegmentation, heatmapScores = _a2.heatmapScores, offsets = _a2.offsets, displacementFwd = _a2.displacementFwd, displacementBwd = _a2.displacementBwd, padding = _a2.padding, internalResolutionHeightAndWidth = _a2.internalResolutionHeightAndWidth;
              _b = partSegmentation.shape, height = _b[0], width = _b[1];
              return [4, partSegmentation.data()];
            case 1:
              data = _c.sent();
              partSegmentation.dispose();
              return [4, toTensorBuffers3D([heatmapScores, offsets, displacementFwd, displacementBwd])];
            case 2:
              tensorBuffers = _c.sent();
              scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
              poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config2.maxDetections, config2.scoreThreshold, config2.nmsRadius);
              poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding);
              heatmapScores.dispose();
              offsets.dispose();
              displacementFwd.dispose();
              displacementBwd.dispose();
              return [2, { height, width, data, allPoses: poses }];
          }
        });
      });
    };
    BodyPix2.prototype.segmentMultiPersonParts = function(input, config2) {
      if (config2 === void 0) {
        config2 = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG;
      }
      return __awaiter(this, void 0, void 0, function() {
        var _a2, height, width, internalResolutionHeightAndWidth, _b, resized, padding, _c, segmentation, longOffsets, heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw, partSegmentation, tensorBuffers, scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, poses, instanceMasks;
        var _this = this;
        return __generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              config2 = __assign(__assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), config2);
              validateMultiPersonInstanceInferenceConfig(config2);
              _a2 = getInputSize(input), height = _a2[0], width = _a2[1];
              internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(config2.internalResolution, this.baseModel.outputStride, [height, width]);
              _b = padAndResizeTo(input, internalResolutionHeightAndWidth), resized = _b.resized, padding = _b.padding;
              _c = tidy(function() {
                var _a3 = _this.predictForMultiPersonInstanceSegmentationAndPart(resized), segmentLogits = _a3.segmentLogits, longOffsets2 = _a3.longOffsets, heatmapScores = _a3.heatmapScores, offsets = _a3.offsets, displacementFwd = _a3.displacementFwd, displacementBwd = _a3.displacementBwd, partHeatmaps = _a3.partHeatmaps;
                var scaledSegmentScores = scaleAndCropToInputTensorShape(segmentLogits, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]]);
                var scaledPartSegmentationScores = scaleAndCropToInputTensorShape(partHeatmaps, [height, width], internalResolutionHeightAndWidth, [[padding.top, padding.bottom], [padding.left, padding.right]]);
                var scaledLongOffsets = longOffsets2;
                var segmentation2 = toMaskTensor(squeeze(scaledSegmentScores), config2.segmentationThreshold);
                var partSegmentation2 = decodeOnlyPartSegmentation(scaledPartSegmentationScores);
                return {
                  segmentation: segmentation2,
                  longOffsets: scaledLongOffsets,
                  heatmapScoresRaw: heatmapScores,
                  offsetsRaw: offsets,
                  displacementFwdRaw: displacementFwd,
                  displacementBwdRaw: displacementBwd,
                  partSegmentation: partSegmentation2
                };
              }), segmentation = _c.segmentation, longOffsets = _c.longOffsets, heatmapScoresRaw = _c.heatmapScoresRaw, offsetsRaw = _c.offsetsRaw, displacementFwdRaw = _c.displacementFwdRaw, displacementBwdRaw = _c.displacementBwdRaw, partSegmentation = _c.partSegmentation;
              return [4, toTensorBuffers3D([heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw])];
            case 1:
              tensorBuffers = _d.sent();
              scoresBuf = tensorBuffers[0], offsetsBuf = tensorBuffers[1], displacementsFwdBuf = tensorBuffers[2], displacementsBwdBuf = tensorBuffers[3];
              poses = decodeMultiplePoses(scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf, this.baseModel.outputStride, config2.maxDetections, config2.scoreThreshold, config2.nmsRadius);
              poses = scaleAndFlipPoses(poses, [height, width], internalResolutionHeightAndWidth, padding);
              return [4, decodePersonInstancePartMasks(segmentation, longOffsets, partSegmentation, poses, height, width, this.baseModel.outputStride, internalResolutionHeightAndWidth, padding, config2.scoreThreshold, config2.refineSteps, config2.minKeypointScore, config2.maxDetections)];
            case 2:
              instanceMasks = _d.sent();
              resized.dispose();
              segmentation.dispose();
              longOffsets.dispose();
              heatmapScoresRaw.dispose();
              offsetsRaw.dispose();
              displacementFwdRaw.dispose();
              displacementBwdRaw.dispose();
              partSegmentation.dispose();
              return [2, instanceMasks];
          }
        });
      });
    };
    BodyPix2.prototype.dispose = function() {
      this.baseModel.dispose();
    };
    return BodyPix2;
  }()
);
function loadMobileNet(config2) {
  return __awaiter(this, void 0, void 0, function() {
    var outputStride, quantBytes, multiplier, url, graphModel, mobilenet;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          outputStride = config2.outputStride;
          quantBytes = config2.quantBytes;
          multiplier = config2.multiplier;
          if (tf == null) {
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          }
          url = mobileNetSavedModel(outputStride, multiplier, quantBytes);
          return [4, loadGraphModel(config2.modelUrl || url)];
        case 1:
          graphModel = _a2.sent();
          mobilenet = new MobileNet(graphModel, outputStride);
          return [2, new BodyPix(mobilenet)];
      }
    });
  });
}
function loadResNet(config2) {
  return __awaiter(this, void 0, void 0, function() {
    var outputStride, quantBytes, url, graphModel, resnet;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          outputStride = config2.outputStride;
          quantBytes = config2.quantBytes;
          if (tf == null) {
            throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");
          }
          url = resNet50SavedModel(outputStride, quantBytes);
          return [4, loadGraphModel(config2.modelUrl || url)];
        case 1:
          graphModel = _a2.sent();
          resnet = new ResNet(graphModel, outputStride);
          return [2, new BodyPix(resnet)];
      }
    });
  });
}
function load(config2) {
  if (config2 === void 0) {
    config2 = MOBILENET_V1_CONFIG;
  }
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a2) {
      config2 = validateModelConfig(config2);
      if (config2.architecture === "ResNet50") {
        return [2, loadResNet(config2)];
      } else if (config2.architecture === "MobileNetV1") {
        return [2, loadMobileNet(config2)];
      } else {
        return [2, null];
      }
    });
  });
}
async function getBase64Image(src, removeImageBackGround, callback, outputFormat) {
  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.addEventListener("load", () => loadFunc(), false);
  async function loadFunc() {
    const canvas = document.createElement("canvas");
    const ctx2 = canvas.getContext("2d");
    let convertingCanvas = canvas;
    if (removeImageBackGround) {
      const selectedSize = 320;
      canvas.height = selectedSize;
      canvas.width = selectedSize;
      ctx2.drawImage(img, 0, 0, selectedSize, selectedSize);
      await removeBackGround(canvas);
      const canvas2 = document.createElement("canvas");
      const ctx22 = canvas2.getContext("2d");
      canvas2.height = 64;
      canvas2.width = 64;
      ctx22.drawImage(canvas, 0, 0, selectedSize, selectedSize, 0, 0, img.naturalHeight, img.naturalHeight);
      convertingCanvas = canvas2;
    } else {
      canvas.height = img.naturalHeight;
      canvas.width = img.naturalWidth;
      ctx2.drawImage(img, 0, 0);
    }
    const dataURL = convertingCanvas.toDataURL(outputFormat);
    canvas.remove();
    convertingCanvas.remove();
    img.remove();
    callback(dataURL);
  }
  img.src = src;
  if (img.complete || img.complete === void 0) {
    img.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAkCAIAAACIS8SLAAAAKklEQVRIie3NMQEAAAgDILV/55nBww8K0Enq2XwHDofD4XA4HA6Hw+E4Wwq6A0U+bfCEAAAAAElFTkSuQmCC";
    img.src = src;
  }
}
async function Convert(pMugShotTxd, removeImageBackGround, id2) {
  let tempUrl = `https://nui-img/${pMugShotTxd}/${pMugShotTxd}?t=${String(Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3))}`;
  if (pMugShotTxd === "none") {
    tempUrl = "/img/failSafe.png";
  }
  getBase64Image(tempUrl, removeImageBackGround, (dataUrl) => {
    fetch(`https://kibra-smartpad/Answer`, {
      method: "POST",
      body: JSON.stringify({
        Answer: dataUrl,
        Id: id2
      })
    });
  });
}
async function removeBackGround(sentCanvas) {
  const canvas = sentCanvas;
  const ctx2 = canvas.getContext("2d");
  const net = await load({
    architecture: "MobileNetV1",
    outputStride: 16,
    multiplier: 0.75,
    quantBytes: 2,
    modelUrl: "/js/models/model-stride16.json"
  });
  const { data: map } = await net.segmentPerson(canvas, {
    internalResolution: "medium"
  });
  const { data: imgData } = ctx2.getImageData(0, 0, canvas.width, canvas.height);
  const newImg = ctx2.createImageData(canvas.width, canvas.height);
  const newImgData = newImg.data;
  for (let i = 0; i < map.length; i++) {
    const [r, g, b, a] = [imgData[i * 4], imgData[i * 4 + 1], imgData[i * 4 + 2], imgData[i * 4 + 3]];
    [newImgData[i * 4], newImgData[i * 4 + 1], newImgData[i * 4 + 2], newImgData[i * 4 + 3]] = !map[i] ? [255, 255, 255, 0] : [r, g, b, a];
  }
  ctx2.putImageData(newImg, 0, 0);
}
function GotMessage(event) {
  const msg = event.data;
  if (msg.type === "convert") {
    Convert(msg.pMugShotTxd, msg.removeImageBackGround, msg.id);
  }
}
window.addEventListener("message", GotMessage, false);
const LoadingCircle = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-circle", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
  ] });
};
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time2 = raf.now() + ms;
  const cancel = () => {
    const i = timeouts.findIndex((t) => t.cancel == cancel);
    if (~i)
      timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  const timeout = { time: time2, handler, cancel };
  timeouts.splice(findTimeout(time2), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time2) => ~(~timeouts.findIndex((t) => t.time > time2) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count2 = findTimeout(ts);
  if (count2) {
    eachSafely(timeouts.splice(0, count2), (t) => t.handler());
    pendingCount -= count2;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value) => {
    try {
      each2(value);
    } catch (e) {
      raf.catch(e);
    }
  });
}
var __defProp2 = Object.defineProperty;
var __export = (target, all2) => {
  for (var name in all2)
    __defProp2(target, name, { get: all2[name], enumerable: true });
};
var globals_exports = {};
__export(globals_exports, {
  assign: () => assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});
function noop() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a) => !!a && a.constructor.name === "Object",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0
};
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  return a === b;
}
var each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx2) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn.call(ctx2, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   *  Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt) {
  const nextFrame2 = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame2.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame2;
  return currentFrame.length > 0;
}
function findIndex(arr, test2) {
  const index = arr.findIndex(test2);
  return index < 0 ? arr.length : index;
}
var clamp = (min2, max2, v) => Math.min(Math.max(v, min2), max2);
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color2) {
  let match;
  if (typeof color2 === "number") {
    return color2 >>> 0 === color2 && color2 >= 0 && color2 <= 4294967295 ? color2 : null;
  }
  if (match = hex6.exec(color2))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color2] !== void 0) {
    return colors[color2];
  }
  if (match = rgb.exec(color2)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color2)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color2)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color2))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color2)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color2)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color2)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int2 = parseInt(str, 10);
  if (int2 < 0)
    return 0;
  if (int2 > 255)
    return 255;
  return int2;
}
function parse360(str) {
  const int2 = parseFloat(str);
  return (int2 % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int2 = parseFloat(str);
  if (int2 < 0)
    return 0;
  if (int2 > 100)
    return 1;
  return int2 / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r = (int32Color & 4278190080) >>> 24;
  const g = (int32Color & 16711680) >>> 16;
  const b = (int32Color & 65280) >>> 8;
  const a = (int32Color & 255) / 255;
  return `rgba(${r}, ${g}, ${b}, ${a})`;
}
var createInterpolator = (range2, output, extrapolate) => {
  if (is.fun(range2)) {
    return range2;
  }
  if (is.arr(range2)) {
    return createInterpolator({
      range: range2,
      output,
      extrapolate
    });
  }
  if (is.str(range2.output[0])) {
    return createStringInterpolator(range2);
  }
  const config2 = range2;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t) => t);
  return (input) => {
    const range22 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range22],
      inputRange[range22 + 1],
      outputRange[range22],
      outputRange[range22 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config2.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i)
    if (inputRange[i] >= input)
      break;
  return i - 1;
}
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
  steps
};
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers2 = target[$observers];
  if (observers2) {
    observers2.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers2 = target[$observers];
    if (!observers2) {
      setHidden(target, $observers, observers2 = /* @__PURE__ */ new Set());
    }
    if (!observers2.has(observer2)) {
      observers2.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers2.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers2 = target[$observers];
  if (observers2 && observers2.has(observer2)) {
    const count2 = observers2.size - 1;
    if (count2) {
      observers2.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count2, observer2);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value2) {
      return value2;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes2 = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes2[0].map(
    (_, i) => keyframes2.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config2, output: output2 })
  );
  return (input) => {
    var _a2;
    const missingUnit = !unitRegex.test(output[0]) && ((_a2 = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a2.replace(numberRegex, ""));
    let i = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? reactExports.useEffect : reactExports.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update2 = reactExports.useState()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update2(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = reactExports.useState(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = reactExports.useRef();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  reactExports.useEffect(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => reactExports.useEffect(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = reactExports.useRef();
  reactExports.useEffect(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}
var $node = Symbol.for("Animated:node");
var isAnimated$1 = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value) {
    return new AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step2) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step2) {
        value = Math.round(value / step2) * step2;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  /** @internal */
  static create(value) {
    return new AnimatedString(value);
  }
  getValue() {
    const value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = { dependencies: null };
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated$1(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
var withAnimated = (Component, host2) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return reactExports.forwardRef((givenProps, givenRef) => {
    const instanceRef = reactExports.useRef(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    reactExports.useCallback(
      (value) => {
        instanceRef.current = updateRef(givenRef, value);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = reactExports.useRef();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    reactExports.useEffect(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return /* @__PURE__ */ reactExports.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update2, deps) {
    this.update = update2;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host2.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref))
      ref(value);
    else
      ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: applyAnimatedValues2 = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: applyAnimatedValues2,
    createAnimatedStyle,
    getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform2 = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform2(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count2 = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count2++;
    }
  });
  if (count2) {
    return forward;
  }
}
function inferTo(props) {
  const to2 = getForwardProps(props);
  if (to2) {
    const out = { to: to2 };
    eachProp(props, (val, key) => key in to2 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props)
    return true;
  return false;
}
function isAsyncTo(to2) {
  return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
}
function detachRefs(ctrl, ref) {
  var _a2;
  (_a2 = ctrl.ref) == null ? void 0 : _a2.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  var _a2;
  if (ref && ctrl.ref !== ref) {
    (_a2 = ctrl.ref) == null ? void 0 : _a2.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay2;
    let timeout;
    let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay2 = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay2 = timeout.time - raf.now();
    }
    function onResume() {
      if (delay2 > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay2);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to2, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to2 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to2;
    const defaultProps = getDefaultProps(
      props,
      (value, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to2)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to2);
      } else {
        animating = Promise.resolve(to2(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t) => t.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count2) {
    if (count2 == 1)
      this._attach();
  }
  observerRemoved(count2) {
    if (count2 == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.animation = new Animation();
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i) => {
      if (node2.done)
        return;
      const to2 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
      );
      let finished = anim.immediate;
      let position = to2;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position = from + config2.easing(p) * (to2 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
          let isMoving;
          let isBouncing = false;
          const step2 = 1;
          const numSteps = Math.ceil(dt / step2);
          for (let n = 0; n < numSteps; ++n) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to2 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to2 || position > to2 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to2;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to2);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step2;
            position = position + velocity * step2;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to2, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to2, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to2, arg2) {
    let queue;
    if (!is.und(to2)) {
      queue = [is.obj(to2) ? to2 : { ...arg2, to: to2 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to2 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to2, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to2, from } = props;
    to2 = is.obj(to2) ? to2[key] : to2;
    if (to2 == null || isAsyncTo(to2)) {
      to2 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range2 = { to: to2, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to2, from] = [from, to2];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to2);
      }
    }
    return range2;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range2 = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range2)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range2, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range2.to);
    const hasFromProp = !is.und(range2.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to2 = prevTo, from = prevFrom } = range2;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
      to2 = from;
    }
    if (props.reverse)
      [to2, from] = [from, to2];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to2, prevTo);
    if (hasToChanged) {
      this._focus(to2);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to2)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value = reset ? from : this.get();
    const goal = computeGoal(to2);
    const isAnimatable2 = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable2 || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to2);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to2);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            var _a2;
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              (_a2 = anim.onStart) == null ? void 0 : _a2.call(anim, result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      addFluidObserver(to2, this);
      if (isFrameValue(to2)) {
        priority2 = to2.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const { to: to2 } = this.animation;
    if (hasFluidValue(to2)) {
      removeFluidObserver(to2, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to2) {
  const goal = computeGoal(to2);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
  const loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse2 = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop: loop2,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse2 || isAsyncTo(to2) ? to2 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to2, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to2))
    findDefined(to2, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update2 = createUpdate(props);
  if (is.und(update2.default)) {
    update2.default = getDefaultProps(update2);
  }
  return update2;
}
function findDefined(values, keys) {
  eachProp(values, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _a2, _b, _c, _d;
  (_b = (_a2 = target.animation)[type]) == null ? void 0 : _b.call(_a2, ...args);
  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    this.springs = {};
    this.queue = [];
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring2) => {
      return spring2.idle && !spring2.isDelayed && !spring2.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring2, key) => values[key] = spring2.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value = values[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring2) => spring2.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to2, from, loop: loop2, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to2 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to2);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring2, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring2;
      addFluidObserver(spring2, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring2 = new SpringValue();
  spring2.key = key;
  if (observer) {
    addFluidObserver(spring2, observer);
  }
  return spring2;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring2 = springs[key] || (springs[key] = create(key));
      spring2["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = reactExports.useContext(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = ctx;
  return /* @__PURE__ */ reactExports.createElement(Provider, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, reactExports.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = _getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i)
      current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl, i) => {
      const update2 = is.fun(values) ? values(i, ctrl) : values;
      if (update2) {
        ctrl.set(update2);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update2 = this._getProps(props, ctrl, i);
        if (update2) {
          results.push(ctrl.start(update2));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = reactExports.useMemo(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = reactExports.useRef(0);
  const forceUpdate = useForceUpdate();
  const state = reactExports.useMemo(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = reactExports.useRef([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  reactExports.useMemo(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  reactExports.useMemo(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
      const update2 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update2) {
        updates[i] = declareUpdate(update2);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context2 = reactExports.useContext(SpringContext);
  const prevContext = usePrev(context2);
  const hasContext = context2 !== prevContext && hasProps(context2);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context2 });
      }
      const update2 = updates[i];
      if (update2) {
        replaceRef(ctrl, update2.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update2);
        } else {
          ctrl.start(update2);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x) => ({ ...x }));
  return ref ? [values, ref] : values;
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    this.idle = true;
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var reactDomExports = requireReactDom();
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "")
    return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n) => "-" + n.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values[i]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id2) => is.arr(value) ? value.every((v) => isValueIdentity(v, id2)) : is.num(value) ? value === id2 : parseFloat(value) === id2;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform2) => [transform2, transform2 === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z2, deg]) => [
            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform2 = "";
    let identity = true;
    each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id2] = this.transforms[i](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform2 += " " + t;
      identity = identity && id2;
    });
    return identity ? "none" : transform2;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count2) {
    if (count2 == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count2) {
    if (count2 == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: reactDomExports.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;
const SplitText = ({
  text = "",
  className = "",
  delay: delay2 = 100,
  animationFrom = { opacity: 0, transform: "translate3d(0,40px,0)" },
  animationTo = { opacity: 1, transform: "translate3d(0,0,0)" },
  easing = "easeOutCubic",
  threshold: threshold2 = 0.1,
  rootMargin = "-100px",
  textAlign = "center",
  onLetterAnimationComplete
}) => {
  const words = text.split(" ").map((word) => word.split(""));
  const letters = words.flat();
  const [inView, setInView] = reactExports.useState(false);
  const ref = reactExports.useRef();
  const animatedCount = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.unobserve(ref.current);
        }
      },
      { threshold: threshold2, rootMargin }
    );
    observer.observe(ref.current);
    return () => observer.disconnect();
  }, [threshold2, rootMargin]);
  const springs = useSprings(
    letters.length,
    letters.map((_, i) => ({
      from: animationFrom,
      to: inView ? async (next) => {
        await next(animationTo);
        animatedCount.current += 1;
        if (animatedCount.current === letters.length && onLetterAnimationComplete) {
          onLetterAnimationComplete();
        }
      } : animationFrom,
      delay: i * delay2,
      config: { easing }
    }))
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      className: `split-parent ${className}`,
      style: { textAlign, overflow: "hidden", display: "inline", whiteSpace: "normal", wordWrap: "break-word" },
      children: words.map((word, wordIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { display: "inline-block", whiteSpace: "nowrap" }, children: [
        word.map((letter, letterIndex) => {
          const index = words.slice(0, wordIndex).reduce((acc, w) => acc + w.length, 0) + letterIndex;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            animated.span,
            {
              style: {
                ...springs[index],
                display: "inline-block",
                willChange: "transform, opacity"
              },
              children: letter
            },
            index
          );
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { display: "inline-block", width: "0.3em" }, children: "" })
      ] }, wordIndex))
    }
  );
};
const ShinyText = ({ text, disabled = false, speed = 5, className = "" }) => {
  const animationDuration = `${speed}s`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `shiny-text ${disabled ? "disabled" : ""} ${className}`,
      style: { animationDuration },
      children: text
    }
  );
};
const handlers = /* @__PURE__ */ new Map();
function useNui(action, handler) {
  if (!handlers.has(action)) {
    handlers.set(action, []);
  }
  handlers.get(action).push(handler);
}
function callNui(action, data, handler) {
  fetch(`https://kibra-smartpad/${action}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json; charset=UTF-8"
    },
    body: JSON.stringify(data)
  }).then((resp) => resp.json()).then((resp) => {
    if (handler) handler(resp);
  }).catch((error) => {
  });
}
window.addEventListener("message", (event) => {
  const action = event.data.action;
  const data = event.data.data;
  if (action === void 0) {
    return;
  }
  if (!handlers.has(action)) {
    return;
  }
  handlers.get(action).forEach((handler) => {
    handler(data);
  });
});
const LockScreen = ({ newPad, StartSetupScreen, loading: loading2, setNewPad, data, lang, months, days, notifications, background, setLoginX, logined, Notification: Notification2, batteryLevel }) => {
  const [notifysOpened, setOpened] = reactExports.useState(false);
  const [password, setPassword] = reactExports.useState("");
  const [error, setError] = reactExports.useState(false);
  const [correctPassword, setCorrectPassword] = reactExports.useState("nopass");
  const [setupTextShowed, setSetupText] = reactExports.useState(false);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const [color2, setColor] = reactExports.useState("rgb(237, 237, 237)");
  const [isUnlocked, setIsUnlocked] = reactExports.useState(false);
  const [showForgot, setShowForgot] = reactExports.useState(false);
  const [secInput, setSecInput] = reactExports.useState("");
  const [secError, setSecError] = reactExports.useState(false);
  const [allowReset, setAllowReset] = reactExports.useState(false);
  const [newPass, setNewPass] = reactExports.useState("");
  const [newPassConfirm, setNewPassConfirm] = reactExports.useState("");
  const [passMatch, setPassMatch] = reactExports.useState(false);
  const handleAnimationComplete = () => {
  };
  const passValid = /^\d{6}$/.test(newPass);
  const [tabletBackground, setBackground] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (background) {
      setBackground(background);
    } else {
      setBackground(background);
    }
  }, []);
  reactExports.useEffect(() => {
    setPassMatch(newPass !== "" && newPass === newPassConfirm);
  }, [newPass, newPassConfirm]);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  reactExports.useEffect(() => {
    if (!newPad) {
      if (data) {
        if (data.data.passcode == "nopass") {
          setIsUnlocked(true);
          setLoginX(true);
        } else {
          setCorrectPassword(data.data.passcode);
        }
      } else {
        setCorrectPassword("allah");
      }
    }
  }, [newPad, data, isUnlocked, logined]);
  const handleSecSubmit = () => {
    if (secInput === data.data.security.answer) setAllowReset(true);
    else {
      setSecError(true);
      setTimeout(() => setSecError(false), 300);
    }
  };
  --Notification2;
  const handleResetSubmit = () => {
    setCorrectPassword(newPass);
    setShowForgot(false);
    callNui("UpdateTabletMainData", {
      datatype: "passcode",
      result: newPass
    });
  };
  const formattedDate = `${days[time2.getDay()]}, ${time2.getDate()} ${months[time2.getMonth()]} ${time2.getFullYear()}`;
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setTime(/* @__PURE__ */ new Date());
    }, 1e3);
    return () => clearInterval(interval);
  }, []);
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setColor(generateRandomGray());
    }, 400);
    return () => clearInterval(interval);
  }, []);
  const generateRandomGray = () => {
    const grayValue = Math.floor(Math.random() * 156) + 100;
    return `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
  };
  const handlePasswordSubmit = () => {
    if (parseInt(password) == correctPassword) {
      setError(false);
      setOpened(true);
      setLoginX(true);
      setIsUnlocked(true);
    } else {
      setError(true);
      setLoginX(false);
      setIsUnlocked(false);
      setTimeout(() => setError(false), 300);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "tablet-frame-lockscreen",
      style: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "100%",
        height: "100%",
        backgroundImage: `url("/web/build/${tabletBackground}-background.jpg")`,
        backgroundSize: "100% 100%",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        borderRadius: "28px",
        userSelect: "none",
        zIndex: "1"
      },
      children: [
        !newPad && !loading2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "lockscreen-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lockscreen-time", children: formattedTime }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lockscreen-date", children: formattedDate })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "lock-icon", children: isUnlocked ? /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-unlock" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-lock" }) }),
          !logined && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "login-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "avatar-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: `/web/pimg/${data.owner}.png`,
                onError: (e) => {
                  e.currentTarget.onerror = null;
                  e.currentTarget.src = "/web/pimg/avatar.png";
                },
                className: "user-avatar"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "username", children: data.data.ownername }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "password-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "password-input-wrapper", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "password",
                    className: `password-input ${error ? "shake" : ""}`,
                    placeholder: lang.enterYourPass,
                    value: password,
                    onChange: (e) => setPassword(e.target.value)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "password-submit", onClick: handlePasswordSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-right" }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setShowForgot(true), className: "forgot", children: "Forgot Password" })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tablet-frame-homescreen-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icons battery", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-shell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "battery-level",
                    style: {
                      width: `${batteryLevel}%`,
                      backgroundColor: batteryLevel < 20 ? "red" : "rgb(227 227 227)"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "battery-percent", children: [
                  batteryLevel,
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
              ] }) })
            ] })
          ] }),
          notifysOpened && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-container", children: notifications.map((data2) => {
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `/web/build/appicons/${data2.apphash}`, alt: "App Icon" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notification-content", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-title", children: data2.appname }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notification-body", children: data2.text })
              ] })
            ] });
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showForgot && /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { className: "modal-backdrop2", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { className: "modal-frame2", initial: { scale: 0.8 }, animate: { scale: 1 }, exit: { scale: 0.8 }, transition: { duration: 0.3 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setShowForgot(false), className: "delete-x", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-xmark" }) }),
            !allowReset ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-title2", children: lang.secqu }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "helal", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                  lang.question,
                  ": "
                ] }),
                data.data.security.question
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", placeholder: lang.secanswer, className: `sec-input ${secError ? "shake" : ""}`, value: secInput, onChange: (e) => setSecInput(e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { disabled: !secInput, onClick: handleSecSubmit, children: lang.submit })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "password", placeholder: lang.newPass, value: newPass, onChange: (e) => setNewPass(e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "password", placeholder: lang.confirmPass, value: newPassConfirm, onChange: (e) => setNewPassConfirm(e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { disabled: !(passMatch && passValid), onClick: handleResetSubmit, children: lang.confirm })
            ] })
          ] }) }) })
        ] }),
        newPad && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => {
              setNewPad(false);
              if (newPad) StartSetupScreen();
            },
            className: "newpadscreen-frame",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  onMouseEnter: () => setSetupText(true),
                  onMouseLeave: () => setSetupText(false),
                  style: {
                    color: color2,
                    // Dinamik renk deiimini korur (imdilik effaf olduundan etkili deil)
                    WebkitTextStrokeColor: color2,
                    // Dinamik olarak stroke rengini deitirir
                    transition: "color 0.5s ease, -webkit-text-stroke-color 0.5s ease"
                  },
                  className: "newpadscreen-frame-text",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    SplitText,
                    {
                      text: lang.hello,
                      className: "text-2xl font-semibold text-center",
                      delay: 150,
                      animationFrom: { opacity: 0, transform: "translate3d(0,50px,0)" },
                      animationTo: { opacity: 1, transform: "translate3d(0,0,0)" },
                      easing: "easeOutCubic",
                      threshold: 0.2,
                      rootMargin: "-50px",
                      onLetterAnimationComplete: handleAnimationComplete
                    }
                  )
                }
              ),
              setupTextShowed && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "newpadscreen-setuptext",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ShinyText, { text: lang.setupYourTablet, disabled: false, speed: 3, className: "custom-class" })
                }
              )
            ]
          }
        ) }),
        loading2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingCircle, {}) })
      ]
    }
  ) });
};
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color: color2 = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref) => reactExports.createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$m = [
  ["rect", { width: "16", height: "10", x: "2", y: "7", rx: "2", ry: "2", key: "1w10f2" }],
  ["line", { x1: "22", x2: "22", y1: "11", y2: "13", key: "4dh1rd" }]
];
const Battery = createLucideIcon("Battery", __iconNode$m);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$l = [
  ["path", { d: "M10.268 21a2 2 0 0 0 3.464 0", key: "vwvbt9" }],
  [
    "path",
    {
      d: "M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326",
      key: "11g9vi"
    }
  ]
];
const Bell = createLucideIcon("Bell", __iconNode$l);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$k = [
  ["path", { d: "M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16", key: "jecpp" }],
  ["rect", { width: "20", height: "14", x: "2", y: "6", rx: "2", key: "i6l2r4" }]
];
const Briefcase = createLucideIcon("Briefcase", __iconNode$k);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$j = [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
];
const Calendar = createLucideIcon("Calendar", __iconNode$j);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$i = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]];
const Check = createLucideIcon("Check", __iconNode$i);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$h = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
const ChevronDown = createLucideIcon("ChevronDown", __iconNode$h);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$g = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
];
const CircleAlert = createLucideIcon("CircleAlert", __iconNode$g);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$f = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
];
const Clock$1 = createLucideIcon("Clock", __iconNode$f);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$e = [
  ["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }],
  ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]
];
const DollarSign = createLucideIcon("DollarSign", __iconNode$e);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$d = [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
];
const Lock = createLucideIcon("Lock", __iconNode$d);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$c = [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
];
const Menu = createLucideIcon("Menu", __iconNode$c);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$b = [
  [
    "path",
    {
      d: "M4 22h16a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2H8a2 2 0 0 0-2 2v16a2 2 0 0 1-2 2Zm0 0a2 2 0 0 1-2-2v-9c0-1.1.9-2 2-2h2",
      key: "7pis2x"
    }
  ],
  ["path", { d: "M18 14h-8", key: "sponae" }],
  ["path", { d: "M15 18h-5", key: "95g1m2" }],
  ["path", { d: "M10 6h8v4h-8V6Z", key: "smlsk5" }]
];
const Newspaper = createLucideIcon("Newspaper", __iconNode$b);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$a = [
  ["path", { d: "M12 20h9", key: "t2du7b" }],
  [
    "path",
    {
      d: "M16.376 3.622a1 1 0 0 1 3.002 3.002L7.368 18.635a2 2 0 0 1-.855.506l-2.872.838a.5.5 0 0 1-.62-.62l.838-2.872a2 2 0 0 1 .506-.854z",
      key: "1ykcvy"
    }
  ]
];
const PenLine = createLucideIcon("PenLine", __iconNode$a);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$9 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
];
const Plus = createLucideIcon("Plus", __iconNode$9);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$8 = [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
];
const Search = createLucideIcon("Search", __iconNode$8);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$7 = [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
];
const Shield = createLucideIcon("Shield", __iconNode$7);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$6 = [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
];
const Trash2 = createLucideIcon("Trash2", __iconNode$6);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$5 = [
  ["polyline", { points: "22 7 13.5 15.5 8.5 10.5 2 17", key: "126l90" }],
  ["polyline", { points: "16 7 22 7 22 13", key: "kwv8wd" }]
];
const TrendingUp = createLucideIcon("TrendingUp", __iconNode$5);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$4 = [
  ["path", { d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6", key: "17hqa7" }],
  ["path", { d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18", key: "lmptdp" }],
  ["path", { d: "M4 22h16", key: "57wxv0" }],
  ["path", { d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22", key: "1nw9bq" }],
  ["path", { d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22", key: "1np0yb" }],
  ["path", { d: "M18 2H6v7a6 6 0 0 0 12 0V2Z", key: "u46fv3" }]
];
const Trophy = createLucideIcon("Trophy", __iconNode$4);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$3 = [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
];
const User = createLucideIcon("User", __iconNode$3);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$2 = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
];
const Users = createLucideIcon("Users", __iconNode$2);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode$1 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
const X = createLucideIcon("X", __iconNode$1);
/**
 * @license lucide-react v0.476.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const __iconNode = [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db"
    }
  ]
];
const Zap = createLucideIcon("Zap", __iconNode);
reactExports.createContext(void 0);
reactExports.createContext(void 0);
const SetupScreen = ({ isOpened, onCloseV2, setLoading, Notification: Notification2, keepMounted, style, lang, allLang, setLoginX, prefix: prefix2, allmails }) => {
  const [langScreen, SetLangScreen] = reactExports.useState(true);
  const [currentLang, setCurrentLang] = reactExports.useState(lang || {});
  const [wifiPart, WifiScreen] = reactExports.useState(false);
  const [chooseTheme, ChooseScreen] = reactExports.useState(false);
  const [selectedTheme, setSelectedTheme] = reactExports.useState("light");
  const [passwordScreen, setPasswordScreen] = reactExports.useState(false);
  const [faceidscreen, faceIdScreen] = reactExports.useState(false);
  const [createPasswordScreen, SetCreatePasswordSc] = reactExports.useState(false);
  const [securityPart, setSecurityPart] = reactExports.useState(false);
  const [tabletNamePart, setTabletNameScreen] = reactExports.useState(false);
  const [passcode, setPasscode] = reactExports.useState("");
  const [allMails, setAllMails] = reactExports.useState([]);
  const [welcomeScreen, setWelcomeScreen] = reactExports.useState(false);
  const containerRef = reactExports.useRef(null);
  const [tabletNameValue, setTabletNameValue] = reactExports.useState("");
  const [registeredTablets, setRegisteredTablets] = reactExports.useState([]);
  const [selectedTablet, onSelectTablet] = reactExports.useState(null);
  const [showTabletList, setShowTabletList] = reactExports.useState(false);
  const [isMailInUse, setIsMailInUse] = reactExports.useState(false);
  const [icloudScreen, setIcloudScreen] = reactExports.useState(false);
  const [icloudSignIn, setIcloudSignIn] = reactExports.useState(false);
  const [icloudCreateAccount, setIcloudCreateAccount] = reactExports.useState(false);
  const [icloudData, setIcloudData] = reactExports.useState({
    email: "",
    password: "",
    firstName: "",
    lastName: "",
    emailPrefix: "",
    emailPrefixChanged: false,
    birthDate: "",
    confirmPassword: ""
  });
  reactExports.useEffect(() => {
    if (!isOpened) {
      SetLangScreen(true);
      WifiScreen(false);
      ChooseScreen(false);
      faceIdScreen(false);
      setPasswordScreen(false);
      SetCreatePasswordSc(false);
      setSecurityPart(false);
      setTabletNameScreen(false);
      setWelcomeScreen(false);
      setIcloudScreen(false);
      setIcloudSignIn(false);
      setIcloudCreateAccount(false);
      setShowTabletList(false);
      onSelectTablet(null);
      setIsMailInUse(false);
      setIcloudData({
        email: "",
        password: "",
        firstName: "",
        lastName: "",
        emailPrefix: "",
        emailPrefixChanged: false,
        birthDate: "",
        confirmPassword: ""
      });
    }
  }, [isOpened]);
  const [showPassword, setShowPassword] = reactExports.useState(false);
  const [isCreatingAccount, setIsCreatingAccount] = reactExports.useState(false);
  const [settings, setSettings] = reactExports.useState({
    language: "en",
    region: "US",
    wifi: null,
    privacy: false,
    icloudAccount: null
  });
  const notificationRef = reactExports.useRef(Notification2);
  reactExports.useEffect(() => {
    notificationRef.current = Notification2;
  }, [Notification2]);
  const selectLanguage = (langTag) => {
    setSettings((prev) => ({ ...prev, language: langTag }));
    callNui("selectLanguage", { language: langTag }, (response) => {
      if (response && response.langData) {
        setCurrentLang(response.langData);
        handleSettingChange("language");
      }
    });
  };
  const updateTabletNamePart = (e) => {
    setTabletNameValue(e.target.value);
  };
  reactExports.useEffect(() => {
    setAllMails(allmails);
  }, [allMails]);
  reactExports.useEffect(() => {
    if (!icloudCreateAccount) return;
    const checkMail = `${icloudData.emailPrefix}@${prefix2}`;
    setIsMailInUse(allMails.some((x) => x.mail === checkMail));
  }, [icloudData.emailPrefix, allMails, prefix2, icloudCreateAccount]);
  const handleIcloudInput = (field, value) => {
    let updated;
    setIcloudData((prev) => {
      updated = { ...prev, [field]: value };
      if ((field === "firstName" || field === "lastName") && !prev.emailPrefixChanged) {
        const first = field === "firstName" ? value : updated.firstName;
        const last = field === "lastName" ? value : updated.lastName;
        updated.emailPrefix = `${first.toLowerCase()}.${last.toLowerCase()}`;
      }
      if (field === "emailPrefix") {
        updated.emailPrefixChanged = true;
      }
      return updated;
    });
    if (field === "emailPrefix") {
      const checkMail = `${value}@${prefix2}`;
      setIsMailInUse(allMails.some((x) => x.mail === checkMail));
    }
    if (field === "firstName" || field === "lastName") {
      let autoPrefix = field === "firstName" ? `${value.toLowerCase()}.${icloudData.lastName.toLowerCase()}` : `${icloudData.firstName.toLowerCase()}.${value.toLowerCase()}`;
      const checkMail = `${autoPrefix}@${prefix2}`;
      setIsMailInUse(allMails.some((x) => x.mail === checkMail));
    }
  };
  const validateEmail = (email) => {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  };
  const handleIcloudSignIn = async () => {
    if (!icloudData.email || !icloudData.password) {
      Notification2(currentLang.invalid || "Invalid", currentLang.fillAllFields || "Please fill all fields");
      return;
    }
    if (!validateEmail(icloudData.email)) {
      Notification2(currentLang.invalid || "Invalid", currentLang.invalidEmail || "Please enter a valid email");
      return;
    }
    callNui("checkAccount", {
      email: icloudData.email,
      password: icloudData.password
    }, (response) => {
      if (!response) {
        Notification2(currentLang.invalid || "Invalid", currentLang.invalidLogin || "Email or password is incorrect");
        return;
      }
      if (response.export && response.data.length > 0) {
        setRegisteredTablets(response.data);
        setShowTabletList(true);
      } else {
        proceedWithPasswordCreation();
      }
    });
  };
  const proceedWithPasswordCreation = () => {
    setSettings((prev) => ({ ...prev, icloudAccount: icloudData.email }));
    setIcloudSignIn(false);
    handleSettingChange("password");
  };
  const TabletListModal = ({ tablets, onClose, onContinue, onAddNewTablet, lang: lang2 }) => {
    const [selectedSerial, setSelectedSerial] = reactExports.useState(null);
    const handleTabletClick = (serial) => {
      setSelectedSerial(serial);
    };
    const handleAddNewTablet = () => {
      setSelectedSerial("new");
      onAddNewTablet();
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-tablet-list-modal", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-modal-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-modal-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang2.registeredTablets || "Registered Tablets" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-registered-tablets-container", children: [
        tablets.map((tablet, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `icloud-tablet-item ${selectedSerial === tablet.serial ? "selected" : ""}`,
            onClick: () => handleTabletClick(tablet.serial),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-tablet-device-name", children: tablet.tabname }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-tablet-serial-number", children: tablet.serial })
            ]
          },
          index
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `icloud-tablet-item add-new ${selectedSerial === "new" ? "selected" : ""}`,
            onClick: handleAddNewTablet,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icloud-tablet-add-icon", children: "+" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "icloud-tablet-add-text", children: lang2.addNewTablet || "Add New Tablet" })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-modal-action-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "icloud-modal-cancel-btn", onClick: onClose, children: lang2.cancel || "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "icloud-modal-continue-btn", onClick: onContinue, children: lang2.continue || "Continue" })
      ] })
    ] }) });
  };
  const handleIcloudCreate = () => {
    const fullEmail = `${icloudData.emailPrefix}@${prefix2}`;
    if (!icloudData.emailPrefix || !icloudData.password || !icloudData.confirmPassword || !icloudData.firstName || !icloudData.lastName || !icloudData.birthDate) {
      Notification2(currentLang.invalid || "Invalid", currentLang.fillAllFields || "Please fill all fields");
      return;
    }
    if (!validateEmail(fullEmail)) {
      Notification2(currentLang.invalid || "Invalid", currentLang.invalidEmail || "Please enter a valid email");
      return;
    }
    if (icloudData.password !== icloudData.confirmPassword) {
      Notification2(currentLang.invalid || "Invalid", currentLang.passwordMismatch || "Passwords do not match");
      return;
    }
    if (icloudData.password.length < 8) {
      Notification2(currentLang.invalid || "Invalid", currentLang.passwordTooShort || "Password must be at least 8 characters");
      return;
    }
    setIsCreatingAccount(true);
    setTimeout(() => {
      setSettings((prev) => ({ ...prev, icloudAccount: fullEmail }));
      setIcloudCreateAccount(false);
      setIsCreatingAccount(false);
      handleSettingChange("password");
    }, 2e3);
  };
  const handleSettingChange = (key) => {
    switch (key) {
      case "language":
        SetLangScreen(false);
        ChooseScreen(true);
        break;
      case "icloud":
        ChooseScreen(false);
        setIcloudScreen(true);
        break;
      case "icloud-signin":
        setIcloudScreen(false);
        setIcloudSignIn(true);
        break;
      case "icloud-create":
        setIcloudScreen(false);
        setIcloudCreateAccount(true);
        break;
      case "skip-icloud":
        setIcloudScreen(false);
        handleSettingChange("password");
        break;
      case "password":
        setIcloudScreen(false);
        setIcloudSignIn(false);
        setIcloudCreateAccount(false);
        ChooseScreen(false);
        setTabletNameScreen(false);
        setPasswordScreen(false);
        SetCreatePasswordSc(true);
        break;
      case "faceid":
        setTabletNameScreen(false);
        setPasswordScreen(false);
        faceIdScreen(true);
        break;
      case "cancel-faceid":
        faceIdScreen(false);
        setPasswordScreen(true);
        break;
      case "pincode":
        setPasswordScreen(false);
        ChooseScreen(false);
        SetCreatePasswordSc(true);
        break;
      case "welcomeScreen":
        if (!secQuest.trim() || !secAnswer.trim()) {
          Notification2(currentLang.invalid, currentLang.fillAllFields);
        } else {
          setSecurityPart(false);
          setWelcomeScreen(true);
        }
        break;
      case "securityPart":
        setTabletNameScreen(false);
        setSecurityPart(true);
        break;
      case "finish":
        setWelcomeScreen(false);
        onCloseV2(false);
        setLoading(true);
        setLoginX(true);
        callNui("saveNewTablet", {
          lang: settings.language,
          passcode,
          theme: selectedTheme,
          deviceName: tabletNameValue,
          securityQuest: secQuest,
          secAnswer,
          selectedtab: selectedTablet,
          icloudAccount: settings.icloudAccount,
          icloudData
        });
        break;
      case "giveTabletName":
        setPasswordScreen(false);
        SetCreatePasswordSc(false);
        setTabletNameScreen(true);
        break;
    }
  };
  reactExports.useEffect(() => {
    const handleKeyDown = (e) => {
      if (!isNaN(e.key) && e.key !== " " && createPasswordScreen) {
        setPasscode((prev) => {
          if (prev.length < 6) {
            const next = prev + e.key;
            if (next.length === 6) handleSettingChange("giveTabletName");
            return next;
          }
          return prev;
        });
      } else if (e.key === "Backspace" && createPasswordScreen) {
        setPasscode((prev) => prev.slice(0, -1));
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [createPasswordScreen]);
  const handleThemeChange = (theme) => {
    setSelectedTheme(theme);
  };
  const [secQuest, setSecQuest] = reactExports.useState("");
  const [secAnswer, setSecAnswer] = reactExports.useState("");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `setupscreen-frame ${isOpened ? "show" : "hide"}`, style: { display: isOpened ? "block" : "none" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `setupscreen-modal ${selectedTheme == "dark" ? "dark-mode" : ""}`, children: [
    langScreen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "select-lang-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { fontSize: "4rem" }, className: "fa-solid fa-globe" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "language-list", children: Object.entries(allLang).map(([tag, lang2]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => selectLanguage(tag), className: "language-list-item", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "language-list-item-text", children: lang2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "language-list-item-icon fas fa-chevron-right" })
      ] }, tag)) })
    ] }),
    icloudScreen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-main-screen minimal", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-minimal-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-circle-notch" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "icloud-minimal-title", children: currentLang.signInWithAppleId || "Sign in with Apple ID" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "icloud-minimal-desc", children: currentLang.icloudDescription || "Sign in to access your photos, purchases, iCloud, and more." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-minimal-buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "minimal-btn primary",
            onClick: () => handleSettingChange("icloud-signin"),
            children: currentLang.signIn || "Sign In"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "minimal-btn secondary",
            onClick: () => handleSettingChange("icloud-create"),
            children: currentLang.createAppleId || "Create Apple ID"
          }
        )
      ] })
    ] }) }),
    icloudSignIn && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-card-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "apple-logo-gradient", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "gradient-circle" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { fontSize: "42px" }, className: "fa-solid fa-circle-notch" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "icloud-card-title", children: currentLang.signInWithAppleId || "Sign in with Apple ID" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "icloud-card-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "email",
            className: "apple-input",
            placeholder: currentLang.appleId || "Apple ID",
            value: icloudData.email,
            onChange: (e) => handleIcloudInput("email", e.target.value)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "password-input-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: showPassword ? "text" : "password",
              className: "apple-input",
              placeholder: currentLang.password || "Password",
              value: icloudData.password,
              onChange: (e) => handleIcloudInput("password", e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "password-toggle-btn",
              onClick: () => setShowPassword(!showPassword),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: `fas fa-${showPassword ? "eye-slash" : "eye"}` })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "keep-signed-in", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "checkbox", id: "keepSignedIn", className: "apple-checkbox" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "keepSignedIn", children: currentLang.keepSignedIn || "Keep me signed in" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", className: "forgot-apple-id", children: currentLang.forgotAppleId || "Forgotten your Apple ID or password?" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "apple-continue-btn",
            onClick: handleIcloudSignIn,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-arrow-right" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "create-apple-id-link", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          currentLang.dontHaveAppleId || "Don't have an Apple ID?",
          " "
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: () => {
          setIcloudSignIn(false);
          setIcloudCreateAccount(true);
        }, children: currentLang.createYours || "Create yours now." })
      ] })
    ] }) }),
    icloudCreateAccount && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "icloud-card-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "icloud-card create-account", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "apple-back-btn",
          onClick: () => {
            setIcloudCreateAccount(false);
            setIcloudScreen(true);
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-chevron-left" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: currentLang.back || "Back" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "icloud-card-title", children: currentLang.createNewAppleId || "Create a new Apple ID" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "icloud-create-form", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "apple-input half",
              placeholder: currentLang.firstName || "First Name",
              value: icloudData.firstName,
              onChange: (e) => handleIcloudInput("firstName", e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "apple-input half",
              placeholder: currentLang.lastName || "Last Name",
              value: icloudData.lastName,
              onChange: (e) => handleIcloudInput("lastName", e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "apple-input",
            placeholder: "mm/dd/yyyy",
            value: icloudData.birthDate,
            onChange: (e) => handleIcloudInput("birthDate", e.target.value)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-divider" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "email-input-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "apple-input email-prefix",
              placeholder: currentLang.email || "Email",
              value: icloudData.emailPrefix,
              onChange: (e) => handleIcloudInput("emailPrefix", e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "email-suffix", children: [
            "@",
            prefix2
          ] })
        ] }),
        isMailInUse && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "red", fontSize: "0.9rem", marginTop: "2px" }, children: currentLang.mailInUse || "This email is already in use" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "password",
              className: "apple-input half",
              placeholder: currentLang.password || "Password",
              value: icloudData.password,
              onChange: (e) => handleIcloudInput("password", e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "password",
              className: "apple-input half",
              placeholder: currentLang.confirmPassword || "Confirm",
              value: icloudData.confirmPassword,
              onChange: (e) => handleIcloudInput("confirmPassword", e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "apple-create-btn",
            onClick: handleIcloudCreate,
            disabled: isCreatingAccount || isMailInUse,
            children: isCreatingAccount ? currentLang.creating || "Creating..." : currentLang.createAccount || "Create Account"
          }
        )
      ] })
    ] }) }),
    securityPart && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "security-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "security-label", children: currentLang.secpart }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: currentLang.infosec }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ios-input-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: currentLang.secquestion,
            value: secQuest,
            onChange: (e) => setSecQuest(e.target.value),
            className: "sec-input"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: currentLang.secanswer,
            value: secAnswer,
            onChange: (e) => setSecAnswer(e.target.value),
            className: "sec-input"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          disabled: !secQuest || !secAnswer,
          onClick: () => handleSettingChange("welcomeScreen"),
          className: "next-btn",
          children: currentLang.nextStep
        }
      )
    ] }),
    wifiPart && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wifi-selection", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-chevron-left back-icon" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: currentLang.back })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-sharp fa-regular fa-wifi" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wifilist", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wifi-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "WiFi" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fas fa-wifi wifi-icon" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wifi-item link", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: currentLang.choseAnotherNetwork }) })
      ] })
    ] }) }),
    tabletNamePart && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-selection-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-selection-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-selection-text ${selectedTheme === "dark" ? "dark-mode-st" : ""}`, children: currentLang.customizeTablet }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "theme-selection-paragraph", children: currentLang.giveTabletName })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tablet-name-givepart", children: /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: `theme-selection-text ${selectedTheme === "dark" ? "dark-mode-input" : ""}`, placeholder: currentLang.giveTabletName || "Give Tablet Name", value: tabletNameValue, onChange: (e) => updateTabletNamePart(e) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleSettingChange("securityPart"), className: "continue-button", children: currentLang.continue })
    ] }) }),
    showTabletList && /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabletListModal,
      {
        tablets: registeredTablets,
        lang: currentLang,
        onClose: () => setShowTabletList(false),
        onAddNewTablet: () => setSelectedTablet("new"),
        onContinue: () => {
          setShowTabletList(false);
          proceedWithPasswordCreation();
        }
      }
    ),
    chooseTheme && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-selection-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-selection-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-selection-text ${selectedTheme === "dark" ? "dark-mode-st" : ""}`, children: currentLang.lightOrDisplay }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "theme-selection-paragraph", children: currentLang.choselight })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "theme-options", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `theme-option ${selectedTheme === "light" ? "selected6" : ""}`,
            onClick: () => handleThemeChange("light"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "theme-preview light" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-label ${selectedTheme === "dark" ? "dark-mode-st" : ""}`, children: currentLang.light }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  name: "theme",
                  value: "light",
                  checked: selectedTheme === "light",
                  readOnly: true
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `theme-option ${selectedTheme === "dark" ? "selected6" : ""}`,
            onClick: () => handleThemeChange("dark"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "theme-preview dark" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-label ${selectedTheme === "dark" ? "dark-mode-st" : ""}`, children: currentLang.dark }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  name: "theme",
                  value: "dark",
                  checked: selectedTheme === "dark",
                  readOnly: true
                }
              )
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleSettingChange("icloud"), className: "continue-button", children: currentLang.continue })
    ] }) }),
    passwordScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faceid-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "i",
        {
          style: { "fontSize": "3.5rem", "paddingTop": "3.5rem", "color": "#0a5cc2" },
          className: "fa-duotone fa-solid fa-face-viewfinder"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `faceid-text ${selectedTheme == "dark" ? "dark-mode-st" : ""}`, children: currentLang.faceIdd }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: currentLang.faceid }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttoncon prime", onClick: () => handleSettingChange("faceid"), children: currentLang.continue }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttoncon", onClick: () => handleSettingChange("pincode"), children: currentLang.setupLater })
    ] }) }),
    faceidscreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "faceid-container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "faceid-headerText", children: currentLang.setupFaceId }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "faceid-avatarContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: "https://encrypted-tbn0.gstatic.com./build?q=tbn:ANd9GcTZpOFpjuJ3nwUs2h2pK75HtzQfioB7dY1wyg&s",
          alt: "Avatar Placeholder",
          className: "faceid-avatar"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "faceid-description", children: currentLang.faceidInfo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => handleSettingChange("cancel-faceid"), className: "faceid-setupButton", children: currentLang.cancel })
    ] }) }),
    createPasswordScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "passcode-container",
        tabIndex: "0",
        ref: containerRef,
        onClick: () => containerRef.current.focus(),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: `passcode-headerText ${selectedTheme == "dark" ? "dark-mode-st" : ""}`, children: currentLang.createPasscode }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "passcode-description", children: currentLang.passcodeEntry }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "passcode-inputContainer", children: [...Array(6)].map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `passcode-circle ${index < passcode.length ? "filled" : ""}`
            },
            index
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "passcode-backButton", onClick: () => setPasscode(""), children: currentLang.back })
        ]
      }
    ) }),
    welcomeScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "welcomeScreen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `welcome-string ${selectedTheme == "dark" ? "dark-mode-st" : ""}`, children: currentLang.welcome }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "welcome-desc", children: currentLang.yourTablet }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSettingChange("finish"), className: "open-tablet", children: currentLang.finishSetup })
    ] }) })
  ] }) });
};
const ClockWidget = () => {
  const [t, setT] = reactExports.useState(/* @__PURE__ */ new Date());
  reactExports.useEffect(() => {
    const i = setInterval(() => setT(/* @__PURE__ */ new Date()), 1e3);
    return () => clearInterval(i);
  }, []);
  const s = t.getSeconds();
  const m = t.getMinutes();
  const h = t.getHours() % 12;
  const sd = s * 6;
  const md = m * 6 + s * 0.1;
  const hd = h * 30 + m * 0.5;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "clock-widget", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 100 100", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "50", cy: "50", r: "48", className: "clock-face" }),
    Array.from({ length: 12 }).map((_, i) => {
      const a = i * 30 * (Math.PI / 180);
      const x1 = 50 + 40 * Math.sin(a);
      const y1 = 50 - 40 * Math.cos(a);
      const x2 = 50 + 45 * Math.sin(a);
      const y2 = 50 - 45 * Math.cos(a);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1, y1, x2, y2, className: "tick" }, i);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "50", y1: "50", x2: "50", y2: "20", className: "hour-hand", style: { transform: `rotate(${hd}deg)`, transformOrigin: "50% 50%" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "50", y1: "50", x2: "50", y2: "15", className: "minute-hand", style: { transform: `rotate(${md}deg)`, transformOrigin: "50% 50%" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "50", y1: "50", x2: "50", y2: "10", className: "second-hand", style: { transform: `rotate(${sd}deg)`, transformOrigin: "50% 50%" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "50", cy: "50", r: "2", className: "center-dot" })
  ] }) });
};
const MainScreen = ({ openApp, apps, background, playerApps, days, months, currentData, widgets, mails, lang, batteryLevel }) => {
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  const [tabletBack, setBack] = reactExports.useState("");
  reactExports.useEffect(() => {
    setBack(background);
  }, [background]);
  const formattedDate = `${days[time2.getDay()]}, ${time2.getDate()} ${months[time2.getMonth()]} ${time2.getFullYear()}`;
  reactExports.useEffect(() => {
    const interval = setInterval(() => {
      setTime(/* @__PURE__ */ new Date());
    }, 1e3);
    return () => clearInterval(interval);
  }, []);
  const fastbarApps = playerApps.filter((a) => a.Default);
  const sliderRef = reactExports.useRef(null);
  const [maxDrag, setMaxDrag] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (sliderRef.current) {
      setMaxDrag(
        sliderRef.current.scrollWidth - sliderRef.current.offsetWidth
      );
    }
  }, [playerApps]);
  const pageSize = 10;
  const pages = reactExports.useMemo(() => {
    const filtered = playerApps.filter((app) => {
      if (app.Widget) {
        return widgets;
      }
      return true;
    });
    const arr = [];
    for (let i = 0; i < filtered.length; i += pageSize) {
      arr.push(filtered.slice(i, i + pageSize));
    }
    return arr;
  }, [playerApps, widgets]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "tablet-frame-homescreen",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          backgroundImage: tabletBack.startsWith("http") ? `url(${tabletBack})` : `url(/web/build/${tabletBack}-background.jpg)`,
          backgroundSize: "100% 100%",
          backgroundRepeat: "no-repeat",
          backgroundPosition: "center center",
          borderRadius: "8px",
          userSelect: "none",
          zIndex: 1
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tablet-frame-homescreen-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icons battery", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-shell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "battery-level",
                    style: {
                      width: `${batteryLevel}%`,
                      backgroundColor: batteryLevel < 20 ? "red" : "rgb(227 227 227)"
                    }
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "battery-percent", children: [
                  batteryLevel,
                  "%"
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
              ] }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timeShareder", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-count", children: formattedTime }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-descript", children: formattedDate })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                position: "relative",
                overflow: "hidden",
                height: "calc(100% - 200px)",
                width: "54rem",
                margin: "3rem auto 0px",
                boxSizing: "border-box"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, { ref: sliderRef, drag: "x", dragConstraints: { left: -maxDrag, right: 0 }, style: { display: "flex", height: "100%" }, children: pages.map((page, pi) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    minWidth: "57rem",
                    boxSizing: "border-box",
                    placeContent: "flex-start",
                    marginLeft: "4rem",
                    gap: "0rem 4rem",
                    display: "flex",
                    flexWrap: "wrap",
                    padding: "0.5rem 1rem"
                  },
                  children: page.map(
                    (app, ai) => app.Widget ? widgets ? app.AppHash === "weather" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "weather-widget", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "weather-top", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "weather-location", children: currentData.location }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "weather-temp", children: currentData.weather })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "weather-bottom", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "weather-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "7.99999", cy: "7.99999", r: "4.06349", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "7.61905", width: "0.761905", height: "3.04762", rx: "0.380952", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "7.61905", y: "12.9524", width: "0.761905", height: "3.04762", rx: "0.380952", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "12.9524", y: "7.61905", width: "3.04762", height: "0.761905", rx: "0.380952", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "11.1746", y: "4.35536", width: "2.53968", height: "0.761905", rx: "0.380952", transform: "rotate(-45 11.1746 4.35536)", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "3.07843", y: "2.53968", width: "2.53968", height: "0.761905", rx: "0.380952", transform: "rotate(45 3.07843 2.53968)", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "11.7133", y: "11.1746", width: "2.53968", height: "0.761905", rx: "0.380952", transform: "rotate(45 11.7133 11.1746)", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2.53967", y: "12.9704", width: "2.53968", height: "0.761905", rx: "0.380952", transform: "rotate(-45 2.53967 12.9704)", fill: "#F2C800" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { y: "7.61905", width: "3.04762", height: "0.761905", rx: "0.380952", fill: "#F2C800" })
                        ] }) }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "weather-desc", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: currentData.wstring }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "weather-range", children: "H:30 L:13" })
                        ] })
                      ] })
                    ] }, ai) : app.AppHash === "clock" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ClockWidget, {}, ai) : app.AppHash === "mail" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mail-widgets", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-widgets", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-widgets-header", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { fontSize: "10px" }, className: "fa-regular fa-user" }),
                        "  ",
                        lang.allbox
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => openApp("mail"), className: "mail-boxes", children: mails.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { textAlign: "center", marginTop: "2rem", color: "#565656" }, children: lang.emptymailbox }) : mails.slice(-2).map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-item", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mail-hex", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "11", height: "11", viewBox: "0 0 11 11", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.30396 10.8474C3.97787 10.8474 2.7061 10.3206 1.76842 9.38295C0.830739 8.44526 0.303955 7.17349 0.303955 5.84741C0.303955 4.52133 0.830739 3.24956 1.76842 2.31188C2.7061 1.3742 3.97787 0.847412 5.30396 0.847412C6.63004 0.847412 7.90181 1.3742 8.83949 2.31188C9.77717 3.24956 10.304 4.52133 10.304 5.84741C10.304 7.17349 9.77717 8.44526 8.83949 9.38295C7.90181 10.3206 6.63004 10.8474 5.30396 10.8474Z", fill: "#0478FF" }) }),
                          "  ",
                          (() => {
                            const msg = (element.data.subject || "").trim().replace(/\s+/g, " ");
                            const words = msg.split(" ");
                            return words.length > 3 ? words.slice(0, 3).join(" ") + "..." : msg;
                          })()
                        ] }),
                        element.data.message ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-cor", children: (() => {
                          const msg = (element.data.message || "").trim().replace(/\s+/g, " ");
                          const words = msg.split(" ");
                          return words.length > 10 ? words.slice(0, 10).join(" ") + "..." : msg;
                        })() }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-cor", children: element.from_name })
                      ] }, index)) })
                    ] }) }, ai) : null : null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app-box", onClick: () => openApp(app.AppHash), children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: "app-icon",
                          style: { backgroundImage: `url(/web/build/appicons/${app.Icon})` }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-name", children: app.App })
                    ] }, ai)
                  )
                },
                pi
              )) })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fastbar", children: fastbarApps.filter((app) => !app.Widget).map((app, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "fastbar-app",
        onClick: () => openApp(app.AppHash),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "app-icon",
            style: { backgroundImage: `url(/web/build/appicons/${app.Icon})` }
          }
        )
      },
      idx
    )) })
  ] });
};
const MyLogo = "" + new URL("mdt-minilogo.png", import.meta.url).href;
const Avatar$2 = "" + new URL("avatar.png", import.meta.url).href;
const CrimeDetailsModal = ({ lang, isOpen, onClose, crimeData, typeland, theme }) => {
  if (!isOpen || !crimeData) return null;
  const offenders = Array.isArray(crimeData.offenders) ? crimeData.offenders : [];
  const articles = Array.isArray(crimeData.articles) ? crimeData.articles : [];
  const media = Array.isArray(crimeData.media) ? crimeData.media : [];
  Array.isArray(crimeData.media) ? crimeData.media : [];
  const vehicles = typeof crimeData.vehicle_data === "string" ? JSON.parse(crimeData.vehicle_data || "[]") : crimeData.vehicle_data || [];
  const cars = typeof crimeData.cars === "string" ? JSON.parse(crimeData.cars) : Array.isArray(crimeData.cars) ? crimeData.cars : [];
  const articlesveh = typeof crimeData.crimes === "string" ? JSON.parse(crimeData.crimes) : Array.isArray(crimeData.crimes) ? crimeData.crimes : [];
  typeof crimeData.vehicle_data === "string" ? JSON.parse(crimeData.vehicle_data)[0] || {} : Array.isArray(crimeData.vehicle_data) ? crimeData.vehicle_data[0] : {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "crime-modal-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      initial: { opacity: 0, scale: 0.95 },
      animate: { opacity: 1, scale: 1 },
      exit: { opacity: 0, scale: 0.95 },
      transition: { duration: 0.2 },
      className: `crime-modal-container ${theme !== "dark" ? "crime-white" : ""}`,
      children: [
        (crimeData.typeland == "cid" || typeland == "cid") && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `crime-modal-header ${theme !== "dark" ? "crime-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { fontSize: "17px", margin: 0 }, children: lang.crimeDetails }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `crime-title ${theme !== "dark" ? "dark-text" : ""}`, children: lang.offenders }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `crime-list ${theme !== "dark" ? "crime-list-white" : ""}`, children: offenders.map((off, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              off.name,
              " (",
              off.cid,
              ")"
            ] }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `crime-title ${theme !== "dark" ? "dark-text" : ""}`, children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `crime-list ${theme !== "dark" ? "crime-list-white" : ""}`, children: articles.map((a, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              a.name,
              " - $",
              a.fine
            ] }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.date,
                ":"
              ] }),
              " ",
              crimeData.date
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.location,
                ":"
              ] }),
              " ",
              crimeData.location
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.note,
                ":"
              ] }),
              " ",
              crimeData.description
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.enteredby,
                ":"
              ] }),
              " ",
              crimeData.officer_name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.witnesses,
                ":"
              ] }),
              " ",
              crimeData.witnesses
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.prisontime,
                ":"
              ] }),
              " ",
              crimeData.jail_time || "N/A"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.fine,
                ":"
              ] }),
              " $",
              crimeData.fine_amount
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.casenumber,
                ":"
              ] }),
              " ",
              crimeData.crime_id
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.vehicleInfo,
                ":"
              ] }),
              vehicles && vehicles.modelName ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                lang.model,
                ": ",
                vehicles.modelName || lang.unkown,
                " - ",
                lang.color,
                ": ",
                vehicles.color1 || lang.unkown
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#777" }, children: lang.noinformationveh })
            ] })
          ] })
        ] }),
        (crimeData.typeland == "veh" || typeland == "veh") && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { fontSize: "17px", margin: 0 }, children: lang.crimeDetails }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, children: "" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "crime-title", children: lang.cars }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `crime-list ${theme !== "dark" ? "crime-list-white" : ""}`, children: cars.map((off, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              off.plate,
              " (",
              off.model,
              ")"
            ] }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-section", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "crime-title", children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `crime-list ${theme !== "dark" ? "crime-list-white" : ""}`, children: articlesveh.map((a, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
              a.name,
              " - $",
              a.fine
            ] }, i)) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.date,
                ":"
              ] }),
              " ",
              crimeData.date
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.location,
                ":"
              ] }),
              " ",
              crimeData.location
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.note,
                ":"
              ] }),
              " ",
              crimeData.notes
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.enteredby,
                ":"
              ] }),
              " ",
              crimeData.officer_name
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.driver,
                ":"
              ] }),
              " ",
              crimeData.dname || "N/A"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.fine,
                ":"
              ] }),
              " $",
              crimeData.fine_amount
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-label", children: [
                lang.casenumber,
                ":"
              ] }),
              " ",
              crimeData.case_id
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "crime-modal-section", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "crime-title", children: lang.media }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "crime-media", children: media.length > 0 ? media.map((m, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: m.url, alt: `evidence-${i}`, className: "crime-media-img" }, i)) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#777" }, children: lang.nomedia }) })
        ] })
      ]
    }
  ) });
};
const CitizenProfileScreen = ({ lang, onOpen, data, onClose, crimes, theme }) => {
  const [playerPhoto, setPhoto] = reactExports.useState("");
  const [playerCrimes, setPlayerCrimes] = reactExports.useState([]);
  const [modalOpen, setModalOpen] = reactExports.useState(null);
  const [isSet, izzet] = reactExports.useState("cid");
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  const selectOnMap = (data2) => {
    if (data2.coords !== void 0 || data2.coords !== null) {
      callNui("SelectOnMap", {
        coords: data2.coords
      });
    }
  };
  const getCrimeData = (data2, veh) => {
    data2.typeland = veh;
    setModalOpen(data2);
  };
  reactExports.useEffect(() => {
    if (!crimes || !(data == null ? void 0 : data.cid)) return;
    const filtered = crimes.filter((crime) => {
      let parsedOffenders = [];
      try {
        parsedOffenders = typeof crime.offenders === "string" ? JSON.parse(crime.offenders) : crime.offenders;
      } catch (err) {
        console.warn("JSON parse failed for crime.offenders:", crime.offenders);
      }
      return Array.isArray(parsedOffenders) && parsedOffenders.some((off) => off.cid === data.cid);
    });
    setPlayerCrimes(filtered);
  }, [crimes, data]);
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const photo = await returnPlayerPhoto(data.cid);
      setPhoto(photo);
    };
    prepareData();
  }, [data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-citizenprofile-page2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        width: "33%",
        float: "left",
        marginLeft: "1rem",
        marginTop: "1rem",
        height: "22rem"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playerPhoto }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-citizenprofile-page-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.citizenname }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.pName })
        ] }),
        data.nationality ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.nationality }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.nationality })
        ] }) : "",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.citizenid }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.cid })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.birthdate }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.birthdate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.phoneNumber }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.phone })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.wlevel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.wantedlevel ? data.wantedlevel : lang.notwanted })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.gunlevel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data wrong", children: data.wlicense ? data.wlicense : lang.nolicense })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.gender }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data wrong", children: data.gender == 0 ? lang.male : lang.female })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.dlicense }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data wrong", children: data.dlicense ? lang.yes : lang.no })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.job }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.job })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => selectOnMap(data.house), className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.house }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.house.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.apartment }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.apartment.name })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mdt-citizenprofile-page-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: lang.history }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "back-button", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-left" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onOpen, className: "add-button", children: lang.addrecord })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "table", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.resperson }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.status })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: playerCrimes.map((record, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { onClick: () => getCrimeData(record, "cid"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: record.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: (() => {
              const names = record.articles.map((s) => s.name);
              const joined = names.join(", ");
              return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
            })() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: record.officer_name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: record.status === 0 ? "status-pending" : "status-approved", children: record.status === 0 ? lang.pending : record.status === 3 ? lang.rejected : lang.approved })
          ] }, i)) })
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CrimeDetailsModal,
      {
        lang,
        isOpen: !!modalOpen,
        crimeData: modalOpen,
        theme,
        onClose: () => setModalOpen(null),
        manageCrime: false,
        typeland: isSet
      }
    )
  ] });
};
const OfficersPage = ({ officers, grades, lang, theme }) => {
  const [officersList, setOfficersList] = reactExports.useState([]);
  const [searchValue, setSearchValue] = reactExports.useState("");
  const [showActive, setShowActive] = reactExports.useState(true);
  const [openIdx, setOpenIdx] = reactExports.useState(null);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    const list = Array.isArray(officers) ? officers : [officers];
    if (!list.length) return;
    (async () => {
      const nd = await Promise.all(
        list.map(async (e) => {
          const photoUrl2 = await returnPlayerPhoto(e.cid);
          return { ...e, photoUrl: photoUrl2 };
        })
      );
      setOfficersList(nd.reverse());
    })();
  }, [JSON.stringify(officers)]);
  reactExports.useEffect(() => {
    const handleGlobalClick = () => setOpenIdx(null);
    document.addEventListener("click", handleGlobalClick);
    return () => document.removeEventListener("click", handleGlobalClick);
  }, []);
  const filtered = officersList.filter((o) => o.name.toLowerCase().includes(searchValue.toLowerCase())).filter((o) => showActive ? o.online : true);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "officers-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bothofthem", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `search-part ${theme !== "dark" ? "search-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "16", viewBox: "0 0 15 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.125 13.625L10.4062 10.9062M11.875 7.375C11.875 10.1364 9.63642 12.375 6.875 12.375C4.11358 12.375 1.875 10.1364 1.875 7.375C1.875 4.61358 4.11358 2.375 6.875 2.375C9.63642 2.375 11.875 4.61358 11.875 7.375Z", stroke: "white", "stroke-width": "1.25", "stroke-linecap": "round", "stroke-linejoin": "round" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            className: "inpat",
            placeholder: lang.searchofficer,
            onChange: (e) => setSearchValue(e.target.value),
            value: searchValue
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-button", children: "Search" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "showactiveoffc", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "switch2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              checked: showActive,
              onChange: (e) => setShowActive(e.target.checked),
              type: "checkbox"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "slider2" })
        ] }),
        lang.activeoffc
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `yenimenum ${theme !== "dark" ? "border-white" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `yenimenum-header ${theme !== "dark" ? "white-hed" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "25rem" }, className: `header-menx ${theme !== "dark" ? "black-text" : ""}`, children: lang.officer }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "12rem" }, className: `header-menx ${theme !== "dark" ? "black-text" : ""}`, children: lang.rank }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: "22rem",
          paddingRight: "2rem",
          justifyContent: "end"
        }, className: `header-menx ${theme !== "dark" ? "black-text" : ""}`, children: lang.citizenid })
      ] }),
      filtered.map((officer, idx) => {
        const jobGrades = grades[officer.job] || [];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-man ${theme !== "dark" ? "border-whitex" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "35rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "like-manx", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { style: { width: "40px" }, src: officer.photoUrl, alt: "officer" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-manxv ${theme !== "dark" ? "black-text" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activeoffc", children: officer.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `activeoffc ${officer.online ? "onlinec" : ""}`, children: officer.online ? "On Duty" : "Offline" })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "36rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-manx ${theme !== "dark" ? "black-text" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `dropbown ${theme !== "dark" ? "vc" : ""}`,
                onClick: (e) => {
                  e.stopPropagation();
                  setOpenIdx(openIdx === idx ? null : idx);
                },
                children: [
                  officer.grade,
                  "  ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-arrow-right" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: openIdx === idx && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                className: `dropdown-menu3 ${theme !== "dark" ? "vcx" : ""}`,
                onClick: (e) => e.stopPropagation(),
                initial: { height: 0, opacity: 0 },
                animate: { height: "auto", opacity: 1 },
                exit: { height: 0, opacity: 0 },
                transition: { duration: 0.2, ease: "easeInOut" },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `dropdown-item3 ${theme !== "dark" ? "black-text" : ""}`,
                      onClick: (e) => {
                        e.stopPropagation();
                        const u = [...officersList];
                        u[idx] = { ...u[idx], grade: "Unemployed" };
                        setOfficersList(u);
                        callNui("UpdateJob", {
                          gradename: "Unemployed",
                          gradelevel: 0,
                          job: "unemployed",
                          cid: officer.cid
                        });
                        setOpenIdx(null);
                      },
                      children: lang.unemployed
                    }
                  ),
                  jobGrades.map((el) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "dropdown-item3",
                      onClick: (e) => {
                        e.stopPropagation();
                        const u = [...officersList];
                        u[idx] = { ...u[idx], grade: el.label };
                        setOfficersList(u);
                        callNui("UpdateJob", {
                          gradename: el.label,
                          gradelevel: el.gradelevel,
                          job: officer.job,
                          cid: officer.cid
                        });
                        setOpenIdx(null);
                      },
                      children: el.label
                    },
                    el.gradelevel
                  ))
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "16rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "like-manx", style: { float: "right", marginRight: "1.5rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizenid", children: officer.cid }) }) })
        ] }, idx);
      })
    ] })
  ] });
};
const VehicleQueryPage = ({ isOpened, vehicles, lang, setVehicleProfileData, isVehicleProfileScreen, theme }) => {
  const [VehiclePlate, SetVehiclePlate] = reactExports.useState("");
  const [vehicleList, setNewVehicleList] = reactExports.useState([]);
  const VehiclePlateEvent = (e) => {
    SetVehiclePlate(e);
  };
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  const handleSett = (data) => {
    isVehicleProfileScreen(true);
    setVehicleProfileData(data);
  };
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const search2 = VehiclePlate.toLowerCase();
      const filtered = vehicles.filter(
        (v) => v.plate.toLowerCase().includes(search2) || v.modelname.toLowerCase().includes(search2) || v.ownerName.toLowerCase().includes(search2)
      );
      const newData = await Promise.all(filtered.map(async (element) => {
        const photo = await returnPlayerPhoto(element.owner);
        return { ...element, photoUrl: photo };
      }));
      setNewVehicleList(newData.reverse());
    };
    prepareData();
  }, [vehicles, VehiclePlate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-head`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.queryveh, value: VehiclePlate, onChange: (e) => VehiclePlateEvent(e.target.value) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `part-title ${theme !== "dark" ? "black-text" : ""}`, children: lang.vehicles }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.photo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.oname }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.model }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.plate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: vehicleList.map((vehicle, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: vehicle.photoUrl }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: vehicle.ownerName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: vehicle.modelname }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: vehicle.plate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSett(vehicle), className: "button-rev2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-eye" }) }) })
      ] })) })
    ] })
  ] });
};
const CrimeTable = ({ lang, crimeList, vehCrimes, theme }) => {
  const [activeTab, setActiveTab] = reactExports.useState("personal");
  const [query, setQuery] = reactExports.useState("");
  const activeList = activeTab === "personal" ? crimeList : vehCrimes;
  const filteredCrimes = activeList.filter(
    (crime) => crime.name.toLowerCase().includes(query.toLowerCase()) || crime.description.toLowerCase().includes(query.toLowerCase())
  );
  const SetPage = (page) => {
    if (page === "poffences") {
      setActiveTab("personal");
    } else {
      setActiveTab("vehicle");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-head`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          placeholder: lang.scrime,
          value: query,
          onChange: (e) => setQuery(e.target.value)
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => SetPage("poffences"), className: `part-title2 ${theme !== "dark" ? "partd" : ""}`, children: lang.poffences }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => SetPage("toffences"), className: `part-title2 ${theme !== "dark" ? "partd" : ""}`, children: lang.toffences })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.id }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.crime }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.penalty }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.description })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: filteredCrimes.map((crime, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: crime.id }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: crime.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: [
          "$ ",
          crime.fine
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.description })
      ] })) })
    ] })
  ] });
};
const CameraModal = ({ onCloseV2, setPhotoLink }) => {
  reactExports.useState(false);
  const [screenshotUrl, setScreenshotUrl] = reactExports.useState(null);
  const [flashEffect, setFlashEffect] = reactExports.useState(false);
  reactExports.useState("photo");
  reactExports.useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === "Enter") {
        takeScreenshot();
      }
    };
    window.addEventListener("keydown", handleKeyPress);
    return () => {
      window.removeEventListener("keydown", handleKeyPress);
    };
  }, []);
  reactExports.useEffect(() => {
    const checkCanvasInterval = setInterval(() => {
      const canvas = document.getElementById("gameview-canvas");
      if (canvas && window.MainRender) {
        window.MainRender.renderToTarget(canvas);
        clearInterval(checkCanvasInterval);
        setTimeout(() => {
          const ctx2 = canvas.getContext("2d");
          ctx2.getImageData(0, 0, 1, 1).data;
        }, 2e3);
      }
    }, 500);
    return () => clearInterval(checkCanvasInterval);
  }, []);
  const [isTakingScreenshot, setIsTakingScreenshot] = reactExports.useState(false);
  const takeScreenshot = async () => {
    try {
      if (!window.MainRender) {
        return;
      }
      if (isTakingScreenshot) {
        return;
      }
      setIsTakingScreenshot(true);
      setFlashEffect(true);
      let imageUrl = await window.MainRender.requestScreenshot();
      setIsTakingScreenshot(false);
      setScreenshotUrl(imageUrl);
      setPhotoLink(imageUrl);
      onCloseV2();
      callNui("CloseCameraApp", {});
      callNui("SaveGalleryPhoto", {
        url: imageUrl,
        type: "photo",
        custom: customState
      }, function(x) {
        if (x) {
          setPhotoLink(imageUrl);
          onCloseV2();
        }
      });
      setTimeout(() => setFlashEffect(false), 300);
    } catch (error) {
      setIsTakingScreenshot(false);
      setFlashEffect(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `modal-cameraAppContainer`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: onCloseV2, className: "modal-camapp", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-regular fa-xmark" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flash-overlay ${flashEffect ? "active" : ""}`, children: flashEffect && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flash-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-circle" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", { id: "gameview-canvas" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-camera-app-topbar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-camera-app-topbar-icons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 3.31091L1.45455 4.76545C5.06909 1.15091 10.9309 1.15091 14.5455 4.76545L16 3.31091C11.5855 -1.10364 4.42182 -1.10364 0 3.31091ZM5.81818 9.12909L8 11.3109L10.1818 9.12909C9.89557 8.84208 9.55551 8.61437 9.18112 8.459C8.80672 8.30363 8.40535 8.22365 8 8.22365C7.59465 8.22365 7.19328 8.30363 6.81888 8.459C6.44449 8.61437 6.10443 8.84208 5.81818 9.12909ZM2.90909 6.22L4.36364 7.67454C5.32834 6.71064 6.63627 6.1692 8 6.1692C9.36373 6.1692 10.6717 6.71064 11.6364 7.67454L13.0909 6.22C10.2836 3.41273 5.72364 3.41273 2.90909 6.22Z", fill: "white" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "12", viewBox: "0 0 20 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.375 0C15.2038 0 15.9987 0.316071 16.5847 0.87868C17.1708 1.44129 17.5 2.20435 17.5 3V3.9996L18.9587 4.0032C19.2349 4.0032 19.4998 4.10851 19.695 4.29598C19.8903 4.48344 20 4.73769 20 5.0028V7.0032C20 7.26831 19.8903 7.52256 19.695 7.71002C19.4998 7.89749 19.2349 8.0028 18.9587 8.0028L17.5 8.0004V9C17.5 9.79565 17.1708 10.5587 16.5847 11.1213C15.9987 11.6839 15.2038 12 14.375 12H3.125C2.2962 12 1.50134 11.6839 0.915291 11.1213C0.32924 10.5587 0 9.79565 0 9V3C0 2.20435 0.32924 1.44129 0.915291 0.87868C1.50134 0.316071 2.2962 0 3.125 0H14.375ZM14.6875 1.1352H3.125C2.3125 1.1352 1.36875 1.7304 1.26 2.4912L1.25 2.6352V9.2292C1.25 10.0056 1.865 10.6452 2.6525 10.722L2.8125 10.7292H14.6875C15.0741 10.7291 15.4469 10.5914 15.7339 10.3427C16.0209 10.094 16.2017 9.75199 16.2412 9.3828L16.25 9.2292V2.6352C16.2499 2.26406 16.1064 1.90614 15.8474 1.63064C15.5883 1.35513 15.2321 1.18161 14.8475 1.1436L14.6875 1.1352ZM3.5425 2.3388H12.705C13.2387 2.3388 13.6775 2.7204 13.7425 3.2148L13.75 3.3408V8.5332C13.7502 8.77726 13.6576 9.01299 13.4896 9.19615C13.3216 9.37931 13.0897 9.49731 12.8375 9.528L12.7063 9.5352H3.54375C3.28931 9.53568 3.04345 9.44691 2.8524 9.2856C2.66134 9.12428 2.53824 8.90152 2.50625 8.6592L2.5 8.532V3.3408C2.5 2.8296 2.89875 2.4084 3.4125 2.346L3.5425 2.3388Z", fill: "white" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-camera-modes", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "18", viewBox: "0 0 10 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3.66802 17.9983C3.31802 17.9983 3.04802 17.6883 3.09802 17.3383L3.99802 10.9983H0.498018C-0.381982 10.9983 0.168018 10.2483 0.188018 10.2183C1.44802 7.98826 3.33802 4.68826 5.83802 0.288255C5.90532 0.172797 6.01061 0.0842806 6.13592 0.0378206C6.26123 -0.00863935 6.39877 -0.0101616 6.52508 0.0335136C6.65138 0.0771888 6.75861 0.163353 6.82845 0.277294C6.89829 0.391234 6.92641 0.525886 6.90802 0.658256L6.00802 6.99826H9.51802C9.91802 6.99826 10.138 7.18826 9.91802 7.65826C6.62802 13.3983 4.71802 16.7483 4.16802 17.7083C4.06802 17.8883 3.87802 17.9983 3.66802 17.9983Z", fill: "white" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "8", viewBox: "0 0 24 8", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M24.0059 3.33333V2C24.0059 0.933333 23.0725 0 22.0059 0H17.3392V8H19.3392V5.33333H20.8059L22.0059 8H24.0059L22.8059 5.2C23.4725 4.8 24.0059 4.13333 24.0059 3.33333ZM22.0059 3.33333H19.3392V2H22.0059V3.33333ZM4.67253 2.66667H2.00586V0H0.00585938V8H2.00586V4.66667H4.67253V8H6.67253V0H4.67253V2.66667ZM13.3392 0H8.67253V8H13.3392C14.4059 8 15.3392 7.06667 15.3392 6V2C15.3392 0.933333 14.4059 0 13.3392 0ZM13.3392 6H10.6725V2H13.3392V6Z", fill: "white", "fill-opacity": "0.35" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "18", viewBox: "0 0 16 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.416 0C9.66297 0 8.94083 0.29912 8.40839 0.831558C7.87596 1.364 7.57684 2.08614 7.57684 2.83912V6.62461C7.57684 7.37759 7.87596 8.09973 8.40839 8.63216C8.94083 9.1646 9.66297 9.46372 10.416 9.46372C11.1689 9.46372 11.8911 9.1646 12.4235 8.63216C12.956 8.09973 13.2551 7.37759 13.2551 6.62461V2.83912C13.2551 2.08614 12.956 1.364 12.4235 0.831558C11.8911 0.29912 11.1689 0 10.416 0ZM11.8355 6.62461C11.8355 7.0011 11.686 7.36217 11.4197 7.62839C11.1535 7.8946 10.7924 8.04416 10.416 8.04416C10.0395 8.04416 9.67839 7.8946 9.41217 7.62839C9.14596 7.36217 8.9964 7.0011 8.9964 6.62461V2.83912C8.9964 2.46263 9.14596 2.10156 9.41217 1.83534C9.67839 1.56912 10.0395 1.41956 10.416 1.41956C10.7924 1.41956 11.1535 1.56912 11.4197 1.83534C11.686 2.10156 11.8355 2.46263 11.8355 2.83912V6.62461ZM0.00585938 11.9479C0.00585938 11.6215 0.270844 11.3565 0.597342 11.3565H3.67589C3.83276 11.3565 3.98321 11.4188 4.09413 11.5297C4.20506 11.6406 4.26737 11.7911 4.26737 11.9479C4.26737 12.1048 4.20506 12.2553 4.09413 12.3662C3.98321 12.4771 3.83276 12.5394 3.67589 12.5394H1.18882V14.1956H3.19987C3.35674 14.1956 3.50718 14.2579 3.61811 14.3688C3.72903 14.4797 3.79135 14.6302 3.79135 14.7871C3.79135 14.9439 3.72903 15.0944 3.61811 15.2053C3.50718 15.3162 3.35674 15.3785 3.19987 15.3785H1.18882V17.4085C1.18882 17.5654 1.12651 17.7158 1.01558 17.8268C0.904659 17.9377 0.754213 18 0.597342 18C0.440471 18 0.290025 17.9377 0.179101 17.8268C0.0681761 17.7158 0.00585937 17.5654 0.00585938 17.4085V11.9479ZM6.03898 11.3565C5.71248 11.3565 5.4475 11.6215 5.4475 11.9479V17.4085C5.4475 17.5654 5.50982 17.7158 5.62074 17.8268C5.73167 17.9377 5.88211 18 6.03898 18C6.19585 18 6.3463 17.9377 6.45722 17.8268C6.56815 17.7158 6.63047 17.5654 6.63047 17.4085V15.3785H7.69513C8.22849 15.3785 8.74001 15.1667 9.11715 14.7895C9.4943 14.4124 9.70617 13.9009 9.70617 13.3675C9.70617 12.8341 9.4943 12.3226 9.11715 11.9455C8.74001 11.5683 8.22849 11.3565 7.69513 11.3565H6.03898ZM7.69513 14.1956H6.63047V12.5394H7.69513C7.91475 12.5394 8.12538 12.6267 8.28067 12.782C8.43597 12.9373 8.52321 13.1479 8.52321 13.3675C8.52321 13.5871 8.43597 13.7978 8.28067 13.953C8.12538 14.1083 7.91475 14.1956 7.69513 14.1956ZM11.8355 13.323C11.8355 12.8901 12.1861 12.5394 12.6191 12.5394H13.3734C13.6999 12.5394 13.9648 12.8044 13.9648 13.1309C13.9648 13.2878 14.0272 13.4382 14.1381 13.5492C14.249 13.6601 14.3995 13.7224 14.5563 13.7224C14.7132 13.7224 14.8636 13.6601 14.9746 13.5492C15.0855 13.4382 15.1478 13.2878 15.1478 13.1309C15.1478 12.6603 14.9609 12.209 14.6281 11.8762C14.2953 11.5434 13.844 11.3565 13.3734 11.3565H12.6191C12.3583 11.3524 12.0993 11.4003 11.8572 11.4973C11.6151 11.5943 11.3947 11.7385 11.2089 11.9215C11.023 12.1045 10.8754 12.3226 10.7747 12.5632C10.6739 12.8038 10.622 13.062 10.622 13.3228C10.622 13.5836 10.6739 13.8418 10.7747 14.0824C10.8754 14.323 11.023 14.5411 11.2089 14.7241C11.3947 14.9071 11.6151 15.0513 11.8572 15.1483C12.0993 15.2453 12.3583 15.2932 12.6191 15.2891H13.2106C13.4074 15.294 13.5945 15.3757 13.732 15.5167C13.8695 15.6576 13.9464 15.8467 13.9464 16.0436C13.9464 16.2405 13.8695 16.4296 13.732 16.5706C13.5945 16.7115 13.4074 16.7932 13.2106 16.7981H12.427C12.1005 16.7981 11.8355 16.5331 11.8355 16.2066C11.8355 16.0498 11.7732 15.8993 11.6623 15.7884C11.5513 15.6775 11.4009 15.6151 11.244 15.6151C11.0872 15.6151 10.9367 15.6775 10.8258 15.7884C10.7149 15.8993 10.6525 16.0498 10.6525 16.2066C10.6525 16.6772 10.8395 17.1286 11.1723 17.4613C11.505 17.7941 11.9564 17.9811 12.427 17.9811H13.2106C13.7244 17.9811 14.2172 17.7769 14.5806 17.4136C14.9439 17.0503 15.1481 16.5575 15.1481 16.0436C15.1481 15.5298 14.9439 15.037 14.5806 14.6736C14.2172 14.3103 13.7244 14.1062 13.2106 14.1062H12.6191C12.4114 14.1062 12.2121 14.0237 12.0652 13.8768C11.9183 13.73 11.8356 13.5308 11.8355 13.323ZM2.37179 2.83912C2.37179 2.46263 2.52135 2.10156 2.78757 1.83534C3.05379 1.56912 3.41486 1.41956 3.79135 1.41956C4.16784 1.41956 4.52891 1.56912 4.79513 1.83534C5.06135 2.10156 5.21091 2.46263 5.21091 2.83912C5.21091 3.02736 5.28569 3.2079 5.4188 3.34101C5.55191 3.47412 5.73244 3.5489 5.92069 3.5489C6.10893 3.5489 6.28947 3.47412 6.42257 3.34101C6.55568 3.2079 6.63047 3.02736 6.63047 2.83912C6.63047 2.08614 6.33135 1.364 5.79891 0.831558C5.26647 0.29912 4.54433 0 3.79135 0C3.03837 0 2.31623 0.29912 1.78379 0.831558C1.25135 1.364 0.952232 2.08614 0.952232 2.83912V6.7429C0.952232 6.78265 0.955386 6.82177 0.961696 6.86025C1.01277 7.47299 1.26139 8.0526 1.67017 8.5119C2.07894 8.97121 2.62578 9.2854 3.22846 9.40723C3.83113 9.52906 4.45707 9.45195 5.01216 9.18748C5.56724 8.92302 6.02147 8.48549 6.30654 7.9407C6.59161 7.39591 6.69212 6.7733 6.59294 6.16648C6.49377 5.55967 6.20028 5.00144 5.7566 4.57575C5.31293 4.15006 4.74305 3.87991 4.13265 3.80592C3.52225 3.73193 2.90432 3.8581 2.37179 4.16546V2.83912ZM2.37179 6.62461C2.37179 6.24812 2.52135 5.88704 2.78757 5.62083C3.05379 5.35461 3.41486 5.20505 3.79135 5.20505C4.16784 5.20505 4.52891 5.35461 4.79513 5.62083C5.06135 5.88704 5.21091 6.24812 5.21091 6.62461C5.21091 7.0011 5.06135 7.36217 4.79513 7.62839C4.52891 7.8946 4.16784 8.04416 3.79135 8.04416C3.41486 8.04416 3.05379 7.8946 2.78757 7.62839C2.52135 7.36217 2.37179 7.0011 2.37179 6.62461Z", fill: "white" }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-camera-bottom-bar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: onCloseV2, className: "camera-last-photo", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cancel-bte", children: "Cancel" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: takeScreenshot, className: "modal-camera-button-radius", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-camera-capture" }) })
    ] })
  ] });
};
const NewAddCriminalRecordModal = ({ isOpen, onClose, dataLand, location, lang, players, NotificationX, cidCrimes, judMode, setColdModal2 }) => {
  const [crimeLocation, UpdateCrimeLocation] = reactExports.useState("");
  const [data, setData] = reactExports.useState("");
  const [currentDate, setCurrentDate] = reactExports.useState("");
  const [currentTime, setCurrentTime] = reactExports.useState("");
  const [selectedCrimes, setSelectedCrimes] = reactExports.useState([]);
  const [offenceValue, setOffenceValue] = reactExports.useState("");
  const [addedMedias, setAddMedia] = reactExports.useState([]);
  const [openedCameraModal, setCameraModal] = reactExports.useState(false);
  const [photoLink, setPhotoLink] = reactExports.useState("");
  const [crimeReason, setCrimeReason] = reactExports.useState("");
  const [witnesses, setWitnesses] = reactExports.useState("");
  const [prisonTime, setPrisonTime] = reactExports.useState(null);
  const [prisonDropdownOpen, setPrisonDropdownOpen] = reactExports.useState(false);
  const [offenders, setOffenders] = reactExports.useState([dataLand]);
  const [offenderDropdownOpen, setOffenderDropdownOpen] = reactExports.useState(false);
  const [offendersWithPhoto, setOffendersWithPhoto] = reactExports.useState([]);
  const [caseNumber, setCaseNumber] = reactExports.useState("");
  reactExports.useState(false);
  const [vehiclePlate, setVehiclePlate] = reactExports.useState("");
  const toggleOffender = (player) => {
    const exists = offenders.some((o) => o.cid === player.cid);
    if (exists) {
      setOffenders((prev) => prev.filter((o) => o.cid !== player.cid));
    } else {
      setOffenders((prev) => [...prev, player]);
    }
    setOffenderDropdownOpen(false);
  };
  const createNewCriminalRecord = () => {
    if (offenders.length === 0 || !caseNumber || selectedCrimes.length === 0 || !currentDate || !currentTime || !crimeLocation || !crimeReason || !witnesses) {
      NotificationX(lang.invalid, lang.emptyFields);
      return;
    }
    callNui("CreateNewCriminalRecord", {
      offenders: offenders.map((o) => ({ cid: o.cid, name: o.pName })),
      caseNumber,
      crimes: selectedCrimes,
      money: getTotalFine(),
      date: currentDate,
      time: currentTime,
      location: crimeLocation,
      medias: addedMedias,
      reason: crimeReason,
      witnesses,
      prisonTime,
      plate: vehiclePlate
    });
    if (judMode !== "POLICE") {
      setColdModal2(true);
    }
    onClose();
  };
  reactExports.useEffect(() => {
    setCaseNumber(generateCaseNumber());
  }, []);
  const dropdownRef = reactExports.useRef(null);
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
  const addPhoto = (dataurl) => {
    const newPhoto = {
      id: addedMedias.length + 1,
      url: dataurl
    };
    setAddMedia((prevPhotos) => [...prevPhotos, newPhoto]);
    callNui("CloseCameraApp", {});
    setCameraModal(false);
  };
  const toggleCameraApp = reactExports.useCallback(() => {
    callNui("ToggleCameraAppModule", {});
    setCameraModal((prev) => !prev);
  }, []);
  const [playerPhoto, setPhoto] = reactExports.useState("");
  const setMedia = (url) => {
    setPhotoLink(url);
    addPhoto(url);
  };
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const photo = await returnPlayerPhoto(dataLand.cid);
      setPhoto(photo);
    };
    prepareData();
  }, [data]);
  const toggleCrime = (crime) => {
    const exists = selectedCrimes.find((c) => c.name === crime.name);
    if (exists) {
      setSelectedCrimes((prev) => prev.filter((c) => c.name !== crime.name));
    } else {
      setSelectedCrimes((prev) => [...prev, crime]);
    }
  };
  const getTotalFine = () => {
    return selectedCrimes.reduce((sum2, c) => sum2 + c.fine, 0);
  };
  const generateCaseNumber = () => {
    const date = /* @__PURE__ */ new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, "0");
    const dd = String(date.getDate()).padStart(2, "0");
    const random = Math.random().toString(36).substring(2, 5).toUpperCase();
    return `CR-${yyyy}${mm}${dd}-${random}`;
  };
  const UpdateInputLocation = (e) => {
    UpdateCrimeLocation(e.target.value);
  };
  const handleDateChange = (event) => {
    setCurrentDate(event.target.value);
  };
  const handleTimeChange = (event) => {
    setCurrentTime(event.target.value);
  };
  reactExports.useEffect(() => {
    const fetchPhotos = async () => {
      const newData = await Promise.all(offenders.map(async (off) => {
        const photo = await returnPlayerPhoto(off.cid);
        return { ...off, photoUrl: photo };
      }));
      setOffendersWithPhoto(newData);
    };
    if (offenders.length > 0) fetchPhotos();
  }, [offenders]);
  reactExports.useEffect(() => {
    const now2 = /* @__PURE__ */ new Date();
    const formattedDate = now2.toISOString().slice(0, 10);
    const formattedTime = now2.toTimeString().slice(0, 5);
    setCurrentDate(formattedDate);
    setCurrentTime(formattedTime);
    UpdateCrimeLocation(location);
  }, []);
  const filteredCrimes = cidCrimes.filter(
    (crime) => crime.name.toLowerCase().includes(offenceValue.toLowerCase())
  );
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `criminalrecord-container ${isOpen ? "show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-box", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-box-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "crbh-text", children: lang.addrecord }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "crbh-desc", children: lang.addcrimedesc }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => onClose(), style: {
          float: "right",
          color: "rgb(117, 117, 117)",
          position: "absolute",
          right: "1.5rem",
          top: "1rem",
          cursor: "pointer"
        }, className: "fa-solid fa-xmark" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seperate-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.offenders }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-multi-box", children: [
          offendersWithPhoto.map((off, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: off.photoUrl }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-name", children: off.pName }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-cid", children: off.cid })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "offender-remove", onClick: () => toggleOffender(off), children: "" })
          ] }, i)),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: "offender-add-btn",
              onClick: () => setOffenderDropdownOpen(!offenderDropdownOpen),
              children: [
                "+ ",
                lang.addoffender
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: offenderDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, height: 0 },
            animate: { opacity: 1, height: "auto" },
            exit: { opacity: 0, height: 0 },
            transition: { duration: 0.2 },
            className: "offender-dropdown-list",
            children: players.map((p, index) => {
              const selected = offenders.some((o) => o.cid === p.cid);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `offender-dropdown-item ${selected ? "selected" : ""}`,
                  onClick: () => toggleOffender(p),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: p.pName }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cid-label", children: p.cid })
                  ]
                },
                index
              );
            })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-box-level", ref: dropdownRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.crimeList }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: "Search crime...",
            className: "crime-search-input",
            value: offenceValue,
            onChange: (e) => setOffenceValue(e.target.value),
            onFocus: () => setDropdownOpen(true)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: dropdownOpen && filteredCrimes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, height: 0 },
            animate: { opacity: 1, height: "auto" },
            exit: { opacity: 0, height: 0 },
            transition: { duration: 0.2 },
            className: "crime-dropdown-list",
            children: filteredCrimes.map((crime, index) => {
              const selected = selectedCrimes.some((c) => c.name === crime.name);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `crime-dropdown-item ${selected ? "selected" : ""}`,
                  onClick: () => toggleCrime(crime),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: crime.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      "$",
                      crime.fine
                    ] })
                  ]
                },
                index
              );
            })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-lines", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.dateTime }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dateler", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                className: "datetime-input date-input",
                value: currentDate,
                onChange: handleDateChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "time",
                className: "datetime-input time-input",
                value: currentTime,
                onChange: handleTimeChange
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.location }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: crimeLocation,
              placeholder: "Crime Location",
              onChange: (e) => UpdateInputLocation(e)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.note }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: crimeReason,
              placeholder: "Note",
              onChange: (e) => setCrimeReason(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.witnesses }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: witnesses,
              placeholder: "John Wack, Serdar Bakan",
              onChange: (e) => setWitnesses(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { zIndex: 999 }, className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.prisontime }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "prison-dropdown-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "prison-dropdown-toggle",
                onClick: () => setPrisonDropdownOpen(!prisonDropdownOpen),
                children: prisonTime ? `${prisonTime} Months` : "Select Prison Time"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: prisonDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0, height: 0 },
                animate: { opacity: 1, height: "auto" },
                exit: { opacity: 0, height: 0 },
                transition: { duration: 0.2 },
                className: "prison-dropdown-list",
                children: [0, 15, 30, 45, 60, 999].map((time2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `prison-dropdown-item ${prisonTime === time2 ? "selected" : ""}`,
                    onClick: () => {
                      setPrisonTime(time2);
                      setPrisonDropdownOpen(false);
                    },
                    children: time2 === 0 ? "No Jail" : time2 === 999 ? "Life Sentence" : `${time2} Months`
                  },
                  index
                ))
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.casenumber }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: caseNumber,
              readOnly: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.vehplate }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              placeholder: "e.g. 34ABC123",
              value: vehiclePlate,
              onChange: (e) => setVehiclePlate(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.media }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "media-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleCameraApp, className: "add-media", children: lang.addevidence }),
            addedMedias.map(
              (element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url, className: "evidence-img" })
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: createNewCriminalRecord,
            className: `create-new-crime ${judMode === "POLICE" ? "police-style" : "doj-style"}`,
            children: judMode === "POLICE" ? lang.create : lang.sentCrimeRecord
          }
        )
      ] })
    ] }) }),
    openedCameraModal && /* @__PURE__ */ jsxRuntimeExports.jsx(CameraModal, { onCloseV2: () => setShowCamera(false), setPhotoLink: setMedia })
  ] });
};
const CreateVehicleCrime = ({ isOpen, onClose, dataLand, location, lang, vehicles, NotificationX, players, vehCrimes }) => {
  const [crimeLocation, UpdateCrimeLocation] = reactExports.useState("");
  const [data, setData] = reactExports.useState("");
  const [currentDate, setCurrentDate] = reactExports.useState("");
  const [currentTime, setCurrentTime] = reactExports.useState("");
  const [selectedCrimes, setSelectedCrimes] = reactExports.useState([]);
  const [offenceValue, setOffenceValue] = reactExports.useState("");
  const [addedMedias, setAddMedia] = reactExports.useState([]);
  const [openedCameraModal, setCameraModal] = reactExports.useState(false);
  const [photoLink, setPhotoLink] = reactExports.useState("");
  const [crimeReason, setCrimeReason] = reactExports.useState("");
  const [witnesses, setWitnesses] = reactExports.useState("");
  const [prisonTime, setPrisonTime] = reactExports.useState(null);
  const [prisonDropdownOpen, setPrisonDropdownOpen] = reactExports.useState(false);
  const [offenders, setOffenders] = reactExports.useState([dataLand]);
  const [offenderDropdownOpen, setOffenderDropdownOpen] = reactExports.useState(false);
  const [offendersWithPhoto, setOffendersWithPhoto] = reactExports.useState([]);
  const [caseNumber, setCaseNumber] = reactExports.useState("");
  reactExports.useState("");
  const [driverName, setDriverName] = reactExports.useState("");
  const toggleOffender = (player) => {
    const exists = offenders.some((o) => o.plate === player.plate);
    if (exists) {
      setOffenders((prev) => prev.filter((o) => o.plate !== player.plate));
    } else {
      setOffenders((prev) => [...prev, player]);
    }
    setOffenderDropdownOpen(false);
  };
  const createNewCriminalRecord = () => {
    if (offenders.length === 0 || !caseNumber || selectedCrimes.length === 0 || !currentDate || !currentTime || !crimeLocation || !crimeReason || !witnesses || !driverName) {
      NotificationX(lang.invalid, lang.emptyFields);
      return;
    }
    callNui("CreateVehicleCrime", {
      offenders: offenders.map((o) => ({ plate: o.plate, model: o.model, owner: o.owner })),
      caseNumber,
      crimes: selectedCrimes,
      money: getTotalFine(),
      date: currentDate,
      time: currentTime,
      location: crimeLocation,
      medias: addedMedias,
      reason: crimeReason,
      witnesses,
      driverName
    });
    onClose();
  };
  reactExports.useEffect(() => {
    setCaseNumber(generateCaseNumber());
  }, []);
  const dropdownRef = reactExports.useRef(null);
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
  const addPhoto = (dataurl) => {
    const newPhoto = {
      id: addedMedias.length + 1,
      url: dataurl
    };
    setAddMedia((prevPhotos) => [...prevPhotos, newPhoto]);
    callNui("CloseCameraApp", {});
    setCameraModal(false);
  };
  const toggleCameraApp = reactExports.useCallback(() => {
    callNui("ToggleCameraAppModule", {});
    setCameraModal((prev) => !prev);
  }, []);
  const [playerPhoto, setPhoto] = reactExports.useState("");
  const setMedia = (url) => {
    setPhotoLink(url);
    addPhoto(url);
  };
  const returnPlayerPhoto = (model) => {
    const pathorg = `https://docs.fivem.net/vehicles/${model}.webp`;
    const path = `/web/modvehicles/${model}.png`;
    const img = new Image();
    return new Promise((resolve) => {
      img.onload = () => resolve(pathorg);
      img.onerror = () => {
        const img2 = new Image();
        img2.src = path;
        img2.onload = () => resolve(path);
        img2.onerror = () => resolve(Avatar$2);
      };
      img.src = pathorg;
    });
  };
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const photo = await returnPlayerPhoto(dataLand.model);
      setPhoto(photo);
    };
    prepareData();
  }, [data]);
  const toggleCrime = (crime) => {
    const exists = selectedCrimes.find((c) => c.name === crime.name);
    if (exists) {
      setSelectedCrimes((prev) => prev.filter((c) => c.name !== crime.name));
    } else {
      setSelectedCrimes((prev) => [...prev, crime]);
    }
  };
  const getTotalFine = () => {
    return selectedCrimes.reduce((sum2, c) => sum2 + c.fine, 0);
  };
  const generateCaseNumber = () => {
    const date = /* @__PURE__ */ new Date();
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, "0");
    const dd = String(date.getDate()).padStart(2, "0");
    const random = Math.random().toString(36).substring(2, 5).toUpperCase();
    return `CR-${yyyy}${mm}${dd}-${random}`;
  };
  const UpdateInputLocation = (e) => {
    UpdateCrimeLocation(e.target.value);
  };
  const handleDateChange = (event) => {
    setCurrentDate(event.target.value);
  };
  const handleTimeChange = (event) => {
    setCurrentTime(event.target.value);
  };
  reactExports.useEffect(() => {
    const fetchPhotos = async () => {
      const newData = await Promise.all(offenders.map(async (off) => {
        const photo = await returnPlayerPhoto(off.model);
        return { ...off, photoUrl: photo };
      }));
      setOffendersWithPhoto(newData);
    };
    if (offenders.length > 0) fetchPhotos();
  }, [offenders]);
  reactExports.useEffect(() => {
    const now2 = /* @__PURE__ */ new Date();
    const formattedDate = now2.toISOString().slice(0, 10);
    const formattedTime = now2.toTimeString().slice(0, 5);
    setCurrentDate(formattedDate);
    setCurrentTime(formattedTime);
    UpdateCrimeLocation(location);
  }, []);
  const filteredCrimes = vehCrimes.filter(
    (crime) => crime.name.toLowerCase().includes(offenceValue.toLowerCase())
  );
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setDropdownOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `criminalrecord-container ${isOpen ? "show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-box", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-box-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "crbh-text", children: "Add Criminal Record" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "crbh-desc", children: "Create a new offence record" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => onClose(), style: {
          float: "right",
          color: "rgb(117, 117, 117)",
          position: "absolute",
          right: "1.5rem",
          top: "1rem",
          cursor: "pointer"
        }, className: "fa-solid fa-xmark" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "seperate-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.vehicles }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-multi-box", children: [
          offendersWithPhoto.map((off, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: off.photoUrl }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "player-name", children: [
                off.plate,
                " - ",
                off.ownerName
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-cid", children: off.modelname })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "offender-remove", onClick: () => toggleOffender(off), children: "" })
          ] }, i)),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "offender-add-btn",
              onClick: () => setOffenderDropdownOpen(!offenderDropdownOpen),
              children: "+ Add Car"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: offenderDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, height: 0 },
            animate: { opacity: 1, height: "auto" },
            exit: { opacity: 0, height: 0 },
            transition: { duration: 0.2 },
            className: "offender-dropdown-list",
            children: vehicles.map((p, index) => {
              const selected = offenders.some((o) => o.plate === p.plate);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `offender-dropdown-item ${selected ? "selected" : ""}`,
                  onClick: () => toggleOffender(p),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: p.plate }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cid-label", children: p.modelname })
                  ]
                },
                index
              );
            })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "offender-box-level", ref: dropdownRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: "Crime List" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: "Search crime...",
            className: "crime-search-input",
            value: offenceValue,
            onChange: (e) => setOffenceValue(e.target.value),
            onFocus: () => setDropdownOpen(true)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: dropdownOpen && filteredCrimes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, height: 0 },
            animate: { opacity: 1, height: "auto" },
            exit: { opacity: 0, height: 0 },
            transition: { duration: 0.2 },
            className: "crime-dropdown-list",
            children: filteredCrimes.map((crime, index) => {
              const selected = selectedCrimes.some((c) => c.name === crime.name);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `crime-dropdown-item ${selected ? "selected" : ""}`,
                  onClick: () => toggleCrime(crime),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: crime.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      "$",
                      crime.fine
                    ] })
                  ]
                },
                index
              );
            })
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-linesx", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dateler", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                className: "datetime-input date-input",
                value: currentDate,
                onChange: handleDateChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "time",
                className: "datetime-input time-input",
                value: currentTime,
                onChange: handleTimeChange
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.location }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: crimeLocation,
              placeholder: lang.clocation,
              onChange: (e) => UpdateInputLocation(e)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.note }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: crimeReason,
              placeholder: lang.note,
              onChange: (e) => setCrimeReason(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.witnesses }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: witnesses,
              placeholder: "John Wack, Serdar Bakan",
              onChange: (e) => setWitnesses(e.target.value)
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { zIndex: 999 }, className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: lang.driver }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "prison-dropdown-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "part-lineinput",
                value: driverName,
                placeholder: "John Wack",
                onChange: (e) => setDriverName(e.target.value),
                onClick: () => setPrisonDropdownOpen(!prisonDropdownOpen)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: prisonDropdownOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                initial: { opacity: 0, height: 0 },
                animate: { opacity: 1, height: "auto" },
                exit: { opacity: 0, height: 0 },
                transition: { duration: 0.2 },
                className: "prison-dropdown-list",
                children: players.map((time2, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: `prison-dropdown-item ${prisonTime === time2 ? "selected" : ""}`,
                    onClick: () => {
                      setDriverName(time2.pName);
                      setPrisonDropdownOpen(false);
                    },
                    children: [
                      time2.pName,
                      " - ",
                      time2.cid
                    ]
                  },
                  index
                ))
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: "Case Number" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "part-lineinput",
              value: caseNumber,
              readOnly: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "part-line", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "box-title", children: "Media" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "media-list", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleCameraApp, className: "add-media", children: "Add Evidence" }),
            addedMedias.map(
              (element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url, className: "evidence-img" })
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: createNewCriminalRecord, className: "create-new-crime", children: "Create" })
      ] })
    ] }) }),
    openedCameraModal && /* @__PURE__ */ jsxRuntimeExports.jsx(CameraModal, { onCloseV2: () => setShowCamera(false), setPhotoLink: setMedia })
  ] });
};
const NewCreateWanted = ({ isOpen, onClose, padres, lang, openApp, NotificationX, players, vehicles, judMode, setColdModal, openedColdModal }) => {
  reactExports.useState("");
  reactExports.useState("");
  reactExports.useState("");
  const [currentDate, setCurrentDate] = reactExports.useState("");
  const [currentTime, setCurrentTime] = reactExports.useState("");
  reactExports.useState("person");
  const [adress, setAddress] = reactExports.useState("");
  const [photoLink, setFoto] = reactExports.useState("");
  const [filteredPlayers, setFilteredPlayers] = reactExports.useState([]);
  const [showPlayerDropdown, setShowPlayerDropdown] = reactExports.useState(false);
  const [firstname, setFirstname] = reactExports.useState("");
  const [curCid, setIdentifier] = reactExports.useState("unkown");
  const [lastname, setLastname] = reactExports.useState("");
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [details, setDetails] = reactExports.useState("");
  const [plate, setPlate] = reactExports.useState("");
  const [vehicleModel, setModel] = reactExports.useState("");
  const [location, setLocation] = reactExports.useState("");
  const [dangerLevel, setLevel] = reactExports.useState(1);
  const [filteredPlates, setFilteredPlates] = reactExports.useState([]);
  const [orgModel, setOrgModel] = reactExports.useState("");
  const [showPlateDropdown, setShowPlateDropdown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (firstname.trim() !== "") {
      const results = players.filter(
        (p) => p.pName.toLowerCase().includes(firstname.toLowerCase())
      );
      setFilteredPlayers(results);
      setShowPlayerDropdown(true);
    } else {
      setShowPlayerDropdown(false);
    }
  }, [firstname]);
  reactExports.useEffect(() => {
    if (plate.trim() !== "") {
      const results = vehicles.filter(
        (v) => v.plate.toLowerCase().includes(plate.toLowerCase())
      );
      setFilteredPlates(results);
      setShowPlateDropdown(true);
    } else {
      setShowPlateDropdown(false);
    }
  }, [plate]);
  const selectPlayer = (player, identifier) => {
    const [first, ...last] = player.pName.split(" ");
    setFirstname(first);
    setIdentifier(identifier);
    setLastname(last.join(" "));
    setShowPlayerDropdown(false);
  };
  const selectPlate = (vehicle) => {
    setPlate(vehicle.plate);
    setModel(vehicle.model);
    setOrgModel(vehicle.orgmodel);
    setShowPlateDropdown(false);
  };
  const setPhotoLink = (newLink) => {
    addPhoto(newLink);
    setFoto(newLink);
  };
  const [addedPhotos, setAddedPhotos] = reactExports.useState([]);
  reactExports.useState({ citizen: false, vehicle: false });
  const addPhoto = (dataurl) => {
    const newPhoto = {
      id: addedPhotos.length + 1,
      url: dataurl
    };
    setAddedPhotos((prevPhotos) => [...prevPhotos, newPhoto]);
  };
  const [selected, setSelected] = reactExports.useState("citizen");
  reactExports.useEffect(() => {
    const now2 = /* @__PURE__ */ new Date();
    const formattedDate = now2.toISOString().slice(0, 10);
    const formattedTime = now2.toTimeString().slice(0, 5);
    setCurrentDate(formattedDate);
    setCurrentTime(formattedTime);
    setAddress(padres);
  }, []);
  reactExports.useEffect(() => {
    useNui("openApp", (data2) => {
      openApp("mdt", "openmdtforcamera");
      addPhoto(data2.url);
    });
  });
  const colors3 = ["Red", "Green", "Blue", "Yellow", "Orange", "Purple", "Black", "White"];
  const [showList, setShowList] = reactExports.useState(false);
  const [selectedColor, setSelectedColor] = reactExports.useState("");
  const listRef = reactExports.useRef(null);
  const handleClickOutside = (e) => {
    if (listRef.current && !listRef.current.contains(e.target)) setShowList(false);
  };
  reactExports.useEffect(() => {
    setLocation(padres);
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const [openedCameraModal, setCameraModal] = reactExports.useState(false);
  const toggleCameraApp = reactExports.useCallback(() => {
    callNui("ToggleCameraAppModule", {});
    setCameraModal((prevState) => !prevState);
  }, []);
  const CreateWanted = () => {
    if (selected == "citizen") {
      if ((firstname == null ? void 0 : firstname.trim()) && (lastname == null ? void 0 : lastname.trim()) && (details == null ? void 0 : details.trim()) && (location == null ? void 0 : location.trim())) {
        if (dangerLevel >= 1 && dangerLevel <= 5) {
          callNui("CreateNewWanted", {
            type: selected,
            cid: curCid,
            firstname,
            lastname,
            details,
            location,
            dangerlevel: dangerLevel,
            medias: addedPhotos
          });
          callNui("CloseCameraApp", {});
          onClose();
        } else {
          NotificationX(lang.invalid, lang.wantedLevelReq);
        }
      } else {
        NotificationX(lang.invalid, lang.emptyFields);
      }
    } else {
      if ((plate == null ? void 0 : plate.trim()) && (vehicleModel == null ? void 0 : vehicleModel.trim()) && (details == null ? void 0 : details.trim()) && (location == null ? void 0 : location.trim()) && (selectedColor == null ? void 0 : selectedColor.trim())) {
        if (dangerLevel >= 1 && dangerLevel <= 5) {
          callNui("CreateNewWanted", {
            type: selected,
            cid: curCid,
            plate,
            vehicleModel,
            selectedColor,
            orgModel,
            details,
            location,
            dangerlevel: dangerLevel,
            medias: addedPhotos
          });
          callNui("CloseCameraApp", {});
          onClose();
        } else {
          NotificationX(lang.invalid, lang.wantedLevelReq);
        }
      } else {
        NotificationX(lang.invalid, lang.emptyFields);
      }
    }
    if (judMode !== "POLICE") {
      setColdModal(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `createwanted-container ${isOpen ? "show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "create-wanted-box", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-title", children: [
        "Add New Wanted",
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => onClose(), style: { float: "right", color: "#757575", cursor: "pointer" }, className: "fa-solid fa-xmark" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wanted-type-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wanted Type" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "checkbox-container", children: [
          { label: "Citizen", type: "citizen" },
          { label: "Vehicle", type: "vehicle" }
        ].map(({ label, type }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "checkbox-label", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "radio",
              name: "selection",
              className: "hidden-checkbox",
              value: type,
              checked: selected === type,
              onChange: () => setSelected(type)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `custom-checkbox ${selected === type ? "checked" : ""}`, children: selected === type && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "checkbox-indicator" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "checkbox-text", children: label })
        ] }, type)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "criminal-record-content", children: [
        selected == "citizen" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Firstname" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                placeholder: "Firstname",
                onChange: (e) => setFirstname(e.target.value),
                value: firstname,
                onFocus: () => firstname.trim() && setShowPlayerDropdown(true)
              }
            ),
            showPlayerDropdown && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "dropdown-listx", children: filteredPlayers.map((player, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "li",
              {
                onClick: () => selectPlayer(player, player.cid),
                className: "dropdown-item",
                children: player.pName
              },
              index
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Lastname" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: "Lastname", onChange: (e) => setLastname(e.target.value), value: lastname })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "descriptionpart", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: "Add Details", onChange: (e) => setDetails(e.target.value), value: details })
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Plate" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                placeholder: "Vehicle Plate",
                onChange: (e) => setPlate(e.target.value),
                value: plate,
                onFocus: () => plate.trim() && setShowPlateDropdown(true)
              }
            ),
            showPlateDropdown && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "dropdown-listx", children: filteredPlates.map((vehicle, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "li",
              {
                onClick: () => selectPlate(vehicle),
                className: "dropdown-item",
                children: [
                  vehicle.plate,
                  " - ",
                  vehicle.modelname
                ]
              },
              index
            )) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Model" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: "Vehicle Model", onChange: (e) => setModel(e.target.value), value: vehicleModel })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", style: { position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Color" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                placeholder: "Vehicle Color",
                value: selectedColor,
                onChange: (e) => setSelectedColor(e.target.value),
                onFocus: () => setShowList(true)
              }
            ),
            showList && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "ul",
              {
                ref: listRef,
                className: "listref",
                children: colors3.filter((c) => c.toLowerCase().includes(selectedColor.toLowerCase())).map((c, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { onClick: () => {
                  setSelectedColor(c);
                  setShowList(false);
                }, children: c }, i))
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "descriptionpart", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Details" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: "Add Details", onChange: (e) => setDetails(e.target.value), value: details })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "descriptionpart", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wanted Level" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "number", placeholder: "Wanted Level", onChange: (e) => setLevel(e.target.value), value: dangerLevel })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Location" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: "Location", onChange: (e) => setLocation(e.target.value), value: location })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "record-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "", children: "Add Media" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listed-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: toggleCameraApp, className: "listed-detail-takePhoto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-camera" }) }),
            addedPhotos.map(
              (element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "listed-detail-takePhoto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url }) })
            )
          ] })
        ] }),
        judMode == "POLICE" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => CreateWanted(), className: "create-new-wanted-person", children: lang.cwanted }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => CreateWanted(), className: "create-new-wanted-person", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "spinner" }) : lang.csendreq })
      ] })
    ] }) }),
    openedCameraModal && /* @__PURE__ */ jsxRuntimeExports.jsx(CameraModal, { onCloseV2: toggleCameraApp, setPhotoLink })
  ] });
};
const addAnnounceModal = ({ isOpen, onClose, lang, NotificationX, theme }) => {
  const [onePut, setPut] = reactExports.useState("");
  const [secondPut, setPut2] = reactExports.useState("");
  const SendAnnounce = () => {
    if (onePut.trim() && secondPut.trim()) {
      callNui("SendAnnounceForMdt", {
        title: onePut,
        message: secondPut
      }, function(data) {
        if (data) {
          onClose();
        }
      });
      setPut("");
      setPut2("");
    } else {
      NotificationX(lang.invalid, lang.emptyFields);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `mdt-addannouncemodal ${isOpen ? "show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { className: `mdt-announcemodal-container ${theme !== "dark" ? "modal-white" : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => onClose(), className: "close-announce-modal", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-xmark" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `header-label ${theme !== "dark" ? "header-white" : ""}`, children: lang.sendAnnounce }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-label-br" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "enterprise", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label-sp", children: lang.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.announceTitle, value: onePut, onChange: (e) => setPut(e.target.value) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "enterprise", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label-sp", children: lang.message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.announceMessage, value: secondPut, onChange: (e) => setPut2(e.target.value) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => SendAnnounce(), className: "enterprise", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { children: lang.sendAnnounce }) })
  ] }) });
};
function WeaponLicenseModal({ lang, onClose, players, weapons, NotificationX }) {
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useState("");
  const [search2, setSearch] = reactExports.useState("");
  const [filteredPlayers, setFilteredPlayers] = reactExports.useState([]);
  reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  reactExports.useRef(null);
  const [licenseCode, setLicenseCode] = reactExports.useState("");
  const [weaponName, setWeaponName] = reactExports.useState("");
  const [expirationDate, setExpirationDate] = reactExports.useState("");
  const [licenseType, setWeaponLicenseType] = reactExports.useState("");
  const [allweapons, setWeapons] = reactExports.useState([]);
  const [filteredWeapons, setFilteredWeapons] = reactExports.useState([]);
  const [showWeaponDropdown, setShowWeaponDropdown] = reactExports.useState(false);
  const [selectedCid, setCid] = reactExports.useState("");
  reactExports.useEffect(() => {
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    setExpirationDate(today);
    setWeapons(weapons);
  }, []);
  const handleDateChange = (e) => {
    setExpirationDate(e.target.value);
  };
  const generateLicenseCode = () => {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let code = "WL-";
    for (let i = 0; i < 5; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  };
  reactExports.useEffect(() => {
    setTimeout(() => setVisible(true), 10);
  }, []);
  const handleClose = () => {
    setVisible(false);
    setTimeout(() => onClose(), 300);
  };
  const handleWeaponSearch = (e) => {
    const value = e.target.value;
    setWeaponName(value);
    if (value.length > 0) {
      const filtered = allweapons.filter(
        (w) => w.name.toLowerCase().includes(value.toLowerCase())
      );
      setFilteredWeapons(filtered);
    } else {
      setFilteredWeapons([]);
    }
  };
  const handleWeaponSelect = (weapon) => {
    setWeaponName(weapon.name);
    setLicenseCode(generateLicenseCode());
    setWeaponLicenseType(weapon.licenseType);
    setFilteredWeapons([]);
  };
  const handleSearch = (e) => {
    const value = e.target.value;
    setSearch(value);
    if (value.length > 0) {
      const filtered = players.filter(
        (player) => player.pName.toLowerCase().includes(value.toLowerCase())
      );
      setFilteredPlayers(filtered);
    } else {
      setFilteredPlayers([]);
    }
  };
  const handleSelect = (player) => {
    setSearch(player.pName);
    setCid(player.cid);
    setFilteredPlayers([]);
  };
  const CreateNewWeaponLicense = () => {
    if ((search2 == null ? void 0 : search2.trim()) && (licenseCode == null ? void 0 : licenseCode.trim()) && (weaponName == null ? void 0 : weaponName.trim()) && (licenseType == null ? void 0 : licenseType.trim()) && (expirationDate == null ? void 0 : expirationDate.trim())) {
      callNui("CreateNewLicense", {
        selectedCid,
        search: search2,
        licenseCode,
        licenseType,
        expirationDate,
        status: 1
      }, function() {
        onClose();
      });
      onClose();
    } else {
      NotificationX(lang.invalid, lang.emptyFields);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `modal-overlay-wpn ${visible ? "fade-in" : "fade-out"}`, onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `modal-container-wpn ${visible ? "fade-in" : "fade-out"}`, onClick: (e) => e.stopPropagation(), ref: modalRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: lang.rweaponlicense }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => onClose(), className: "modal-cnt-closend", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-xmark" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bolburalari" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bimbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bimbox-label", children: lang.scitizen }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "bimbox-input",
          placeholder: "Search Player",
          value: search2,
          onChange: handleSearch
        }
      ),
      filteredPlayers.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "player-list", children: filteredPlayers.map((player) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { onClick: () => handleSelect(player), children: player.pName }, player.id)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bimbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bimbox-label", children: lang.weapon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "bimbox-input",
          placeholder: "Weapon Name",
          value: weaponName,
          onChange: handleWeaponSearch,
          onFocus: () => setShowWeaponDropdown(true),
          onBlur: () => {
            setTimeout(() => setShowWeaponDropdown(false), 150);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: `weapon-dropdown ${showWeaponDropdown ? "open" : ""}`, children: filteredWeapons.map((w, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { onClick: () => handleWeaponSelect(w), children: w.name }, i)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bimbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bimbox-label", children: lang.licenseCode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "bimbox-input",
          placeholder: "License Code",
          value: licenseCode,
          onChange: (e) => setLicenseCode(e.target.value)
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bimbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bimbox-label", children: lang.ltype }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "bimbox-input",
          placeholder: "License Type",
          value: licenseType,
          onChange: (e) => setWeaponLicenseType(e.target.value)
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bimbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bimbox-label", children: lang.expirationdate }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "bimbox-input",
          type: "date",
          value: expirationDate,
          onChange: handleDateChange
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => CreateNewWeaponLicense(), className: "button-create-license", children: lang.register })
  ] }) });
}
const CitizenQueryPage = ({ onClose, isOpened, players, lang, setCitizenProfile, isCitizenProfile, setProfileData, theme }) => {
  const [citizenName, setCitizenName] = reactExports.useState("");
  const [citizenList, setCitizenList] = reactExports.useState([]);
  const VehiclePlateEvent = (e) => {
    setCitizenName(e);
  };
  reactExports.useEffect(() => {
    const prepareInitialList = async () => {
      if (!players || !players.length) return;
      const enriched = await Promise.all(players.map(async (p) => {
        const photo = await returnPlayerPhoto(p.cid);
        return { ...p, photoUrl: photo };
      }));
      setCitizenList(enriched);
    };
    prepareInitialList();
  }, [players]);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    const handleSearch = async () => {
      if (!players || !players.length) return;
      if (citizenName.trim() === "") {
        const all2 = await Promise.all(players.map(async (p) => {
          const photo = await returnPlayerPhoto(p.cid);
          return { ...p, photoUrl: photo };
        }));
        setCitizenList(all2);
        return;
      }
      const search2 = citizenName.toLowerCase();
      const filtered = players.filter(
        (v) => v.pName.toLowerCase().includes(search2) || v.cid.toLowerCase().includes(search2)
      );
      const enriched = await Promise.all(filtered.map(async (element) => {
        const photo = await returnPlayerPhoto(element.cid);
        return { ...element, photoUrl: photo };
      }));
      setCitizenList(enriched.reverse());
    };
    handleSearch();
  }, [citizenName, players]);
  const handleSett = (data) => {
    setCitizenProfile(true);
    setProfileData(data);
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-head`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.citizenqueryplc, value: citizenName, onChange: (e) => VehiclePlateEvent(e.target.value) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `part-title ${theme !== "dark" ? "black-text" : ""}`, children: lang.citizens }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.photo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.citizenname }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.job }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.birthdate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: citizenList.map((citizen, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: citizen.photoUrl }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: citizen.pName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: citizen.job }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: citizen.birthdate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSett(citizen), className: "button-rev2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-eye" }) }) })
      ] })) })
    ] })
  ] });
};
const Avatar$1 = "" + new URL("unkown.png", import.meta.url).href;
const VehicleProfileScreen = ({ lang, data, onClose, crimes, onOpen, theme }) => {
  const [playerPhoto, setPhoto] = reactExports.useState("");
  const [vehicleCrimes, setVehicleCrimes] = reactExports.useState([]);
  const [modalOpen, setModalOpen] = reactExports.useState(null);
  const [isSet, izzet] = reactExports.useState("veh");
  const returnPlayerPhoto = (model) => {
    const pathorg = `https://docs.fivem.net/vehicles/${model}.webp`;
    const path = `/web/modvehicles/${model}.png`;
    const img = new Image();
    return new Promise((resolve) => {
      img.onload = () => resolve(pathorg);
      img.onerror = () => {
        const img2 = new Image();
        img2.src = path;
        img2.onload = () => resolve(path);
        img2.onerror = () => resolve(Avatar$1);
      };
      img.src = pathorg;
    });
  };
  const getCrimeData = (data2, veh) => {
    data2.typeland = veh;
    setModalOpen(data2);
  };
  const parseArticles = (articles) => {
    if (!articles) return [];
    try {
      const parsed = typeof articles === "string" ? JSON.parse(articles) : articles;
      return Array.isArray(parsed) ? parsed : [];
    } catch (err) {
      console.warn("Article parse error:", articles);
      return [];
    }
  };
  reactExports.useEffect(() => {
    if (!(crimes == null ? void 0 : crimes.length) || !(data == null ? void 0 : data.plate)) return;
    const filtered = crimes.filter((crime) => {
      let parsedCars = [];
      try {
        parsedCars = typeof crime.cars === "string" ? JSON.parse(crime.cars) : crime.cars;
      } catch (err) {
        console.warn("Ara listesi JSON parse edilemedi:", crime.cars);
        return false;
      }
      return Array.isArray(parsedCars) && parsedCars.some((car) => {
        var _a2;
        return ((_a2 = car.plate) == null ? void 0 : _a2.toUpperCase()) === data.plate.toUpperCase();
      });
    });
    setVehicleCrimes(filtered);
  }, [crimes, data]);
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const photo = await returnPlayerPhoto(data.model);
      setPhoto(photo);
    };
    prepareData();
  }, [data]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-citizenprofile-page2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        width: "33%",
        float: "left",
        marginLeft: "1rem",
        marginTop: "1rem",
        height: "22rem"
      }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playerPhoto }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-citizenprofile-page-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.plate }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.plate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.oname }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.ownerName })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.model }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.modelname })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.vehicleColor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.vehicleColor })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.wlevel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.wantedlevel ? data.wantedlevel : lang.notwanted })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.class }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.class })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.public }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: data.type })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mdt-citizenprofile-page-bottom", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: lang.history }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onClose, className: "back-button", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-arrow-turn-down-left" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: onOpen, className: "add-button", children: lang.addrecord })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "table", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.cars })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: vehicleCrimes.map((record, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { onClick: () => getCrimeData(record, "veh"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: record.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: (() => {
              const crimes2 = parseArticles(record.crimes);
              const shown = crimes2.slice(0, 3).map((a) => a.name).join(", ");
              return crimes2.length > 2 ? `${shown}, ...` : shown;
            })() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: parseArticles(record.cars).map((a) => a.plate).join(", ") })
          ] }, i)) })
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CrimeDetailsModal,
      {
        lang,
        isOpen: !!modalOpen,
        crimeData: modalOpen,
        theme,
        onClose: () => setModalOpen(null),
        manageCrime: false,
        typeland: isSet
      }
    )
  ] });
};
const CrimeList = ({ lang, cidCrimes, vehCrimes, wantedList, wantedVehicles, theme }) => {
  const [query, setQuery] = reactExports.useState("");
  const [photoMap, setPhotoMap] = reactExports.useState({});
  reactExports.useState(null);
  const [isPersonalCrimes, setType] = reactExports.useState("cid");
  const [modalOpen, setModalOpen] = reactExports.useState(null);
  const [isModalFor, setModalForWanted] = reactExports.useState(null);
  const [isModalForVeh, setModalForWantedVeh] = reactExports.useState(null);
  const parseIfNeeded = (data, fallback = []) => {
    if (Array.isArray(data)) return data;
    if (typeof data === "string") {
      try {
        return JSON.parse(data);
      } catch {
        return fallback;
      }
    }
    return fallback;
  };
  const closeLicenseModal = () => {
    setModalForWanted(null);
    setModalForWantedVeh(null);
  };
  const openWantedModal = (data) => {
    setModalForWanted(data);
  };
  const openWantedModalVeh = (data) => {
    setModalForWantedVeh(data);
  };
  const deleteData = (type, data) => {
    callNui("deleteDataFromMdt", {
      type,
      deletedData: data
    });
  };
  const filtered = cidCrimes.filter((c) => {
    const offenders = parseIfNeeded(c.offenders);
    return offenders.some(
      (off) => `${off.name} ${off.cid}`.toLowerCase().includes(query.toLowerCase())
    ) || c.crime_id.toLowerCase().includes(query.toLowerCase());
  });
  const filteredVeh = vehCrimes.filter((c) => {
    const cars = parseIfNeeded(c.cars);
    return cars.some(
      (off) => `${off.plate} ${off.model}`.toLowerCase().includes(query.toLowerCase())
    ) || c.case_id.toLowerCase().includes(query.toLowerCase());
  });
  const returnPlayerPhoto = async (cid) => {
    const path = `/web/pimg/${cid}.png`;
    try {
      const res = await fetch(path);
      if (res.ok) return path;
      else throw new Error();
    } catch {
      return Avatar$2;
    }
  };
  reactExports.useEffect(() => {
    const load2 = async () => {
      const map = {};
      for (const row of filtered) {
        const offenders = parseIfNeeded(row.offenders);
        for (const o of offenders) {
          if (!map[o.cid]) map[o.cid] = await returnPlayerPhoto(o.cid);
        }
      }
      setPhotoMap(map);
    };
    load2();
  }, [filtered]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cquery-head", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.searchcrime, value: query, onChange: (e) => setQuery(e.target.value) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setType("cid"), className: `part-title2 ${theme !== "dark" ? "partdark" : ""}`, children: lang.ccrimes }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setType("veh"), className: `part-title2 ${theme !== "dark" ? "partdark" : ""}`, children: lang.vehcrimes }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setType("wlist"), className: `part-title2 ${theme !== "dark" ? "partdark" : ""}`, children: lang.wlist }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setType("wlistveh"), className: `part-title2 ${theme !== "dark" ? "partdark" : ""}`, children: lang.wvehicles })
        ] }),
        isPersonalCrimes == "cid" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.suspect }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.caseid }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: filtered.map((crime, index) => {
            parseIfNeeded(crime.offenders);
            const articles = parseIfNeeded(crime.articles);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setModalOpen(crime), className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Avatar$2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: crime.crime_id }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: [
                articles.slice(0, 2).map((a, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  a.name,
                  i < Math.min(1, articles.length - 1) ? ", " : ""
                ] }, i)),
                articles.length > 2 && "..."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => {
                e.stopPropagation();
                deleteData("crimepersonal", crime.crime_id);
              }, className: "button-rev", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-trash" }) }) })
            ] });
          }) })
        ] }),
        isPersonalCrimes == "veh" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.suspect }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.caseid }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.articles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.date }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: filteredVeh.map((crime, index) => {
            const cars = parseIfNeeded(crime.cars);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setModalOpen(crime), style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Avatar$2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: crime.case_id }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: [
                cars.slice(0, 2).map((a, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  a.plate,
                  i < Math.min(1, cars.length - 1) ? ", " : ""
                ] }, i)),
                cars.length > 2 && "..."
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => {
                e.stopPropagation();
                deleteData("crimevehicle", crime.case_id);
              }, className: "button-rev", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-trash" }) }) })
            ] });
          }) })
        ] }),
        isPersonalCrimes == "wlist" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.citizenid }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.citizenname }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.wlevel }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.wsince }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: wantedList.map((crime, index) => {
            parseIfNeeded(crime.cars);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => openWantedModal(crime), className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: crime.cid }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: [
                crime.first_name,
                " ",
                crime.last_name
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.danger_level }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.wanted_since }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => {
                e.stopPropagation();
                deleteData("wantedlist", crime.cid);
              }, className: "button-rev", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-trash" }) }) })
            ] });
          }) })
        ] }),
        isPersonalCrimes == "wlistveh" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.plate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.model }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.wlevel }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.wsince }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: wantedVehicles.map((crime, index) => {
            parseIfNeeded(crime.cars);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => openWantedModalVeh(crime), className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: crime.plate }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: crime.modellabel }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.danger_level }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.wanted_since }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: (e) => {
                e.stopPropagation();
                deleteData("wantedlistveh", crime.plate);
              }, className: "button-rev", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-trash" }) }) })
            ] });
          }) })
        ] })
      ] })
    ] }),
    isModalFor !== null && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "license-modal-overlay", onClick: closeLicenseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "license-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: closeLicenseModal, className: "close-btn-5", style: { float: "right", cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-xmark" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: isModalFor.photoUrl || Avatar$2,
          alt: "Profile",
          className: "license-modal-photo"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
        isModalFor.first_name,
        " ",
        isModalFor.last_name
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: isModalFor.cid }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ayir" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "parts", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wsince }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalFor.wanted_since })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.identitynum }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalFor.cid })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.llocation }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalFor.last_seen_location })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wlevel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalFor.danger_level })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.addedby }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalFor.added_by })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fotolar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.media }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "photos", children: isModalFor.medias.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url }, element.id)) })
      ] })
    ] }) }),
    isModalForVeh !== null && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "license-modal-overlay", onClick: closeLicenseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "license-modal-content", onClick: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: closeLicenseModal, className: "close-btn-5", style: { float: "right", cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-xmark" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: isModalForVeh.photoUrl || Avatar$2,
          alt: "Profile",
          className: "license-modal-photo"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: isModalForVeh.modellabel }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "Created by ",
        isModalForVeh.added_by
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ayir" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "parts", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.plate }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.plate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.color }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.color })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.llocation }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.last_seen_location })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wsince }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.wanted_since })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wlevel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.danger_level })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.reason }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: isModalForVeh.reason })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fotolar", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.media }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "photos", children: isModalForVeh.medias.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url }, element.id)) })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CrimeDetailsModal,
      {
        lang,
        isOpen: !!modalOpen,
        crimeData: modalOpen,
        theme,
        onClose: () => setModalOpen(null),
        manageCrime: true,
        typeland: isPersonalCrimes
      }
    )
  ] });
};
const MdtHistory = ({ lang, history, theme }) => {
  const [query, setQuery] = reactExports.useState("");
  const filtered = history.filter((c) => {
    return c.created_by || c.casenumber.toLowerCase().includes(query.toLowerCase());
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cquery-head", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.searchcrime, value: query, onChange: (e) => setQuery(e.target.value) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `part-title ${theme !== "dark" ? "black-text" : ""}`, children: lang.history }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginLeft: "1rem", width: "15rem" }, children: lang.performedby }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "39rem" }, children: lang.transaction }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "10rem" }, children: lang.date })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: filtered.map((crime, index) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginLeft: "1rem", width: "15rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: crime.created_by }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "39rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: crime.transaction }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "10rem", display: "flex", alignItems: "center" }, children: crime.date })
          ] });
        }) })
      ] })
    ] })
  ] }) });
};
var rngBrowser = { exports: {} };
var hasRequiredRngBrowser;
function requireRngBrowser() {
  if (hasRequiredRngBrowser) return rngBrowser.exports;
  hasRequiredRngBrowser = 1;
  var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
  if (getRandomValues) {
    var rnds8 = new Uint8Array(16);
    rngBrowser.exports = function whatwgRNG() {
      getRandomValues(rnds8);
      return rnds8;
    };
  } else {
    var rnds = new Array(16);
    rngBrowser.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 3) === 0) r = Math.random() * 4294967296;
        rnds[i] = r >>> ((i & 3) << 3) & 255;
      }
      return rnds;
    };
  }
  return rngBrowser.exports;
}
var bytesToUuid_1;
var hasRequiredBytesToUuid;
function requireBytesToUuid() {
  if (hasRequiredBytesToUuid) return bytesToUuid_1;
  hasRequiredBytesToUuid = 1;
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      "-",
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]]
    ].join("");
  }
  bytesToUuid_1 = bytesToUuid;
  return bytesToUuid_1;
}
var v1_1;
var hasRequiredV1;
function requireV1() {
  if (hasRequiredV1) return v1_1;
  hasRequiredV1 = 1;
  var rng = requireRngBrowser();
  var bytesToUuid = requireBytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5]
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    var tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid(b);
  }
  v1_1 = v1;
  return v1_1;
}
var v4_1;
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4_1;
  hasRequiredV4 = 1;
  var rng = requireRngBrowser();
  var bytesToUuid = requireBytesToUuid();
  function v4(options, buf, offset) {
    var i = buf && offset || 0;
    if (typeof options == "string") {
      buf = options === "binary" ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  v4_1 = v4;
  return v4_1;
}
var uuid_1;
var hasRequiredUuid;
function requireUuid() {
  if (hasRequiredUuid) return uuid_1;
  hasRequiredUuid = 1;
  var v1 = requireV1();
  var v4 = requireV4();
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid_1 = uuid;
  return uuid_1;
}
var uuidExports = requireUuid();
function MDTChat({ lang, allMessages, playerName }) {
  const [text, setText] = reactExports.useState("");
  const [messages, setMessages] = reactExports.useState([]);
  reactExports.useEffect(() => {
    setMessages(allMessages);
  }, [allMessages]);
  const messagesRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const el = messagesRef.current;
    if (el) {
      el.scrollTop = el.scrollHeight;
    }
  }, [messages]);
  const send = () => {
    if (!text) return;
    const newMsg = {
      id: uuidExports.v4(),
      sender: playerName,
      message: text,
      type: "mdt",
      time: (/* @__PURE__ */ new Date()).toLocaleTimeString()
    };
    callNui("sendMessage", newMsg);
    setText("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ems-chat", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ems-chat-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ems-heax", children: lang.mdtchat }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ems-messages", ref: messagesRef, children: messages.map((m, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: m.sender === playerName ? "msg minex" : "msg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sender", children: m.sender }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text", children: m.message }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timestamp", children: m.time })
    ] }, i)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ems-input", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          value: text,
          onChange: (e) => setText(e.target.value),
          onKeyDown: (e) => e.key === "Enter" && send(),
          placeholder: lang.writesmt
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: send, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "19", height: "16", viewBox: "0 0 19 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 0V6.18182L10.9091 8L0 9.81818V16L18.9091 8L0 0Z", fill: "#9B9B9B" }) }) })
    ] })
  ] });
}
const ColdModal = ({ appName, title, message, buttons, isOpen, onClose }) => {
  reactExports.useEffect(() => {
    document.body.style.overflow = isOpen ? "hidden" : "";
  }, [isOpen]);
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nm-overlay", onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nm-modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nm-header", children: [
      "",
      appName,
      " ",
      title
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nm-message", children: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "nm-buttons", children: buttons.map((btn, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "nm-button", onClick: btn.onClick, children: btn.label }, idx)) })
  ] }) });
};
const SopApp = ({ lang, theme }) => {
  const [selectedCategory, setSelectedCategory] = reactExports.useState("general");
  const [selectedTab, setSelectedTab] = reactExports.useState("sop");
  const sopData = {
    general: [
      {
        title: "General Conduct",
        procedures: [
          "Always maintain professional behavior while on duty",
          "Treat all citizens with respect and dignity",
          "Follow department policies and procedures",
          "Maintain proper uniform and equipment standards",
          "Report any violations or incidents immediately"
        ]
      },
      {
        title: "Communication",
        procedures: [
          "Use clear and professional language",
          "Maintain radio discipline",
          "Document all interactions properly",
          "Follow chain of command",
          "Use appropriate codes and signals"
        ]
      }
    ],
    traffic: [
      {
        title: "Traffic Stops",
        procedures: [
          "Activate emergency lights and siren when necessary",
          "Position vehicle safely and strategically",
          "Approach vehicle with caution",
          "Request license, registration, and insurance",
          "Explain reason for stop clearly",
          "Issue citations or warnings as appropriate"
        ]
      },
      {
        title: "Accident Response",
        procedures: [
          "Secure the scene and ensure safety",
          "Provide medical assistance if needed",
          "Collect witness statements",
          "Document damage and injuries",
          "Direct traffic around the scene",
          "Complete accident report thoroughly"
        ]
      }
    ],
    arrest: [
      {
        title: "Arrest Procedures",
        procedures: [
          "Inform suspect of Miranda rights",
          "Use appropriate force only when necessary",
          "Search suspect for weapons and contraband",
          "Handcuff suspect securely",
          "Transport to booking facility",
          "Complete arrest report and documentation"
        ]
      },
      {
        title: "Search and Seizure",
        procedures: [
          "Obtain warrant when required",
          "Document all evidence collected",
          "Maintain chain of custody",
          "Photograph evidence and scene",
          "Package evidence properly",
          "Submit to evidence room"
        ]
      }
    ],
    emergency: [
      {
        title: "Emergency Response",
        procedures: [
          "Respond immediately to emergency calls",
          "Assess situation and request backup if needed",
          "Provide first aid and medical assistance",
          "Secure perimeter and control access",
          "Coordinate with other emergency services",
          "Document all actions taken"
        ]
      },
      {
        title: "Active Shooter Response",
        procedures: [
          "Stop the killing - engage threat immediately",
          "Stop the dying - provide medical aid",
          "Evacuate civilians to safety",
          "Establish command post",
          "Coordinate with SWAT and other units",
          "Preserve evidence and document scene"
        ]
      }
    ]
  };
  const categories = [
    { id: "general", name: "General Procedures", icon: "fa-solid fa-shield" },
    { id: "traffic", name: "Traffic Enforcement", icon: "fa-solid fa-car" },
    { id: "arrest", name: "Arrest & Search", icon: "fa-solid fa-handcuffs" },
    { id: "emergency", name: "Emergency Response", icon: "fa-solid fa-exclamation-triangle" }
  ];
  const pd10Codes = {
    status: [
      { code: "10-1", meaning: "Officer needs help - EMERGENCY!", priority: "high" },
      { code: "10-2", meaning: "Signal good", priority: "low" },
      { code: "10-3", meaning: "Stop transmitting", priority: "medium" },
      { code: "10-4", meaning: "Acknowledged", priority: "low" },
      { code: "10-5", meaning: "Relay", priority: "medium" },
      { code: "10-6", meaning: "Busy - unless urgent", priority: "medium" },
      { code: "10-7", meaning: "Out of service", priority: "medium" },
      { code: "10-8", meaning: "In service", priority: "low" },
      { code: "10-9", meaning: "Repeat", priority: "medium" },
      { code: "10-10", meaning: "Fight in progress", priority: "high" }
    ],
    calls: [
      { code: "10-11", meaning: "SWAT call", priority: "high" },
      { code: "10-12", meaning: "Notify news media", priority: "medium" },
      { code: "10-13", meaning: "Weather and road report", priority: "low" },
      { code: "10-14", meaning: "Prowler report", priority: "medium" },
      { code: "10-15", meaning: "Civil disturbance", priority: "high" },
      { code: "10-16", meaning: "Domestic problem", priority: "high" },
      { code: "10-17", meaning: "Meet complainant", priority: "medium" },
      { code: "10-18", meaning: "Quickly", priority: "high" },
      { code: "10-19", meaning: "Return to station", priority: "medium" },
      { code: "10-20", meaning: "Location", priority: "medium" }
    ],
    situations: [
      { code: "10-21", meaning: "Call by telephone", priority: "medium" },
      { code: "10-22", meaning: "Disregard", priority: "low" },
      { code: "10-23", meaning: "Arrived at scene", priority: "medium" },
      { code: "10-24", meaning: "Assignment completed", priority: "low" },
      { code: "10-25", meaning: "Report to (meet)", priority: "medium" },
      { code: "10-26", meaning: "ETA (estimated time of arrival)", priority: "medium" },
      { code: "10-27", meaning: "License/Permit information", priority: "medium" },
      { code: "10-28", meaning: "Vehicle registration information", priority: "medium" },
      { code: "10-29", meaning: "Check for wanted", priority: "medium" },
      { code: "10-30", meaning: "Unnecessary use of radio", priority: "low" }
    ],
    emergency: [
      { code: "10-31", meaning: "Crime in progress", priority: "high" },
      { code: "10-32", meaning: "Man with gun", priority: "high" },
      { code: "10-33", meaning: "EMERGENCY! All units stand by", priority: "critical" },
      { code: "10-34", meaning: "Riot", priority: "high" },
      { code: "10-35", meaning: "Major crime alert", priority: "high" },
      { code: "10-36", meaning: "Correct time", priority: "low" },
      { code: "10-37", meaning: "(Investigate) suspicious vehicle", priority: "medium" },
      { code: "10-38", meaning: "Stopping suspicious vehicle", priority: "medium" },
      { code: "10-39", meaning: "Urgent - use light, siren", priority: "high" },
      { code: "10-40", meaning: "Silent run - no light, siren", priority: "medium" }
    ]
  };
  const codeCategories = [
    { id: "status", name: "Status Codes", icon: "fa-solid fa-circle-info" },
    { id: "calls", name: "Call Types", icon: "fa-solid fa-phone" },
    { id: "situations", name: "Situations", icon: "fa-solid fa-clipboard-list" },
    { id: "emergency", name: "Emergency Codes", icon: "fa-solid fa-triangle-exclamation" }
  ];
  const getPriorityColor = (priority2) => {
    switch (priority2) {
      case "critical":
        return "#ff4444";
      case "high":
        return "#ff6b35";
      case "medium":
        return "#ffa726";
      case "low":
        return "#66bb6a";
      default:
        return "#4a90e2";
    }
  };
  const getFirstCategoryId = (tab) => {
    var _a2, _b;
    if (tab === "sop") return ((_a2 = categories[0]) == null ? void 0 : _a2.id) || "general";
    return ((_b = codeCategories[0]) == null ? void 0 : _b.id) || "status";
  };
  reactExports.useEffect(() => {
    setSelectedCategory(getFirstCategoryId(selectedTab));
  }, [selectedTab]);
  const getCurrentSopData = () => {
    return sopData[selectedCategory] || [];
  };
  const getCurrentCodesData = () => {
    return pd10Codes[selectedCategory] || [];
  };
  const getCurrentCategoryName = () => {
    var _a2, _b;
    if (selectedTab === "sop") {
      return ((_a2 = categories.find((cat) => cat.id === selectedCategory)) == null ? void 0 : _a2.name) || "Unknown";
    }
    return ((_b = codeCategories.find((cat) => cat.id === selectedCategory)) == null ? void 0 : _b.name) || "Unknown";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `sop-container ${theme !== "dark" ? "light-theme" : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-header-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-title-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: `sop-title ${theme !== "dark" ? "light-text" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-book" }),
          "Standard Operating Procedures"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `sop-subtitle ${theme !== "dark" ? "light-text" : ""}`, children: "Department guidelines and procedures for law enforcement operations" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-tabs", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `sop-tab ${selectedTab === "sop" ? "active" : ""} ${theme !== "dark" ? "light-tab" : ""}`,
            onClick: () => setSelectedTab("sop"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-book" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "SOP" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `sop-tab ${selectedTab === "codes" ? "active" : ""} ${theme !== "dark" ? "light-tab" : ""}`,
            onClick: () => setSelectedTab("codes"),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-hashtag" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "10 Codes" })
            ]
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-content", children: selectedTab === "sop" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-sidebar", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-categories", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-categories-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-list" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Categories" })
        ] }),
        categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `sop-category ${selectedCategory === category.id ? "active" : ""} ${theme !== "dark" ? "light-category" : ""}`,
            onClick: () => setSelectedCategory(category.id),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: category.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: category.name })
            ]
          },
          category.id
        ))
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-main", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-procedures", children: getCurrentSopData().map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `sop-section ${theme !== "dark" ? "light-section" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-section-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: `sop-section-title ${theme !== "dark" ? "light-text" : ""}`, children: section.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-section-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-clipboard-check" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-procedure-list", children: section.procedures.map((procedure, procIndex) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `sop-procedure-item ${theme !== "dark" ? "light-item" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-procedure-number", children: procIndex + 1 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `sop-procedure-text ${theme !== "dark" ? "light-text" : ""}`, children: procedure })
        ] }, procIndex)) })
      ] }, index)) }) })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-sidebar", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-categories", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-categories-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-hashtag" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Code Categories" })
        ] }),
        codeCategories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `sop-category ${selectedCategory === category.id ? "active" : ""} ${theme !== "dark" ? "light-category" : ""}`,
            onClick: () => setSelectedCategory(category.id),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: category.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: category.name })
            ]
          },
          category.id
        ))
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-main", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-codes", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-codes-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: `sop-codes-title ${theme !== "dark" ? "light-text" : ""}`, children: getCurrentCategoryName() }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-codes-count", children: [
            getCurrentCodesData().length,
            " codes"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-codes-grid", children: getCurrentCodesData().map((code, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `sop-code-item ${theme !== "dark" ? "light-code-item" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "sop-code-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "sop-code-number",
                style: { backgroundColor: getPriorityColor(code.priority) },
                children: code.code
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `sop-code-priority ${theme !== "dark" ? "light-priority" : ""}`, children: (code.priority || "low").toUpperCase() })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `sop-code-meaning ${theme !== "dark" ? "light-text" : ""}`, children: code.meaning })
        ] }, index)) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sop-footer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `sop-disclaimer ${theme !== "dark" ? "light-text" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-info-circle" }),
      selectedTab === "sop" ? "These procedures are guidelines and may be modified based on specific circumstances and department policies." : "These codes are standard police radio codes. Use appropriate codes based on department protocols and situation requirements."
    ] }) })
  ] });
};
const MdtApp = ({ lang, setMdtPersonelCrimes, setMdtVehCrimes, mdtData, mdtCrimes, mdtVehCrimes, NotificationX, disData, padres, openApp, plocation, clientJobGrade, theme, tabOwnerName, allMessages, judMode }) => {
  const [password, setPassword] = reactExports.useState("");
  const [loginScreen, setLoginScreen] = reactExports.useState(false);
  const [mdtMain, setMainMdt] = reactExports.useState(false);
  const [mdtOverview, setOverviewPage] = reactExports.useState(true);
  const [citizenProfileScreen, setCitizenProfileScreen] = reactExports.useState(false);
  const [vehicleProfileScreen, setVehProfile] = reactExports.useState(false);
  const [officersScreen, setOfficersScreen] = reactExports.useState(false);
  const [isVehicleQueryPage, setIsVehicleQueryPage] = reactExports.useState(false);
  const [isCitizenQueryPage, setIsCitizenQueryPage] = reactExports.useState(false);
  const [isCrimeTableOpen, setCrimeTableOpen] = reactExports.useState(false);
  const [isModalCreateWantedRecord, setModalCreateWantedRecord] = reactExports.useState(false);
  const [addAnnounceModal$1, setAnnounceModal] = reactExports.useState(false);
  const [mdtAnnouncements, setAnnouncements] = reactExports.useState([]);
  const [isMenuOpen, setIsMenuOpen] = reactExports.useState(false);
  const [IscriminalRecordAdd, setCriminalRecordAdd] = reactExports.useState(false);
  const [weaponModal, setWeaponModal] = reactExports.useState(false);
  reactExports.useState("mdtMain");
  const [dispatches, setDispatches] = reactExports.useState([]);
  const [mapUrl, setMapUrl] = reactExports.useState("https://map.0resmon.org/");
  const [showInput, setShowInput] = reactExports.useState(false);
  const [showInputVehicle, setShowVehicleInput] = reactExports.useState(false);
  reactExports.useState("");
  const [searchInWantedList, setWantedListResult] = reactExports.useState("");
  const [searchInWantedVehList, setSearchInWantedVehList] = reactExports.useState("");
  reactExports.useState(false);
  const [isMdtChat, setMdtChat] = reactExports.useState(false);
  reactExports.useState(null);
  const [wantedList, setWantedList] = reactExports.useState([]);
  const [weaponlicenses, setWeaponLicenses] = reactExports.useState([]);
  const [wantedVehicles, setWantedVehicles] = reactExports.useState([]);
  const [selectedLicense, setSelectedLicense] = reactExports.useState(null);
  const [isLicenseModalOpen, setIsLicenseModalOpen] = reactExports.useState(false);
  const [selectedWantedVehicle, setselectedWantedVehicle] = reactExports.useState(null);
  const [selectedWantedCitizen, setSelectedWantedPeople] = reactExports.useState(null);
  const [cidProfileData, setCitizenProfileData] = reactExports.useState(null);
  const [isBoss, setBoss] = reactExports.useState(false);
  const [vehProfileData, setVehProfileData] = reactExports.useState(null);
  const [allCrimes, setAllCrimes] = reactExports.useState([]);
  const [allVehicleCrimes, setVehicleCrimes] = reactExports.useState([]);
  const [isVehicleCriminalModal, setVehicleCriminalRecordAdd] = reactExports.useState(false);
  const [vehCrimeList, setVehCrimeList] = reactExports.useState([]);
  const [cidCrimeList, setCidCrimeList] = reactExports.useState([]);
  const [isCrimeDatabase, setCrimeDatabase] = reactExports.useState(false);
  const [mdtHistory, setHistory] = reactExports.useState([]);
  const [isMdtHistory, setPageHistory] = reactExports.useState([]);
  const [isSopApp, setSopApp] = reactExports.useState(false);
  const [openedColdModal, setColdModal] = reactExports.useState(null);
  const [openedColdModal2, setColdModal2] = reactExports.useState(null);
  const [isOnDuty, setIsOnDuty] = reactExports.useState(false);
  reactExports.useEffect(() => {
    var _a2;
    const onlineOfficers = (_a2 = mdtData == null ? void 0 : mdtData.officers) == null ? void 0 : _a2.filter(
      (officer) => {
        var _a3, _b, _c;
        return officer.online && ((_a3 = officer.coords) == null ? void 0 : _a3.x) !== 0 && ((_b = officer.coords) == null ? void 0 : _b.y) !== 0 && ((_c = officer.coords) == null ? void 0 : _c.z) !== 0;
      }
    );
    let coordsParam = "";
    if ((onlineOfficers == null ? void 0 : onlineOfficers.length) > 0) {
      coordsParam = onlineOfficers.map((officer) => `${officer.coords.x},${officer.coords.y},mdt_officer,${encodeURIComponent(officer.name)}`).join("|");
    }
    if ((dispatches == null ? void 0 : dispatches.length) > 0) {
      const dispatchCoords = dispatches.filter((dispatch) => {
        var _a3, _b, _c;
        return ((_a3 = dispatch.coordsdecode) == null ? void 0 : _a3.x) !== 0 && ((_b = dispatch.coordsdecode) == null ? void 0 : _b.y) !== 0 && ((_c = dispatch.coordsdecode) == null ? void 0 : _c.z) !== 0;
      }).map((dispatch) => {
        const coords = dispatch.coordsdecode;
        const markerName = dispatch.title || "Dispatch";
        return `${coords.x},${coords.y},mdt_dispatch,${encodeURIComponent(markerName)}`;
      }).join("|");
      if (coordsParam && dispatchCoords) {
        coordsParam = coordsParam + "|" + dispatchCoords;
      } else if (dispatchCoords) {
        coordsParam = dispatchCoords;
      }
    }
    if (coordsParam) {
      setMapUrl(`https://map.0resmon.org/?coords=${coordsParam}`);
    } else {
      setMapUrl("https://map.0resmon.org/");
    }
    setVehCrimeList(mdtData.vehcrimes);
    setCidCrimeList(mdtData.cidcrimes);
    setVehicleCrimes(mdtVehCrimes);
    setAllCrimes(mdtCrimes);
    setAnnouncements(mdtData.mdtDatabase.mdtData_announcements);
    setHistory([...mdtData.mdtDatabase.mdtData_history].reverse());
  }, [mdtData, dispatches]);
  reactExports.useEffect(() => {
    useNui("setNewCriminal", (data) => {
      setMdtPersonelCrimes((prev) => [...prev, data.dataland]);
      setAllCrimes((prev) => [...prev, data.dataland]);
    });
    useNui("setNewVehicleCrime", (data) => {
      setMdtVehCrimes((prev) => [...prev, data.data]);
      setVehicleCrimes(mdtVehCrimes);
    });
    useNui("updateOfficerDuty", (data) => {
      if (data && data.cid && data.state !== void 0) ;
    });
  }, []);
  const openLicenseModal = (license) => {
    setSelectedLicense(license);
    setIsLicenseModalOpen(true);
  };
  const openWantedVehicleModal = (data) => {
    setselectedWantedVehicle(data);
    setIsLicenseModalOpen(true);
  };
  const checkClientGrade = () => {
    var newData = mdtData.bosslevels;
    for (let index = 0; index < newData.length; index++) {
      const element = newData[index];
      if (element === clientJobGrade) {
        setBoss(true);
      } else {
        setBoss(false);
      }
    }
  };
  const openWantedPeople = (data) => {
    setSelectedWantedPeople(data);
    setIsLicenseModalOpen(true);
  };
  const closeLicenseModal = () => {
    setIsLicenseModalOpen(false);
    setSelectedLicense(null);
    setselectedWantedVehicle(null);
    setSelectedWantedPeople(null);
  };
  reactExports.useEffect(() => {
    if (!(mdtData == null ? void 0 : mdtData.mdtDatabase)) return;
    setAnnouncements(mdtData.mdtDatabase.mdtData_announcements);
    setWantedList([...mdtData.mdtDatabase.mdtData_wantedPeople].reverse());
    setWantedVehicles(mdtData.mdtDatabase.mdtData_wantedVehicles);
    setWeaponLicenses(mdtData.mdtDatabase.mdtData_weaponLicenses);
  }, [mdtData]);
  reactExports.useEffect(() => {
    setDispatches(disData);
    checkClientGrade();
    useNui("newAnnouncements", (data) => {
      setAnnouncements(data.data);
    });
    useNui("newWanteds", (data) => {
      if (data.type == "citizen") {
        setWantedList(data.data);
      } else if (data.type == "wlicenses") {
        const prepareData = async () => {
          const licenses = data.data;
          const newData = await Promise.all(licenses.map(async (element) => {
            const photo = await returnPlayerPhoto(element.citizen_id);
            return { ...element, photoUrl: photo };
          }));
          setWeaponLicenses(newData.reverse());
        };
        prepareData();
      } else {
        setWantedVehicles(data.data);
      }
    });
    useNui("updateDirect", (data) => {
      if (data.type == "crimepersonal") {
        setAllCrimes(data.data.data);
      } else if (data.type == "crimevehicle") {
        setVehicleCrimes(data.data.data);
      } else if (data.type == "wantedlist") {
        setWantedList(data.data.data);
      } else if (data.type == "wantedlistveh") {
        setWantedVehicles(data.data.data);
      }
      setHistory([...data.data.history].reverse());
    });
  }, [mdtAnnouncements, weaponlicenses, wantedVehicles, wantedList, mdtHistory, disData]);
  const HideAllMdtPages = () => {
    setLoginScreen(false);
    setOverviewPage(false);
    setCitizenProfileScreen(false);
    setVehProfile(false);
    setCrimeDatabase(false);
    setPageHistory(false);
    setOfficersScreen(false);
    setIsVehicleQueryPage(false);
    setIsCitizenQueryPage(false);
    setMdtChat(false);
    setCrimeTableOpen(false);
    setSopApp(false);
  };
  const handleWantedListVehicleSearch = (e) => {
    setSearchInWantedVehList(e.target.value.toLowerCase());
  };
  const filteredWantedVehicles = wantedVehicles.filter(
    (vehicle) => vehicle.plate.toLowerCase().includes(searchInWantedVehList) || vehicle.modellabel.toLowerCase().includes(searchInWantedVehList)
  );
  const ChangePageInMdt = (page) => {
    switch (page) {
      case "mdtOverview":
        HideAllMdtPages();
        setOverviewPage(true);
        break;
      case "citizenProfileScreen":
        HideAllMdtPages();
        setCitizenProfileScreen(true);
        break;
      case "officersScreen":
        HideAllMdtPages();
        setOfficersScreen(true);
        break;
      case "mdtchat":
        HideAllMdtPages();
        setMdtChat(true);
        break;
      case "isVehicleQueryPage":
        HideAllMdtPages();
        setIsVehicleQueryPage(true);
        break;
      case "isCitizenQueryPage":
        HideAllMdtPages();
        setIsCitizenQueryPage(true);
        break;
      case "isCrimeTableOpen":
        HideAllMdtPages();
        setCrimeTableOpen(true);
        break;
      case "setPageHistory":
        HideAllMdtPages();
        setPageHistory(true);
        break;
      case "isCrimeDatabase":
        HideAllMdtPages();
        setCrimeDatabase(true);
        break;
      case "isSopApp":
        HideAllMdtPages();
        setSopApp(true);
        break;
    }
  };
  const ToggleCriminalRecordScreen = (type) => {
    if (type == "citizen") {
      setCriminalRecordAdd(!IscriminalRecordAdd);
    } else {
      setVehicleCriminalRecordAdd(true);
    }
  };
  const toggleDuty = () => {
    const newState = !isOnDuty;
    callNui("toggleDuty", { state: newState }, (resp) => {
      if (resp && typeof resp.state === "boolean") {
        setIsOnDuty(resp.state);
        if (NotificationX) {
          NotificationX({
            title: lang.success,
            message: resp.state ? lang.onduty : lang.offduty,
            options: { app: "mdt" }
          });
        }
      }
    });
  };
  reactExports.useEffect(() => {
    callNui("getDutyState", {}, (resp) => {
      if (resp && typeof resp.state === "boolean") setIsOnDuty(resp.state);
    });
  }, []);
  const handleSearchClick = () => {
    setShowInput(!showInput);
  };
  const OpenAnnounceModal = () => {
    setIsMenuOpen(false);
    setAnnounceModal(true);
  };
  const CreateWantedModal = () => {
    setIsMenuOpen(false);
    setModalCreateWantedRecord(true);
  };
  const handleWantedListSearch = (e) => {
    const value = e.target.value.toLowerCase();
    setWantedListResult(value);
    const filtered = wantedList.filter((item) => {
      const fullName = `${item.first_name} ${item.last_name}`.toLowerCase();
      return fullName.includes(value);
    });
    const loadFilteredPhotos = async () => {
      const updatedList = await Promise.all(
        filtered.reverse().map(async (item) => {
          const url = await returnPlayerPhoto(item.cid);
          return { ...item, photoUrl: url };
        })
      );
      setDisplayList(updatedList);
    };
    loadFilteredPhotos();
  };
  const handleSearchClickVehicle = (e) => {
    setShowVehicleInput(!showInputVehicle);
  };
  reactExports.useState(false);
  reactExports.useState({
    applicantName: "",
    weaponType: "Select",
    licenseReason: "",
    officerName: ""
  });
  const setVahcanP = (data) => {
    setVehProfileData(data);
    setIsVehicleQueryPage(false);
  };
  const [displayList, setDisplayList] = reactExports.useState([]);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    if (!(mdtData == null ? void 0 : mdtData.mdtDatabase)) return;
    const prepareData = async () => {
      const licenses = mdtData.mdtDatabase.mdtData_weaponLicenses;
      const newData = await Promise.all(licenses.map(async (element) => {
        const photo = await returnPlayerPhoto(element.citizen_id);
        return { ...element, photoUrl: photo };
      }));
      setWeaponLicenses(newData.reverse());
    };
    prepareData();
  }, [mdtData]);
  const toggleBaba = () => {
    setCitizenProfileScreen(false);
    setIsCitizenQueryPage(true);
  };
  const toggleVehicleBaba = () => {
    setVehProfile(false);
    setIsVehicleQueryPage(true);
  };
  reactExports.useEffect(() => {
    const loadPhotos = async () => {
      const updatedList = await Promise.all(
        [...wantedList].reverse().map(async (item) => {
          const url = await returnPlayerPhoto(item.cid);
          return { ...item, photoUrl: url };
        })
      );
      setDisplayList(updatedList);
    };
    loadPhotos();
  }, [wantedList]);
  const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-app-frame ${theme !== "dark" ? "mdt-app-frame-white" : ""}`, children: [
    loginScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mdt-app-frame-alt", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-app-login-screen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mdt-app-logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mdt-login-screen-text", children: "You are connecting to Los Santos Police Department database" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mdt-login-screen-desc", children: "Please enter password to identify you" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "password-entered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "password", onChange: (e) => setPassword(e.target.value), value: password, placeholder: "Enter password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "login-mdt-panel", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "material-symbols-outlined", children: "arrow_forward" }) })
      ] })
    ] }) }) }),
    !mdtMain && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-app-panelscreen", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-app-panelscreen-main ${theme !== "dark" ? "leftmain" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-left-panel ${theme !== "dark" ? "leftmain" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-left-mainpart ${theme !== "dark" ? "leftmain" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: MyLogo, alt: "Los Santos Logo" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-left-logo-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `mdt-left-logo-header ${theme !== "dark" ? "mdt-left-dark" : ""}`, children: "Los Santos" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mdt-left-logo-subheader", children: "Police Department Database" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notifications-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announce-box", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: ".7rem" }, className: "announcebox-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-icon ${theme !== "dark" ? "actionwhite" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "14", viewBox: "0 0 16 14", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.6 4V8.8C14.96 8.8 16 7.76 16 6.4C16 5.04 14.96 4 13.6 4ZM7.2 3.2H1.6C0.72 3.2 0 3.92 0 4.8V8C0 8.88 0.72 9.6 1.6 9.6H2.4V12C2.4 12.88 3.12 13.6 4 13.6H5.6V9.6H7.2L10.4 12.8H12V0H10.4L7.2 3.2Z", fill: "#64666F" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-label ${theme !== "dark" ? "anbox-hd-lbl" : ""}`, children: lang.announcements })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-notifications", children: mdtAnnouncements.map(
                (item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `announcebox-notify-item ${theme !== "dark" ? "announcebox-notify-item-white" : ""}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-notify-header", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-badge", children: item.title }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-user", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 0L9.856 5.49H15.8L10.972 8.884L12.828 14.373L8 10.98L3.172 14.373L5.028 8.884L0.2 5.49H6.144L8 0Z" }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `announcebox-username ${theme !== "dark" ? "anbox-user-white" : ""}`, children: item.created_by })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-notify-content ${theme !== "dark" ? "text-white" : ""}`, children: item.message }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-notify-date", children: item.created_at })
                ] })
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announce-box", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-header", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-icon ${theme !== "dark" ? "actionwhite" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "14", viewBox: "0 0 16 14", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.6 4V8.8C14.96 8.8 16 7.76 16 6.4C16 5.04 14.96 4 13.6 4ZM7.2 3.2H1.6C0.72 3.2 0 3.92 0 4.8V8C0 8.88 0.72 9.6 1.6 9.6H2.4V12C2.4 12.88 3.12 13.6 4 13.6H5.6V9.6H7.2L10.4 12.8H12V0H10.4L7.2 3.2Z", fill: "#64666F" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-label ${theme !== "dark" ? "anbox-hd-lbl" : ""}`, children: lang.activityHistory })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-notifications", children: disData.map(
                (element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `announcebox-notify-item ${theme !== "dark" ? "thedark" : ""}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-timestamp", children: element.timestring }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcebox-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `announcebox-header-bold ${theme !== "dark" ? "announcebox-dark" : ""}`, children: element.title }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-details", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-detail", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `detail-label ${theme !== "dark" ? "detail-label-white" : ""}`, children: [
                        lang.gender,
                        ":"
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `detail-value ${theme !== "dark" ? "detail-white" : ""}`, children: element.gender })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcebox-detail", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `detail-label ${theme !== "dark" ? "detail-label-white" : ""}`, children: lang.location }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `detail-value ${theme !== "dark" ? "detail-white" : ""}`, children: element.address })
                    ] })
                  ] })
                ] })
              ) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-homepage-box-header ${theme !== "dark" ? "leftmain" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("mdtOverview"), className: `mdt-homepage-box-header-item ${mdtOverview ? "selected" : ""}`, children: lang.overview }),
            isBoss && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("officersScreen"), className: `mdt-homepage-box-header-item ${officersScreen ? "selected" : ""}`, children: lang.officers }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("isCitizenQueryPage"), className: `mdt-homepage-box-header-item ${isCitizenQueryPage ? "selected" : ""}`, children: lang.citizens }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("isVehicleQueryPage"), className: `mdt-homepage-box-header-item`, children: lang.vehicles }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("isCrimeDatabase"), className: `mdt-homepage-box-header-item`, children: lang.cdatabase }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("isSopApp"), className: `mdt-homepage-box-header-item ${isSopApp ? "selected" : ""}`, children: lang.sop }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("mdtchat"), className: `mdt-homepage-box-header-item`, children: lang.chat }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("isCrimeTableOpen"), className: `mdt-homepage-box-header-item`, children: lang.crimelist }),
            isBoss && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => ChangePageInMdt("setPageHistory"), className: `mdt-homepage-box-header-item ${isMdtHistory ? "selected" : ""}`, children: lang.history }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                onClick: () => setIsMenuOpen(!isMenuOpen),
                className: "mdt-homepage-box-header-item",
                children: [
                  lang.creat,
                  " ",
                  !isMenuOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-down" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `duty-toggle ${isOnDuty ? "on" : "off"}`, onClick: toggleDuty, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dot" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isOnDuty ? lang.onduty : lang.offduty })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `dropdown-menuv ${theme !== "dark" ? "dropx-white" : ""} ${isMenuOpen ? "open" : "closed"}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => CreateWantedModal(), children: lang.cwanted }),
              isBoss && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => OpenAnnounceModal(), children: lang.cannounce })
            ] })
          ] }),
          mdtOverview && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `mdt-overview-part ${mdtOverview ? "show" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "iframe",
              {
                src: mapUrl,
                loading: "lazy",
                style: {
                  border: "0px",
                  borderRadius: "4px",
                  width: "100%",
                  height: "22rem",
                  marginTop: ".4rem",
                  willChange: "transform"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-icon ${theme !== "dark" ? "actionwhite" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7 0C6.10169 0 5.24016 0.335648 4.60496 0.933106C3.96976 1.53056 3.6129 2.34089 3.6129 3.18582C3.6129 4.03076 3.96976 4.84108 4.60496 5.43854C5.24016 6.036 6.10169 6.37165 7 6.37165C7.89831 6.37165 8.75984 6.036 9.39504 5.43854C10.0302 4.84108 10.3871 4.03076 10.3871 3.18582C10.3871 2.34089 10.0302 1.53056 9.39504 0.933106C8.75984 0.335648 7.89831 0 7 0ZM3.3871 8.07076C2.48878 8.07076 1.62726 8.4064 0.992058 9.00386C0.356854 9.60132 0 10.4116 0 11.2566V12.2658C0 12.9064 0.493161 13.4518 1.16516 13.5546C5.02916 14.1485 8.97084 14.1485 12.8348 13.5546C13.1601 13.5048 13.4559 13.3478 13.6693 13.1117C13.8828 12.8756 14 12.5758 14 12.2658V11.2566C14 10.4116 13.6431 9.60132 13.0079 9.00386C12.3727 8.4064 11.5112 8.07076 10.6129 8.07076H10.3058C10.1387 8.07076 9.97252 8.09624 9.81445 8.14382L9.03226 8.38424C7.7117 8.78967 6.2883 8.78967 4.96774 8.38424L4.18555 8.14382C4.02717 8.09534 3.86165 8.07068 3.6951 8.07076H3.3871Z", fill: "#64666E" }) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-label ${theme !== "dark" ? "anbox-hd-lbl" : ""}`, children: lang.wlist }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSearchClick(), className: "announcebox-header-righticon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.20365 2.69638e-08C6.05284 0.000124636 4.91881 0.27593 3.89648 0.804329C2.87415 1.33273 1.99328 2.09834 1.32761 3.03708C0.661933 3.97582 0.230825 5.06037 0.0703713 6.19994C-0.090082 7.3395 0.0247894 8.50093 0.405369 9.58698C0.785949 10.673 1.42116 11.6521 2.25783 12.4423C3.09451 13.2324 4.10829 13.8106 5.21432 14.1285C6.32035 14.4464 7.48644 14.4947 8.61497 14.2694C9.74351 14.0441 10.8016 13.5517 11.7008 12.8335L14.6426 15.7753C14.7936 15.9211 14.9958 16.0018 15.2057 16C15.4156 15.9981 15.6163 15.914 15.7648 15.7655C15.9132 15.6171 15.9974 15.4163 15.9992 15.2065C16.001 14.9966 15.9203 14.7944 15.7745 14.6434L12.8327 11.7016C13.6796 10.6416 14.21 9.36406 14.3628 8.01594C14.5157 6.66782 14.2847 5.30395 13.6966 4.0813C13.1084 2.85866 12.187 1.82695 11.0383 1.10491C9.88962 0.382882 8.5604 -0.000117334 7.20365 2.69638e-08ZM2.4007 7.20443C2.4007 6.57369 2.52493 5.94914 2.7663 5.36642C3.00767 4.7837 3.36145 4.25422 3.80745 3.80823C4.25344 3.36223 4.78292 3.00845 5.36564 2.76708C5.94836 2.52571 6.57292 2.40148 7.20365 2.40148C7.83438 2.40148 8.45894 2.52571 9.04166 2.76708C9.62438 3.00845 10.1539 3.36223 10.5998 3.80823C11.0458 4.25422 11.3996 4.7837 11.641 5.36642C11.8824 5.94914 12.0066 6.57369 12.0066 7.20443C12.0066 8.47825 11.5006 9.6999 10.5998 10.6006C9.69912 11.5014 8.47747 12.0074 7.20365 12.0074C5.92983 12.0074 4.70818 11.5014 3.80745 10.6006C2.90672 9.6999 2.4007 8.47825 2.4007 7.20443Z", fill: "#64666E" }) }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists", children: [
                  showInput && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "36px" }, className: "slide-down box-lists-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      placeholder: "Search in List",
                      value: searchInWantedList,
                      onChange: (e) => handleWantedListSearch(e)
                    }
                  ) }),
                  [...displayList].reverse().map(
                    (element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `box-lists-item ${theme !== "dark" ? "thedark" : ""}`, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-content", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.photoUrl, alt: "Profile Picture", className: "box-lists-item-image" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-details", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `box-lists-item-title ${theme !== "dark" ? "dark-title" : ""}`, children: [
                            element.first_name,
                            " ",
                            element.last_name
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-subtitle", children: [
                            element.wanted_since,
                            " ",
                            " ",
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: element.status === 0 ? "status-pending" : "status-wanted", children: element.status === 0 ? lang.aapproval : lang.wntd })
                          ] })
                        ] })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => openWantedPeople(element), className: "box-lists-item-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 0C10.1217 0 12.1566 0.842855 13.6569 2.34315C15.1571 3.84344 16 5.87827 16 8C16 10.1217 15.1571 12.1566 13.6569 13.6569C12.1566 15.1571 10.1217 16 8 16C5.87827 16 3.84344 15.1571 2.34315 13.6569C0.842854 12.1566 0 10.1217 0 8C0 5.87827 0.842854 3.84344 2.34315 2.34315C3.84344 0.842855 5.87827 0 8 0ZM9.19991 4.91165C9.79416 4.91165 10.2764 4.49911 10.2764 3.88772C10.2764 3.27634 9.79301 2.8638 9.19991 2.8638C8.60567 2.8638 8.12571 3.27634 8.12571 3.88772C8.12571 4.49911 8.60567 4.91165 9.19991 4.91165ZM9.40904 11.342C9.40904 11.2198 9.45132 10.9021 9.42733 10.7215L8.48797 11.8026C8.29369 12.0071 8.05028 12.1488 7.936 12.1111C7.88416 12.0921 7.84082 12.0551 7.8138 12.0069C7.78677 11.9587 7.77783 11.9025 7.78859 11.8483L9.35419 6.90236C9.48218 6.27498 9.13021 5.70245 8.38397 5.62931C7.5966 5.62931 6.43783 6.42811 5.73273 7.44175C5.73273 7.56289 5.70988 7.86458 5.73388 8.04514L6.67209 6.96293C6.86637 6.76066 7.09264 6.61781 7.20691 6.65667C7.26322 6.67688 7.30935 6.71835 7.33542 6.77219C7.36148 6.82603 7.3654 6.88795 7.34633 6.94465L5.79444 11.8666C5.61503 12.4425 5.95443 13.0071 6.77723 13.1351C7.98857 13.1351 8.70395 12.3557 9.41018 11.342H9.40904Z", fill: "#343434" }) }) })
                    ] }, index)
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-icon ${theme !== "dark" ? "actionwhite" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "imx fa-solid fa-car" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-label ${theme !== "dark" ? "anbox-hd-lbl" : ""}`, children: lang.wvehicles }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSearchClickVehicle(), className: "announcebox-header-righticon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.20365 2.69638e-08C6.05284 0.000124636 4.91881 0.27593 3.89648 0.804329C2.87415 1.33273 1.99328 2.09834 1.32761 3.03708C0.661933 3.97582 0.230825 5.06037 0.0703713 6.19994C-0.090082 7.3395 0.0247894 8.50093 0.405369 9.58698C0.785949 10.673 1.42116 11.6521 2.25783 12.4423C3.09451 13.2324 4.10829 13.8106 5.21432 14.1285C6.32035 14.4464 7.48644 14.4947 8.61497 14.2694C9.74351 14.0441 10.8016 13.5517 11.7008 12.8335L14.6426 15.7753C14.7936 15.9211 14.9958 16.0018 15.2057 16C15.4156 15.9981 15.6163 15.914 15.7648 15.7655C15.9132 15.6171 15.9974 15.4163 15.9992 15.2065C16.001 14.9966 15.9203 14.7944 15.7745 14.6434L12.8327 11.7016C13.6796 10.6416 14.21 9.36406 14.3628 8.01594C14.5157 6.66782 14.2847 5.30395 13.6966 4.0813C13.1084 2.85866 12.187 1.82695 11.0383 1.10491C9.88962 0.382882 8.5604 -0.000117334 7.20365 2.69638e-08ZM2.4007 7.20443C2.4007 6.57369 2.52493 5.94914 2.7663 5.36642C3.00767 4.7837 3.36145 4.25422 3.80745 3.80823C4.25344 3.36223 4.78292 3.00845 5.36564 2.76708C5.94836 2.52571 6.57292 2.40148 7.20365 2.40148C7.83438 2.40148 8.45894 2.52571 9.04166 2.76708C9.62438 3.00845 10.1539 3.36223 10.5998 3.80823C11.0458 4.25422 11.3996 4.7837 11.641 5.36642C11.8824 5.94914 12.0066 6.57369 12.0066 7.20443C12.0066 8.47825 11.5006 9.6999 10.5998 10.6006C9.69912 11.5014 8.47747 12.0074 7.20365 12.0074C5.92983 12.0074 4.70818 11.5014 3.80745 10.6006C2.90672 9.6999 2.4007 8.47825 2.4007 7.20443Z", fill: "#64666E" }) }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists", children: [
                  showInputVehicle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: "36px" }, className: "slide-down box-lists-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      placeholder: "Search in List",
                      value: searchInWantedVehList,
                      onChange: (e) => handleWantedListVehicleSearch(e)
                    }
                  ) }),
                  filteredWantedVehicles.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `box-lists-item ${theme !== "dark" ? "thedark" : ""}`, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-content", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `https://docs.fivem.net/vehicles/${element.model}.webp`, alt: "Profile Picture", className: "box-lists-item-image" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-details", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `box-lists-item-title ${theme !== "dark" ? "dark-title" : ""}`, children: element.modellabel }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-subtitle", children: [
                          element.plate,
                          " ",
                          " ",
                          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: element.status === 0 ? "status-pending" : "status-wanted", children: element.status === 0 ? lang.aapproval : lang.wntd })
                        ] })
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => openWantedVehicleModal(element), className: "box-lists-item-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 0C10.1217 0 12.1566 0.842855 13.6569 2.34315C15.1571 3.84344 16 5.87827 16 8C16 10.1217 15.1571 12.1566 13.6569 13.6569C12.1566 15.1571 10.1217 16 8 16C5.87827 16 3.84344 15.1571 2.34315 13.6569C0.842854 12.1566 0 10.1217 0 8C0 5.87827 0.842854 3.84344 2.34315 2.34315C3.84344 0.842855 5.87827 0 8 0ZM9.19991 4.91165C9.79416 4.91165 10.2764 4.49911 10.2764 3.88772C10.2764 3.27634 9.79301 2.8638 9.19991 2.8638C8.60567 2.8638 8.12571 3.27634 8.12571 3.88772C8.12571 4.49911 8.60567 4.91165 9.19991 4.91165ZM9.40904 11.342C9.40904 11.2198 9.45132 10.9021 9.42733 10.7215L8.48797 11.8026C8.29369 12.0071 8.05028 12.1488 7.936 12.1111C7.88416 12.0921 7.84082 12.0551 7.8138 12.0069C7.78677 11.9587 7.77783 11.9025 7.78859 11.8483L9.35419 6.90236C9.48218 6.27498 9.13021 5.70245 8.38397 5.62931C7.5966 5.62931 6.43783 6.42811 5.73273 7.44175C5.73273 7.56289 5.70988 7.86458 5.73388 8.04514L6.67209 6.96293C6.86637 6.76066 7.09264 6.61781 7.20691 6.65667C7.26322 6.67688 7.30935 6.71835 7.33542 6.77219C7.36148 6.82603 7.3654 6.88795 7.34633 6.94465L5.79444 11.8666C5.61503 12.4425 5.95443 13.0071 6.77723 13.1351C7.98857 13.1351 8.70395 12.3557 9.41018 11.342H9.40904Z", fill: "#343434" }) }) })
                  ] }, index))
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mdt-homepage-box-subbox-item-header", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-icon ${theme !== "dark" ? "actionwhite" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "imx fa-solid fa-gun" }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `announcebox-header-label ${theme !== "dark" ? "anbox-hd-lbl" : ""}`, children: lang.wlicenses }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setWeaponModal(true), className: "announcebox-header-righticon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: {}, className: "imx fa-regular fa-plus" }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box-lists", children: weaponlicenses.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `box-lists-item ${theme !== "dark" ? "thedark" : ""}`, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-content", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.photoUrl, alt: "Profile Picture", className: "box-lists-item-image" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-details", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `box-lists-item-title ${theme !== "dark" ? "dark-title" : ""}`, children: element.playername }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box-lists-item-subtitle", children: [
                        lang.type,
                        ": ",
                        capitalize(element.weapon_type)
                      ] })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => openLicenseModal(element), className: "box-lists-item-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8 0C10.1217 0 12.1566 0.842855 13.6569 2.34315C15.1571 3.84344 16 5.87827 16 8C16 10.1217 15.1571 12.1566 13.6569 13.6569C12.1566 15.1571 10.1217 16 8 16C5.87827 16 3.84344 15.1571 2.34315 13.6569C0.842854 12.1566 0 10.1217 0 8C0 5.87827 0.842854 3.84344 2.34315 2.34315C3.84344 0.842855 5.87827 0 8 0ZM9.19991 4.91165C9.79416 4.91165 10.2764 4.49911 10.2764 3.88772C10.2764 3.27634 9.79301 2.8638 9.19991 2.8638C8.60567 2.8638 8.12571 3.27634 8.12571 3.88772C8.12571 4.49911 8.60567 4.91165 9.19991 4.91165ZM9.40904 11.342C9.40904 11.2198 9.45132 10.9021 9.42733 10.7215L8.48797 11.8026C8.29369 12.0071 8.05028 12.1488 7.936 12.1111C7.88416 12.0921 7.84082 12.0551 7.8138 12.0069C7.78677 11.9587 7.77783 11.9025 7.78859 11.8483L9.35419 6.90236C9.48218 6.27498 9.13021 5.70245 8.38397 5.62931C7.5966 5.62931 6.43783 6.42811 5.73273 7.44175C5.73273 7.56289 5.70988 7.86458 5.73388 8.04514L6.67209 6.96293C6.86637 6.76066 7.09264 6.61781 7.20691 6.65667C7.26322 6.67688 7.30935 6.71835 7.33542 6.77219C7.36148 6.82603 7.3654 6.88795 7.34633 6.94465L5.79444 11.8666C5.61503 12.4425 5.95443 13.0071 6.77723 13.1351C7.98857 13.1351 8.70395 12.3557 9.41018 11.342H9.40904Z", fill: "#343434" }) }) })
                ] })) })
              ] })
            ] })
          ] }),
          isCrimeTableOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(CrimeTable, { theme, lang, crimeList: mdtData.cidcrimes, vehCrimes: mdtData.vehcrimes }),
          officersScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(OfficersPage, { theme, officers: mdtData.officers, lang, grades: mdtData.allgrades }),
          citizenProfileScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(CitizenProfileScreen, { theme, crimes: allCrimes, lang, onClose: () => toggleBaba(), data: cidProfileData, onOpen: () => ToggleCriminalRecordScreen("citizen") }),
          vehicleProfileScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(VehicleProfileScreen, { theme, onClose: toggleVehicleBaba, crimes: allVehicleCrimes, lang, data: vehProfileData, onOpen: () => ToggleCriminalRecordScreen("vehicle") }),
          isVehicleQueryPage && /* @__PURE__ */ jsxRuntimeExports.jsx(VehicleQueryPage, { theme, onClose: () => setIsVehicleQueryPage(false), vehicles: mdtData.vehicles, lang, setVehicleProfileData: setVahcanP, isVehicleProfileScreen: setVehProfile, isOpened: isVehicleQueryPage }),
          isCitizenQueryPage && /* @__PURE__ */ jsxRuntimeExports.jsx(CitizenQueryPage, { theme, onClose: () => setIsCitizenQueryPage(false), isCitizenProfile: citizenProfileScreen, setCitizenProfile: setCitizenProfileScreen, setProfileData: setCitizenProfileData, isOpened: isCitizenQueryPage, players: mdtData.players, lang }),
          isCrimeDatabase && /* @__PURE__ */ jsxRuntimeExports.jsx(CrimeList, { theme, wantedVehicles, wantedList, cidCrimes: allCrimes, vehCrimes: allVehicleCrimes, lang }),
          isSopApp && /* @__PURE__ */ jsxRuntimeExports.jsx(SopApp, { theme, lang }),
          isMdtHistory && /* @__PURE__ */ jsxRuntimeExports.jsx(MdtHistory, { theme, history: mdtHistory, lang }),
          isMdtChat && /* @__PURE__ */ jsxRuntimeExports.jsx(MDTChat, { lang, playerName: tabOwnerName, allMessages })
        ] })
      ] }),
      isLicenseModalOpen && selectedLicense && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "license-modal-overlay", onClick: closeLicenseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "license-modal-content", onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: selectedLicense.photoUrl || Avatar$2,
            alt: "Profile",
            className: "license-modal-photo"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { marginBottom: ".5rem" }, children: selectedLicense.playername }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ayir" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "parts", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wtype }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: capitalize(selectedLicense.weapon_type) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.lnumber }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedLicense.license_number || "N/A" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.addedby }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedLicense.issued_by || "Unknown Officer" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.dateofissue }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedLicense.issued_at || "N/A" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.expirationdate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedLicense.expiration_date || "N/A" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.status }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedLicense.status || "Unknown" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: closeLicenseModal, className: "close-btn", children: lang.close })
      ] }) }),
      isLicenseModalOpen && selectedWantedVehicle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "license-modal-overlay", onClick: closeLicenseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "license-modal-content", onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: closeLicenseModal, className: "close-btn-5", style: { float: "right", cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-xmark" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: selectedWantedVehicle.photoUrl || Avatar$2,
            alt: "Profile",
            className: "license-modal-photo"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: selectedWantedVehicle.modellabel }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Created by ",
          selectedWantedVehicle.added_by
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ayir" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "parts", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.plate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.plate })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.color }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.color })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.llocation }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.last_seen_location })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wsince }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.wanted_since })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wlevel }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.danger_level })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.reason }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedVehicle.reason })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fotolar", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.media }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "photos", children: selectedWantedVehicle.medias.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url }, element.id)) })
        ] })
      ] }) }),
      isLicenseModalOpen && selectedWantedCitizen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "license-modal-overlay", onClick: closeLicenseModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "license-modal-content", onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: closeLicenseModal, className: "close-btn-5", style: { float: "right", cursor: "pointer" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-xmark" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: selectedWantedCitizen.photoUrl || Avatar$2,
            alt: "Profile",
            className: "license-modal-photo"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
          selectedWantedCitizen.first_name,
          " ",
          selectedWantedCitizen.last_name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: selectedWantedCitizen.cid }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ayir" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "parts", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wsince }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedCitizen.wanted_since })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.identitynum }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedCitizen.cid })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.llocation }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedCitizen.last_seen_location })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.wlevel }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedCitizen.danger_level })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "partone", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.addedby }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "weapon-type", children: selectedWantedCitizen.added_by })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fotolar", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.media }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "photos", children: selectedWantedCitizen.medias.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: element.url }, element.id)) })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(AnimatePresence, { children: [
        isVehicleCriminalModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, scale: 0.95, zIndex: 9999 },
            animate: { opacity: 1, scale: 1, zIndex: 9999 },
            exit: { opacity: 0, scale: 0.95, zIndex: 9999 },
            transition: { duration: 0.2 },
            style: {
              position: "fixed",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              zIndex: 9999,
              // garantiye alalm
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              pointerEvents: "auto"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CreateVehicleCrime,
              {
                isOpen: isVehicleCriminalModal,
                onClose: () => setVehicleCriminalRecordAdd(false),
                lang,
                NotificationX,
                vehCrimes: mdtData.vehcrimes,
                dataLand: vehProfileData,
                location: padres,
                theme,
                players: mdtData.players,
                openApp,
                vehicles: mdtData.vehicles
              }
            )
          }
        ),
        IscriminalRecordAdd && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0, scale: 0.95, zIndex: 9999 },
            animate: { opacity: 1, scale: 1, zIndex: 9999 },
            exit: { opacity: 0, scale: 0.95, zIndex: 9999 },
            transition: { duration: 0.2 },
            style: {
              position: "fixed",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              zIndex: 9999,
              // garantiye alalm
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              pointerEvents: "auto"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              NewAddCriminalRecordModal,
              {
                isOpen: IscriminalRecordAdd,
                onClose: () => setCriminalRecordAdd(false),
                lang,
                NotificationX,
                setColdModal2,
                judMode,
                dataLand: cidProfileData,
                cidCrimes: mdtData.cidcrimes,
                location: padres,
                openApp,
                theme,
                players: mdtData.players
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColdModal,
        {
          appName: "MDT",
          title: lang.success,
          message: lang.dojwax,
          isOpen: openedColdModal,
          onClose: () => setColdModal(null),
          buttons: [
            { label: lang.ok, onClick: () => setColdModal(null) }
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColdModal,
        {
          appName: "MDT",
          title: lang.success,
          message: lang.awaintcrime,
          isOpen: openedColdModal2,
          onClose: () => setColdModal2(null),
          buttons: [
            { label: lang.ok, onClick: () => setColdModal2(null) }
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isModalCreateWantedRecord && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0, scale: 0.95 },
          animate: { opacity: 1, scale: 1 },
          exit: { opacity: 0, scale: 0.95 },
          transition: { duration: 0.25 },
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 9999,
            // garantiye alalm
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            pointerEvents: "auto"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            NewCreateWanted,
            {
              isOpen: isModalCreateWantedRecord,
              onClose: () => setModalCreateWantedRecord(false),
              NotificationX,
              padres,
              judMode,
              setColdModal,
              openedColdModal,
              lang,
              openApp,
              theme,
              players: mdtData.players,
              vehicles: mdtData.vehicles
            }
          )
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: addAnnounceModal$1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0, scale: 0.95 },
          animate: { opacity: 1, scale: 1 },
          exit: { opacity: 0, scale: 0.95 },
          transition: { duration: 0.25 },
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 9999,
            // garantiye alalm
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            pointerEvents: "auto"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            addAnnounceModal,
            {
              isOpen: addAnnounceModal$1,
              onClose: () => setAnnounceModal(false),
              NotificationX,
              theme,
              lang
            }
          )
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: weaponModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
        motion.div,
        {
          initial: { opacity: 0, scale: 0.95 },
          animate: { opacity: 1, scale: 1 },
          exit: { opacity: 0, scale: 0.95 },
          transition: { duration: 0.25 },
          style: {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            zIndex: 9999,
            // garantiye alalm
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            pointerEvents: "auto"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            WeaponLicenseModal,
            {
              onClose: () => setWeaponModal(false),
              players: mdtData.players,
              weapons: mdtData.weapons,
              lang,
              theme,
              NotificationX
            }
          )
        }
      ) })
    ] }) })
  ] }) });
};
const CreatingHersey = ({ isVisible }) => {
  const [visibleClass, setVisibleClass] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (isVisible) {
      setTimeout(() => setVisibleClass("show"), 10);
    } else {
      setVisibleClass("");
    }
  }, [isVisible]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `creating-frame ${visibleClass}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "loading-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-text", children: "We are setting things up for you..." }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-bar-progress" }) })
  ] }) });
};
const TabletNameModal = ({ isModalOpen, closeModal, lang, setTabName, Notification: Notification2 }) => {
  const [tabletName, setTabletName] = reactExports.useState("My Tablet");
  const [newName, setNewName] = reactExports.useState("");
  const handleNameChange = () => {
    if (!newName.trim()) {
      Notification2(lang.invalid, lang.enterTabletName);
    } else {
      setTabletName(newName || tabletName);
      setTabName(newName);
      closeModal();
      callNui("UpdateTabletData", {
        datatype: "deviceName",
        result: newName
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: isModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-backdrop", onClick: closeModal, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: lang.changeTabletName }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "text",
        placeholder: lang.entername,
        value: newName,
        onChange: (e) => setNewName(e.target.value)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: handleNameChange, children: lang.save }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: closeModal, children: lang.cancel })
    ] })
  ] }) }) });
};
const AboutDevice = ({ themeMode, lang, allLang, tabData, Notification: Notification2 }) => {
  const [isModalOpen, closeModal] = reactExports.useState(false);
  const [isLoading, setIsLoading] = reactExports.useState(false);
  reactExports.useState(false);
  const [langScreen, setLangScreen] = reactExports.useState(false);
  const [selectedLang, setLangSelect] = reactExports.useState(null);
  const [IsAboutDevice, setAboutDevice] = reactExports.useState(true);
  const [tabletName, setTabName] = reactExports.useState("Tablet");
  reactExports.useEffect(() => {
    setTabName(tabData.data.deviceName);
  }, []);
  const selectNewLang = (lang2) => {
    setLangSelect(lang2);
    setLangScreen(false);
    setAboutDevice(true);
    callNui("UpdateTabletData", {
      datatype: "lang",
      result: lang2
    });
  };
  const deviceInfos = [
    { "infoName": "Name", "data": tabletName },
    { "infoName": "resOSVersion", "data": "1.2.0" },
    { "infoName": "Model", "data": "Kibra SmartPad 1" },
    { "infoName": "Model Number", "data": 19484957812 },
    { "infoName": "Serial Number", "data": tabData.serialnumber },
    { "infoName": "Photos", "data": tabData.gallery.length },
    { "infoName": "Videos", "data": 4 }
  ];
  const openLangScreen = () => {
    setAboutDevice(false);
    setLangScreen(true);
  };
  const handleCheck = () => {
    setIsLoading(true);
    setTimeout(() => {
      setIsLoading(false);
    }, 5e3);
  };
  const toggleModal = () => {
    if (isModalOpen) {
      closeModal(false);
    } else {
      closeModal(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "87%" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "aboutdevice-frame", children: [
      IsAboutDevice ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "aboutdevice-frame-label", children: lang.aboutDevice }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "aboutdevice-frame-label", children: lang.selectLanguage }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `aboutdevice-form ${themeMode == "light" ? "lightmode" : ""}`, children: [
        IsAboutDevice && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          deviceInfos.map((row) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `aboutdevice-form-item ${themeMode == "light" ? "lightmode" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-left", children: row.infoName }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { cursor: "pointer", float: "right" }, children: row.infoName == "Name" ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => toggleModal(), className: "aboutdevice-form-item-right", children: row.data }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-right", children: row.data }) })
          ] })),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `aboutdevice-form-item ${themeMode == "light" ? "lightmode" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-left", children: lang.country }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-right", children: "United States" }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: openLangScreen, className: `aboutdevice-form-item accessible ${themeMode == "light" ? "lightmode" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-left", children: lang.language }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "gray" }, class: "fa-solid fa-chevron-right" }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `aboutdevice-form-item ${themeMode == "light" ? "lightmode" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-left", children: lang.softwareUpdate }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "software-update-check checkbut",
                onClick: handleCheck,
                children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loader" }) : "Check"
              }
            ) }) })
          ] })
        ] }),
        langScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: Object.entries(allLang).map(([code, name]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: () => selectNewLang(code),
            className: "aboutdevice-form-item accessible",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-left", children: name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "aboutdevice-form-item-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) })
            ]
          },
          code
        )) })
      ] })
    ] }),
    isModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(TabletNameModal, { closeModal: toggleModal, isModalOpen, lang, setTabName, Notification: Notification2 })
  ] });
};
const WallpaperPage = ({ theme, themeMode, setNewTheme, background, setTabletBg, allBackgrounds, job, lang, Notification: Notification2 }) => {
  const scrollRef = reactExports.useRef(null);
  const [customUrl, setCustomUrl] = reactExports.useState("");
  const [selected, setSelected] = reactExports.useState(background || ((allBackgrounds == null ? void 0 : allBackgrounds[0]) || null));
  const [loadingBackground, setLoadingBackground] = reactExports.useState(null);
  const [modTheme, setModTheme] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (theme == "light") {
      setModTheme(true);
    } else {
      setModTheme(false);
    }
  }, [theme]);
  reactExports.useEffect(() => {
    if (allBackgrounds && allBackgrounds.length > 0 && !selected) {
      setSelected(allBackgrounds[0]);
    }
  }, [allBackgrounds]);
  const scrollLeft = () => {
    scrollRef.current.scrollBy({ left: -200, behavior: "smooth" });
  };
  const scrollRight = () => {
    scrollRef.current.scrollBy({ left: 200, behavior: "smooth" });
  };
  reactExports.useRef(null);
  reactExports.useEffect(() => {
    setCustomUrl(background);
  }, [background]);
  const updateBackgroundCustom = () => {
    if (!customUrl.trim()) {
      Notification2(lang.invalid, lang.validlink);
      return;
    }
    callNui("UpdateTabletData", {
      datatype: "background",
      result: customUrl
    });
    setTabletBg(customUrl);
  };
  const UpdateBackground = (theme2) => {
    setTabletBg(theme2);
    setLoadingBackground(theme2);
    setTimeout(() => {
      setLoadingBackground(null);
    }, 3e3);
    callNui("UpdateTabletData", {
      datatype: "background",
      result: theme2
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-wallpaper-box ${modTheme ? "light" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `wallpaper-ti ${modTheme ? "li" : ""}`, children: "Wallpaper" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "wallpaper-info", children: "You can change the tablet background here." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallpaper-carousel-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "chevron-btn left", onClick: scrollLeft, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-left" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallpapers", ref: scrollRef, children: allBackgrounds.filter((row) => !row.jobs || row.jobs.includes(job)).map((row, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `wallpaper-container ${background === row.label ? "selected" : ""}`,
            onClick: () => UpdateBackground(row.label),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "wallpaper-img",
                  style: {
                    backgroundImage: `url('${row.url}')`,
                    backgroundSize: "cover",
                    backgroundPosition: "center",
                    opacity: background === row.label ? 1 : 0.5,
                    borderRadius: "12px"
                  }
                }
              ),
              background === row.label && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tick-overlay", children: loadingBackground === row.label ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-circle2" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check" }) })
            ]
          },
          index
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "chevron-btn right", onClick: scrollRight, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "wallpaper-dots", children: allBackgrounds.map((_, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `dotx ${selected === allBackgrounds[index] ? "active" : ""} ${modTheme ? "light" : ""}`
        },
        index
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-back", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `setxz ${modTheme ? "li" : ""}`, children: "Custom Background" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-app-general-items", style: { height: "3rem", width: "41rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-general-item ${modTheme ? "light" : ""}`, style: { borderRadius: "10rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-file-image" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: "op-put", style: { width: "20rem" }, value: customUrl, placeholder: "Enter Url", onChange: (e) => setCustomUrl(e.target.value) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: updateBackgroundCustom, className: "right--xx", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check" }) })
      ] }) })
    ] })
  ] });
};
const PasswordX = ({ isOpened, lang, tabData, theme }) => {
  const [passEntered, setPassEntered] = reactExports.useState(false);
  const [passcode, setPasscode] = reactExports.useState("");
  const [shake, setShake] = reactExports.useState(false);
  const [correctPassword, setPassword] = reactExports.useState("Amna Kodumun Allah");
  const containerRef = reactExports.useRef(null);
  const [tabletHasPass, setHasPass] = reactExports.useState(false);
  const [currentScreen, setCurrentScreen] = reactExports.useState("main");
  const setCurrent = (screen) => {
    setCurrentScreen(screen);
    setPasscode("");
  };
  reactExports.useEffect(() => {
    if (tabData.data.passcode !== "nopass") {
      setHasPass(true);
      setPassword(tabData.data.passcode);
    } else {
      setHasPass(false);
    }
  }, [tabData.data.passcode]);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (!isNaN(event.key) && event.key !== " ") {
        setPasscode((prev) => {
          if (prev.length < 6) {
            const newPasscode = prev + event.key;
            if (newPasscode.length === 6) {
              if (currentScreen === "main") {
                if (Number(newPasscode) === Number(correctPassword)) {
                  setPassEntered(true);
                } else {
                  setShake(true);
                  setTimeout(() => {
                    setShake(false);
                    setPasscode("");
                  }, 500);
                }
              } else if (currentScreen === "removePassword") {
                if (Number(newPasscode) === Number(correctPassword)) {
                  setPassword("");
                  setCurrent("main");
                  setHasPass(false);
                  setPassEntered(true);
                  callNui("UpdateTabletMainData", {
                    datatype: "passcode",
                    result: "nopass"
                  });
                } else {
                  setShake(true);
                  setTimeout(() => {
                    setShake(false);
                    setPasscode("");
                  }, 500);
                }
              } else if (currentScreen === "changePassword") {
                setPassword(newPasscode);
                setCurrent("main");
                setPassEntered(false);
                callNui("UpdateTabletMainData", {
                  datatype: "passcode",
                  result: newPasscode
                });
              } else if (currentScreen == "createPassword") {
                setPassword(newPasscode);
                setCurrent("main");
                setHasPass(true);
                callNui("UpdateTabletMainData", {
                  datatype: "passcode",
                  result: newPasscode
                });
              }
            }
            return newPasscode;
          }
          return prev;
        });
      } else if (event.key === "Backspace") {
        setPasscode((prev) => prev.slice(0, -1));
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [correctPassword, currentScreen]);
  reactExports.useEffect(() => {
    if (containerRef.current) {
      containerRef.current.focus();
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `password-screen-frame ${isOpened ? "opened" : "hidden"}`, children: [
    !passEntered && tabletHasPass && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `password-enter-container ${theme == "dark" ? "dark" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "enter-tablet-pass", children: lang.enterCurrentPass }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "verify-info", children: lang.requireForYou }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `password-dots ${shake ? "shake" : ""}`, children: [...Array(6)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dot ${passcode.length > i ? "filled" : ""}` }, i)) })
    ] }),
    passEntered && tabletHasPass && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        initial: { opacity: 0, y: 20 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -20 },
        className: "password-settings",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "password-label", children: lang.password }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `password-entry ${theme == "dark" ? "dark" : ""}`, onClick: () => setCurrent("changePassword"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: lang.changePass }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "gray" }, className: "fa-solid fa-chevron-right" }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `password-entry ${theme == "dark" ? "dark" : ""}`, style: { height: "4rem" }, onClick: () => setCurrent("removePassword"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { float: "left", display: "flex", flexDirection: "column" }, children: [
              lang.removePass,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: "500" }, children: lang.notRecom })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right", padding: "24px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "gray" }, className: "fa-solid fa-chevron-right" }) })
          ] })
        ]
      },
      "settings"
    ),
    !tabletHasPass && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        initial: { opacity: 0, y: 20 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -20 },
        className: "password-settings",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "password-label", children: lang.password }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `password-entry ${theme == "dark" ? "dark" : ""}`, onClick: () => setCurrent("createPassword"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: lang.createPass }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "gray" }, className: "fa-solid fa-chevron-right" }) })
          ] })
        ]
      },
      "settings"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(AnimatePresence, { children: [
      currentScreen === "changePassword" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          exit: { opacity: 0, y: -20 },
          className: `password-enter-container ${theme == "dark" ? "dark" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "enter-tablet-pass", children: lang.enterNewPass }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `password-dots ${shake ? "shake" : ""}`, children: [...Array(6)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dot ${passcode.length > i ? "filled" : ""}` }, i)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "passiptal", onClick: () => setCurrent("main"), children: lang.cancel })
          ]
        },
        "change-password"
      ),
      currentScreen === "removePassword" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          exit: { opacity: 0, y: -20 },
          className: `password-enter-container ${theme == "dark" ? "dark" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "enter-tablet-pass", children: lang.confirmPass }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `password-dots ${shake ? "shake" : ""}`, children: [...Array(6)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dot ${passcode.length > i ? "filled" : ""}` }, i)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "passiptal", onClick: () => setCurrentScreen("main"), children: lang.cancel })
          ]
        },
        "remove-password"
      ),
      currentScreen === "createPassword" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        motion.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          exit: { opacity: 0, y: -20 },
          className: `password-enter-container ${theme == "dark" ? "dark" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "enter-tablet-pass", children: lang.createNewPass }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `password-dots ${shake ? "shake" : ""}`, children: [...Array(6)].map((_, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dot ${passcode.length > i ? "filled" : ""}` }, i)) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "passiptal", onClick: () => setCurrentScreen("main"), children: lang.cancel })
          ]
        },
        "create-password"
      )
    ] })
  ] });
};
const DisplayPart = ({ bright, setBright, theme, themeMode, setNewTheme, lang, setData, dataX }) => {
  const [selectedTheme, setSelectedTheme] = reactExports.useState("dark");
  const [brightness, setBrightness] = reactExports.useState(50);
  reactExports.useEffect(() => {
    if (bright) {
      setBrightness(bright);
    }
  }, [bright]);
  const handleChange = (e) => {
    setBright(e.target.value);
    setBrightness(e.target.value);
  };
  reactExports.useEffect(() => {
    if (theme) {
      setSelectedTheme(theme);
    }
  }, [theme]);
  const UpdateTheme = (theme2) => {
    setNewTheme(theme2);
    setSelectedTheme(theme2);
    callNui("UpdateTabletData", {
      datatype: "theme",
      result: theme2
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `devsirme ${theme ? "li" : ""}`, children: "Display & Brightness" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `setpage-x ${theme ? "li" : ""}`, children: "Appearance" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `setpage-themepart ${theme ? "light" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "setpage-themes", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `theme-optionx ${selectedTheme === "light" ? "selected" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/web/build/light-theme-preview.png", alt: "Light Theme" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-nam ${theme ? "li" : ""}`, children: "Light" }),
            selectedTheme === "light" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "theme-indicator seced", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => UpdateTheme("light"), className: "theme-indicator" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `theme-optionx ${selectedTheme === "dark" ? "selected" : ""}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/web/build/dark-theme-preview.png", alt: "Dark Theme" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `theme-nam ${theme ? "li" : ""}`, children: "Dark" }),
            selectedTheme === "dark" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "theme-indicator seced", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => UpdateTheme("dark"), className: "theme-indicator" })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `setpage-x ${theme ? "li" : ""}`, children: lang.brightness }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `setpage-themepart ${theme ? "light" : ""}`, style: { height: "1.2rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "brightness-slider-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-sun dim-icon" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: brightness,
          onChange: handleChange,
          className: "brightness-slider",
          style: {
            background: `linear-gradient(to right, #0a84ff ${brightness}%, #333 ${brightness}%)`
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-sun bright-icon" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `settings-app-general-items ${theme ? "light" : ""}`, style: { height: "3rem", width: "43rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-app-general-item", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-person-walking-luggage" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.widgets }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { top: ".9rem", right: "1rem" }, className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "plane-toggle", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: () => setData("widgets"), type: "checkbox", checked: dataX.widgets ? "checked" : "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "plane-slider" })
      ] }) })
    ] }) })
  ] }) });
};
const SettingsApp = ({ bright, setBright, tabletTheme, setThemeMode, apps, themeMode, settings, setSettings, background, setBackground, allBackgrounds, lang, tabData, allLang, Notification: Notification2, job }) => {
  const [showTabletInfo, setTabletInfo] = reactExports.useState(false);
  const [isOpenedOverview, setOverview] = reactExports.useState(true);
  const [isOpenedThemes, setBackgroundPage] = reactExports.useState(false);
  const [passScreen, setPassScreen] = reactExports.useState(false);
  const [forceUpdate, setForceUpdate] = reactExports.useState(false);
  const [currentMenu, setCurrentMenu] = reactExports.useState("general");
  const [themePart, setThemePart] = reactExports.useState(false);
  const [generalPage, setGeneral] = reactExports.useState(true);
  const [backPage, setBackPage] = reactExports.useState(false);
  const [modTheme, setModTheme] = reactExports.useState(false);
  const fillColor = modTheme ? "#000" : "#fff";
  const [showModa, setShowModa] = reactExports.useState(false);
  const [resetModal, setResetModal] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (themeMode == "light") {
      setModTheme(true);
    } else {
      setModTheme(false);
    }
  }, []);
  const CheckVersion = () => {
    setShowModa(true);
  };
  const setNewTheme = (theme) => {
    setThemeMode(theme);
    if (theme == "light") {
      setModTheme(true);
    } else {
      setModTheme(false);
    }
    setForceUpdate((prev) => !prev);
  };
  const hideAll = () => {
    setOverview(false);
    setThemePart(false);
    setPassScreen(false);
    setGeneral(false);
    setTabletInfo(false);
    setThemePart(false);
    setBackPage(false);
    setBackgroundPage(false);
  };
  const setPage = (page) => {
    switch (page) {
      case "general":
        hideAll();
        setGeneral(true);
        setCurrentMenu("general");
        break;
      case "background":
        hideAll();
        setBackPage(true);
        setCurrentMenu("background");
        break;
      case "password":
        hideAll();
        setPassScreen(true);
        setCurrentMenu("password");
        break;
      case "theme":
        hideAll();
        setThemePart(true);
        setCurrentMenu("theme");
        break;
      case "about":
        hideAll();
        setTabletInfo(true);
        break;
    }
  };
  const handleToggle = (key) => {
    setSettings((prev) => {
      const newSettings = {
        ...prev,
        [key]: !prev[key]
      };
      callNui("UpdateTabletData", {
        datatype: key,
        result: newSettings[key]
      });
      return newSettings;
    });
  };
  const resetAllData = () => {
    callNui("resetTablet", {}, (data) => {
    });
  };
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-frame ${modTheme ? "light" : "dark"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `time-string ${modTheme ? "li" : ""}`, children: formattedTime }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: fillColor, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: fillColor, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-left-bar ${modTheme ? "light" : "dark"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "appa-title", children: lang.settingsAppLabel }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "logar-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: `/web/pimg/${tabData.owner}.png`,
            onError: (e) => {
              e.currentTarget.onerror = null;
              e.currentTarget.src = "/web/pimg/avatar.png";
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `hesap-title ${modTheme ? "li" : ""}`, children: tabData.data.ownername }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hesap-info-txt", children: tabData.email })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-item ${modTheme ? "light" : "dark"}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `setting-item-logo`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plane" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.planeMode }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "plane-toggle", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: () => handleToggle("planemode"), checked: settings.planemode ? "checked" : "", type: "checkbox" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "plane-slider" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "general" ? "selected" : ""}`, onClick: () => setPage("general"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "20", viewBox: "0 0 21 20", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.0547 18.5951C10.2656 18.5951 10.4678 18.5776 10.6875 18.56L11.1797 19.4916C11.2852 19.7289 11.5225 19.8432 11.7949 19.808C12.0498 19.7641 12.2256 19.5707 12.2607 19.3071L12.4102 18.2612C12.8232 18.1557 13.2275 17.9975 13.6143 17.8305L14.3877 18.5248C14.5723 18.7094 14.8271 18.7358 15.082 18.6039C15.3018 18.4721 15.3896 18.2348 15.3457 17.9711L15.126 16.9516C15.4688 16.7055 15.8027 16.433 16.1191 16.1342L17.0684 16.5297C17.3232 16.6352 17.5605 16.5737 17.7539 16.3539C17.9121 16.1694 17.9385 15.9057 17.7979 15.6772L17.2441 14.7895C17.4814 14.4467 17.6836 14.0688 17.8682 13.6733L18.9229 13.726C19.1777 13.7436 19.4062 13.5942 19.4941 13.3481C19.582 13.102 19.4941 12.8471 19.292 12.6889L18.4746 12.0385C18.5801 11.6342 18.6592 11.2123 18.6943 10.7729L19.6875 10.4565C19.9424 10.3686 20.1006 10.1664 20.1006 9.90276C20.1006 9.63909 19.9424 9.43694 19.6875 9.34905L18.6943 9.03264C18.6592 8.59319 18.5713 8.18011 18.4746 7.76702L19.292 7.11663C19.4941 6.96722 19.5732 6.72112 19.4941 6.47503C19.4062 6.22014 19.1777 6.07073 18.9229 6.08831L17.8682 6.12347C17.6836 5.73675 17.4814 5.36761 17.2441 5.01604L17.7979 4.11956C17.9297 3.90862 17.9121 3.64495 17.7539 3.46038C17.5605 3.24065 17.3232 3.17913 17.0684 3.2846L16.1104 3.67132C15.8027 3.38128 15.4688 3.10003 15.126 2.86272L15.3457 1.84319C15.3896 1.57073 15.3018 1.33343 15.0732 1.21038C14.8271 1.07854 14.5723 1.09612 14.3877 1.28948L13.6143 1.97503C13.2275 1.79925 12.8232 1.65862 12.4102 1.54436L12.2607 0.516043C12.2256 0.252371 12.0498 0.0590119 11.7949 0.00627753C11.5225 -0.0288787 11.2939 0.0853791 11.1797 0.305106L10.6875 1.24554C10.4678 1.22796 10.2656 1.21917 10.0547 1.21917C9.82617 1.21917 9.62402 1.22796 9.4043 1.24554L8.91211 0.305106C8.80664 0.0853791 8.56934 -0.0288787 8.29688 0.0150666C8.04199 0.0590119 7.86621 0.252371 7.83105 0.516043L7.68164 1.54436C7.27734 1.65862 6.87305 1.79925 6.47754 1.97503L5.71289 1.28948C5.51953 1.10491 5.26465 1.07854 5.01855 1.21038C4.79883 1.33343 4.70215 1.57073 4.74609 1.84319L4.96582 2.86272C4.62305 3.10003 4.28906 3.38128 3.98145 3.67132L3.02344 3.2846C2.77734 3.17913 2.53125 3.24065 2.34668 3.46038C2.17969 3.64495 2.16211 3.90862 2.29395 4.11956L2.85645 5.01604C2.61914 5.36761 2.41699 5.73675 2.22363 6.12347L1.17773 6.08831C0.914062 6.07073 0.685547 6.22014 0.606445 6.47503C0.518555 6.72112 0.588867 6.96722 0.799805 7.11663L1.62598 7.76702C1.52051 8.18011 1.43262 8.59319 1.40625 9.03264L0.413086 9.34905C0.149414 9.43694 0 9.6303 0 9.90276C0 10.1664 0.149414 10.3686 0.413086 10.4565L1.40625 10.7729C1.43262 11.2123 1.52051 11.6342 1.62598 12.0385L0.808594 12.6889C0.597656 12.8383 0.527344 13.0932 0.606445 13.3393C0.685547 13.5942 0.914062 13.7436 1.17773 13.726L2.22363 13.6733C2.4082 14.0688 2.61914 14.4467 2.85645 14.7895L2.29395 15.686C2.15332 15.9057 2.17969 16.1694 2.34668 16.3539C2.53125 16.5737 2.77734 16.6352 3.02344 16.5297L3.98145 16.1342C4.28906 16.433 4.62305 16.7055 4.96582 16.9516L4.74609 17.9711C4.70215 18.2348 4.79004 18.4721 5.01855 18.6039C5.26465 18.7358 5.51953 18.7094 5.71289 18.5248L6.47754 17.8305C6.87305 17.9975 7.26855 18.1557 7.68164 18.2699L7.83105 19.3071C7.86621 19.5707 8.04199 19.7641 8.30566 19.808C8.56934 19.8432 8.80664 19.7289 8.91211 19.5004L9.4043 18.56C9.62402 18.5776 9.82617 18.5951 10.0547 18.5951ZM12.3486 9.20843C11.918 8.07464 11.0391 7.4594 10.002 7.4594C9.85254 7.4594 9.69434 7.47698 9.42188 7.5385L7.04883 3.46038C7.9541 3.0385 8.96484 2.8012 10.0459 2.8012C13.7637 2.8012 16.6816 5.59612 17.0156 9.20843H12.3486ZM3.0498 9.91155C3.0498 7.55608 4.13086 5.49065 5.84473 4.19866L8.23535 8.28557C7.76953 8.79534 7.5498 9.35784 7.5498 9.93792C7.5498 10.4916 7.75195 11.019 8.23535 11.5551L5.77441 15.5717C4.10449 14.2797 3.0498 12.2319 3.0498 9.91155ZM8.94727 9.92913C8.94727 9.33147 9.44824 8.87444 10.0107 8.87444C10.5996 8.87444 11.083 9.33147 11.083 9.92913C11.083 10.5092 10.5996 10.9926 10.0107 10.9926C9.44824 10.9926 8.94727 10.5092 8.94727 9.92913ZM10.0459 17.0131C8.93848 17.0131 7.90137 16.767 6.97852 16.3188L9.41309 12.3285C9.67676 12.3813 9.85254 12.3989 10.002 12.3989C11.0479 12.3989 11.918 11.766 12.3486 10.6059H17.0156C16.6816 14.2182 13.7637 17.0131 10.0459 17.0131Z", fill: "white" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.general })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "background" ? "selected" : ""}`, onClick: () => setPage("background"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo blue", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "30", height: "30", viewBox: "0 0 30 30", fill: "none", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { width: "30", height: "30", rx: "6", fill: "#38ADDE" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5622 17.17C16.0025 17.17 17.1701 16.0025 17.1701 14.5621C17.1701 13.1218 16.0025 11.9541 14.5622 11.9541C13.1219 11.9541 11.9542 13.1218 11.9542 14.5621C11.9542 16.0025 13.1219 17.17 14.5622 17.17Z", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.4318 11.9545C15.4318 11.9545 16.3011 10.2159 16.3011 8.47727C16.3011 6.73864 14.5625 5 14.5625 5C14.5625 5 12.8239 6.73864 12.8239 8.47727C12.8239 10.2159 13.6932 11.9545 13.6932 11.9545", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.9545 13.6932C11.9545 13.6932 10.2159 12.8239 8.47727 12.8239C6.73864 12.8239 5 14.5625 5 14.5625C5 14.5625 6.73864 16.3011 8.47727 16.3011C10.2159 16.3011 11.9545 15.4318 11.9545 15.4318", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.4318 17.1705C15.4318 17.1705 16.3011 18.9091 16.3011 20.6477C16.3011 22.3864 14.5625 24.125 14.5625 24.125C14.5625 24.125 12.8239 22.3864 12.8239 20.6477C12.8239 18.9091 13.6932 17.1705 13.6932 17.1705", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.1705 13.6932C17.1705 13.6932 18.9091 12.8239 20.6477 12.8239C22.3864 12.8239 24.125 14.5625 24.125 14.5625C24.125 14.5625 22.3864 16.3011 20.6477 16.3011C18.9091 16.3011 17.1705 15.4318 17.1705 15.4318", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.3331 12.1039C13.3331 12.1039 12.7184 10.2598 11.489 9.03036C10.2596 7.80096 7.8008 7.80096 7.8008 7.80096C7.8008 7.80096 7.8008 10.2598 9.0302 11.4892C10.2596 12.7186 12.1037 13.3333 12.1037 13.3333", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.1037 15.7919C12.1037 15.7919 10.2596 16.4066 9.03016 17.636C7.80075 18.8654 7.80075 21.3242 7.80075 21.3242C7.80075 21.3242 10.2596 21.3242 11.489 20.0949C12.7184 18.8654 13.333 17.0213 13.333 17.0213", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.0214 15.7919C17.0214 15.7919 18.8655 16.4066 20.0948 17.636C21.3242 18.8654 21.3242 21.3242 21.3242 21.3242C21.3242 21.3242 18.8655 21.3242 17.6361 20.0949C16.4067 18.8654 15.792 17.0213 15.792 17.0213", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.7919 12.1039C15.7919 12.1039 16.4066 10.2598 17.636 9.03036C18.8654 7.80096 21.3242 7.80096 21.3242 7.80096C21.3242 7.80096 21.3242 10.2598 20.0948 11.4892C18.8654 12.7186 17.0213 13.3333 17.0213 13.3333", stroke: "white", "stroke-miterlimit": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "14.5", cy: "14.5", r: "5", stroke: "white" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "14.5", cy: "14.5", r: "10", stroke: "white" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.background })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "password" ? "selected" : ""}`, onClick: () => setPage("password"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo green", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-lock" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.passsec })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "theme" ? "selected" : ""}`, onClick: () => setPage("theme"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo blue", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-sun" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.dixbri })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-app-main-part", children: [
      generalPage && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-general-header ${modTheme ? "light" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "3rem", height: "3rem", borderRadius: ".7rem", margin: "0" }, className: "setting-item-logo gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "60", height: "30", viewBox: "0 0 21 20", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.0547 18.5951C10.2656 18.5951 10.4678 18.5776 10.6875 18.56L11.1797 19.4916C11.2852 19.7289 11.5225 19.8432 11.7949 19.808C12.0498 19.7641 12.2256 19.5707 12.2607 19.3071L12.4102 18.2612C12.8232 18.1557 13.2275 17.9975 13.6143 17.8305L14.3877 18.5248C14.5723 18.7094 14.8271 18.7358 15.082 18.6039C15.3018 18.4721 15.3896 18.2348 15.3457 17.9711L15.126 16.9516C15.4688 16.7055 15.8027 16.433 16.1191 16.1342L17.0684 16.5297C17.3232 16.6352 17.5605 16.5737 17.7539 16.3539C17.9121 16.1694 17.9385 15.9057 17.7979 15.6772L17.2441 14.7895C17.4814 14.4467 17.6836 14.0688 17.8682 13.6733L18.9229 13.726C19.1777 13.7436 19.4062 13.5942 19.4941 13.3481C19.582 13.102 19.4941 12.8471 19.292 12.6889L18.4746 12.0385C18.5801 11.6342 18.6592 11.2123 18.6943 10.7729L19.6875 10.4565C19.9424 10.3686 20.1006 10.1664 20.1006 9.90276C20.1006 9.63909 19.9424 9.43694 19.6875 9.34905L18.6943 9.03264C18.6592 8.59319 18.5713 8.18011 18.4746 7.76702L19.292 7.11663C19.4941 6.96722 19.5732 6.72112 19.4941 6.47503C19.4062 6.22014 19.1777 6.07073 18.9229 6.08831L17.8682 6.12347C17.6836 5.73675 17.4814 5.36761 17.2441 5.01604L17.7979 4.11956C17.9297 3.90862 17.9121 3.64495 17.7539 3.46038C17.5605 3.24065 17.3232 3.17913 17.0684 3.2846L16.1104 3.67132C15.8027 3.38128 15.4688 3.10003 15.126 2.86272L15.3457 1.84319C15.3896 1.57073 15.3018 1.33343 15.0732 1.21038C14.8271 1.07854 14.5723 1.09612 14.3877 1.28948L13.6143 1.97503C13.2275 1.79925 12.8232 1.65862 12.4102 1.54436L12.2607 0.516043C12.2256 0.252371 12.0498 0.0590119 11.7949 0.00627753C11.5225 -0.0288787 11.2939 0.0853791 11.1797 0.305106L10.6875 1.24554C10.4678 1.22796 10.2656 1.21917 10.0547 1.21917C9.82617 1.21917 9.62402 1.22796 9.4043 1.24554L8.91211 0.305106C8.80664 0.0853791 8.56934 -0.0288787 8.29688 0.0150666C8.04199 0.0590119 7.86621 0.252371 7.83105 0.516043L7.68164 1.54436C7.27734 1.65862 6.87305 1.79925 6.47754 1.97503L5.71289 1.28948C5.51953 1.10491 5.26465 1.07854 5.01855 1.21038C4.79883 1.33343 4.70215 1.57073 4.74609 1.84319L4.96582 2.86272C4.62305 3.10003 4.28906 3.38128 3.98145 3.67132L3.02344 3.2846C2.77734 3.17913 2.53125 3.24065 2.34668 3.46038C2.17969 3.64495 2.16211 3.90862 2.29395 4.11956L2.85645 5.01604C2.61914 5.36761 2.41699 5.73675 2.22363 6.12347L1.17773 6.08831C0.914062 6.07073 0.685547 6.22014 0.606445 6.47503C0.518555 6.72112 0.588867 6.96722 0.799805 7.11663L1.62598 7.76702C1.52051 8.18011 1.43262 8.59319 1.40625 9.03264L0.413086 9.34905C0.149414 9.43694 0 9.6303 0 9.90276C0 10.1664 0.149414 10.3686 0.413086 10.4565L1.40625 10.7729C1.43262 11.2123 1.52051 11.6342 1.62598 12.0385L0.808594 12.6889C0.597656 12.8383 0.527344 13.0932 0.606445 13.3393C0.685547 13.5942 0.914062 13.7436 1.17773 13.726L2.22363 13.6733C2.4082 14.0688 2.61914 14.4467 2.85645 14.7895L2.29395 15.686C2.15332 15.9057 2.17969 16.1694 2.34668 16.3539C2.53125 16.5737 2.77734 16.6352 3.02344 16.5297L3.98145 16.1342C4.28906 16.433 4.62305 16.7055 4.96582 16.9516L4.74609 17.9711C4.70215 18.2348 4.79004 18.4721 5.01855 18.6039C5.26465 18.7358 5.51953 18.7094 5.71289 18.5248L6.47754 17.8305C6.87305 17.9975 7.26855 18.1557 7.68164 18.2699L7.83105 19.3071C7.86621 19.5707 8.04199 19.7641 8.30566 19.808C8.56934 19.8432 8.80664 19.7289 8.91211 19.5004L9.4043 18.56C9.62402 18.5776 9.82617 18.5951 10.0547 18.5951ZM12.3486 9.20843C11.918 8.07464 11.0391 7.4594 10.002 7.4594C9.85254 7.4594 9.69434 7.47698 9.42188 7.5385L7.04883 3.46038C7.9541 3.0385 8.96484 2.8012 10.0459 2.8012C13.7637 2.8012 16.6816 5.59612 17.0156 9.20843H12.3486ZM3.0498 9.91155C3.0498 7.55608 4.13086 5.49065 5.84473 4.19866L8.23535 8.28557C7.76953 8.79534 7.5498 9.35784 7.5498 9.93792C7.5498 10.4916 7.75195 11.019 8.23535 11.5551L5.77441 15.5717C4.10449 14.2797 3.0498 12.2319 3.0498 9.91155ZM8.94727 9.92913C8.94727 9.33147 9.44824 8.87444 10.0107 8.87444C10.5996 8.87444 11.083 9.33147 11.083 9.92913C11.083 10.5092 10.5996 10.9926 10.0107 10.9926C9.44824 10.9926 8.94727 10.5092 8.94727 9.92913ZM10.0459 17.0131C8.93848 17.0131 7.90137 16.767 6.97852 16.3188L9.41309 12.3285C9.67676 12.3813 9.85254 12.3989 10.002 12.3989C11.0479 12.3989 11.918 11.766 12.3486 10.6059H17.0156C16.6816 14.2182 13.7637 17.0131 10.0459 17.0131Z", fill: "white" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "gen-title", children: lang.general }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "genx-span", children: lang.generalInfo })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-general-items ${modTheme ? "light" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setPage("about"), className: "settings-app-general-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-tablet-screen-button" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.aboutDevice }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-bottom" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => CheckVersion(), className: "settings-app-general-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-cloud-arrow-up" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.softwareupdate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-bottom" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-app-general-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-brands fa-creative-commons-share" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.airdrop }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `settings-app-general-items ${modTheme ? "light" : ""}`, style: { height: "3rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-app-general-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-person-walking-luggage" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.useTabletWhileWalking }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { top: ".9rem", right: "1rem" }, className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "plane-toggle", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: () => handleToggle("walkanduse"), type: "checkbox" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "plane-slider" })
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setResetModal(true), className: `settings-app-general-items ${modTheme ? "light" : ""}`, style: { height: "3rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings-app-general-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "settings-tabbar gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-rotate-right" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "op-name", children: lang.resetpad }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "right--x", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" }) })
        ] }) })
      ] }),
      showTabletInfo && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AboutDevice,
        {
          themeMode,
          lang,
          allLang,
          tabData,
          Notification: Notification2
        }
      ),
      backPage && /* @__PURE__ */ jsxRuntimeExports.jsx(
        WallpaperPage,
        {
          theme: tabletTheme,
          themeMode,
          setNewTheme,
          background,
          setTabletBg: setBackground,
          allBackgrounds,
          lang,
          job,
          Notification: Notification2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColdModal,
        {
          appName: "SmartPad",
          title: lang.version,
          message: lang.latestver,
          isOpen: showModa,
          onClose: () => setShowModa(false),
          buttons: [
            { label: lang.ok, onClick: () => setShowModa(false) }
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColdModal,
        {
          appName: "SmartPad",
          title: lang.respad,
          message: lang.willbelost,
          isOpen: resetModal,
          onClose: () => setResetModal(false),
          buttons: [
            { label: lang.cancel, onClick: () => setResetModal(false) },
            { label: lang.reset, onClick: () => resetAllData() }
          ]
        }
      ),
      passScreen && /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordX,
        {
          isOpened: passScreen,
          lang,
          tabData,
          theme: tabletTheme
        }
      ),
      themePart && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DisplayPart,
        {
          bright,
          setBright,
          theme: modTheme,
          dataX: settings,
          themeMode,
          setData: handleToggle,
          setNewTheme,
          background,
          setTabletBg: setBackground,
          allBackgrounds,
          lang,
          job,
          Notification: Notification2
        }
      )
    ] })
  ] });
};
const AlertModal = ({ title, message, okay, onCancel, onConfirm }) => {
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setTimeout(() => setVisible(true), 10);
  }, []);
  const handleClose = () => {
    setVisible(false);
    setTimeout(onCancel, 300);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `n-modal-overlay ${visible ? "show" : "hide"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `n-modal-box ${visible ? "fade-in" : "fade-out"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "n-modal-title", children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "n-modal-message", children: message }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "n-modal-buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "n-cancel-btn2", onClick: handleClose, children: okay }) })
  ] }) });
};
const CameraApp = ({ allGallery, galleryLastPhoto, lang, customState: customState2 }) => {
  reactExports.useState(false);
  const [screenshotUrl, setScreenshotUrl] = reactExports.useState(null);
  const [flashEffect, setFlashEffect] = reactExports.useState(false);
  const [lastPhoto, setLastPhoto] = reactExports.useState("");
  const [currentMode, setMode] = reactExports.useState("photo");
  const [isRecording, setIsRecording] = reactExports.useState(false);
  const [videoStartTime, setVideoStartTime] = reactExports.useState(null);
  const [videoDuration, setVideoDuration] = reactExports.useState("00:00");
  const [videoTime, setVideoTime] = reactExports.useState(0);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const [currentIndex, setCurrentIndex] = reactExports.useState(0);
  const [recordingInterval, setRecordingInterval] = reactExports.useState(null);
  const [isTakingScreenshot, setIsTakingScreenshot] = reactExports.useState(false);
  const errorLoggedUrls = reactExports.useRef(/* @__PURE__ */ new Set());
  const canvasRef = reactExports.useRef(null);
  const renderInitialized = reactExports.useRef(false);
  const frameCache = reactExports.useRef(/* @__PURE__ */ new Map());
  const lastProcessedGalleryLength = reactExports.useRef(0);
  reactExports.useEffect(() => {
    return () => {
      if (window.MainRender) {
        window.MainRender.stop();
        window.isAnimated = false;
      }
      if (recordingInterval) {
        clearInterval(recordingInterval);
      }
      if (canvasRef.current) {
        const ctx2 = canvasRef.current.getContext("2d");
        ctx2.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      }
      frameCache.current.clear();
      errorLoggedUrls.current.clear();
    };
  }, []);
  reactExports.useEffect(() => {
    if (renderInitialized.current) return;
    const initCanvas = () => {
      const canvas = document.getElementById("gameview-canvas");
      if (canvas && window.MainRender) {
        canvasRef.current = canvas;
        window.MainRender.renderToTarget(canvas);
        renderInitialized.current = true;
        window.isAnimated = true;
      }
    };
    const checkInterval = setInterval(() => {
      if (window.MainRender) {
        clearInterval(checkInterval);
        initCanvas();
      }
    }, 100);
    return () => {
      clearInterval(checkInterval);
      if (window.MainRender && renderInitialized.current) {
        window.MainRender.stop();
        window.isAnimated = false;
        renderInitialized.current = false;
      }
    };
  }, []);
  const isValidVideoUrl = reactExports.useCallback((url) => {
    return url && typeof url === "string" && url.length > 8 && url.endsWith(".webm");
  }, []);
  const extractFirstFrame = reactExports.useCallback((videoUrl2, cb) => {
    if (!isValidVideoUrl(videoUrl2)) {
      cb && cb("web/public/black.png");
      return;
    }
    if (frameCache.current.has(videoUrl2)) {
      cb && cb(frameCache.current.get(videoUrl2));
      return;
    }
    const video = document.createElement("video");
    video.crossOrigin = "anonymous";
    video.muted = true;
    video.preload = "metadata";
    video.src = videoUrl2;
    const clean = () => {
      video.pause();
      video.src = "";
      video.load();
      video.remove();
    };
    video.onloadedmetadata = () => {
      video.currentTime = 0;
    };
    video.onseeked = () => {
      requestAnimationFrame(() => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx2 = canvas.getContext("2d");
        ctx2.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageUrl = canvas.toDataURL("image/png");
        frameCache.current.set(videoUrl2, imageUrl);
        cb && cb(imageUrl);
        canvas.remove();
        clean();
      });
    };
    video.onerror = () => {
      clean();
      cb && cb("web/public/black.png");
      if (!errorLoggedUrls.current.has(videoUrl2)) {
        errorLoggedUrls.current.add(videoUrl2);
      }
    };
  }, [isValidVideoUrl]);
  reactExports.useEffect(() => {
    if (!allGallery || !allGallery.length) {
      setLastPhoto("web/public/black.png");
      return;
    }
    if (allGallery.length <= lastProcessedGalleryLength.current) return;
    const last = allGallery[allGallery.length - 1];
    if (last.type === "video") {
      if (isValidVideoUrl(last.url)) {
        extractFirstFrame(last.url, (frameUrl) => setLastPhoto(frameUrl));
      }
    } else {
      setLastPhoto(last.url);
    }
    lastProcessedGalleryLength.current = allGallery.length;
  }, [allGallery, extractFirstFrame, isValidVideoUrl]);
  const updateMode = reactExports.useCallback((mode) => {
    setMode(mode);
  }, []);
  const openModal = reactExports.useCallback((index) => {
    setCurrentIndex(index);
    setIsModalOpen(true);
  }, []);
  const nextMedia = reactExports.useCallback(() => {
    setCurrentIndex(
      (prevIndex) => prevIndex >= allGallery.length - 1 ? prevIndex : prevIndex + 1
    );
  }, [allGallery.length]);
  const prevMedia = reactExports.useCallback(() => {
    setCurrentIndex(
      (prevIndex) => prevIndex <= 0 ? prevIndex : prevIndex - 1
    );
  }, []);
  const takeScreenshot = reactExports.useCallback(async () => {
    if (!window.MainRender || isTakingScreenshot) return;
    try {
      setIsTakingScreenshot(true);
      setFlashEffect(true);
      const imageUrl = await window.MainRender.requestScreenshot();
      setScreenshotUrl(imageUrl);
      callNui("SaveGalleryPhoto", {
        url: imageUrl,
        type: "photo",
        custom: customState2
      }, (x) => {
        if (x) {
        }
      });
      setTimeout(() => {
        setFlashEffect(false);
        setIsTakingScreenshot(false);
      }, 300);
    } catch (error) {
      setIsTakingScreenshot(false);
      setFlashEffect(false);
    }
  }, [customState2, isTakingScreenshot]);
  const startVideoRecording = reactExports.useCallback(() => {
    if (!window.MainRender || isRecording) return;
    setIsRecording(true);
    setVideoStartTime(Date.now());
    setVideoTime(0);
    window.MainRender.startRecording();
    const interval = setInterval(() => {
      setVideoTime((prevTime) => prevTime + 1);
    }, 1e3);
    setRecordingInterval(interval);
  }, [isRecording]);
  const stopVideoRecording = reactExports.useCallback(() => {
    if (!window.MainRender || !isRecording) return;
    setIsRecording(false);
    setVideoStartTime(null);
    setVideoTime(0);
    setVideoDuration("00:00");
    window.MainRender.stopRecording();
    if (recordingInterval) {
      clearInterval(recordingInterval);
      setRecordingInterval(null);
    }
  }, [isRecording, recordingInterval]);
  reactExports.useEffect(() => {
    return () => {
      if (isRecording) {
        stopVideoRecording();
      }
    };
  }, [isRecording, stopVideoRecording]);
  reactExports.useEffect(() => {
    const handler = (data) => {
      if (data.url.endsWith(".webm")) {
        extractFirstFrame(data.url, setLastPhoto);
      } else {
        setLastPhoto(data.url);
      }
    };
    useNui("updateLastPhoto", handler);
  }, [extractFirstFrame]);
  reactExports.useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === "Enter") {
        if (currentMode === "photo") {
          takeScreenshot();
        } else {
          isRecording ? stopVideoRecording() : startVideoRecording();
        }
      }
    };
    window.addEventListener("keydown", handleKeyPress);
    return () => window.removeEventListener("keydown", handleKeyPress);
  }, [currentMode, isRecording, takeScreenshot, startVideoRecording, stopVideoRecording]);
  reactExports.useEffect(() => {
    const minutes = String(Math.floor(videoTime / 60)).padStart(2, "0");
    const seconds = String(videoTime % 60).padStart(2, "0");
    setVideoDuration(`${minutes}:${seconds}`);
  }, [videoTime]);
  const currentMedia = reactExports.useMemo(
    () => allGallery[currentIndex] || null,
    [allGallery, currentIndex]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "CameraAppContainer", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flash-overlay ${flashEffect ? "active" : ""}`, children: flashEffect && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flash-loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "loading-circle" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", { id: "gameview-canvas" }),
    currentMode === "video" && isRecording && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "video-time", children: videoDuration }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "camera-bottom-bar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "cover-o", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrows-rotate" }) }),
      currentMode === "photo" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: takeScreenshot,
          className: "camera-button-radius",
          style: { pointerEvents: isTakingScreenshot ? "none" : "auto" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "camera-capture" })
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: isRecording ? stopVideoRecording : startVideoRecording,
          className: `camera-button-radius ${isRecording ? "recording" : ""}`,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `camera-capture ${isRecording ? "red" : "white"}` })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: () => openModal(allGallery.length - 1),
          className: "camera-last-photo",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: lastPhoto, alt: "Last capture" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "camera-modes-bar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: () => updateMode("photo"),
            className: `camera-mode-but ${currentMode === "photo" ? "selectedmode" : ""}`,
            children: lang.photo
          }
        ),
        customState2 !== "forMdt" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: () => updateMode("video"),
            className: `camera-mode-but ${currentMode === "video" ? "selectedmode" : ""}`,
            children: lang.video
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isModalOpen && currentMedia && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "camera-app-minigallery",
        initial: { opacity: 0, scale: 0.8, y: -50 },
        animate: { opacity: 1, scale: 1, y: 0 },
        exit: { opacity: 0, scale: 0.8, y: 50 },
        transition: { duration: 0.2, ease: "easeInOut" },
        children: [
          currentMedia.type === "photo" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: currentMedia.url, alt: "Gallery item" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("video", { src: currentMedia.url, controls: true }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: () => setIsModalOpen(false),
              className: "camera-app-close",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-xmark" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: prevMedia,
              style: { left: "2rem" },
              className: "minigallery-button",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-left" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              onClick: nextMedia,
              style: { right: "2rem" },
              className: "minigallery-button",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-right" })
            }
          )
        ]
      }
    ) })
  ] });
};
function Notification() {
  const [notification, setNotification] = reactExports.useState(null);
  let lastPlayed = 0;
  const playNotificationSound = () => {
    const now2 = Date.now();
    if (now2 - lastPlayed < 500) return;
    lastPlayed = now2;
    const audio = new Audio("/web/build/notify.mp3");
    audio.volume = 0.5;
    audio.play();
  };
  reactExports.useEffect(() => {
    const unsub = useNui("tabletNotification", (data) => {
      const notif = {
        title: data.title,
        message: data.message,
        icon: data.icon,
        location: data.location,
        type: data.opened ? "internal" : "external"
      };
      setNotification(notif);
      playNotificationSound();
      setTimeout(() => {
        setNotification(null);
      }, data.opened ? 3e3 : 6e3);
    });
    return () => unsub == null ? void 0 : unsub();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: notification && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    notification.type === "external" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: `notifyx external ${notification.location || "top-right"}`,
        initial: { opacity: 0, y: -50 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -50 },
        style: { zIndex: 9999 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "notif-content external-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "external-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: `/web/build/appicons/${notification.icon}.png`,
              alt: "App Icon"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { margin: 0 }, children: notification.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: "4px 0 0", fontSize: "13px" }, children: notification.message })
          ] })
        ] })
      }
    ),
    notification.type === "internal" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: `iosNotBox`,
        initial: { opacity: 0, y: -50 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: -50 },
        style: { zIndex: 9999 },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "columnb" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `/web/build/appicons/${notification.icon}.png` }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "iosAppName", children: notification.title })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "notifMessage", children: notification.message })
        ]
      }
    )
  ] }) });
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var runtime = { exports: {} };
(function(module) {
  var runtime2 = function(exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context2 = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self2, context2);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self2, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context2) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context2.method = method;
        context2.arg = arg;
        while (true) {
          var delegate = context2.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context2);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if (context2.method === "next") {
            context2.sent = context2._sent = context2.arg;
          } else if (context2.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context2.arg;
            }
            context2.dispatchException(context2.arg);
          } else if (context2.method === "return") {
            context2.abrupt("return", context2.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context2);
          if (record.type === "normal") {
            state = context2.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context2.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context2.method = "throw";
            context2.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context2) {
      var method = delegate.iterator[context2.method];
      if (method === undefined$1) {
        context2.delegate = null;
        if (context2.method === "throw") {
          if (delegate.iterator["return"]) {
            context2.method = "return";
            context2.arg = undefined$1;
            maybeInvokeDelegate(delegate, context2);
            if (context2.method === "throw") {
              return ContinueSentinel;
            }
          }
          context2.method = "throw";
          context2.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context2.arg);
      if (record.type === "throw") {
        context2.method = "throw";
        context2.arg = record.arg;
        context2.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context2.method = "throw";
        context2.arg = new TypeError("iterator result is not an object");
        context2.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context2[delegate.resultName] = info.value;
        context2.next = delegate.nextLoc;
        if (context2.method !== "return") {
          context2.method = "next";
          context2.arg = undefined$1;
        }
      } else {
        return info;
      }
      context2.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context2 = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context2.next = loc;
          if (caught) {
            context2.method = "next";
            context2.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports
  );
  try {
    regeneratorRuntime = runtime2;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime2;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime2);
    }
  }
})(runtime);
var _regeneratorRuntime = runtime.exports;
var SvgPath = function SvgPath2(_ref) {
  var paths = _ref.paths, id2 = _ref.id, strokeWidth = _ref.strokeWidth, strokeColor = _ref.strokeColor, _ref$command = _ref.command, command = _ref$command === void 0 ? bezierCommand : _ref$command;
  if (paths.length === 1) {
    var _paths$ = paths[0], x = _paths$.x, y = _paths$.y;
    var radius = strokeWidth / 2;
    return reactExports.createElement("circle", {
      key: id2,
      id: id2,
      cx: x,
      cy: y,
      r: radius,
      stroke: strokeColor,
      fill: strokeColor
    });
  }
  var d = paths.reduce(function(acc, point, i, a) {
    return i === 0 ? "M " + point.x + "," + point.y : acc + " " + command(point, i, a);
  }, "");
  return reactExports.createElement("path", {
    key: id2,
    id: id2,
    d,
    fill: "none",
    strokeLinecap: "round",
    stroke: strokeColor,
    strokeWidth
  });
};
var line = function line2(pointA, pointB) {
  var lengthX = pointB.x - pointA.x;
  var lengthY = pointB.y - pointA.y;
  return {
    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
    angle: Math.atan2(lengthY, lengthX)
  };
};
var controlPoint = function controlPoint2(controlPoints) {
  var current = controlPoints.current, next = controlPoints.next, previous = controlPoints.previous, reverse2 = controlPoints.reverse;
  var p = previous || current;
  var n = next || current;
  var smoothing = 0.2;
  var o = line(p, n);
  var angle = o.angle + (reverse2 ? Math.PI : 0);
  var length = o.length * smoothing;
  var x = current.x + Math.cos(angle) * length;
  var y = current.y + Math.sin(angle) * length;
  return [x, y];
};
var bezierCommand = function bezierCommand2(point, i, a) {
  var cpsX = null;
  var cpsY = null;
  switch (i) {
    case 0:
      var _controlPoint = controlPoint({
        current: point
      });
      cpsX = _controlPoint[0];
      cpsY = _controlPoint[1];
      break;
    case 1:
      var _controlPoint2 = controlPoint({
        current: a[i - 1],
        next: point
      });
      cpsX = _controlPoint2[0];
      cpsY = _controlPoint2[1];
      break;
    default:
      var _controlPoint3 = controlPoint({
        current: a[i - 1],
        previous: a[i - 2],
        next: point
      });
      cpsX = _controlPoint3[0];
      cpsY = _controlPoint3[1];
      break;
  }
  var _controlPoint4 = controlPoint({
    current: point,
    previous: a[i - 1],
    next: a[i + 1],
    reverse: true
  }), cpeX = _controlPoint4[0], cpeY = _controlPoint4[1];
  return "C " + cpsX + "," + cpsY + " " + cpeX + "," + cpeY + " " + point.x + ", " + point.y;
};
var Paths = function Paths2(_ref2) {
  var id2 = _ref2.id, paths = _ref2.paths;
  return reactExports.createElement(reactExports.Fragment, null, paths.map(function(path, index) {
    return reactExports.createElement(SvgPath, {
      key: id2 + "__" + index,
      paths: path.paths,
      id: id2 + "__" + index,
      strokeWidth: path.strokeWidth,
      strokeColor: path.strokeColor,
      command: bezierCommand
    });
  }));
};
var loadImage = function loadImage2(url) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.addEventListener("load", function() {
      if (img.width > 0) {
        resolve(img);
      }
      reject("Image not found");
    });
    img.addEventListener("error", function(err) {
      return reject(err);
    });
    img.src = url;
    img.setAttribute("crossorigin", "anonymous");
  });
};
function getCanvasWithViewBox(canvas) {
  var _canvas$firstChild;
  var svgCanvas = (_canvas$firstChild = canvas.firstChild) == null ? void 0 : _canvas$firstChild.cloneNode(true);
  var width = canvas.offsetWidth;
  var height = canvas.offsetHeight;
  svgCanvas.setAttribute("viewBox", "0 0 " + width + " " + height);
  svgCanvas.setAttribute("width", width.toString());
  svgCanvas.setAttribute("height", height.toString());
  return {
    svgCanvas,
    width,
    height
  };
}
var Canvas = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var paths = props.paths, isDrawing = props.isDrawing, onPointerDown = props.onPointerDown, onPointerMove = props.onPointerMove, onPointerUp = props.onPointerUp, _props$id = props.id, id2 = _props$id === void 0 ? "react-sketch-canvas" : _props$id, _props$width = props.width, width = _props$width === void 0 ? "100%" : _props$width, _props$height = props.height, height = _props$height === void 0 ? "100%" : _props$height, _props$className = props.className, className = _props$className === void 0 ? "react-sketch-canvas" : _props$className, _props$canvasColor = props.canvasColor, canvasColor = _props$canvasColor === void 0 ? "red" : _props$canvasColor, _props$backgroundImag = props.backgroundImage, backgroundImage = _props$backgroundImag === void 0 ? "" : _props$backgroundImag, _props$exportWithBack = props.exportWithBackgroundImage, exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack, _props$preserveBackgr = props.preserveBackgroundImageAspectRatio, preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? "none" : _props$preserveBackgr, _props$allowOnlyPoint = props.allowOnlyPointerType, allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? "all" : _props$allowOnlyPoint, _props$style = props.style, style = _props$style === void 0 ? {
    border: "0.0625rem solid #9c9c9c",
    borderRadius: "0.25rem"
  } : _props$style, _props$svgStyle = props.svgStyle, svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle;
  var canvasRef = reactExports.useRef(null);
  var getCoordinates = function getCoordinates2(pointerEvent) {
    var _canvasRef$current, _window$scrollX, _window$scrollY;
    var boundingArea = (_canvasRef$current = canvasRef.current) == null ? void 0 : _canvasRef$current.getBoundingClientRect();
    var scrollLeft = (_window$scrollX = window.scrollX) != null ? _window$scrollX : 0;
    var scrollTop = (_window$scrollY = window.scrollY) != null ? _window$scrollY : 0;
    if (!boundingArea) {
      return {
        x: 0,
        y: 0
      };
    }
    var point = {
      x: pointerEvent.pageX - boundingArea.left - scrollLeft,
      y: pointerEvent.pageY - boundingArea.top - scrollTop
    };
    return point;
  };
  var handlePointerDown = function handlePointerDown2(event) {
    if (allowOnlyPointerType !== "all" && event.pointerType !== allowOnlyPointerType) {
      return;
    }
    if (event.pointerType === "mouse" && event.button !== 0) return;
    var point = getCoordinates(event);
    onPointerDown(point);
  };
  var handlePointerMove = function handlePointerMove2(event) {
    if (!isDrawing) return;
    if (allowOnlyPointerType !== "all" && event.pointerType !== allowOnlyPointerType) {
      return;
    }
    var point = getCoordinates(event);
    onPointerMove(point);
  };
  var handlePointerUp = function handlePointerUp2(event) {
    if (event.pointerType === "mouse" && event.button !== 0) return;
    if (allowOnlyPointerType !== "all" && event.pointerType !== allowOnlyPointerType) {
      return;
    }
    onPointerUp();
  };
  reactExports.useImperativeHandle(ref, function() {
    return {
      exportImage: function exportImage(imageType) {
        return new Promise(/* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime.mark(function _callee(resolve, reject) {
            var canvas, _getCanvasWithViewBox, svgCanvas, _width, _height, canvasSketch, loadImagePromises, img;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    canvas = canvasRef.current;
                    if (canvas) {
                      _context.next = 4;
                      break;
                    }
                    throw Error("Canvas not rendered yet");
                  case 4:
                    _getCanvasWithViewBox = getCanvasWithViewBox(canvas), svgCanvas = _getCanvasWithViewBox.svgCanvas, _width = _getCanvasWithViewBox.width, _height = _getCanvasWithViewBox.height;
                    canvasSketch = "data:image/svg+xml;base64," + btoa(svgCanvas.outerHTML);
                    _context.next = 8;
                    return loadImage(canvasSketch);
                  case 8:
                    _context.t0 = _context.sent;
                    loadImagePromises = [_context.t0];
                    if (!exportWithBackgroundImage) {
                      _context.next = 21;
                      break;
                    }
                    _context.prev = 11;
                    _context.next = 14;
                    return loadImage(backgroundImage);
                  case 14:
                    img = _context.sent;
                    loadImagePromises.push(img);
                    _context.next = 21;
                    break;
                  case 18:
                    _context.prev = 18;
                    _context.t1 = _context["catch"](11);
                    console.warn("exportWithBackgroundImage props is set without a valid background image URL. This option is ignored");
                  case 21:
                    Promise.all(loadImagePromises).then(function(images) {
                      var renderCanvas = document.createElement("canvas");
                      renderCanvas.setAttribute("width", _width.toString());
                      renderCanvas.setAttribute("height", _height.toString());
                      var context2 = renderCanvas.getContext("2d");
                      if (!context2) {
                        throw Error("Canvas not rendered yet");
                      }
                      images.reverse().forEach(function(image2) {
                        context2.drawImage(image2, 0, 0);
                      });
                      resolve(renderCanvas.toDataURL("image/" + imageType));
                    })["catch"](function(e) {
                      throw e;
                    });
                    _context.next = 27;
                    break;
                  case 24:
                    _context.prev = 24;
                    _context.t2 = _context["catch"](0);
                    reject(_context.t2);
                  case 27:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[0, 24], [11, 18]]);
          }));
          return function(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }());
      },
      exportSvg: function exportSvg() {
        return new Promise(function(resolve, reject) {
          try {
            var _canvasRef$current2;
            var canvas = (_canvasRef$current2 = canvasRef.current) != null ? _canvasRef$current2 : null;
            if (canvas !== null) {
              var _svgCanvas$querySelec, _svgCanvas$querySelec2;
              var _getCanvasWithViewBox2 = getCanvasWithViewBox(canvas), svgCanvas = _getCanvasWithViewBox2.svgCanvas;
              if (exportWithBackgroundImage) {
                resolve(svgCanvas.outerHTML);
                return;
              }
              (_svgCanvas$querySelec = svgCanvas.querySelector("#" + id2 + "__background")) == null ? void 0 : _svgCanvas$querySelec.remove();
              (_svgCanvas$querySelec2 = svgCanvas.querySelector("#" + id2 + "__canvas-background")) == null ? void 0 : _svgCanvas$querySelec2.setAttribute("fill", canvasColor);
              resolve(svgCanvas.outerHTML);
            }
            reject(new Error("Canvas not loaded"));
          } catch (e) {
            reject(e);
          }
        });
      }
    };
  });
  reactExports.useEffect(function() {
    document.addEventListener("pointerup", handlePointerUp);
    return function() {
      document.removeEventListener("pointerup", handlePointerUp);
    };
  }, [handlePointerUp]);
  var eraserPaths = paths.filter(function(path) {
    return !path.drawMode;
  });
  var currentGroup = 0;
  var pathGroups = paths.reduce(function(arrayGroup, path) {
    if (!path.drawMode) {
      currentGroup += 1;
      return arrayGroup;
    }
    if (arrayGroup[currentGroup] === void 0) {
      arrayGroup[currentGroup] = [];
    }
    arrayGroup[currentGroup].push(path);
    return arrayGroup;
  }, [[]]);
  return reactExports.createElement("div", {
    role: "presentation",
    ref: canvasRef,
    className,
    style: _extends({
      touchAction: "none",
      width,
      height
    }, style),
    "touch-action": "none",
    onPointerDown: handlePointerDown,
    onPointerMove: handlePointerMove,
    onPointerUp: handlePointerUp
  }, reactExports.createElement("svg", {
    version: "1.1",
    baseProfile: "full",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    style: _extends({
      width: "100%",
      height: "100%"
    }, svgStyle),
    id: id2
  }, reactExports.createElement("g", {
    id: id2 + "__eraser-stroke-group",
    display: "none"
  }, reactExports.createElement("rect", {
    id: id2 + "__mask-background",
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    fill: "white"
  }), eraserPaths.map(function(eraserPath, i) {
    return reactExports.createElement(SvgPath, {
      key: id2 + "__eraser-" + i,
      id: id2 + "__eraser-" + i,
      paths: eraserPath.paths,
      strokeColor: "#000000",
      strokeWidth: eraserPath.strokeWidth
    });
  })), reactExports.createElement("defs", null, backgroundImage && reactExports.createElement("pattern", {
    id: id2 + "__background",
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    patternUnits: "userSpaceOnUse"
  }, reactExports.createElement("image", {
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    xlinkHref: backgroundImage,
    preserveAspectRatio: preserveBackgroundImageAspectRatio
  })), eraserPaths.map(function(_, i) {
    return reactExports.createElement("mask", {
      id: id2 + "__eraser-mask-" + i,
      key: id2 + "__eraser-mask-" + i,
      maskUnits: "userSpaceOnUse"
    }, reactExports.createElement("use", {
      href: "#" + id2 + "__mask-background"
    }), Array.from({
      length: eraserPaths.length - i
    }, function(_2, j) {
      return j + i;
    }).map(function(k) {
      return reactExports.createElement("use", {
        key: k.toString(),
        href: "#" + id2 + "__eraser-" + k.toString()
      });
    }));
  })), reactExports.createElement("g", {
    id: id2 + "__canvas-background-group"
  }, reactExports.createElement("rect", {
    id: id2 + "__canvas-background",
    x: "0",
    y: "0",
    width: "100%",
    height: "100%",
    fill: backgroundImage ? "url(#" + id2 + "__background)" : canvasColor
  })), pathGroups.map(function(pathGroup, i) {
    return reactExports.createElement("g", {
      id: id2 + "__stroke-group-" + i,
      key: id2 + "__stroke-group-" + i,
      mask: "url(#" + id2 + "__eraser-mask-" + i + ")"
    }, reactExports.createElement(Paths, {
      id: id2,
      paths: pathGroup
    }));
  })));
});
var ReactSketchCanvas = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var _props$id = props.id, id2 = _props$id === void 0 ? "react-sketch-canvas" : _props$id, _props$width = props.width, width = _props$width === void 0 ? "100%" : _props$width, _props$height = props.height, height = _props$height === void 0 ? "100%" : _props$height, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, _props$canvasColor = props.canvasColor, canvasColor = _props$canvasColor === void 0 ? "white" : _props$canvasColor, _props$strokeColor = props.strokeColor, strokeColor = _props$strokeColor === void 0 ? "red" : _props$strokeColor, _props$backgroundImag = props.backgroundImage, backgroundImage = _props$backgroundImag === void 0 ? "" : _props$backgroundImag, _props$exportWithBack = props.exportWithBackgroundImage, exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack, _props$preserveBackgr = props.preserveBackgroundImageAspectRatio, preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? "none" : _props$preserveBackgr, _props$strokeWidth = props.strokeWidth, strokeWidth = _props$strokeWidth === void 0 ? 4 : _props$strokeWidth, _props$eraserWidth = props.eraserWidth, eraserWidth = _props$eraserWidth === void 0 ? 8 : _props$eraserWidth, _props$allowOnlyPoint = props.allowOnlyPointerType, allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? "all" : _props$allowOnlyPoint, _props$style = props.style, style = _props$style === void 0 ? {
    border: "0.0625rem solid #9c9c9c",
    borderRadius: "0.25rem"
  } : _props$style, _props$svgStyle = props.svgStyle, svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle, _props$onChange = props.onChange, onChange = _props$onChange === void 0 ? function(_paths) {
  } : _props$onChange, _props$onStroke = props.onStroke, onStroke = _props$onStroke === void 0 ? function(_path, _isEraser) {
  } : _props$onStroke, _props$withTimestamp = props.withTimestamp, withTimestamp = _props$withTimestamp === void 0 ? false : _props$withTimestamp;
  var svgCanvas = reactExports.createRef();
  var _React$useState = reactExports.useState(true), drawMode = _React$useState[0], setDrawMode = _React$useState[1];
  var _React$useState2 = reactExports.useState(false), isDrawing = _React$useState2[0], setIsDrawing = _React$useState2[1];
  var _React$useState3 = reactExports.useState([]), resetStack = _React$useState3[0], setResetStack = _React$useState3[1];
  var _React$useState4 = reactExports.useState([]), undoStack = _React$useState4[0], setUndoStack = _React$useState4[1];
  var _React$useState5 = reactExports.useState([]), currentPaths = _React$useState5[0], setCurrentPaths = _React$useState5[1];
  var liftStrokeUp = reactExports.useCallback(function() {
    var _currentPaths$slice$, _currentPaths$slice;
    var lastStroke = (_currentPaths$slice$ = (_currentPaths$slice = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice[0]) != null ? _currentPaths$slice$ : null;
    if (lastStroke === null) {
      console.warn("No stroke found!");
      return;
    }
    onStroke(lastStroke, !lastStroke.drawMode);
  }, [isDrawing]);
  reactExports.useEffect(function() {
    liftStrokeUp();
  }, [isDrawing]);
  reactExports.useEffect(function() {
    onChange(currentPaths);
  }, [currentPaths]);
  reactExports.useImperativeHandle(ref, function() {
    return {
      eraseMode: function eraseMode(erase) {
        setDrawMode(!erase);
      },
      clearCanvas: function clearCanvas() {
        setResetStack([].concat(currentPaths));
        setCurrentPaths([]);
      },
      undo: function undo() {
        if (resetStack.length !== 0) {
          setCurrentPaths([].concat(resetStack));
          setResetStack([]);
          return;
        }
        setUndoStack(function(undoStack2) {
          return [].concat(undoStack2, currentPaths.slice(-1));
        });
        setCurrentPaths(function(currentPaths2) {
          return currentPaths2.slice(0, -1);
        });
      },
      redo: function redo() {
        if (undoStack.length === 0) return;
        setCurrentPaths(function(currentPaths2) {
          return [].concat(currentPaths2, undoStack.slice(-1));
        });
        setUndoStack(function(undoStack2) {
          return undoStack2.slice(0, -1);
        });
      },
      exportImage: function exportImage(imageType) {
        var _svgCanvas$current;
        var exportImage2 = (_svgCanvas$current = svgCanvas.current) == null ? void 0 : _svgCanvas$current.exportImage;
        if (!exportImage2) {
          throw Error("Export function called before canvas loaded");
        } else {
          return exportImage2(imageType);
        }
      },
      exportSvg: function exportSvg() {
        return new Promise(function(resolve, reject) {
          var _svgCanvas$current2;
          var exportSvg2 = (_svgCanvas$current2 = svgCanvas.current) == null ? void 0 : _svgCanvas$current2.exportSvg;
          if (!exportSvg2) {
            reject(Error("Export function called before canvas loaded"));
          } else {
            exportSvg2().then(function(data) {
              resolve(data);
            })["catch"](function(e) {
              reject(e);
            });
          }
        });
      },
      exportPaths: function exportPaths() {
        return new Promise(function(resolve, reject) {
          try {
            resolve(currentPaths);
          } catch (e) {
            reject(e);
          }
        });
      },
      loadPaths: function loadPaths(paths) {
        setCurrentPaths(function(currentPaths2) {
          return [].concat(currentPaths2, paths);
        });
      },
      getSketchingTime: function getSketchingTime() {
        return new Promise(function(resolve, reject) {
          if (!withTimestamp) {
            reject(new Error("Set 'withTimestamp' prop to get sketching time"));
          }
          try {
            var sketchingTime = currentPaths.reduce(function(totalSketchingTime, path) {
              var _path$startTimestamp, _path$endTimestamp;
              var startTimestamp = (_path$startTimestamp = path.startTimestamp) != null ? _path$startTimestamp : 0;
              var endTimestamp = (_path$endTimestamp = path.endTimestamp) != null ? _path$endTimestamp : 0;
              return totalSketchingTime + (endTimestamp - startTimestamp);
            }, 0);
            resolve(sketchingTime);
          } catch (e) {
            reject(e);
          }
        });
      },
      resetCanvas: function resetCanvas() {
        setResetStack([]);
        setUndoStack([]);
        setCurrentPaths([]);
      }
    };
  });
  var handlePointerDown = function handlePointerDown2(point) {
    setIsDrawing(true);
    setUndoStack([]);
    var stroke = {
      drawMode,
      strokeColor: drawMode ? strokeColor : "#000000",
      strokeWidth: drawMode ? strokeWidth : eraserWidth,
      paths: [point]
    };
    if (withTimestamp) {
      stroke = _extends({}, stroke, {
        startTimestamp: Date.now(),
        endTimestamp: 0
      });
    }
    setCurrentPaths(function(currentPaths2) {
      return [].concat(currentPaths2, [stroke]);
    });
  };
  var handlePointerMove = function handlePointerMove2(point) {
    if (!isDrawing) return;
    var currentStroke = currentPaths.slice(-1)[0];
    var updatedStroke = _extends({}, currentStroke, {
      paths: [].concat(currentStroke.paths, [point])
    });
    setCurrentPaths(function(currentPaths2) {
      return [].concat(currentPaths2.slice(0, -1), [updatedStroke]);
    });
  };
  var handlePointerUp = function handlePointerUp2() {
    var _currentPaths$slice$2, _currentPaths$slice2;
    if (!isDrawing) {
      return;
    }
    setIsDrawing(false);
    if (!withTimestamp) {
      return;
    }
    var currentStroke = (_currentPaths$slice$2 = (_currentPaths$slice2 = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice2[0]) != null ? _currentPaths$slice$2 : null;
    if (currentStroke === null) {
      return;
    }
    var updatedStroke = _extends({}, currentStroke, {
      endTimestamp: Date.now()
    });
    setCurrentPaths(function(currentPaths2) {
      return [].concat(currentPaths2.slice(0, -1), [updatedStroke]);
    });
  };
  return reactExports.createElement(Canvas, {
    ref: svgCanvas,
    id: id2,
    width,
    height,
    className,
    canvasColor,
    backgroundImage,
    exportWithBackgroundImage,
    preserveBackgroundImageAspectRatio,
    allowOnlyPointerType,
    style,
    svgStyle,
    paths: currentPaths,
    isDrawing,
    onPointerDown: handlePointerDown,
    onPointerMove: handlePointerMove,
    onPointerUp: handlePointerUp
  });
});
function NotesApp({ lang, allNotes, tabOwner, tabletTheme, myLimit }) {
  var _a2;
  const [notes, setNotes] = reactExports.useState([]);
  const [selectedNoteId, setSelectedNoteId] = reactExports.useState(null);
  const [mode, setMode] = reactExports.useState("nonMode");
  const [text, setText] = reactExports.useState("");
  const [drawData, setDrawData] = reactExports.useState(null);
  const [selectad, setSelectad] = reactExports.useState("");
  const [darkMode, setDarkMode] = reactExports.useState(true);
  const canvasRef = reactExports.useRef(null);
  const [verver, Verme] = reactExports.useState(false);
  const [modTheme, setModTheme] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setNotes(allNotes);
  }, [allNotes]);
  reactExports.useEffect(() => {
    if (mode === "draw" && canvasRef.current) {
      canvasRef.current.clearCanvas();
      if (drawData) {
        canvasRef.current.loadPaths(drawData);
      }
    }
  }, [mode]);
  reactExports.useEffect(() => {
    setNotes(allNotes);
    if (tabletTheme == "light") {
      setModTheme(true);
    } else {
      setModTheme(false);
    }
  }, []);
  const generateId = () => Math.random().toString(36).substr(2, 9);
  const handleNewNote = () => {
    if (notes.length < myLimit) {
      const newId = generateId();
      const newNote = {
        id: newId,
        label: lang.untitledNot,
        text: "",
        mode: "nonMode",
        drawing: null,
        date: (/* @__PURE__ */ new Date()).toLocaleString()
      };
      const updated = [...notes, newNote];
      setNotes(updated);
      setSelectedNoteId(newId);
      setText("");
      setDrawData(null);
      callNui("updateNote", { id: newId, note: newNote });
      openNote(newNote, false);
      setMode("nonMode");
    } else {
      Verme(true);
    }
  };
  const openNote = (note, skipMode = true) => {
    setSelectedNoteId(note.id);
    setText(note.text);
    setSelectad(note.id);
    setDrawData(note.drawing);
    if (skipMode) {
      setMode(note.drawing && note.drawing.length > 0 ? "draw" : "text");
    }
  };
  const handleSaveNote = async () => {
    if (!selectedNoteId) return;
    const idx = notes.findIndex((n) => n.id === selectedNoteId);
    if (idx === -1) return;
    let paths = drawData || [];
    if (canvasRef.current) paths = await canvasRef.current.exportPaths();
    const updatedNotes = [...notes];
    const old = updatedNotes[idx];
    const newNote = { id: old.id, label: old.label, text, drawing: paths, date: old.date };
    updatedNotes.splice(idx, 1);
    updatedNotes.unshift(newNote);
    setNotes(updatedNotes);
    callNui("updateNote", { id: selectedNoteId, note: newNote });
  };
  const handleTextChange = (e) => {
    const val = e.target.value;
    setText(val);
  };
  const handleDrawingChange = (data) => {
    setDrawData(data);
  };
  const handleClearDrawing = () => {
    if (canvasRef.current) {
      canvasRef.current.clearCanvas();
      setDrawData(null);
      callNui("changeNoteDrawing", { id: selectedNoteId, drawing: null });
    }
  };
  const handleDeleteNote = () => {
    if (!selectedNoteId) return;
    const updated = notes.filter((n) => n.id !== selectedNoteId);
    setNotes(updated);
    callNui("deleteSelectedNote", { id: selectedNoteId });
    const next = updated[0];
    setSelectedNoteId((next == null ? void 0 : next.id) || null);
    setText((next == null ? void 0 : next.text) || "");
    setDrawData((next == null ? void 0 : next.drawing) || null);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `notes-container ${darkMode ? "dark" : "light"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 3.31091L1.45455 4.76545C5.06909 1.15091 10.9309 1.15091 14.5455 4.76545L16 3.31091C11.5855 -1.10364 4.42182 -1.10364 0 3.31091ZM5.81818 9.12909L8 11.3109L10.1818 9.12909C9.89557 8.84208 9.55551 8.61437 9.18112 8.459C8.80672 8.30363 8.40535 8.22365 8 8.22365C7.59465 8.22365 7.19328 8.30363 6.81888 8.459C6.44449 8.61437 6.10443 8.84208 5.81818 9.12909ZM2.90909 6.22L4.36364 7.67454C5.32834 6.71064 6.63627 6.1692 8 6.1692C9.36373 6.1692 10.6717 6.71064 11.6364 7.67454L13.0909 6.22C10.2836 3.41273 5.72364 3.41273 2.90909 6.22Z", fill: "white" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "12", viewBox: "0 0 20 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.375 0C15.2038 0 15.9987 0.316071 16.5847 0.87868C17.1708 1.44129 17.5 2.20435 17.5 3V3.9996L18.9587 4.0032C19.2349 4.0032 19.4998 4.10851 19.695 4.29598C19.8903 4.48344 20 4.73769 20 5.0028V7.0032C20 7.26831 19.8903 7.52256 19.695 7.71002C19.4998 7.89749 19.2349 8.0028 18.9587 8.0028L17.5 8.0004V9C17.5 9.79565 17.1708 10.5587 16.5847 11.1213C15.9987 11.6839 15.2038 12 14.375 12H3.125C2.2962 12 1.50134 11.6839 0.915291 11.1213C0.32924 10.5587 0 9.79565 0 9V3C0 2.20435 0.32924 1.44129 0.915291 0.87868C1.50134 0.316071 2.2962 0 3.125 0H14.375ZM14.6875 1.1352H3.125C2.3125 1.1352 1.36875 1.7304 1.26 2.4912L1.25 2.6352V9.2292C1.25 10.0056 1.865 10.6452 2.6525 10.722L2.8125 10.7292H14.6875C15.0741 10.7291 15.4469 10.5914 15.7339 10.3427C16.0209 10.094 16.2017 9.75199 16.2412 9.3828L16.25 9.2292V2.6352C16.2499 2.26406 16.1064 1.90614 15.8474 1.63064C15.5883 1.35513 15.2321 1.18161 14.8475 1.1436L14.6875 1.1352ZM3.5425 2.3388H12.705C13.2387 2.3388 13.6775 2.7204 13.7425 3.2148L13.75 3.3408V8.5332C13.7502 8.77726 13.6576 9.01299 13.4896 9.19615C13.3216 9.37931 13.0897 9.49731 12.8375 9.528L12.7063 9.5352H3.54375C3.28931 9.53568 3.04345 9.44691 2.8524 9.2856C2.66134 9.12428 2.53824 8.90152 2.50625 8.6592L2.5 8.532V3.3408C2.5 2.8296 2.89875 2.4084 3.4125 2.346L3.5425 2.3388Z", fill: "white" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `settings-app-left-bar ${modTheme ? "light" : "dark"}`, style: { zIndex: "100", marginTop: "5rem", height: "47rem" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "appa-title", children: lang.notes }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logar-part", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "settings", style: { top: "5rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `settings-item ${modTheme ? "light" : "dark"}`,
            onClick: handleNewNote,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: lang.newnote })
            ]
          }
        ),
        notes.map((note) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `settings-item ${modTheme ? "light" : "dark"} ${selectedNoteId == note.id ? "selectedt" : ""}`,
            onClick: () => {
              var _a3;
              setSelectedNoteId(note.id);
              setText(note.text);
              setSelectad(note.id);
              setDrawData(note.drawing);
              const hasText = ((_a3 = note.text) == null ? void 0 : _a3.trim()) !== "";
              const hasDraw = note.drawing && note.drawing.length > 0;
              const newMode = !hasText && !hasDraw ? "nonMode" : hasDraw ? "draw" : "text";
              setMode(newMode);
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "setting-item-logo gray", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-folder" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-namex", children: note.label })
            ]
          }
        ))
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `notes-main ${darkMode ? "dark" : "light"}`, children: selectedNoteId && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "notes-toolbar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          className: "note-title-input",
          value: ((_a2 = notes.find((n) => n.id === selectedNoteId)) == null ? void 0 : _a2.label) || "",
          onChange: (e) => {
            const val = e.target.value;
            const idx = notes.findIndex((n) => n.id === selectedNoteId);
            if (idx === -1) return;
            const updated = [...notes];
            updated[idx].label = val;
            setNotes(updated);
          },
          placeholder: lang.notetitle
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `notes-content ${darkMode ? "dark" : "light"}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "floating-icons", children: [
          mode !== "draw" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "mode-toggle-icon", onClick: () => setMode("text"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-keyboard" }) }),
          mode !== "text" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "mode-toggle-icon", onClick: () => setMode("draw"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-pencil" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "mode-toggle-icon", onClick: handleSaveNote, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-floppy-disk" }) }),
          mode !== "text" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "mode-toggle-icon", onClick: handleClearDrawing, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-eraser" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "mode-toggle-icon", onClick: handleDeleteNote, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-trash-can" }) })
        ] }),
        mode === "text" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: `notes-textarea ${darkMode ? "dark" : "light"}`,
            value: text,
            onChange: handleTextChange
          }
        ) : "",
        mode === "draw" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "drawing-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReactSketchCanvas,
          {
            ref: canvasRef,
            className: "notes-canvas",
            width: "100%",
            height: "100%",
            strokeWidth: 1,
            strokeColor: "#dddddd",
            onChange: handleDrawingChange,
            canvasColor: darkMode ? "#111" : "#fff"
          }
        ) }) : ""
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "SmartPad",
        title: lang.limitfull,
        message: lang.limitmessage,
        isOpen: verver,
        onClose: () => Verme(false),
        buttons: [
          { label: lang.ok, onClick: () => Verme(false) }
        ]
      }
    )
  ] });
}
const GunLicenseCard = ({ lang, data, isOpen }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guncard", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guncard-header", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-small", children: lang.GOVERNMENTOFLOSSANTOS }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-large", children: [
      "LOS SANTOS ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "accent", children: lang.WEAPONLICENSE })
    ] })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "guncard-body", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: `/web/pimg/${data.OwnerCid}.png`,
        alt: "Avatar",
        className: "avatar",
        onError: (e) => {
          e.target.onerror = null;
          e.target.src = Avatar$2;
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "name", children: data.Owner }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "divider" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "details-grid", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.DateofBirth,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: data.PrintingDate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.gender,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: data.Gender == 0 ? lang.male : lang.female })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.type,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: data.Type })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.serialNo,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: data.License })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.signature,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value signature", children: data.Owner })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-block", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.expirationdate,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "detail-value", children: "02-2030" })
        ] })
      ] })
    ] })
  ] })
] });
const emsLogo = "" + new URL("ems.png", import.meta.url).href;
const Paramedics = ({ officers, grades, lang, theme }) => {
  const [officersList, setOfficersList] = reactExports.useState([]);
  const [searchValue, setSearchValue] = reactExports.useState("");
  const [showActive, setShowActive] = reactExports.useState(true);
  const [openIdx, setOpenIdx] = reactExports.useState(null);
  const [themeTab, setTheme] = reactExports.useState(null);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    if (theme == null) {
      setTheme("dark");
    }
  }, []);
  reactExports.useEffect(() => {
    const list = Array.isArray(officers) ? officers : [officers];
    if (!list.length) return;
    (async () => {
      const nd = await Promise.all(
        list.map(async (e) => {
          const photoUrl2 = await returnPlayerPhoto(e.cid);
          return { ...e, photoUrl: photoUrl2 };
        })
      );
      setOfficersList(nd.reverse());
    })();
  }, [JSON.stringify(officers)]);
  reactExports.useEffect(() => {
    const handleGlobalClick = () => setOpenIdx(null);
    document.addEventListener("click", handleGlobalClick);
    return () => document.removeEventListener("click", handleGlobalClick);
  }, []);
  const filtered = officersList.filter((o) => o.name.toLowerCase().includes(searchValue.toLowerCase())).filter((o) => showActive ? o.online : true);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "officers-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bothofthem", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "51rem" }, className: `search-part ${themeTab !== "dark" ? "search-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "16", viewBox: "0 0 15 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.125 13.625L10.4062 10.9062M11.875 7.375C11.875 10.1364 9.63642 12.375 6.875 12.375C4.11358 12.375 1.875 10.1364 1.875 7.375C1.875 4.61358 4.11358 2.375 6.875 2.375C9.63642 2.375 11.875 4.61358 11.875 7.375Z", stroke: "white", "stroke-width": "1.25", "stroke-linecap": "round", "stroke-linejoin": "round" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { float: "left" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            className: "inpat",
            placeholder: "Search Paramedic",
            onChange: (e) => setSearchValue(e.target.value),
            value: searchValue
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "showactiveoffc", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "switch2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              checked: showActive,
              onChange: (e) => setShowActive(e.target.checked),
              type: "checkbox"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "slider2" })
        ] }),
        "Active Paramedics"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `yenimenum ${themeTab !== "dark" ? "border-white" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `yenimenum-header ${themeTab !== "dark" ? "white-hed" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "25rem" }, className: `header-menx ${themeTab !== "dark" ? "black-text" : ""}`, children: "Paramedic" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "12rem" }, className: `header-menx ${themeTab !== "dark" ? "black-text" : ""}`, children: "Rank" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          width: "22rem",
          paddingRight: "2rem",
          justifyContent: "end"
        }, className: `header-menx ${themeTab !== "dark" ? "black-text" : ""}`, children: "Citizen ID" })
      ] }),
      filtered.map((officer, idx) => {
        const jobGrades = grades[officer.job] || [];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-man ${themeTab !== "dark" ? "border-whitex" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "35rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "like-manx", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { style: { width: "40px" }, src: officer.photoUrl, alt: "officer" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-manxv ${themeTab !== "dark" ? "black-text" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "activeoffc", children: officer.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `activeoffc ${officer.online ? "onlinec" : ""}`, children: officer.online ? "On Duty" : "Offline" })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "36rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `like-manx ${themeTab !== "dark" ? "black-text" : ""}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `dropbown ${themeTab !== "dark" ? "vc" : ""}`,
                onClick: (e) => {
                  e.stopPropagation();
                  setOpenIdx(openIdx === idx ? null : idx);
                },
                children: [
                  officer.grade,
                  "  ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-arrow-right" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: openIdx === idx && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                className: `dropdown-menu3 ${themeTab !== "dark" ? "vcx" : ""}`,
                onClick: (e) => e.stopPropagation(),
                initial: { height: 0, opacity: 0 },
                animate: { height: "auto", opacity: 1 },
                exit: { height: 0, opacity: 0 },
                transition: { duration: 0.2, ease: "easeInOut" },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `dropdown-item3 ${themeTab !== "dark" ? "black-text" : ""}`,
                      onClick: (e) => {
                        e.stopPropagation();
                        const u = [...officersList];
                        u[idx] = { ...u[idx], grade: "Unemployed" };
                        setOfficersList(u);
                        callNui("UpdateJob", {
                          gradename: "Unemployed",
                          gradelevel: 0,
                          job: "unemployed",
                          cid: officer.cid
                        });
                        setOpenIdx(null);
                      },
                      children: lang.unemployed
                    }
                  ),
                  jobGrades.map((el) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: "dropdown-item3",
                      onClick: (e) => {
                        e.stopPropagation();
                        const u = [...officersList];
                        u[idx] = { ...u[idx], grade: el.label };
                        setOfficersList(u);
                        callNui("UpdateJob", {
                          gradename: el.label,
                          gradelevel: el.gradelevel,
                          job: officer.job,
                          cid: officer.cid
                        });
                        setOpenIdx(null);
                      },
                      children: el.label
                    },
                    el.gradelevel
                  ))
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "16rem" }, className: "like-man-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "like-manx", style: { float: "right", marginRight: "1.5rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizenid", children: officer.cid }) }) })
        ] }, idx);
      })
    ] })
  ] });
};
const AllCitizens = ({ onClose, isOpened, players, lang, setCitizenProfile, isCitizenProfile, setProfileData, themex, openProfileX }) => {
  const [citizenName, setCitizenName] = reactExports.useState("");
  const [citizenList, setCitizenList] = reactExports.useState([]);
  const [theme, setTheme] = reactExports.useState("dark");
  const VehiclePlateEvent = (e) => {
    setCitizenName(e);
  };
  reactExports.useEffect(() => {
    if (!themex) {
      setTheme("dark");
    }
  }, []);
  reactExports.useEffect(() => {
    const prepareInitialList = async () => {
      if (!players || !players.length) return;
      const enriched = await Promise.all(players.map(async (p) => {
        const photo = await returnPlayerPhoto(p.cid);
        return { ...p, photoUrl: photo };
      }));
      setCitizenList(enriched);
    };
    prepareInitialList();
  }, [players]);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  reactExports.useEffect(() => {
    const handleSearch = async () => {
      if (!players || !players.length) return;
      if (citizenName.trim() === "") {
        const all2 = await Promise.all(players.map(async (p) => {
          const photo = await returnPlayerPhoto(p.cid);
          return { ...p, photoUrl: photo };
        }));
        setCitizenList(all2);
        return;
      }
      const search2 = citizenName.toLowerCase();
      const filtered = players.filter(
        (v) => v.pName.toLowerCase().includes(search2) || v.cid.toLowerCase().includes(search2)
      );
      const enriched = await Promise.all(filtered.map(async (element) => {
        const photo = await returnPlayerPhoto(element.cid);
        return { ...element, photoUrl: photo };
      }));
      setCitizenList(enriched.reverse());
    };
    handleSearch();
  }, [citizenName, players]);
  const handleSett = (data) => {
    openProfileX(data);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "vehicle-query-main-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-head`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-put ${theme !== "dark" ? "white-bold" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { style: { marginLeft: "1rem" }, xmlns: "http://www.w3.org/2000/svg", width: "17", height: "18", viewBox: "0 0 17 18", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16.8042 8.31747L15.2908 6.86681L13.9482 4.09644C13.8329 3.90301 13.6713 3.74347 13.4789 3.63319C13.2865 3.52291 13.0698 3.46561 12.8497 3.46682H5.28256C5.06247 3.46561 4.84579 3.52291 4.6534 3.63319C4.461 3.74347 4.29938 3.90301 4.18409 4.09644L2.84153 6.86681L1.32809 8.31747C1.26644 8.37647 1.21727 8.44797 1.18366 8.5275C1.15006 8.60703 1.13275 8.69286 1.13281 8.77962V14.1705C1.13281 14.3375 1.19711 14.4976 1.31155 14.6157C1.426 14.7338 1.58122 14.8001 1.74307 14.8001H4.18409C4.4282 14.8001 4.79435 14.5483 4.79435 14.2964V13.5409H13.3379V14.1705C13.3379 14.4224 13.582 14.8001 13.8261 14.8001H16.3892C16.5511 14.8001 16.7063 14.7338 16.8207 14.6157C16.9352 14.4976 16.9995 14.3375 16.9995 14.1705V8.77962C16.9995 8.69286 16.9822 8.60703 16.9486 8.5275C16.915 8.44797 16.8659 8.37647 16.8042 8.31747ZM5.40461 4.72607H12.7277L13.9482 7.24459H4.18409L5.40461 4.72607ZM6.01486 10.5187C6.01486 10.7705 5.64871 11.0224 5.40461 11.0224H2.84153C2.59743 11.0224 2.35333 10.6446 2.35333 10.3927V9.00755C2.47538 8.62977 2.71948 8.37792 3.08563 8.50384L5.52666 9.00755C5.77076 9.00755 6.01486 9.38532 6.01486 9.63718V10.5187ZM15.779 10.3927C15.779 10.6446 15.5349 11.0224 15.2908 11.0224H12.7277C12.4836 11.0224 12.1174 10.7705 12.1174 10.5187V9.63718C12.1174 9.38532 12.3615 9.00755 12.6056 9.00755L15.0467 8.50384C15.4128 8.37792 15.6569 8.62977 15.779 9.00755V10.3927Z", fill: "white" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("input", { placeholder: lang.citizenqueryplc, value: citizenName, onChange: (e) => VehiclePlateEvent(e.target.value) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-box ${theme !== "dark" ? "cqbox" : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `cquery-header ${theme !== "dark" ? "white-bold" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `part-title ${theme !== "dark" ? "black-text" : ""}`, children: lang.citizens }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `cquery-mini-header ${theme !== "dark" ? "cquery-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem" }, children: lang.photo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem" }, children: lang.citizenname }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.job }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem" }, children: lang.birthdate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem" }, children: lang.view })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "citizen-list", children: citizenList.map((citizen, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `citizen-list-item ${theme !== "dark" ? "c-list-white" : ""}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "9rem", marginLeft: "1.3rem", alignItems: "center", display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: citizen.photoUrl }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "22rem", color: "#FFF", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", alignItems: "center", fontWeight: "700", lineHeight: "14.461px", display: "flex" }, children: citizen.pName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: citizen.job }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "23rem", display: "flex", color: "#64666E", fontFamily: '"SF Pro Display"', fontSize: "16px", fontStyle: "normal", fontWeight: "700", lineHeight: "14.461px", alignItems: "center" }, children: citizen.birthdate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: "5rem", display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => handleSett(citizen), className: "button-rev2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { class: "fa-solid fa-eye" }) }) })
      ] })) })
    ] })
  ] });
};
function TreatmentModal({ lang, isOpen, onClose, onSubmit, drugs, tabOwnerName, pcid }) {
  const [selectedDrug, setSelectedDrug] = reactExports.useState("Select Drug");
  const [responsible, setResponsible] = reactExports.useState("");
  const [dropdownOpen, setDropdownOpen] = reactExports.useState(false);
  const [secData, setSecData] = reactExports.useState("");
  const dropdownRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (drugs.length > 0) {
      setSecData(drugs[0]);
      setSelectedDrug(drugs[0].drug);
    }
  }, [drugs]);
  reactExports.useEffect(() => {
    setResponsible(tabOwnerName);
    function handleClickOutside(e) {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
        setDropdownOpen(false);
      }
    }
    if (dropdownOpen) {
      document.addEventListener("mousedown", handleClickOutside);
    } else {
      document.removeEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [dropdownOpen]);
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-header-title", children: lang.addtreatment }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "close-button2", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: lang.drug }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "custom-dropdown", ref: dropdownRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `dropdown-selected ${dropdownOpen ? "open" : ""}`,
            onClick: () => setDropdownOpen(!dropdownOpen),
            children: [
              secData ? `${secData.drug} - ${secData.brand} - ${secData.type}` : lang.selectDrug,
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `arrow ${dropdownOpen ? "up" : "down"}` })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `dropdown-list ${dropdownOpen ? "show" : ""}`, children: drugs.map((d, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "dropdown-item",
            onClick: () => {
              setSecData(d);
              setSelectedDrug(d.drug);
              setDropdownOpen(false);
            },
            children: [
              d.drug,
              " - ",
              d.brand,
              " - ",
              d.type
            ]
          },
          i
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: lang.resperson }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: responsible,
          onChange: (e) => setResponsible(e.target.value),
          placeholder: "Johnny Sins"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "submit-button2",
          onClick: () => {
            if (selectedDrug && responsible) {
              setSelectedDrug("");
              setResponsible("");
              onClose();
              callNui("addDrugList", {
                selectedDrug,
                responsible,
                selectedPerson: pcid
              });
            }
          },
          children: lang.addtreatment
        }
      )
    ] })
  ] }) });
}
function DoctorNoteModal({ lang, isOpen, onClose, pcid, tabOwnerName }) {
  const [responsible, setResponsible] = reactExports.useState("");
  const [noteText, setNoteText] = reactExports.useState("");
  reactExports.useEffect(() => {
    setResponsible(tabOwnerName);
  }, [tabOwnerName]);
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-overlay2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-header-title", children: lang.addnote }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "close-button2", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-body2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: lang.resperson }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          value: responsible,
          onChange: (e) => setResponsible(e.target.value),
          placeholder: "Dr. House"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: lang.doctornote }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          value: noteText,
          onChange: (e) => setNoteText(e.target.value),
          placeholder: lang.enterNote,
          rows: 4,
          style: {
            width: "91%",
            resize: "none",
            background: "#0a0a0a",
            padding: "17px",
            borderRadius: "7px",
            border: "1px solid rgb(18, 18, 18)"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "submit-button2",
          onClick: () => {
            if (noteText && responsible) {
              callNui("addDoctorNote", {
                note: noteText,
                responsible,
                selectedPerson: pcid
              });
              setNoteText("");
              setResponsible("");
              onClose();
            }
          },
          children: lang.addnote
        }
      )
    ] })
  ] }) });
}
const PatientProfile = ({ lang, patientData, allTedaviler, allergies, docnotes, drugs, tabOwnerName, backList }) => {
  const [modalOpen, setModalOpen] = reactExports.useState(false);
  const [modalOpen2, setModalOpen2] = reactExports.useState(false);
  const PlayerAlergies = () => {
    const list = allergies.filter((x) => x.citizen_id === patientData.cid).map((x) => x.drug_name);
    return list.length > 0 ? list.join(", ") : lang.none;
  };
  const getDoctorNotes = () => {
    const list = [...docnotes].filter((x) => x.citizen_id === patientData.cid).reverse();
    return list;
  };
  const getTreatments = () => {
    const list = [...allTedaviler].filter((x) => x.patient_id === patientData.cid).reverse();
    return list;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-profile-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "title-patient", children: "About Patient" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => backList(null), className: "add-note", children: lang.back }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setModalOpen(true), className: "add-note", children: lang.addtreatment }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setModalOpen2(true), className: "add-note", children: lang.addnote }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bosanmis", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-profile-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: `/web/pimg/${patientData.cid}.png`,
            onError: (e) => e.currentTarget.src = "/web/pimg/avatar.png"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-name", children: patientData.pName }),
        patientData.nationality ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "player-info-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-name", children: lang.nationality }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "player-item-info-data", children: patientData.nationality })
        ] }) : "",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-label", children: lang.citizenid }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-string", children: patientData.cid })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-label", children: lang.birthday }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-string", children: patientData.birthday })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-label", children: lang.allergies }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "patient-data-string", children: PlayerAlergies() })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-history", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-history-part", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "patient-history-part-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-title", children: lang.doctorNotes }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "patient-content", children: getDoctorNotes().map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-content-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "flex-start" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "patient-content-info-part", children: element.created_at }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-content-info-part", children: [
                element.doctor_name,
                " note:"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "doctor-note", children: element.note })
          ] }, index)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height: "377px", marginTop: "1rem", overflow: "auto" }, className: "patient-history-part", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "patient-history-part-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "h-title", children: lang.treath }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            justifyContent: "flex-start",
            height: "33rem",
            maxHeight: "58rem"
          }, className: "patient-content", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "patient-content-table-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "12rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", children: lang.date }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "20rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", children: lang.drugUsed }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "12rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", style: { textAlign: "right", float: "right", marginLeft: "3rem", marginRight: "0rem" }, children: lang.responper }) })
            ] }),
            getTreatments().map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "patient-content-table-item",
                style: { backgroundColor: index % 2 === 0 ? "transparent" : "#101010" },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "12rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", children: element.date }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "20rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", style: { color: "#fff" }, children: element.drug }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", width: "12rem", height: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "th-table", style: { color: "#FFF177", textAlign: "right", float: "right", marginLeft: "3rem", marginRight: "0rem" }, children: element.responsible }) })
                ]
              },
              index
            ))
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TreatmentModal,
      {
        isOpen: modalOpen,
        lang,
        tabOwnerName,
        onClose: () => setModalOpen(false),
        drugs,
        pcid: patientData.cid
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      DoctorNoteModal,
      {
        isOpen: modalOpen2,
        lang,
        tabOwnerName,
        onClose: () => setModalOpen2(false),
        drugs,
        pcid: patientData.cid
      }
    )
  ] });
};
function EMSChat({ lang, allMessages, playerName }) {
  const [text, setText] = reactExports.useState("");
  const [messages, setMessages] = reactExports.useState(allMessages);
  const messagesEndRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setMessages(allMessages);
  }, [allMessages]);
  const send = () => {
    if (!text) return;
    const newMsg = { sender: playerName, message: text, type: "ems" };
    setMessages((prev) => [...prev, newMsg]);
    callNui("sendMessage", newMsg);
    setText("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ems-chat", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ems-chat-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ems-heax", children: lang.emschat }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ems-messages", children: [
      messages.map((m, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: m.sender === playerName ? "msg mine" : "msg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sender", children: m.sender }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text", children: m.message }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timestamp", children: m.time })
      ] }, i)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: messagesEndRef })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ems-input", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          value: text,
          onChange: (e) => setText(e.target.value),
          onKeyDown: (e) => e.key === "Enter" && send(),
          placeholder: lang.writesmt
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: send, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "19", height: "16", viewBox: "0 0 19 16", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 0V6.18182L10.9091 8L0 9.81818V16L18.9091 8L0 0Z", fill: "#9B9B9B" }) }) })
    ] })
  ] });
}
const EmsApp = ({ lang, emsData, emsDispatch, tabOwnerName, allMessages }) => {
  const [loginPart, setLoginPart] = reactExports.useState(false);
  const [passValue, setValuePass] = reactExports.useState("");
  const [dashboard, setDashboard] = reactExports.useState(true);
  const [mapUrl, setMapUrl] = reactExports.useState("https://map.0resmon.org/");
  const [overview, setOverview] = reactExports.useState(true);
  const [paramedics, setParamedics] = reactExports.useState(false);
  const [allpatients, setAllPatients] = reactExports.useState(false);
  const [paramedicsList, setParamedicsList] = reactExports.useState([]);
  const [patientProfile, setPatientProfile] = reactExports.useState(null);
  const [selectedMenu, setAddX] = reactExports.useState("overview");
  const [allPlayers, setPlayers] = reactExports.useState([]);
  const [q, setQ] = reactExports.useState("");
  const [f, setF] = reactExports.useState([]);
  const [emsChat, setEmsChat] = reactExports.useState(false);
  const [o, setO] = reactExports.useState(false);
  reactExports.useState([]);
  const [treatments, setTreatments] = reactExports.useState([]);
  const [docnotes, setNotes] = reactExports.useState([]);
  const OpenProfilePatient = (data) => {
    hideAll();
    setPatientProfile(data);
  };
  const CloseProfilePatient = () => {
    setPatientProfile(null);
  };
  const backListBro = () => {
    setPatientProfile(null);
    setAllPatients(true);
  };
  reactExports.useEffect(() => {
    var _a2;
    const onlineOfficers = (_a2 = emsData == null ? void 0 : emsData.officers) == null ? void 0 : _a2.filter((officer) => officer.online);
    if ((onlineOfficers == null ? void 0 : onlineOfficers.length) > 0) {
      const coordsParam = onlineOfficers.map((officer) => `${officer.coords.x},${officer.coords.y},${encodeURIComponent(officer.name)}`).join("|");
      setMapUrl(`https://map.0resmon.org/?coords=${coordsParam}`);
    }
    setParamedicsList(emsData.officers);
    setTreatments(emsData.mdtDatabase.emsData_treatments);
    setNotes(emsData.mdtDatabase.emsData_notes);
  }, [emsData]);
  reactExports.useEffect(() => {
    useNui("updateEmsData", (data) => {
      if (data.type == "treatments") {
        setTreatments(data.data);
      } else if (data.type == "docnotes") {
        setNotes(data.data);
      }
    });
  }, []);
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar$2);
    });
  };
  const hideAll = () => {
    setOverview(false);
    setPatientProfile(null);
    setParamedics(false);
    setEmsChat(false);
    setAllPatients(false);
  };
  const openProfile = (data) => {
    hideAll();
    setO(false);
    setQ("");
    setPatientProfile(data);
  };
  const setAdd = (page) => {
    setAddX(page);
    if (page === "overview") {
      hideAll();
      setOverview(true);
    } else if (page === "paramedics") {
      hideAll();
      setParamedics(true);
    } else if (page === "allpatients") {
      hideAll();
      setAllPatients(true);
    } else if (page === "emschat") {
      hideAll();
      setEmsChat(true);
    }
  };
  reactExports.useEffect(() => {
    const container = document.querySelector(".paramedics-team");
    if (!container) return;
    const handleWheel = (e) => {
      if (e.deltaY !== 0) {
        container.scrollLeft += e.deltaY;
        e.preventDefault();
      }
    };
    container.addEventListener("wheel", handleWheel, { passive: false });
    return () => {
      container.removeEventListener("wheel", handleWheel);
    };
  }, []);
  reactExports.useEffect(() => {
    const loadPhotos = async () => {
      const updatedList = await Promise.all(
        [...emsData.officers].reverse().map(async (item) => {
          const url = await returnPlayerPhoto(item.cid);
          return { ...item, photoUrl: url };
        })
      );
      setParamedicsList(updatedList);
    };
    loadPhotos();
  }, [emsData.officers]);
  reactExports.useEffect(() => {
    const loadPhotos = async () => {
      const updatedList = await Promise.all(
        [...emsData.players].reverse().map(async (item) => {
          const url = await returnPlayerPhoto(item.cid);
          return { ...item, photoUrl: url };
        })
      );
      setPlayers(updatedList);
    };
    loadPhotos();
  }, [emsData.players]);
  reactExports.useEffect(() => {
    if (!q.trim()) {
      setF([]);
      setO(false);
      return;
    }
    const r = allPlayers.filter(
      (x) => x.pName.toLowerCase().includes(q.toLowerCase()) || x.cid.toLowerCase().includes(q.toLowerCase())
    );
    setF(r);
    setO(r.length > 0);
  }, [q, allPlayers]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-Container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 3.31091L1.45455 4.76545C5.06909 1.15091 10.9309 1.15091 14.5455 4.76545L16 3.31091C11.5855 -1.10364 4.42182 -1.10364 0 3.31091ZM5.81818 9.12909L8 11.3109L10.1818 9.12909C9.89557 8.84208 9.55551 8.61437 9.18112 8.459C8.80672 8.30363 8.40535 8.22365 8 8.22365C7.59465 8.22365 7.19328 8.30363 6.81888 8.459C6.44449 8.61437 6.10443 8.84208 5.81818 9.12909ZM2.90909 6.22L4.36364 7.67454C5.32834 6.71064 6.63627 6.1692 8 6.1692C9.36373 6.1692 10.6717 6.71064 11.6364 7.67454L13.0909 6.22C10.2836 3.41273 5.72364 3.41273 2.90909 6.22Z", fill: "white" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "12", viewBox: "0 0 20 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.375 0C15.2038 0 15.9987 0.316071 16.5847 0.87868C17.1708 1.44129 17.5 2.20435 17.5 3V3.9996L18.9587 4.0032C19.2349 4.0032 19.4998 4.10851 19.695 4.29598C19.8903 4.48344 20 4.73769 20 5.0028V7.0032C20 7.26831 19.8903 7.52256 19.695 7.71002C19.4998 7.89749 19.2349 8.0028 18.9587 8.0028L17.5 8.0004V9C17.5 9.79565 17.1708 10.5587 16.5847 11.1213C15.9987 11.6839 15.2038 12 14.375 12H3.125C2.2962 12 1.50134 11.6839 0.915291 11.1213C0.32924 10.5587 0 9.79565 0 9V3C0 2.20435 0.32924 1.44129 0.915291 0.87868C1.50134 0.316071 2.2962 0 3.125 0H14.375ZM14.6875 1.1352H3.125C2.3125 1.1352 1.36875 1.7304 1.26 2.4912L1.25 2.6352V9.2292C1.25 10.0056 1.865 10.6452 2.6525 10.722L2.8125 10.7292H14.6875C15.0741 10.7291 15.4469 10.5914 15.7339 10.3427C16.0209 10.094 16.2017 9.75199 16.2412 9.3828L16.25 9.2292V2.6352C16.2499 2.26406 16.1064 1.90614 15.8474 1.63064C15.5883 1.35513 15.2321 1.18161 14.8475 1.1436L14.6875 1.1352ZM3.5425 2.3388H12.705C13.2387 2.3388 13.6775 2.7204 13.7425 3.2148L13.75 3.3408V8.5332C13.7502 8.77726 13.6576 9.01299 13.4896 9.19615C13.3216 9.37931 13.0897 9.49731 12.8375 9.528L12.7063 9.5352H3.54375C3.28931 9.53568 3.04345 9.44691 2.8524 9.2856C2.66134 9.12428 2.53824 8.90152 2.50625 8.6592L2.5 8.532V3.3408C2.5 2.8296 2.89875 2.4084 3.4125 2.346L3.5425 2.3388Z", fill: "white" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "1069", height: "894", viewBox: "0 0 1069 894", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M783.646 -46.5C969.676 -46.4998 1067.88 115.377 1067.88 265.022C1067.88 339.907 1061.01 388.245 1052.28 418.002C1047.92 432.881 1043.11 443.092 1038.47 449.65C1033.96 456.021 1029.69 458.869 1026.23 459.31L1025.9 459.345C1018.37 459.978 1001.47 462.308 987.062 458.513C979.87 456.619 973.35 453.211 968.931 447.348C964.654 441.674 962.295 433.637 963.276 422.29L963.382 421.182C965.872 397.148 969.619 376.886 972.749 356.502C975.878 336.124 978.386 315.651 978.386 291.25C978.386 266.839 973.068 212.278 948.59 163.8C924.097 115.294 880.397 72.8477 803.68 72.8477C726.916 72.8477 680.585 125.973 650.663 181.984C635.699 209.996 624.819 238.765 616.279 262.032C612.007 273.672 608.324 283.923 605.006 292.029C601.782 299.904 598.933 305.672 596.266 308.722L596.008 309.009C593.192 312.054 590.758 314.768 588.595 317.184C586.431 319.601 584.541 321.716 582.808 323.57C579.34 327.281 576.528 329.915 573.467 331.793C567.361 335.538 560.171 336.334 544.549 336.334C536.878 336.334 527.332 332.758 516.851 326.953C506.384 321.157 495.049 313.175 483.816 304.441C462.75 288.062 442.106 269.09 428.268 256.999L425.592 254.676C398.166 231.016 353.053 171.516 249.802 171.516C198.106 171.516 163.617 195.808 142.069 226.129C120.537 256.429 111.921 292.753 111.921 316.897C111.921 364.958 147.279 566.634 383.497 717.671L386.285 719.445C505.559 795.017 602.101 847.226 668.828 880.544C702.191 897.203 728.101 909.139 745.671 916.911C754.456 920.797 761.157 923.642 765.662 925.516C767.914 926.452 769.618 927.147 770.759 927.607C771.329 927.837 771.759 928.009 772.046 928.123C772.19 928.18 772.298 928.223 772.37 928.251C772.406 928.265 772.434 928.276 772.452 928.283C772.461 928.287 772.468 928.289 772.473 928.291C772.475 928.292 772.476 928.293 772.478 928.293C772.478 928.293 772.477 928.293 772.511 928.208L772.512 928.209L772.479 928.294L773.161 928.561V928.445C773.403 928.535 773.708 928.648 774.067 928.787C775.066 929.174 776.486 929.748 778.171 930.496C781.543 931.993 785.963 934.182 790.176 936.956C794.394 939.734 798.37 943.078 800.887 946.871C803.315 950.531 804.372 954.587 803.008 958.982L802.868 959.409C801.239 964.14 799.57 967.853 797.237 970.561C794.923 973.247 791.932 974.971 787.589 975.671C783.224 976.374 777.494 976.042 769.729 974.589C762.453 973.228 753.422 970.888 742.099 967.522L739.804 966.836C690.34 951.891 409.629 884.498 170.561 641.55L167.75 638.684C47.9224 516.051 6.78888 411.73 1.18555 328.525C-4.33047 246.616 24.579 185.089 46.9023 146.598L47.96 144.782C92.7695 68.2346 189.923 49.5069 261.076 49.5068C296.653 49.5068 320.953 51.3818 344.769 57.9209C367.844 64.2568 390.493 74.9786 422.522 92.665L425.651 94.3984H425.652C442.504 103.755 455.551 111.885 465.933 118.403C476.302 124.913 484.045 129.838 490.253 132.752C496.463 135.667 501.252 136.627 505.673 135.059C510.067 133.499 513.973 129.482 518.54 122.794C536.838 96.0026 597.564 -46.5 783.646 -46.5Z", stroke: "#121212" }) }),
    loginPart && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "EmsApp-LoginPart", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", flexDirection: "column" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: emsLogo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "welcome-text", children: "You are connecting to Pill Box Hill Medical Center Database" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "info-text", children: "Please enter password to identify you" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "password-box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "password", placeholder: "Enter password", value: passValue, onChange: (e) => setValuePass(e.target.value) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "#d5d5d5", float: "right", cursor: "pointer", marginRight: "1.5rem", marginTop: "1.2rem" }, className: "fa-solid fa-arrow-right" })
      ] })
    ] }) }),
    dashboard && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-Dashboard", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-LeftBar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-LeftBar-Header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: emsLogo }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", marginLeft: "1rem" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "title-ems", children: lang.pillboks }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "desc-ems", children: lang.medbase })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "EmsApp-LeftBar-MainPanel", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-PartOne", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-PartOne-Header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "EmsApp-SubBox", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "14", viewBox: "0 0 16 14", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M13.6 4V8.8C14.96 8.8 16 7.76 16 6.4C16 5.04 14.96 4 13.6 4ZM7.2 3.2H1.6C0.72 3.2 0 3.92 0 4.8V8C0 8.88 0.72 9.6 1.6 9.6H2.4V12C2.4 12.88 3.12 13.6 4 13.6H5.6V9.6H7.2L10.4 12.8H12V0H10.4L7.2 3.2Z", fill: "#64666F" }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "part-x", children: lang.dispatcher })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "EmsApp-List", children: emsDispatch.map((element, index) => {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-List-Item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-clause", children: element.timestring }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "alert-title", children: element.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "alert-detail-box", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "alert-detail-str", children: [
                  lang.reqid,
                  ": ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "white" }, children: element.code })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "alert-detail-str", children: [
                  lang.gender,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "white" }, children: element.gender })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "alert-detail-str", children: [
                  lang.location,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "white" }, children: element.address })
                ] })
              ] })
            ] });
          }) })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-MiddleDashboard", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "EmsApp-MiddleHeader", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setAdd("overview"), className: `menu-title ${selectedMenu == "overview" ? "selected" : ""}`, children: lang.overview }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setAdd("paramedics"), className: `menu-title ${selectedMenu == "paramedics" ? "selected" : ""}`, children: lang.paramedics }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setAdd("allpatients"), className: `menu-title ${selectedMenu == "allpatients" ? "selected" : ""}`, children: lang.citizens }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setAdd("emschat"), className: `menu-title ${selectedMenu == "emschat" ? "selected" : ""}`, children: lang.chat }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-player", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-magnifying-glass", style: { color: "#818181", marginLeft: "1rem" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                value: q,
                onChange: (e) => setQ(e.target.value),
                placeholder: "Search Patient",
                style: { width: "100%", padding: "0.5rem 1rem" }
              }
            ),
            o && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "dropdown open", children: f.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { onClick: () => openProfile(p), style: { display: "flex", alignItems: "center", gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: p.photoUrl || "/public/avatar.png",
                  alt: p.pName,
                  style: {
                    width: 32,
                    height: 32,
                    borderRadius: "50%",
                    objectFit: "cover",
                    marginRight: 8
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: p.pName })
            ] }, p.cid)) })
          ] })
        ] }),
        overview && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "manisalar", style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "map-title", style: { fontFamily: "SF Pro Text", fontSize: "1.2rem", color: "#fff" }, children: lang.overview }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "iframe",
            {
              src: mapUrl,
              loading: "lazy",
              style: {
                border: 0,
                borderRadius: "4px",
                width: "100%",
                height: "611px",
                marginTop: "0.4rem",
                willChange: "transform"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            marginBottom: "0.3rem",
            padding: "0.5rem 1.5rem",
            borderRadius: "33px",
            position: "absolute",
            top: "3.7rem",
            zIndex: "100",
            right: "1rem",
            background: "transparent"
          }, children: paramedicsList.map((p, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            marginBottom: "0.3rem",
            paddingBottom: ".5rem",
            paddingTop: ".5rem",
            borderRadius: "31px",
            paddingLeft: "1rem",
            paddingRight: "1rem",
            background: "#0000003b",
            fontFamily: '"SF Pro Display"',
            color: "rgb(255, 255, 255)",
            fontSize: "13px"
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: p.photoUrl,
                alt: p.name,
                style: {
                  width: "20px",
                  height: "20px",
                  borderRadius: "50%",
                  marginRight: "0.5rem"
                }
              }
            ),
            p.name
          ] }, i)) })
        ] }),
        allpatients && /* @__PURE__ */ jsxRuntimeExports.jsx(AllCitizens, { lang, players: emsData.players, onClose: CloseProfilePatient, openProfileX: OpenProfilePatient, children: " " }),
        paramedics && /* @__PURE__ */ jsxRuntimeExports.jsx(Paramedics, { lang, officers: emsData.officers, grades: emsData.allgrades }),
        patientProfile && /* @__PURE__ */ jsxRuntimeExports.jsx(PatientProfile, { backList: backListBro, tabOwnerName, drugs: emsData.druglist, lang, patientData: patientProfile, allergies: emsData.mdtDatabase.emsData_allergies, docnotes, allTedaviler: treatments }),
        emsChat && /* @__PURE__ */ jsxRuntimeExports.jsx(EMSChat, { lang, playerName: tabOwnerName, allMessages })
      ] })
    ] })
  ] }) });
};
const Avatar = "" + new URL("resim.png", import.meta.url).href;
const TabletFrame = "" + new URL("ipad.png", import.meta.url).href;
const NewGallery = ({ allGallery, lang, theme, albumsv, pname }) => {
  var _a2, _b, _c, _d, _e;
  const [selectedPart, setPart] = reactExports.useState("ariv");
  const [openedAirDrop, setAirDrop] = reactExports.useState(null);
  const [editMode, setEditMode] = reactExports.useState(false);
  const [albums, setAlbums] = reactExports.useState([]);
  const [editingIndex, setEditingIndex] = reactExports.useState(null);
  const [editingName, setEditingName] = reactExports.useState("");
  const [showAllPhotos, setShowAll] = reactExports.useState(true);
  const pressTimer = reactExports.useRef();
  const [selectedPhotos, setSelectedPhotos] = reactExports.useState([]);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const [photos, setPhotos] = reactExports.useState([]);
  const [viewerIndex, setViewerIndex] = reactExports.useState(null);
  const [justPhotos, setJustPhotos] = reactExports.useState(0);
  const [justVideos, setJustVideos] = reactExports.useState(0);
  const [players, setPlayers] = reactExports.useState([]);
  const [showModal, setShowModal] = reactExports.useState(false);
  const [albumName, setAlbumName] = reactExports.useState("");
  const [selectedAlbumData, setAlbumData] = reactExports.useState([]);
  const [nearest, setNearest] = reactExports.useState([]);
  const [showAddToAlbum, setShowAddToAlbum] = reactExports.useState(false);
  const [longPressTriggered, setLongPressTriggered] = reactExports.useState(false);
  const [showFavs, setShowFavs] = reactExports.useState(false);
  const [favPhotos, setFavPhotos] = reactExports.useState([]);
  const deletePhoto = () => {
    if (!showFavs) {
      if (showAllPhotos) {
        if (viewerIndex !== null && viewerIndex < photos.length) {
          callNui("deleteGalleryMedia", { code: photos[viewerIndex].code, type: 1 });
        }
      } else {
        if (viewerIndex !== null && viewerIndex < selectedAlbumData.length) {
          callNui("deleteGalleryMedia", { code: selectedAlbumData[viewerIndex].code, type: 2 });
        }
      }
    } else {
      if (viewerIndex !== null && viewerIndex < selectedAlbumData.length) {
        callNui("deleteGalleryMedia", { code: favPhotos[viewerIndex].code, type: 2 });
      }
    }
  };
  const addToAlbum = (album) => {
    const codes = selectedPhotos.map((i) => photos[i].code);
    callNui("addPhotosToAlbum", {
      albumName: album.name,
      photoCodes: codes
    }, (res) => {
      if (res && res.name) {
        setAlbums((prev) => prev.map((a) => a.name === res.name ? res : a));
        setShowAddToAlbum(false);
        setSelectedPhotos([]);
      }
    });
  };
  const createNewAlbum = () => {
    setShowModal(true);
  };
  const startPress = (i) => {
    pressTimer.current = setTimeout(() => {
      setSelectedPhotos(
        (prev) => prev.includes(i) ? prev.filter((x) => x !== i) : [...prev, i]
      );
      setLongPressTriggered(true);
    }, 800);
  };
  const cancelPress = () => {
    clearTimeout(pressTimer.current);
  };
  const deleteSelected = () => {
    selectedPhotos.forEach((i) => {
      callNui("deleteGalleryMedia", {
        code: photos[i].code,
        type: 1
      });
    });
    setSelectedPhotos([]);
  };
  reactExports.useEffect(() => {
    setPhotos(allGallery);
    setAlbums(albumsv);
    let videoCount = 0;
    let photoCount = 0;
    const likedMedia = [];
    allGallery.forEach((element) => {
      if (element.type === "video") {
        videoCount++;
      } else {
        photoCount++;
      }
      if (element.liked) {
        likedMedia.push(element);
      }
    });
    setFavPhotos(likedMedia);
    setJustVideos(videoCount);
    setJustPhotos(photoCount);
  }, [allGallery]);
  const setShowAlbum = (data) => {
    setAlbumData(data);
  };
  reactExports.useEffect(() => {
    const prepareData = async () => {
      const licenses = players;
      const newData = await Promise.all(licenses.map(async (element) => {
        const photo = await returnPlayerPhoto(element.cid);
        return { ...element, avatar: photo };
      }));
      setPlayers(newData.reverse());
    };
    prepareData();
  }, [players]);
  const addFavourites = () => {
    const updatedPhotos = showFavs ? [...favPhotos] : [...photos];
    const currentPhoto = updatedPhotos[viewerIndex];
    const newLikedState = !currentPhoto.liked;
    callNui("likeMedia", {
      photoCode: currentPhoto.code,
      state: newLikedState
    });
    currentPhoto.liked = newLikedState;
    if (!showFavs) {
      setPhotos(updatedPhotos);
    } else {
      setFavPhotos(updatedPhotos);
    }
    const updatedFavPhotos = newLikedState ? favPhotos.some((p) => p.code === currentPhoto.code) ? favPhotos : [...favPhotos, currentPhoto] : favPhotos.filter((p) => p.code !== currentPhoto.code);
    setFavPhotos(updatedFavPhotos);
  };
  const returnPlayerPhoto = (cid) => {
    const path = `/web/pimg/${cid}.png`;
    const img = new Image();
    img.src = path;
    return new Promise((resolve) => {
      img.onload = () => resolve(path);
      img.onerror = () => resolve(Avatar);
    });
  };
  reactExports.useEffect(() => {
    useNui("addGalleryNewPhoto", (data) => {
      setPhotos((prev) => [...prev, data.data]);
    });
  }, []);
  const showFavourites = () => {
    setPart("favs");
    setShowAll(false);
    setShowFavs(true);
  };
  const extractFirstFrame = async (videoUrl2) => {
    try {
      const video = document.createElement("video");
      video.src = videoUrl2;
      video.crossOrigin = "anonymous";
      video.muted = true;
      video.preload = "auto";
      await new Promise((resolve, reject) => {
        video.onloadeddata = resolve;
        video.onerror = () => reject(" Video yklenirken hata olutu!");
      });
      video.currentTime = 0;
      await new Promise((resolve) => video.onseeked = resolve);
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      const ctx2 = canvas.getContext("2d");
      ctx2.drawImage(video, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL("image/png");
    } catch (error) {
      console.error(error);
      return "fallback_image.png";
    }
  };
  const setHairdrop = () => {
    callNui("getNearestForAirDrop", {}, (res) => {
      setNearest(res);
    });
    setAirDrop(true);
  };
  const SendPhoto = (data) => {
    callNui("SendAirDropPhoto", {
      photoCode: photos[viewerIndex].code,
      receiverTab: data.serial,
      receiverSource: data.source
    }, (res) => {
      if (res) {
        setAirDrop(null);
      }
    });
  };
  const [thumbnails, setThumbnails] = reactExports.useState({});
  reactExports.useEffect(() => {
    const fetchThumbnails = async () => {
      let newThumbnails = {};
      for (const photo of photos) {
        if (photo.type === "video") {
          const image2 = await extractFirstFrame(photo.url);
          newThumbnails[photo.url] = image2;
        }
      }
      setThumbnails(newThumbnails);
    };
    fetchThumbnails();
  }, [photos]);
  reactExports.useEffect(() => {
    if (viewerIndex !== null && viewerIndex >= favPhotos.length) {
      setViewerIndex(null);
    }
  }, [favPhotos]);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "new-gallery-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tablet-frame-homescreen-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 3.31091L1.45455 4.76545C5.06909 1.15091 10.9309 1.15091 14.5455 4.76545L16 3.31091C11.5855 -1.10364 4.42182 -1.10364 0 3.31091ZM5.81818 9.12909L8 11.3109L10.1818 9.12909C9.89557 8.84208 9.55551 8.61437 9.18112 8.459C8.80672 8.30363 8.40535 8.22365 8 8.22365C7.59465 8.22365 7.19328 8.30363 6.81888 8.459C6.44449 8.61437 6.10443 8.84208 5.81818 9.12909ZM2.90909 6.22L4.36364 7.67454C5.32834 6.71064 6.63627 6.1692 8 6.1692C9.36373 6.1692 10.6717 6.71064 11.6364 7.67454L13.0909 6.22C10.2836 3.41273 5.72364 3.41273 2.90909 6.22Z", fill: "white" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "12", viewBox: "0 0 20 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.375 0C15.2038 0 15.9987 0.316071 16.5847 0.87868C17.1708 1.44129 17.5 2.20435 17.5 3V3.9996L18.9587 4.0032C19.2349 4.0032 19.4998 4.10851 19.695 4.29598C19.8903 4.48344 20 4.73769 20 5.0028V7.0032C20 7.26831 19.8903 7.52256 19.695 7.71002C19.4998 7.89749 19.2349 8.0028 18.9587 8.0028L17.5 8.0004V9C17.5 9.79565 17.1708 10.5587 16.5847 11.1213C15.9987 11.6839 15.2038 12 14.375 12H3.125C2.2962 12 1.50134 11.6839 0.915291 11.1213C0.32924 10.5587 0 9.79565 0 9V3C0 2.20435 0.32924 1.44129 0.915291 0.87868C1.50134 0.316071 2.2962 0 3.125 0H14.375ZM14.6875 1.1352H3.125C2.3125 1.1352 1.36875 1.7304 1.26 2.4912L1.25 2.6352V9.2292C1.25 10.0056 1.865 10.6452 2.6525 10.722L2.8125 10.7292H14.6875C15.0741 10.7291 15.4469 10.5914 15.7339 10.3427C16.0209 10.094 16.2017 9.75199 16.2412 9.3828L16.25 9.2292V2.6352C16.2499 2.26406 16.1064 1.90614 15.8474 1.63064C15.5883 1.35513 15.2321 1.18161 14.8475 1.1436L14.6875 1.1352ZM3.5425 2.3388H12.705C13.2387 2.3388 13.6775 2.7204 13.7425 3.2148L13.75 3.3408V8.5332C13.7502 8.77726 13.6576 9.01299 13.4896 9.19615C13.3216 9.37931 13.0897 9.49731 12.8375 9.528L12.7063 9.5352H3.54375C3.28931 9.53568 3.04345 9.44691 2.8524 9.2856C2.66134 9.12428 2.53824 8.90152 2.50625 8.6592L2.5 8.532V3.3408C2.5 2.8296 2.89875 2.4084 3.4125 2.346L3.5425 2.3388Z", fill: "white" }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "flex-start" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "new-gallery-left-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignContent: "center", justifyContent: "center", flexDirection: "column" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick: () => setEditMode(!editMode), className: "edit-text", children: lang.edit }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => {
          setPart("ariv");
          setShowFavs(false);
          setShowAll(true);
        }, className: `photo-bar ${selectedPart == "ariv" ? "selected-bar" : ""}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-images" }),
          "  ",
          lang.archive
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `photo-bar ${selectedPart == "favs" ? "selected-bar" : ""}`,
            style: { color: "#b5b5b5" },
            onClick: () => showFavourites(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-heart" }),
              " ",
              lang.favourites
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "albums-text", children: lang.albums }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `photo-bar`,
            style: { color: "#b5b5b5" },
            onClick: () => createNewAlbum(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
              " ",
              lang.addnewalbum
            ]
          }
        ),
        albums.map((element, i) => editingIndex === i ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "photo-bar", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { value: editingName, onChange: (e) => setEditingName(e.target.value), className: "album-input" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => {
            const a = [...albums];
            a[i] = editingName;
            setAlbums(a);
            setEditingIndex(null);
          }, className: "save-btn", children: lang.save })
        ] }, i) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `photo-bar ${selectedPart === `album${i + 1}` ? "selected-bar" : ""}`,
            onClick: () => {
              setPart(`album${i + 1}`);
              setShowFavs(false);
              setShowAll(false);
              setShowAlbum(element.medias);
            },
            onMouseDown: () => startPress(i, element.name),
            onMouseUp: cancelPress,
            onMouseLeave: cancelPress,
            onTouchStart: () => startPress(i, element.name),
            onTouchEnd: cancelPress,
            children: [
              editMode && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => {
              }, className: "delete-album", children: "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-image" }),
              "",
              element.name
            ]
          },
          i
        ))
      ] }) }),
      selectedPhotos.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: deleteSelected, className: "delete-selected-btn", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-trash-can" }),
          " (",
          selectedPhotos.length,
          ")"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowAddToAlbum(true), className: "addtoalbum-btn", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-images" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "new-gallery-middle-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", position: "absolute", zIndex: "1000" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "arc", children: lang.archive }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "arc-x", children: [
            justPhotos,
            " ",
            lang.photoss,
            ", ",
            justVideos,
            " ",
            lang.videoss
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "photo-list", children: [
          !showFavs && showAllPhotos && photos.map((photo, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `photo-item ${selectedPhotos.includes(i) ? "selected" : ""}`,
              onClick: () => {
                if (longPressTriggered) {
                  setLongPressTriggered(false);
                  return;
                }
                if (selectedPhotos.length) {
                  setSelectedPhotos(
                    (prev) => prev.includes(i) ? prev.filter((x) => x !== i) : [...prev, i]
                  );
                } else {
                  setViewerIndex(i);
                }
              },
              onMouseDown: () => startPress(i),
              onMouseUp: cancelPress,
              onMouseLeave: cancelPress,
              onTouchStart: () => startPress(i),
              onTouchEnd: cancelPress,
              children: [
                selectedPhotos.includes(i) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "select-check", children: "" }),
                photo.type === "video" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: thumbnails[photo.url] || "fallback_image.png",
                      alt: "Gallery Item"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "video-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-play" }) })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: photo.url, alt: "Gallery Item" })
              ]
            },
            i
          )),
          !showFavs && !showAllPhotos && selectedAlbumData.map((photo, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "photo-item", onClick: () => {
            setViewerIndex(i);
          }, children: photo.type === "video" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: thumbnails[photo.url] || "fallback_image.png", alt: "Gallery Item" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "video-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-play" }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: photo.url, alt: "Gallery Item" }) }, i)),
          showFavs && !showAllPhotos && favPhotos.map((photo, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "photo-item",
              onClick: () => {
                if (favPhotos[i]) {
                  setViewerIndex(i);
                }
              },
              children: photo.type === "video" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: thumbnails[photo.url] || "fallback_image.png", alt: "Gallery Item" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "video-overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-play" }) })
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: photo.url, alt: "Gallery Item" })
            },
            i
          ))
        ] })
      ] }),
      openedAirDrop && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "airdrop-modal", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "airdrop-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Avatar }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flexDirection: "column", display: "flex" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "airdropx", children: lang.aidx }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "airdx", children: pname })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setAirDrop(null), className: "close-aidrop", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-xmark" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "device-list", children: Object.entries(nearest).map(([key, element], index) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => SendPhoto(element), className: "device-list-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: TabletFrame }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "cname", children: element.tabName })
          ] }, index);
        }) })
      ] }),
      showAddToAlbum && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "album-select-modal", onClick: () => setShowAddToAlbum(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "album-select-content", onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.selectalbum }),
        albums.map((alb, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "album-option",
            onClick: () => addToAlbum(alb),
            children: alb.name
          },
          idx
        ))
      ] }) }),
      showModal && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "album-modal-overlay", onClick: () => setShowModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "album-modal-content", onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "albu-tit", children: lang.createnewalbum }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder: lang.enteralbumname,
            value: albumName,
            onChange: (e) => setAlbumName(e.target.value),
            className: "album-inputx"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "album-modal-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setShowModal(false), className: "albot", children: lang.cancel }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => {
                if (albumName) {
                  setShowModal(false);
                  callNui("addNewAlbum", {
                    albumName
                  });
                  setAlbums((prev) => [...prev, { name: albumName, medias: [] }]);
                  setAlbumName("");
                }
              },
              style: { background: "#0072ff" },
              className: "albot",
              children: lang.create
            }
          )
        ] })
      ] }) }),
      showAllPhotos && viewerIndex !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overlay", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx > 0 ? idx - 1 : idx), className: "fa-solid fa-chevron-left" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx-rig", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx < photos.length - 1 ? idx + 1 : idx), className: "fa-solid fa-chevron-right" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "backs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setViewerIndex(null), className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-left" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => {
            setHairdrop();
          }, className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-up-from-bracket" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => addFavourites(), className: "ri", children: photos[viewerIndex].liked ? /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "#d11500" }, className: "fa-solid fa-heart" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-heart" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: deletePhoto, className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-trash-can" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "location", children: photos[viewerIndex].location }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "datez", children: photos[viewerIndex].date })
        ] }),
        viewerIndex !== null && (photos[viewerIndex].type === "photo" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: photos[viewerIndex].url, className: "viewer-image" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("video", { controls: true, className: "viewer-video", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: photos[viewerIndex].url, type: "video/mp4" }) }))
      ] }),
      showFavs && !showAllPhotos && viewerIndex !== null && favPhotos[viewerIndex] && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overlay", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx > 0 ? idx - 1 : idx), className: "fa-solid fa-chevron-left" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx-rig", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx < favPhotos.length - 1 ? idx + 1 : idx), className: "fa-solid fa-chevron-right" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "backs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setViewerIndex(null), className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-left" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setHairdrop(), className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-up-from-bracket" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => addFavourites(), className: "ri", children: ((_a2 = favPhotos[viewerIndex]) == null ? void 0 : _a2.liked) ? /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "#d11500" }, className: "fa-solid fa-heart" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-heart" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: deletePhoto, className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-trash-can" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "location", children: ((_b = favPhotos[viewerIndex]) == null ? void 0 : _b.location) || "Konum Yok" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "datez", children: ((_c = favPhotos[viewerIndex]) == null ? void 0 : _c.date) || "Tarih Yok" })
        ] }),
        ((_d = favPhotos[viewerIndex]) == null ? void 0 : _d.type) === "photo" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: favPhotos[viewerIndex].url, className: "viewer-image" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("video", { controls: true, className: "viewer-video", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: (_e = favPhotos[viewerIndex]) == null ? void 0 : _e.url, type: "video/mp4" }) })
      ] }),
      !showAllPhotos && !showFavs && viewerIndex !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overlay", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx > 0 ? idx - 1 : idx), className: "fa-solid fa-chevron-left" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "myposx-rig", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { onClick: () => setViewerIndex((idx) => idx < selectedAlbumData.length - 1 ? idx + 1 : idx), className: "fa-solid fa-chevron-right" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "backs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setViewerIndex(null), className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-left" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => {
            setHairdrop();
          }, className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-up-from-bracket" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-heart" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: deletePhoto, className: "ri", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-trash-can" }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "date-info", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "location", children: selectedAlbumData[viewerIndex].location }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "datez", children: selectedAlbumData[viewerIndex].date })
        ] }),
        viewerIndex !== null && (selectedAlbumData[viewerIndex].type === "photo" ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedAlbumData[viewerIndex].url, className: "viewer-image" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("video", { controls: true, className: "viewer-video", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: selectedAlbumData[viewerIndex].url, type: "video/mp4" }) }))
      ] })
    ] })
  ] });
};
const BillingApp = ({ lang, ownerJob, invoices, checkInvoice }) => {
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const [modTheme, setModdTheme] = reactExports.useState(false);
  const [currentMenu, setCurr] = reactExports.useState("all");
  const [allBillings, setAllShow] = reactExports.useState(true);
  const [pendingBills, setPending] = reactExports.useState(false);
  const [players, setPlayers] = reactExports.useState([]);
  const [newBill, setNewBill] = reactExports.useState(false);
  const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  const [invoiceDate, setInvoiceDate] = reactExports.useState(today);
  const [selectedPlayer, setSelectedPlayer] = reactExports.useState("");
  const VAT_RATE = 18;
  const [dueDate, setDueDate] = reactExports.useState("");
  const [items, setItems] = reactExports.useState([{ Description: "", Quantity: 1, Price: 0 }]);
  const [vatRate, setVatRate] = reactExports.useState(0);
  const [discount, setDiscount] = reactExports.useState(0);
  const [status, setStatus] = reactExports.useState(0);
  const [notes, setNotes] = reactExports.useState("");
  const [alerto, setAlerto] = reactExports.useState(false);
  const [alerto2, setAlerto2] = reactExports.useState(false);
  const [payModal, setPayModal] = reactExports.useState(false);
  const [selectedInvoice, setSelectedBillData] = reactExports.useState([]);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  const hideAll = () => {
    setAllShow(false);
    setPending(false);
    setNewBill(false);
  };
  const PayInvoice = () => {
    callNui("PayInvoice", {
      invoiceKey: selectedInvoice.ikey,
      invoicePrice: selectedInvoice.totalamount
    });
    setPayModal(false);
  };
  const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  const setSelectedInvoice = (data) => {
    if (data.status == 0) {
      setSelectedBillData(data);
      setPayModal(true);
    }
  };
  reactExports.useEffect(() => {
    callNui("getNearestForBilling", {}, (res) => {
      setPlayers(res);
    });
  }, []);
  const changePage = (page) => {
    switch (page) {
      case "allbilling":
        hideAll();
        setCurr("all");
        setAllShow(true);
        break;
      case "new":
        if (checkInvoice) {
          hideAll();
          setCurr("new");
          setNewBill(true);
        } else {
          setAlerto(true);
        }
        break;
      case "pending":
        hideAll();
        setCurr("pending");
        setPending(true);
        break;
    }
  };
  const [open, setOpen] = reactExports.useState(false);
  const [search2, setSearch] = reactExports.useState("");
  const ref = reactExports.useRef(null);
  const filtered = players.filter(
    (p) => p.name && p.name.toLowerCase().includes(search2.toLowerCase())
  );
  reactExports.useEffect(() => {
    const handleClickOutside = (e) => {
      if (ref.current && !ref.current.contains(e.target)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  reactExports.useEffect(() => {
    const today2 = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
    if (!invoiceDate) setInvoiceDate(today2);
    if (!dueDate) setDueDate(today2);
  }, []);
  const onInputChange = (e) => {
    setSearch(e.target.value);
    setOpen(true);
  };
  const onItemClick = (p) => {
    setSelectedPlayer(p.cid);
    setSearch(p.name);
    setOpen(false);
  };
  const addItem = () => {
    setItems([...items, { Description: "", Quantity: 1, Price: 0 }]);
  };
  const updateItem = (i, field, value) => {
    const newItems = [...items];
    newItems[i][field] = field === "Description" ? value : Number(value);
    setItems(newItems);
  };
  const removeItem2 = (i) => {
    setItems(items.filter((_, idx) => idx !== i));
  };
  const CreateNewInvoice = () => {
    const missing = [];
    if (!selectedPlayer) missing.push("selectedPlayer");
    if (!invoiceDate) missing.push("invoiceDate");
    if (!dueDate) missing.push("dueDate");
    if (!(items == null ? void 0 : items.length)) missing.push("items");
    if (subtotal == null) missing.push("subtotal");
    if (vatAmount == null) missing.push("vatAmount");
    if (total == null) missing.push("total");
    if (!notes) missing.push("notes");
    if (missing.length) {
      setAlerto2(true);
      return;
    }
    callNui("createNewInvoice", { selectedPlayer, invoiceDate, dueDate, items, subtotal, vatAmount, total, notes, status, ownerJob });
    setSelectedPlayer("");
    setItems([{ Description: "", Quantity: 1, Price: 0 }]);
  };
  const subtotal = items.reduce((sum2, it) => sum2 + it.Quantity * it.Price, 0);
  const vatAmount = subtotal * vatRate / 100;
  const discountAmount = discount > 0 ? discount < 100 ? subtotal * discount / 100 : discount : 0;
  const total = subtotal + vatAmount - discountAmount;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-time-string", children: formattedTime }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-header-icon-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "16", height: "12", viewBox: "0 0 16 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0 3.31091L1.45455 4.76545C5.06909 1.15091 10.9309 1.15091 14.5455 4.76545L16 3.31091C11.5855 -1.10364 4.42182 -1.10364 0 3.31091ZM5.81818 9.12909L8 11.3109L10.1818 9.12909C9.89557 8.84208 9.55551 8.61437 9.18112 8.459C8.80672 8.30363 8.40535 8.22365 8 8.22365C7.59465 8.22365 7.19328 8.30363 6.81888 8.459C6.44449 8.61437 6.10443 8.84208 5.81818 9.12909ZM2.90909 6.22L4.36364 7.67454C5.32834 6.71064 6.63627 6.1692 8 6.1692C9.36373 6.1692 10.6717 6.71064 11.6364 7.67454L13.0909 6.22C10.2836 3.41273 5.72364 3.41273 2.90909 6.22Z", fill: "white" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "20", height: "12", viewBox: "0 0 20 12", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.375 0C15.2038 0 15.9987 0.316071 16.5847 0.87868C17.1708 1.44129 17.5 2.20435 17.5 3V3.9996L18.9587 4.0032C19.2349 4.0032 19.4998 4.10851 19.695 4.29598C19.8903 4.48344 20 4.73769 20 5.0028V7.0032C20 7.26831 19.8903 7.52256 19.695 7.71002C19.4998 7.89749 19.2349 8.0028 18.9587 8.0028L17.5 8.0004V9C17.5 9.79565 17.1708 10.5587 16.5847 11.1213C15.9987 11.6839 15.2038 12 14.375 12H3.125C2.2962 12 1.50134 11.6839 0.915291 11.1213C0.32924 10.5587 0 9.79565 0 9V3C0 2.20435 0.32924 1.44129 0.915291 0.87868C1.50134 0.316071 2.2962 0 3.125 0H14.375ZM14.6875 1.1352H3.125C2.3125 1.1352 1.36875 1.7304 1.26 2.4912L1.25 2.6352V9.2292C1.25 10.0056 1.865 10.6452 2.6525 10.722L2.8125 10.7292H14.6875C15.0741 10.7291 15.4469 10.5914 15.7339 10.3427C16.0209 10.094 16.2017 9.75199 16.2412 9.3828L16.25 9.2292V2.6352C16.2499 2.26406 16.1064 1.90614 15.8474 1.63064C15.5883 1.35513 15.2321 1.18161 14.8475 1.1436L14.6875 1.1352ZM3.5425 2.3388H12.705C13.2387 2.3388 13.6775 2.7204 13.7425 3.2148L13.75 3.3408V8.5332C13.7502 8.77726 13.6576 9.01299 13.4896 9.19615C13.3216 9.37931 13.0897 9.49731 12.8375 9.528L12.7063 9.5352H3.54375C3.28931 9.53568 3.04345 9.44691 2.8524 9.2856C2.66134 9.12428 2.53824 8.90152 2.50625 8.6592L2.5 8.532V3.3408C2.5 2.8296 2.89875 2.4084 3.4125 2.346L3.5425 2.3388Z", fill: "white" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-left-bar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-title-appz", children: lang.mybillings }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-spanxz", children: lang.inapp }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-spanler", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("allbilling"), className: `bil-settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "all" ? "bil-selectedra" : ""}`, style: {
          width: "77%",
          marginLeft: "0.7rem",
          height: "1.2rem"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bil-setting-item-logo ${currentMenu == "all" ? "bil-green2" : "bil-gray"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-receipt" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-app-namex", children: lang.allin })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("pending"), className: `bil-settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "pending" ? "bil-selectedra" : ""}`, style: {
          width: "77%",
          marginLeft: "0.7rem",
          height: "1.2rem"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bil-setting-item-logo  ${currentMenu == "pending" ? "bil-green2" : "bil-gray"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-hourglass-start" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-app-namex", children: lang.overduein })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-createinm", children: lang.newin }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("new"), className: `bil-settings-item ${modTheme ? "light" : "dark"} ${currentMenu == "new" ? "bil-selectedra" : ""}`, style: {
          width: "77%",
          marginLeft: "0.7rem",
          marginTop: "2.5rem",
          height: "1.2rem"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bil-setting-item-logo  ${currentMenu == "new" ? "bil-green2" : "bil-gray"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-app-namex", children: lang.cbill })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-middle-part", children: [
      allBillings && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-showedAllBillings", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-title-boo", children: lang.allbills }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-showed-list", children: invoices.map((element, index) => {
          const overdueDays = Math.floor((/* @__PURE__ */ new Date() - new Date(element.duedate)) / (1e3 * 60 * 60 * 24));
          if (overdueDays > 0 && element.status != 1) {
            const updatedAmount = (element.totalamount * (1 + overdueDays * 0.01)).toFixed(2);
            const updated = { ...element, totalamount: updatedAmount };
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setSelectedInvoice(updated), className: "bil-invoice-card", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-headerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-invoice-no", children: [
                  "#",
                  index + 1
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-invoice-date", children: element.date })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-body", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-customer-name", children: capitalize(element.job) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { textDecoration: "line-through", color: "#5f5f5f", fontSize: "12px" }, children: [
                  "$",
                  element.totalamount
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-overtime", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-overdue-days", children: lang.latetext.replace("%s", overdueDays) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-updated-amount", children: [
                  "$",
                  updatedAmount
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-footer", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-due-date", children: [
                  lang.duedate,
                  ": ",
                  element.duedate
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-status bil-late", children: lang.late })
              ] })
            ] }, index);
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setSelectedInvoice(element), className: "bil-invoice-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-headerx", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-invoice-no", children: [
                "#",
                index + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-invoice-date", children: element.date })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-body", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-customer-name", children: capitalize(element.job) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-invoice-amount", children: [
                "$",
                element.totalamount
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-footer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-due-date", children: [
                lang.duedate,
                ": ",
                element.duedate
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `bil-status ${element.status == 0 ? "bil-pending" : "bil-paid"}`, children: element.status == 0 ? lang.pending : lang.paid })
            ] })
          ] }, index);
        }) })
      ] }),
      pendingBills && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-showedAllBillings", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-title-boo", children: lang.overduein }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-showed-list", children: invoices.filter((el) => {
          const overdueDays = Math.floor((/* @__PURE__ */ new Date() - new Date(el.duedate)) / (1e3 * 60 * 60 * 24));
          return overdueDays > 0 && el.status != 1;
        }).map((element, index) => {
          const overdueDays = Math.floor((/* @__PURE__ */ new Date() - new Date(element.duedate)) / (1e3 * 60 * 60 * 24));
          const updatedAmount = (element.totalamount * (1 + overdueDays * 0.01)).toFixed(2);
          const updated = { ...element, totalamount: updatedAmount };
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setSelectedInvoice(updated), className: "bil-invoice-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-headerx", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-invoice-no", children: [
                "#",
                index + 1
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-invoice-date", children: element.date })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-body", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-customer-name", children: capitalize(element.job) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#5f5f5f", fontSize: "12px" }, className: "bil-invoice-amount", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("del", { children: [
                "$",
                element.totalamount.toFixed(2)
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-overtime", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-overdue-days", children: lang.latetext.replace("%s", overdueDays) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-updated-amount", children: [
                "$",
                updatedAmount
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-invoice-row bil-footer", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-due-date", children: [
                lang.duedate,
                ": ",
                element.duedate
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-status bil-late", children: lang.late })
            ] })
          ] }, index);
        }) })
      ] }),
      newBill && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-showedAllBillings", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "bil-title-boo", children: [
          lang.cbill,
          " | ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: ownerJob })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: "66rem", height: "53rem", overflow: "auto", background: "transparent" }, className: "bil-create-box", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-data-data", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu", children: lang.customer }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-player-dropdown-container", ref, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  className: "bil-player-dropdown-input",
                  value: search2,
                  onChange: onInputChange,
                  onClick: () => setOpen(true),
                  placeholder: lang.splayer
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `bil-player-dropdown-list ${open ? "" : "bil-closed"}`, children: filtered.map((p) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bil-player-dropdown-item", onClick: () => onItemClick(p), children: p.name }, p)) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-data-data", style: { width: "48%" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu", children: lang.billdate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                className: "bil-invoice-date-input",
                value: invoiceDate,
                onChange: (e) => setInvoiceDate(e.target.value)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-data-data", style: { width: "48%" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu", children: lang.duedate }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "date",
                className: "bil-invoice-date-input",
                value: dueDate,
                onChange: (e) => setDueDate(e.target.value)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-items-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu2", children: lang.lineitems }),
            items.map((it, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-item-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", placeholder: lang.description, value: it.Description, onChange: (e) => updateItem(i, "Description", e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "number", placeholder: lang.amount, value: it.Quantity, onChange: (e) => updateItem(i, "Quantity", e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "number", placeholder: lang.unitprice, value: it.Price, onChange: (e) => updateItem(i, "Price", e.target.value) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => removeItem2(i), children: "" })
            ] }, i)),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: addItem, className: "bil-add-item-btn", children: [
              "+ ",
              lang.addlineitem
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-summary-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                lang.inttotal,
                ":"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: subtotal.toFixed(2) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                lang.vat,
                " (",
                VAT_RATE,
                "%):"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: vatAmount.toFixed(2) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-summary-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.offer }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "number",
                  value: discount,
                  onChange: (e) => setDiscount(Number(e.target.value)),
                  placeholder: lang.tutar
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: discountAmount.toFixed(2) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-summary-row bil-total", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                lang.generaltotal,
                ":"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: total.toFixed(2) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { top: "-1rem" }, className: "bil-data-data", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu", children: lang.state }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                style: { marginTop: ".5rem", marginLeft: "1.5rem" },
                value: status,
                onChange: (e) => setStatus(parseInt(e.target.value, 10)),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 0, children: lang.pending }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: 1, children: lang.paid })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bil-notes-box", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "bil-cucu", children: lang.notes }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { value: notes, onChange: (e) => setNotes(e.target.value), placeholder: lang.notes })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: CreateNewInvoice, className: "bil-create-invoice", children: lang.cbill })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "Billings",
        title: lang.noauth,
        message: lang.noauthmess,
        isOpen: alerto,
        onClose: () => setAlerto(false),
        buttons: [
          { label: lang.ok, onClick: () => setAlerto(false) }
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "Billings",
        title: lang.error,
        message: lang.fillAllFields,
        isOpen: alerto2,
        onClose: () => setAlerto2(false),
        buttons: [
          { label: lang.ok, onClick: () => setAlerto2(false) }
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "Billings",
        title: lang.error,
        message: lang.payinvoi.replace("%s", selectedInvoice.totalamount),
        isOpen: payModal,
        onClose: () => setAlerto2(false),
        buttons: [
          { label: lang.payx.replace("%s", selectedInvoice.totalamount), onClick: () => PayInvoice() },
          { label: lang.cancel, onClick: () => {
            setPayModal(false);
            setSelectedBillData([]);
          } }
        ]
      }
    )
  ] });
};
const MailComposerModal = ({ isOpen, onClose, myMail, allMails, lang, tabOwner }) => {
  const [receiver, setReceiver] = reactExports.useState("");
  const [fromMail, setFromMail] = reactExports.useState("");
  const [subject, setSubject] = reactExports.useState("");
  const [message, setMessage] = reactExports.useState("");
  const [suggestions, setSuggestions] = reactExports.useState([]);
  const [alert2, setAlerto] = reactExports.useState(false);
  const handleReceiverChange = (e) => {
    const v = e.target.value;
    setReceiver(v);
    if (v) {
      const filtered = allMails.filter((m) => m.toLowerCase().includes(v.toLowerCase()));
      setSuggestions(filtered.slice(0, 5));
    } else {
      setSuggestions([]);
    }
  };
  reactExports.useEffect(() => {
    if (myMail) {
      setFromMail(myMail);
    }
  }, [myMail]);
  const selectSuggestion = (suggestion) => {
    setReceiver(suggestion);
    setSuggestions([]);
  };
  const handleSend = () => {
    if (!receiver || !fromMail || !subject || !message) {
      setAlerto(lang.fillAllFields);
      return;
    }
    if (receiver === tabOwner) {
      setAlerto(lang.cannothim);
      return;
    }
    callNui("SendMail", {
      receiver,
      fromMail,
      subject,
      message,
      type: 0
    });
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(
    motion.div,
    {
      className: "mail-overlay",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "mail-modal",
            initial: { scale: 0.95, opacity: 0 },
            animate: { scale: 1, opacity: 1 },
            exit: { scale: 0.95, opacity: 0 },
            transition: { duration: 0.25, ease: "easeInOut" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-title2x", children: lang.newmail }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yanyana-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yanyana", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: onClose, className: "sendor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "#008bff" }, className: "fa-solid fa-xmark" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleSend, className: "sendor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-arrow-up" }) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rowan", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", marginTop: "15rem" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roxa", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "totxo", children: [
                    lang.tox,
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: handleReceiverChange, className: "to-kim", value: receiver })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bottom-bar" }),
                  suggestions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "ul",
                    {
                      style: {
                        listStyle: "none",
                        margin: "0px",
                        fontFamily: "'SF Pro Text'",
                        padding: "0.5rem",
                        fontSize: "12px",
                        zIndex: "1000",
                        background: "rgb(16, 16, 16)",
                        border: "1px solid rgb(36, 36, 36)",
                        borderRadius: "4px",
                        position: "absolute",
                        top: "3rem",
                        width: "100%",
                        boxShadow: "rgb(0 0 0 / 10%) 0px 2px 8px"
                      },
                      children: suggestions.map((s, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "li",
                        {
                          onClick: () => selectSuggestion(s),
                          style: { padding: "0.5rem 0", cursor: "pointer", borderBottom: i < suggestions.length - 1 ? "1px solid rgb(52 52 52)" : "none" },
                          children: s
                        },
                        i
                      ))
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roxa", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "totxo", children: [
                    lang.fromx,
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: (e) => setFromMail(e.target.value), className: "to-kim", value: fromMail })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bottom-bar" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "roxa", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "totxo", children: [
                    lang.subject,
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { onChange: (e) => setSubject(e.target.value), className: "to-kim", value: subject })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bottom-bar" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "roxa", children: /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { onChange: (e) => setMessage(e.target.value), value: message }) })
              ] }) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ColdModal,
          {
            appName: "Mail",
            title: lang.error,
            message: alert2,
            isOpen: alert2,
            onClose: () => setAlerto(false),
            buttons: [
              { label: lang.ok, onClick: () => {
                setAlerto(false);
              } }
            ]
          }
        )
      ]
    }
  ) });
};
const MailApp = ({ lang, tabMails, allMails, myMail, tabOwner, sentedMails, isPolice, isDojApp, dbMails, dojMail, policeMail }) => {
  const [selectedPart, setPart] = reactExports.useState("all");
  const [allInboxes, setAll] = reactExports.useState(true);
  const [sented, setSented] = reactExports.useState(false);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  reactExports.useState(false);
  const [showComposer, setShowComposer] = reactExports.useState(false);
  const [selectedMail, setMailData] = reactExports.useState(null);
  const [selectedMailId, setSelectedMailId] = reactExports.useState(null);
  const [showPoliceMail, setPoliceMails] = reactExports.useState(false);
  const [showDoj, setShowDoj] = reactExports.useState(false);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  const hideAll = () => {
    setAll(false);
    setSented(false);
    setPoliceMails(false);
    setShowDoj(false);
  };
  const justPoliceMailBox = dbMails.filter((item) => item.from === policeMail);
  const justDojMailBox = dbMails.filter((item) => item.from === dojMail);
  const changePage = (page) => {
    switch (page) {
      case "all":
        hideAll();
        setPart("all");
        setAll(true);
        break;
      case "sented":
        hideAll();
        setPart("sented");
        setSented(true);
        break;
      case "policeMails":
        hideAll();
        setPart("policeMails");
        setPoliceMails(true);
        break;
      case "dojMails":
        hideAll();
        setPart("dojMails");
        setShowDoj(true);
        break;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mailapp-frame", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "flex-start" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "new-mail-part2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignContent: "center", justifyContent: "center", flexDirection: "column" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-app-title", children: lang.mapp }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "listed-mails", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("all"), className: `photo-bar ${selectedPart == "all" ? "selected-bar" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-images" }),
              "  ",
              lang.allinboxes
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("sented"), className: `photo-bar ${selectedPart == "sented" ? "selected-bar" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-paper-plane" }),
              "  ",
              lang.sentmails
            ] }),
            isPolice && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("policeMails"), className: `photo-bar ${selectedPart == "policeMails" ? "selected-bar" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-paper-plane" }),
              "  ",
              lang.pmails
            ] }),
            isDojApp && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => changePage("dojMails"), className: `photo-bar ${selectedPart == "dojMails" ? "selected-bar" : ""}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-paper-plane" }),
              "  ",
              lang.dojmails
            ] })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "new-mail-middle", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "middle-mail-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-box-header", children: lang.allinboxes }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-box-header-desc", children: lang.connecting })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-list-x", children: [
            allInboxes && tabMails.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                onClick: () => {
                  setMailData(element);
                  setSelectedMailId(element.id);
                },
                className: `mail-list-x-item${selectedMailId === element.id ? " selected" : ""}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-minibox", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mailt-subject", children: element.from_name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-titlea", children: (() => {
                        const subject = (element.data.subject || "").trim().replace(/\s+/g, " ");
                        const words = subject.split(" ");
                        return words.length > 3 ? words.slice(0, 3).join(" ") + "..." : subject;
                      })() }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-desc", children: (() => {
                        const msg = (element.data.message || "").trim().replace(/\s+/g, " ");
                        const words = msg.split(" ");
                        return words.length > 20 ? words.slice(0, 20).join(" ") + "..." : msg;
                      })() })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-time", children: element.date })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-land" })
                ]
              },
              element.id || index
            )),
            showPoliceMail && justPoliceMailBox.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                onClick: () => {
                  setMailData(element);
                  setSelectedMailId(element.id);
                },
                className: `mail-list-x-item${selectedMailId === element.id ? " selected" : ""}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-minibox", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mailt-subject", children: element.from_name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-titlea", children: (() => {
                        const subject = (element.data.subject || "").trim().replace(/\s+/g, " ");
                        const words = subject.split(" ");
                        return words.length > 3 ? words.slice(0, 3).join(" ") + "..." : subject;
                      })() }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-desc", children: (() => {
                        const msg = (element.data.message || "").trim().replace(/\s+/g, " ");
                        const words = msg.split(" ");
                        return words.length > 20 ? words.slice(0, 20).join(" ") + "..." : msg;
                      })() })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-time", children: element.date })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-land" })
                ]
              },
              element.id || index
            )),
            showDoj && justDojMailBox.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                onClick: () => {
                  setMailData(element);
                  setSelectedMailId(element.id);
                },
                className: `mail-list-x-item${selectedMailId === element.id ? " selected" : ""}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-minibox", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mailt-subject", children: element.from_name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-titlea", children: (() => {
                        const subject = (element.data.subject || "").trim().replace(/\s+/g, " ");
                        const words = subject.split(" ");
                        return words.length > 3 ? words.slice(0, 3).join(" ") + "..." : subject;
                      })() }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-desc", children: (() => {
                        const msg = (element.data.message || "").trim().replace(/\s+/g, " ");
                        const words = msg.split(" ");
                        return words.length > 20 ? words.slice(0, 20).join(" ") + "..." : msg;
                      })() })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-time", children: element.date })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-land" })
                ]
              },
              element.id || index
            )),
            sented && sentedMails.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                onClick: () => {
                  setMailData(element);
                  setSelectedMailId(element.id);
                },
                className: `mail-list-x-item${selectedMailId === element.id ? " selected" : ""}`,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-minibox", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-info", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mailt-subject", children: element.from_name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-titlea", children: (() => {
                        const subject = (element.data.subject || "").trim().replace(/\s+/g, " ");
                        const words = subject.split(" ");
                        return words.length > 3 ? words.slice(0, 3).join(" ") + "..." : subject;
                      })() }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "mail-desc", children: [
                        " ",
                        (() => {
                          const msg = (element.data.message || "").trim().replace(/\s+/g, " ");
                          const words = msg.split(" ");
                          return words.length > 20 ? words.slice(0, 20).join(" ") + "..." : msg;
                        })()
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-time", children: element.date })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-land" })
                ]
              },
              element.id || index
            ))
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "middle-cizgi" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-ana-part", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => setShowComposer(true), className: "mail-anapart-de", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-pen-to-square" }) }),
          selectedMail && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-box-ax", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mail-box-bra-x", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "tabii-x", children: selectedMail.from_name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "tabii-x2", children: [
                lang.tox,
                " ",
                selectedMail.receiver
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "borxer" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mailcontent", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-bold", children: selectedMail.data.subject }),
              selectedMail.type == 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mail-conta", children: selectedMail.data.message }) : "",
              selectedMail.type === 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fine-mail-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "fine-mail-title", children: [
                  " ",
                  selectedMail.data.subject
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "fine-mail-date", children: [
                  lang.date,
                  ": ",
                  selectedMail.date
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "fine-mail-text", children: [
                  lang.dcitizen,
                  ",",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  lang.youhavelspdmail
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "fine-mail-list", children: selectedMail.data.fines.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "crime-name", children: element.fineLabel }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "crime-fine", children: [
                    "$",
                    element.price
                  ] })
                ] })) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fine-mail-total", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.totalPri }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    "$",
                    selectedMail.data.totalPrice
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "fine-mail-footer", children: lang.billInfo })
              ] }),
              selectedMail.type === 2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "invoice-mail-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "invoice-mail-title", children: [
                  " ",
                  lang.newinx
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "invoice-mail-sub", children: lang.yourecex }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "invoice-mail-date", children: selectedMail.date }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "invoice-mail-body", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "invoice-mail-from", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.fromx }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
                      " ",
                      selectedMail.from_name
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "invoice-mail-list", children: selectedMail.data.getProducts.map((element, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "item-desc", children: element.label }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "item-price", children: [
                      "$",
                      element.fine
                    ] })
                  ] })) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "invoice-mail-total", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.generaltotal }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                      "$",
                      selectedMail.data.totalPrice
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "invoice-mail-note", children: [
                    lang.duedate,
                    ":  ",
                    selectedMail.data.DueDate
                  ] })
                ] })
              ] })
            ] })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MailComposerModal, { tabOwner, lang, myMail, allMails, isOpen: showComposer, onClose: () => setShowComposer(false) })
  ] });
};
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim.isRequired = shim;
    function getShim() {
      return shim;
    }
    var ReactPropTypes = {
      array: shim,
      bigint: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
class Display extends reactExports.Component {
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "component-display", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: this.props.value }) });
  }
}
Display.propTypes = {
  value: PropTypes.string
};
class Button extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "handleClick", () => {
      this.props.clickHandler(this.props.name);
    });
  }
  render() {
    let className = "component-button";
    if (this.props.orange) {
      className += " orange";
    }
    if (this.props.wide) {
      className += " wide";
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: this.handleClick, children: this.props.name }) });
  }
}
Button.propTypes = {
  name: PropTypes.string,
  clickHandler: PropTypes.func,
  orange: PropTypes.bool,
  wide: PropTypes.bool
};
class ButtonPanel extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "handleClick", (buttonName) => {
      this.props.clickHandler(buttonName);
    });
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "component-button-panel", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "C", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "+/-", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "%", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "", clickHandler: this.handleClick, orange: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "7", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "8", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "9", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "x", clickHandler: this.handleClick, orange: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "4", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "5", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "6", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "-", clickHandler: this.handleClick, orange: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "1", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "2", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "3", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "+", clickHandler: this.handleClick, orange: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "0", clickHandler: this.handleClick, wide: true }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: ".", clickHandler: this.handleClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { name: "=", clickHandler: this.handleClick, orange: true })
      ] })
    ] });
  }
}
ButtonPanel.propTypes = {
  clickHandler: PropTypes.func
};
var DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, STRICT = false, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big2(n) {
    var x = this;
    if (!(x instanceof Big2)) {
      return n === UNDEFINED && arguments.length === 0 ? _Big_() : new Big2(n);
    }
    if (n instanceof Big2) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== "string") {
        if (Big2.strict === true && typeof n !== "bigint") {
          throw TypeError(INVALID + "value");
        }
        n = n === 0 && 1 / n < 0 ? "-0" : String(n);
      }
      parse(x, n);
    }
    x.constructor = Big2;
  }
  Big2.prototype = P;
  Big2.DP = DP;
  Big2.RM = RM;
  Big2.NE = NE;
  Big2.PE = PE;
  Big2.strict = STRICT;
  Big2.roundDown = 0;
  Big2.roundHalfUp = 1;
  Big2.roundHalfEven = 2;
  Big2.roundUp = 3;
  return Big2;
}
function parse(x, n) {
  var e, i, nl;
  if (!NUMERIC.test(n)) {
    throw Error(INVALID + "number");
  }
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1) n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; ) ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; ) ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; ) x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round(x, sd, rm, more) {
  var xc = x.c;
  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
    xc.length = 1;
    if (more) {
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {
    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
    xc.length = sd;
    if (more) {
      for (; ++xc[--sd] > 9; ) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }
    for (sd = xc.length; !xc[--sd]; ) xc.pop();
  }
  return x;
}
function stringify(x, doExponential, isNonzero) {
  var e = x.e, s = x.c.join(""), n = s.length;
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; ) s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--; ) s += "0";
    } else if (e < n) {
      s = s.slice(0, e) + "." + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && isNonzero ? "-" + s : s;
}
P.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;
  if (i != j) return i;
  isneg = i < 0;
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = -1; ++i < j; ) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P.div = function(y) {
  var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = p < 0 ? 0 : p;
  bz.unshift(0);
  for (; rl++ < bl; ) r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; ) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; ) r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
    p--;
  }
  if (qi > p) round(q, p, Big2.RM, r[0] !== UNDEFINED);
  return q;
};
P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.gte = function(y) {
  return this.cmp(y) > -1;
};
P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.minus = P.sub = function(y) {
  var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big2(x);
    } else {
      y.s = 1;
    }
    return y;
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--; ) t.push(0);
    t.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--; ) xc[i++] = 0;
  for (b = i; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i]; ) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; ) xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P.mod = function(y) {
  var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big2(x);
  a = Big2.DP;
  b = Big2.RM;
  Big2.DP = Big2.RM = 0;
  x = x.div(y);
  Big2.DP = a;
  Big2.RM = b;
  return this.minus(x.times(y));
};
P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};
P.plus = P.add = function(y) {
  var e, k, t, x = this, Big2 = x.constructor;
  y = new Big2(y);
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big2(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }
  xc = xc.slice();
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }
    t.reverse();
    for (; e--; ) t.push(0);
    t.reverse();
  }
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  e = yc.length;
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
  if (k) {
    xc.unshift(k);
    ++ye;
  }
  for (e = xc.length; xc[--e] === 0; ) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P.pow = function(n) {
  var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + "exponent");
  }
  if (isneg) n = -n;
  for (; ; ) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P.prec = function(sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + "precision");
  }
  return round(new this.constructor(this), sd, rm);
};
P.round = function(dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};
P.sqrt = function() {
  var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half2 = new Big2("0.5");
  if (!x.c[0]) return new Big2(x);
  if (s < 0) {
    throw Error(NAME + "No square root");
  }
  s = Math.sqrt(+stringify(x, true, true));
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1)) c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big2((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big2(s + "");
  }
  e = r.e + (Big2.DP += 4);
  do {
    t = r;
    r = half2.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round(r, (Big2.DP -= 4) + r.e + 1, Big2.RM);
};
P.times = P.mul = function(y) {
  var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }
  y.e = i + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; ) c[j] = 0;
  for (i = b; i--; ) {
    b = 0;
    for (j = a + i; j > i; ) {
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = b;
  }
  if (b) ++y.e;
  else c.shift();
  for (i = c.length; !c[--i]; ) c.pop();
  y.c = c;
  return y;
};
P.toExponential = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp; ) x.c.push(0);
  }
  return stringify(x, true, !!n);
};
P.toFixed = function(dp, rm) {
  var x = this, n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);
    for (dp = dp + x.e + 1; x.c.length < dp; ) x.c.push(0);
  }
  return stringify(x, false, !!n);
};
P.toJSON = P.toString = function() {
  var x = this, Big2 = x.constructor;
  return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, !!x.c[0]);
};
if (typeof Symbol !== "undefined") {
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toJSON;
}
P.toNumber = function() {
  var n = +stringify(this, true, true);
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + "Imprecise conversion");
  }
  return n;
};
P.toPrecision = function(sd, rm) {
  var x = this, Big2 = x.constructor, n = x.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    x = round(new Big2(x), sd, rm);
    for (; x.c.length < sd; ) x.c.push(0);
  }
  return stringify(x, sd <= x.e || x.e <= Big2.NE || x.e >= Big2.PE, !!n);
};
P.valueOf = function() {
  var x = this, Big2 = x.constructor;
  if (Big2.strict === true) {
    throw Error(NAME + "valueOf disallowed");
  }
  return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, true);
};
var Big = _Big_();
function operate(a, b, op2) {
  const x = Big(a || "0");
  const y = Big(b || "0");
  if (op2 === "+") return x.plus(y).toString();
  if (op2 === "-") return x.minus(y).toString();
  if (op2 === "x" || op2 === "" || op2 === "*") return x.times(y).toString();
  if (op2 === "" || op2 === "/") return y.eq(0) ? "Error" : x.div(y).toString();
  if (op2 === "%") return x.mod(y).toString();
  return "0";
}
function calculate({ total, next, operation }, buttonName) {
  if (buttonName === "C") return { total: "0", next: null, operation: null };
  if (["+", "-", "x", "", "*", "/", "%"].includes(buttonName)) {
    if (next) return { total: next, next: null, operation: buttonName };
    return { operation: buttonName };
  }
  if (buttonName === "=") {
    if (next && operation) {
      const result = operate(total, next, operation);
      return { total: result, next: null, operation: null };
    }
    return {};
  }
  if (buttonName === ".") {
    if (next) {
      if (!next.includes(".")) return { next: next + "." };
      return {};
    }
    return { next: "0." };
  }
  return next ? { next: next + buttonName } : { next: buttonName };
}
function CalculatorApp() {
  const [s, setS] = reactExports.useState({ total: null, next: null, operation: null });
  const handleClick = (buttonName) => {
    setS((prev) => ({
      ...prev,
      ...calculate(prev, buttonName)
    }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "calculator-component", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Display, { value: s.next || s.total || "0" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonPanel, { clickHandler: handleClick })
  ] });
}
const MapApp = ({ lang, pName }) => {
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  const [mapUrl, setMapUrl] = reactExports.useState("https://map.0resmon.org");
  const [myCoords, setMyCoords] = reactExports.useState([]);
  const [myLocation, setLocation] = reactExports.useState(null);
  const [showModal, setShowModal] = reactExports.useState(false);
  const [players, setPlayers] = reactExports.useState([]);
  const [sharedLoctions, setSharedLocs] = reactExports.useState([]);
  const [blips, setBlips] = reactExports.useState([]);
  const [pato, setPato] = reactExports.useState(false);
  const iframeRef = reactExports.useRef();
  const [selectedLoc, setSelLoc] = reactExports.useState(null);
  const [selectedCoords, setSelectedCoords] = reactExports.useState(null);
  reactExports.useEffect(() => {
    callNui("getAllBlipsAndPlayers", {}, (data) => {
      setBlips(data.blips);
      setPlayers(data.players);
    });
  }, []);
  reactExports.useEffect(() => {
    callNui("getSharedLocations", {}, (data) => {
      setSharedLocs(data);
    });
  });
  reactExports.useEffect(() => {
    callNui("getMyCoords", {}, (data) => {
      setMyCoords({ x: data.x, y: data.y, z: data.z });
      setLocation(data.location);
    });
  }, []);
  reactExports.useEffect(() => {
    if (!iframeRef.current) {
      return;
    }
    const iframeWindow = iframeRef.current.contentWindow;
    if (!iframeWindow) {
      return;
    }
    iframeWindow.postMessage({
      type: "navi",
      coords: myCoords,
      name: pName,
      address: myLocation
    }, "*");
  }, [myCoords, pName, myLocation]);
  reactExports.useEffect(() => {
    const handleMsg = (e) => {
      var _a2;
      if (((_a2 = e.data) == null ? void 0 : _a2.type) !== "blip-click") return;
      const dest = e.data.coords;
      const dx = dest.x - myCoords.x;
      const dy = dest.y - myCoords.y;
      const dist = Math.hypot(dx, dy);
      const speed = 7;
      const etaSec = dist / speed;
      const m = Math.floor(etaSec / 60);
      const s = Math.floor(etaSec % 60);
      setSelLoc(lang.varis.replace("%s", `${m}`).replace("%s", `${s}`));
      setSelectedCoords({ x: dest.x, y: dest.y, z: dest.z, time: lang.varis.replace("%s", `${m}`).replace("%s", `${s}`) });
    };
    window.addEventListener("message", handleMsg);
    return () => window.removeEventListener("message", handleMsg);
  }, [myCoords]);
  reactExports.useEffect(() => {
    const interval = setInterval(() => setTime(/* @__PURE__ */ new Date()), 6e4);
    return () => clearInterval(interval);
  }, []);
  const shareTo = (player) => {
    callNui("shareMyLocationTo", {
      pcid: player.cid
    }, (data) => {
      setSharedLocs([(prev) => [...prev, data]]);
    });
    setShowModal(false);
  };
  const selectLoc = () => {
    setPato(true);
  };
  const setOnMap = () => {
    callNui("setOnMap", {
      coords: selectedCoords
    });
    setSelLoc(null);
    setSelectedCoords(null);
  };
  reactExports.useEffect(() => {
    if (blips.length || myCoords || sharedLoctions.length) {
      const blipCoords = blips.map((b) => `${Math.round(b.x)},${Math.round(b.y)},${b.sprite}`);
      const me = myCoords ? [`${Math.round(myCoords.x)},${Math.round(myCoords.y)},navi`] : [];
      const shared = sharedLoctions.map((s) => `${Math.round(s.x)},${Math.round(s.y)},shared`);
      const all2 = [...blipCoords, ...me, ...shared];
      setMapUrl(`https://map.0resmon.org/?coords=${all2.join("|")}`);
    }
  }, [blips, myCoords, sharedLoctions]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "map-app-frame", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { zIndex: 100 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        ref: iframeRef,
        src: mapUrl,
        title: "GTA5 Map",
        className: "map-iframe",
        allow: "geolocation",
        sandbox: "allow-scripts allow-same-origin",
        onLoad: () => {
          iframeRef.current.contentWindow.postMessage({
            type: "navi",
            coords: myCoords,
            name: pName,
            address: myLocation
          }, "*");
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "share-location-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "map-app-title", children: lang.citysmap }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spanlab", children: lang.favourites }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fav-loc", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: selectLoc, className: "fav-loc-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { style: { color: "#fff" }, className: "fa-solid fa-plus" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: selectLoc, className: "fav-loc-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `https://docs.fivem.net/blips/radar_jewelry_heist.png` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: selectLoc, className: "fav-loc-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `https://docs.fivem.net/blips/radar_safehouse.png` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: selectLoc, className: "fav-loc-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `https://docs.fivem.net/blips/radar_police_station_blue.png` }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: selectLoc, className: "fav-loc-item", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: `https://docs.fivem.net/blips/radar_horde.png` }) })
      ] }),
      selectedLoc && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { top: "3rem" }, className: "spanlab", children: lang.locinfo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "showLocax", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: setOnMap, className: "markerpoint", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-car" }),
          "   ",
          selectedLoc
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "spanlab", style: { top: "3rem", fontSize: "12px" }, children: lang.shmyloca }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: () => setShowModal(true), className: "share-button", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-share-from-square" }),
        lang.shmyloca
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `mapapp-modal-overlay ${showModal ? "mapapp-show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mapapp-modal-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: lang.whom }),
      players.map((pl) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mapapp-player-item", onClick: () => shareTo(pl), children: pl.name }, pl.id)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mapapp-close-modal", onClick: () => setShowModal(false), children: lang.close })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "Map",
        title: lang.error,
        message: lang.soona,
        isOpen: pato,
        onClose: () => setPato(false),
        buttons: [
          { label: lang.ok, onClick: () => setPato(false) }
        ]
      }
    )
  ] });
};
const BossDeskApp = () => {
  var _a2, _b;
  const [activeTab, setActiveTab] = reactExports.useState("kasa");
  const [companyBalance, setCompanyBalance] = reactExports.useState(15e4);
  const [employees, setEmployees] = reactExports.useState([
    { id: 1, name: "Ahmet Ylmaz", role: "Mdr", lastActive: "5 dakika nce", salary: 15e3, sales: 23, revenue: 45e3, permissions: ["view", "manage"] },
    { id: 2, name: "Aye Demir", role: "Sat Uzman", lastActive: "12 dakika nce", salary: 8500, sales: 18, revenue: 32e3, permissions: ["view"] },
    { id: 3, name: "Mehmet Kaya", role: "Kasa Grevlisi", lastActive: "1 saat nce", salary: 7e3, sales: 14, revenue: 7e3, permissions: ["view"] },
    { id: 4, name: "Fatma z", role: "Sat Danman", lastActive: "3 saat nce", salary: 6500, sales: 9, revenue: 12e3, permissions: [] }
  ]);
  const [transactions, setTransactions] = reactExports.useState([
    { id: 1, type: "in", amount: 5e3, employee: "Aye Demir", date: "2024-01-15 14:30", description: "Sat geliri" },
    { id: 2, type: "out", amount: 2e3, employee: "Ahmet Ylmaz", date: "2024-01-15 12:15", description: "Krtasiye alm" },
    { id: 3, type: "out", amount: 15e3, employee: "Sistem", date: "2024-01-14 09:00", description: "Maa demesi - Ahmet Ylmaz" }
  ]);
  const [announcements, setAnnouncements] = reactExports.useState([
    { id: 1, title: "VIP Mteri Ziyareti", content: "Yarn saat 14:00'da VIP mteri gelecek. Herkes temiz gmlek giysin.", date: "2024-01-15", priority: "high" },
    { id: 2, title: "Aylk Toplant", content: "Cuma gn saat 16:00'da aylk deerlendirme toplants yaplacak.", date: "2024-01-14", priority: "medium" }
  ]);
  const [showTransactionModal, setShowTransactionModal] = reactExports.useState(false);
  const [showEmployeeModal, setShowEmployeeModal] = reactExports.useState(false);
  const [showAnnouncementModal, setShowAnnouncementModal] = reactExports.useState(false);
  const [editingEmployee, setEditingEmployee] = reactExports.useState(null);
  const [transactionForm, setTransactionForm] = reactExports.useState({ type: "in", amount: "", description: "" });
  const [employeeForm, setEmployeeForm] = reactExports.useState({ name: "", role: "", salary: "", permissions: [] });
  const [announcementForm, setAnnouncementForm] = reactExports.useState({ title: "", content: "", priority: "medium" });
  const handleTransaction = () => {
    if (!transactionForm.amount) return;
    const newTransaction = {
      id: transactions.length + 1,
      type: transactionForm.type,
      amount: parseFloat(transactionForm.amount),
      employee: "Manuel lem",
      date: (/* @__PURE__ */ new Date()).toLocaleString("tr-TR"),
      description: transactionForm.description || (transactionForm.type === "in" ? "Para yatrma" : "Para ekme")
    };
    setTransactions([newTransaction, ...transactions]);
    setCompanyBalance(
      (prev) => transactionForm.type === "in" ? prev + parseFloat(transactionForm.amount) : prev - parseFloat(transactionForm.amount)
    );
    setShowTransactionModal(false);
    setTransactionForm({ type: "in", amount: "", description: "" });
  };
  const handleEmployeeSubmit = () => {
    if (!employeeForm.name || !employeeForm.role || !employeeForm.salary) return;
    if (editingEmployee) {
      setEmployees(employees.map(
        (emp) => emp.id === editingEmployee.id ? { ...emp, ...employeeForm, salary: parseFloat(employeeForm.salary) } : emp
      ));
    } else {
      const newEmployee = {
        id: employees.length + 1,
        name: employeeForm.name,
        role: employeeForm.role,
        salary: parseFloat(employeeForm.salary),
        lastActive: "imdi",
        sales: 0,
        revenue: 0,
        permissions: employeeForm.permissions
      };
      setEmployees([...employees, newEmployee]);
    }
    setShowEmployeeModal(false);
    setEditingEmployee(null);
    setEmployeeForm({ name: "", role: "", salary: "", permissions: [] });
  };
  const handleDeleteEmployee = (id2) => {
    if (window.confirm("Bu alan silmek istediinize emin misiniz?")) {
      setEmployees(employees.filter((emp) => emp.id !== id2));
    }
  };
  const handleAnnouncementSubmit = () => {
    if (!announcementForm.title || !announcementForm.content) return;
    const newAnnouncement = {
      id: announcements.length + 1,
      ...announcementForm,
      date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0]
    };
    setAnnouncements([newAnnouncement, ...announcements]);
    setShowAnnouncementModal(false);
    setAnnouncementForm({ title: "", content: "", priority: "medium" });
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("tr-TR", {
      style: "currency",
      currency: "TRY",
      minimumFractionDigits: 0
    }).format(amount);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "boss-desk-app", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Briefcase, { size: 24 }),
          " BossDesk"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "company-name", children: "irket Ynetim Sistemi" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-right", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 16 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Patron" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "nav-tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `nav-tab ${activeTab === "kasa" ? "active" : ""}`,
          onClick: () => setActiveTab("kasa"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 18 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Kasa Takibi" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `nav-tab ${activeTab === "calisanlar" ? "active" : ""}`,
          onClick: () => setActiveTab("calisanlar"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { size: 18 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "alanlar" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `nav-tab ${activeTab === "performans" ? "active" : ""}`,
          onClick: () => setActiveTab("performans"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 18 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Performans" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `nav-tab ${activeTab === "duyurular" ? "active" : ""}`,
          onClick: () => setActiveTab("duyurular"),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: 18 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Duyurular" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app-content", children: [
      activeTab === "kasa" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Kasa Takibi" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-primary", onClick: () => setShowTransactionModal(true), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 18 }),
            "lem Yap"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon green", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 24 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Mevcut Bakiye" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: formatCurrency(5e3) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon green", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 24 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Bugn k giri" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: formatCurrency(5e3) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-icon red", children: /* @__PURE__ */ jsxRuntimeExports.jsx(TrendingUp, { size: 24, style: { transform: "rotate(180deg)" } }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-label", children: "Bugnk k" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "stat-value", children: formatCurrency(17e3) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transactions-list", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Son lemler" }),
          transactions.map((transaction) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `transaction-item ${transaction.type}`, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-left", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `transaction-icon ${transaction.type}`, children: transaction.type === "in" ? "+" : "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "transaction-info", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "transaction-desc", children: transaction.description }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "transaction-meta", children: [
                  transaction.employee,
                  "  ",
                  transaction.date
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `transaction-amount ${transaction.type}`, children: [
              transaction.type === "in" ? "+" : "-",
              formatCurrency(transaction.amount)
            ] })
          ] }, transaction.id))
        ] })
      ] }),
      activeTab === "calisanlar" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "alan Ynetimi" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-primary", onClick: () => setShowEmployeeModal(true), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 18 }),
            "alan Ekle"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "employees-list", children: employees.map((employee) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "employee-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "employee-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "employee-info", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: employee.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "employee-role", children: employee.role })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "employee-actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-icon",
                  onClick: () => {
                    setEditingEmployee(employee);
                    setEmployeeForm(employee);
                    setShowEmployeeModal(true);
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(PenLine, { size: 16 })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "btn-icon delete",
                  onClick: () => handleDeleteEmployee(employee.id),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 16 })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "employee-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Clock$1, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: employee.lastActive })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DollarSign, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                formatCurrency(employee.salary),
                "/ay"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-item", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, { size: 14 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: employee.permissions.length > 0 ? employee.permissions.join(", ") : "Yetki yok" })
            ] })
          ] })
        ] }, employee.id)) })
      ] }),
      activeTab === "performans" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: " Performans" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "performance-grid", children: employees.map((employee) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "performance-card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "performance-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: employee.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "role-badge", children: employee.role })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "performance-stats", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "perf-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "perf-label", children: "Toplam Sat" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "perf-value", children: employee.sales })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "perf-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "perf-label", children: "Kazandrd" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "perf-value green", children: formatCurrency(employee.revenue) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "perf-stat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "perf-label", children: "Verimlilik" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "progress-fill",
                  style: { width: `${Math.min(employee.revenue / 5e4 * 100, 100)}%` }
                }
              ) })
            ] })
          ] })
        ] }, employee.id)) })
      ] }),
      activeTab === "duyurular" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tab-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Duyurular & Grevler" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-primary", onClick: () => setShowAnnouncementModal(true), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { size: 18 }),
            "Duyuru Ekle"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "announcements-list", children: announcements.map((announcement) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `announcement-card ${announcement.priority}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcement-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: announcement.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `priority-badge ${announcement.priority}`, children: announcement.priority === "high" ? "Yksek" : announcement.priority === "medium" ? "Orta" : "Dk" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: announcement.content }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "announcement-footer", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Calendar, { size: 14 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: announcement.date })
          ] })
        ] }, announcement.id)) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showTransactionModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "modal-overlayx",
        onClick: () => setShowTransactionModal(false),
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "modalx",
            onClick: (e) => e.stopPropagation(),
            initial: { opacity: 0, scale: 0.95 },
            animate: { opacity: 1, scale: 1 },
            exit: { opacity: 0, scale: 0.95 },
            transition: { duration: 0.2, ease: "easeInOut" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-headerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Kasa lemi" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-icon", onClick: () => setShowTransactionModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-bodyx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "lem Tipi" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "radio-group", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "radio-label", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "radio",
                          name: "type",
                          value: "in",
                          checked: transactionForm.type === "in",
                          onChange: (e) => setTransactionForm({ ...transactionForm, type: e.target.value })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Para Girii" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "radio-label", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "radio",
                          name: "type",
                          value: "out",
                          checked: transactionForm.type === "out",
                          onChange: (e) => setTransactionForm({ ...transactionForm, type: e.target.value })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Para k" })
                    ] })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Tutar" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "0.00",
                      value: transactionForm.amount,
                      onChange: (e) => setTransactionForm({ ...transactionForm, amount: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Aklama" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "lem aklamas...",
                      value: transactionForm.description,
                      onChange: (e) => setTransactionForm({ ...transactionForm, description: e.target.value })
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: () => setShowTransactionModal(false), children: "ptal" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleTransaction, children: "lemi Kaydet" })
              ] })
            ]
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showAnnouncementModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "modal-overlayx",
        onClick: () => setShowAnnouncementModal(false),
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "modalx",
            onClick: (e) => e.stopPropagation(),
            initial: { opacity: 0, scale: 0.9 },
            animate: { opacity: 1, scale: 1 },
            exit: { opacity: 0, scale: 0.9 },
            transition: { duration: 0.2, ease: "easeInOut" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-headerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Yeni Duyuru" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-icon", onClick: () => setShowAnnouncementModal(false), children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-bodyx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Balk" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "Duyuru bal...",
                      value: announcementForm.title,
                      onChange: (e) => setAnnouncementForm({ ...announcementForm, title: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "erik" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Duyuru ierii...",
                      rows: "4",
                      value: announcementForm.content,
                      onChange: (e) => setAnnouncementForm({ ...announcementForm, content: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "ncelik" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: announcementForm.priority,
                      onChange: (e) => setAnnouncementForm({ ...announcementForm, priority: e.target.value }),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "low", children: "Dk" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "medium", children: "Orta" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "high", children: "Yksek" })
                      ]
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: () => setShowAnnouncementModal(false), children: "ptal" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleAnnouncementSubmit, children: "Duyuru Yap" })
              ] })
            ]
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: showEmployeeModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "modal-overlayx",
        onClick: () => {
          setShowEmployeeModal(false);
          setEditingEmployee(null);
          setEmployeeForm({ name: "", role: "", salary: "", permissions: [] });
        },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "modalx",
            onClick: (e) => e.stopPropagation(),
            initial: { opacity: 0, scale: 0.95 },
            animate: { opacity: 1, scale: 1 },
            exit: { opacity: 0, scale: 0.95 },
            transition: { duration: 0.2, ease: "easeInOut" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-headerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: editingEmployee ? "alan Dzenle" : "Yeni alan Ekle" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-icon", onClick: () => {
                  setShowEmployeeModal(false);
                  setEditingEmployee(null);
                  setEmployeeForm({ name: "", role: "", salary: "", permissions: [] });
                }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-bodyx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Ad Soyad" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "alan ad...",
                      value: employeeForm.name,
                      onChange: (e) => setEmployeeForm({ ...employeeForm, name: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Grev" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "Grev/Pozisyon...",
                      value: employeeForm.role,
                      onChange: (e) => setEmployeeForm({ ...employeeForm, role: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Aylk Maa" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "0.00",
                      value: employeeForm.salary,
                      onChange: (e) => setEmployeeForm({ ...employeeForm, salary: e.target.value })
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Yetkiler" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "checkbox-group", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "checkbox-label", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "checkbox",
                          checked: (_a2 = employeeForm.permissions) == null ? void 0 : _a2.includes("view"),
                          onChange: (e) => {
                            const perms = [...employeeForm.permissions || []];
                            if (e.target.checked) {
                              perms.push("view");
                            } else {
                              const index = perms.indexOf("view");
                              if (index > -1) perms.splice(index, 1);
                            }
                            setEmployeeForm({ ...employeeForm, permissions: perms });
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Grntleme" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "checkbox-label", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "checkbox",
                          checked: (_b = employeeForm.permissions) == null ? void 0 : _b.includes("manage"),
                          onChange: (e) => {
                            const perms = [...employeeForm.permissions || []];
                            if (e.target.checked) {
                              perms.push("manage");
                            } else {
                              const index = perms.indexOf("manage");
                              if (index > -1) perms.splice(index, 1);
                            }
                            setEmployeeForm({ ...employeeForm, permissions: perms });
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Ynetim" })
                    ] })
                  ] })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-footerx", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-secondary", onClick: () => {
                  setShowEmployeeModal(false);
                  setEditingEmployee(null);
                  setEmployeeForm({ name: "", role: "", salary: "", permissions: [] });
                }, children: "ptal" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: handleEmployeeSubmit, children: editingEmployee ? "Gncelle" : "Ekle" })
              ] })
            ]
          }
        )
      }
    ) })
  ] }) });
};
const BatteryDeadScreen = ({ lang, onChargerConnect }) => {
  const [showChargingHint, setShowChargingHint] = reactExports.useState(false);
  const [isCharging, setIsCharging] = reactExports.useState(false);
  const [chargeProgress, setChargeProgress] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const hintTimer = setTimeout(() => {
      setShowChargingHint(true);
    }, 2e3);
    return () => clearTimeout(hintTimer);
  }, []);
  const usePowerBank = () => {
    callNui("usePowerBank", {}, (res) => {
      if (res) {
        setIsCharging(true);
        let current = 0;
        const interval = setInterval(() => {
          current += 5;
          setChargeProgress(current);
          if (current >= 100) {
            clearInterval(interval);
            callNui("updateChargeWait", { value: res });
            setTimeout(() => {
              if (onChargerConnect) onChargerConnect();
            }, 500);
          }
        }, 100);
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "battery-dead-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-dead-gradient" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "battery-dead-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "battery-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Battery,
          {
            size: 120,
            className: "battery-icon",
            strokeWidth: 1.5
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-fill" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "warning-badge", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "!" }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "battery-dead-title", children: lang.batterovered }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "battery-dead-subtitle", children: lang.batterydesc }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `charging-hint ${showChargingHint ? "show" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: usePowerBank, className: "hint-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Zap, { className: "zap-icon", size: 24 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hint-text", children: lang.usePowerBank })
      ] }) }),
      isCharging && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "charge-progress-bar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "charge-progress-fill",
            style: { width: `${chargeProgress}%` }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "charge-progress-text", children: [
          chargeProgress,
          "%"
        ] })
      ] }),
      onChargerConnect && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: onChargerConnect,
          className: "test-button",
          children: lang.usePowerBank
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "corner-glow-top" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "corner-glow-bottom" })
  ] }) });
};
function ToggleSwitch({ checked, onChange, label, input }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "toggle-row", style: {
    display: "flex",
    alignItems: "center",
    gap: 13,
    fontWeight: 600,
    cursor: "pointer",
    marginBottom: 7
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { minWidth: 124 }, children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "toggle-switch2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "checkbox",
          checked,
          onChange,
          style: { display: "none" }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `slider6${checked ? " on" : ""}` })
    ] }),
    input
  ] });
}
function EnterVerdictModal({ open, onClose, onSubmit, lang, data, allCrimes }) {
  const presetOffenseIds = reactExports.useMemo(
    () => Array.isArray(data == null ? void 0 : data.articles) ? data.articles.map((s) => s.case_id) : [],
    [data == null ? void 0 : data.articles]
  );
  const [selectedOffenses, setSelectedOffenses] = reactExports.useState([]);
  const [prison, setPrison] = reactExports.useState(false);
  const [prisonTime, setPrisonTime] = reactExports.useState("");
  const [communityService, setCommunityService] = reactExports.useState(false);
  const [communityTime, setCommunityTime] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (open) setSelectedOffenses(presetOffenseIds);
  }, [open, presetOffenseIds]);
  const [notes, setNotes] = reactExports.useState("");
  const [search2, setSearch] = reactExports.useState("");
  const handleOffenseChange = (id2) => {
    setSelectedOffenses(
      (prev) => prev.includes(id2) ? prev.filter((o) => o !== id2) : [...prev, id2]
    );
  };
  const filteredCrimes = reactExports.useMemo(() => {
    const s = search2.toLowerCase();
    return (allCrimes || []).filter(
      (c) => c.name.toLowerCase().includes(s) || String(c.fine).includes(s)
    );
  }, [allCrimes, search2]);
  const totalFine = allCrimes.filter((c) => selectedOffenses.includes(c.id)).reduce((sum2, crime) => sum2 + (crime.fine || 0), 0);
  const totalSentence = allCrimes.filter((c) => selectedOffenses.includes(c.id)).reduce((sum2, crime) => sum2 + (crime.sentence || 0), 0);
  const handleSubmit = () => {
    if (selectedOffenses.length === 0) {
      alert("Bir su semek zorundasn, hakim bey/hanm!");
      return;
    }
    if (prison && (!prisonTime || isNaN(prisonTime) || prisonTime < 1)) {
      alert("Hapise gnderiyorsan geerli bir sre gir!");
      return;
    }
    if (communityService && (!communityTime || isNaN(communityTime) || communityTime < 1)) {
      alert("Kamu cezas veriyorsan geerli bir sre gir!");
      return;
    }
    onSubmit({
      crimes: allCrimes.filter((c) => selectedOffenses.includes(c.id)),
      notes,
      totalSentence,
      totalFine,
      prison,
      prisonTime: prison ? Number(prisonTime) : 0,
      communityService,
      communityTime: communityService ? Number(communityTime) : 0
    });
    callNui("verdictCase", {
      crimeId: data.crime_id,
      crimes: allCrimes.filter((c) => selectedOffenses.includes(c.id)),
      notes,
      totalSentence,
      totalFine,
      prison,
      prisonTime: prison ? Number(prisonTime) : 0,
      communityService,
      communityTime: communityService ? Number(communityTime) : 0
    });
    setSelectedOffenses([]);
    setNotes("");
    setPrison(false);
    setPrisonTime("");
    setCommunityService(false);
    setCommunityTime("");
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
  .modal2-backdrop {
         position: fixed;
    inset: 0;
    background: rgb(4 4 4 / 88%);
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .modal2-box {
        background: #0c0c0c;
    color: #e0e3ee;
    border-radius: 16px;
    width: 600px;
    max-width: 94vw;
    box-shadow: 0 16px 48px 0 #01040eaa;
    padding: 32px 30px 22px 30px;
    position: relative;
    max-height: 88vh;
    overflow-y: auto;
    border: 1.5px solid #202020;
    font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
    font-smooth: always;
    letter-spacing: 0.01em;
  }
  .modal2-close-btn {
    position: absolute;
    right: 18px;
    top: 10px;
    background: none;
    color: #9298a6;
    border: none;
    font-size: 27px;
    font-weight: 700;
    cursor: pointer;
    transition: color .18s;
  }
  .modal2-close-btn:hover {
    color: #e74c3c;
  }
  .suspect-list {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 12px;
  }
  .suspect-badge {
        background: #222736;
    color: #e0eaff;
    border-radius: 7px;
    padding: 3px 7px 3px 7px;
    font-family: 'SF PRO TEXT';
    font-weight: 100;
    font-size: 11px;
    box-shadow: 0 1px 2px #0004;
    border: 1px solid #31394d;
  }
  .police-note {
        background: #1c1c1c;
    color: #fcba61;
    border-radius: 7px;
    padding: 8px 13px;
    margin-bottom: 13px;
    font-size: 13px;
    font-weight: 500;
    border-left: 3px solid #ffcb6b;
  }
  .modal-search {
       width: 100%;
    margin-bottom: 10px;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid #2c2c2c;
    background: #0e0e10;
    color: #f0f0f0;
    font-family: 'SF Pro Text';
    font-size: 13px;
    transition: border .13s;
  }
  .modal-search:focus {
    border: 1.5px solid #448aff;
    outline: none;
  }
  .offense-list {
        margin-top: 4px;
    margin-bottom: 12px;
    max-height: 148px;
    font-weight: 100;
    font-family: SF Pro Text;
    overflow-y: auto;
    border: 1px solid #2e2e2e;
    border-radius: 7px;
    padding: 7px 9px 7px 8px;
    background: #0e0e0e;
    font-size: 12.2px;
  }
  .offense-item {
       display: flex;
    align-items: center;
    padding: 5px 2px 5px 2px;
    cursor: pointer;
    border-radius: 6px;
    margin-bottom: 1px;
    transition: background .13s, color .11s;
    color: #d3d7e7;
    user-select: none;
  }
  .offense-item.selected {
    background: #129dff45;
    color: #36c3ee;
  }
  .offense-item:hover {
    background: #212531;
    color: #5db0fa;
  }
  textarea {
       width: 100%;
    min-height: 60px;
    margin-top: 12px;
    font-weight: 100;
    border-radius: 7px;
    border: 1px solid #24273a;
    padding: 8px;
    resize: vertical;
    background: #191d29;
    color: #f5f5f7;
    font-size: 13.5px;
    font-family: 'SF Pro Text';
    letter-spacing: 0.01em;
  }
  .modalxx-actions {
    display: flex;
    gap: 10px;
    margin-top: 18px;
  }
  .modalxx-btn {
    padding: 10px 18px;
    border: none;
    border-radius: 7px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: background .15s, color .12s, box-shadow .13s;
    box-shadow: 0 1px 3px #0002;
    letter-spacing: 0.01em;
  }
  .modalxx-btn-primary {
    background: #35c8a1;
    color: #091012;
    font-weight: 700;
  }
  .modalxx-btn-primary:hover {
    background: #26997c;
    color: #f5fffa;
  }
  .modalxx-btn-secondary {
    background: #212535;
    color: #dde1ff;
  }
  .modalxx-btn-secondary:hover {
    background: #181a25;
    color: #ef5350;
  }
  h2 {
    font-family: inherit;
    font-size: 26px;
    font-weight: 700;
    letter-spacing: .02em;
    color: #d7e2fa;
    margin-bottom: 15px;
    margin-top: 4px;
    text-shadow: 0 1px 2px #0003;
  }
  ::-webkit-scrollbar { width: 7px; background: #161823; }
  ::-webkit-scrollbar-thumb { background: #21242e; border-radius: 6px; }
` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: open && /* @__PURE__ */ jsxRuntimeExports.jsx(
      motion.div,
      {
        className: "modal2-backdrop",
        variants: {
          visible: { opacity: 1 },
          hidden: { opacity: 0 }
        },
        initial: "hidden",
        animate: "visible",
        exit: "hidden",
        onClick: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          motion.div,
          {
            className: "modal2-box",
            variants: {
              hidden: { scale: 0.92, opacity: 0, y: 40 },
              visible: { scale: 1, opacity: 1, y: 0 }
            },
            initial: "hidden",
            animate: "visible",
            exit: "hidden",
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modal2-close-btn", onClick: onClose, children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { fontWeight: 600, fontSize: 25, marginBottom: 16 }, children: lang.enterdec }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "suspect-list", children: (Array.isArray(data == null ? void 0 : data.offenders) ? data.offenders : []).map((name, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "suspect-badge", children: (name == null ? void 0 : name.name) || name || `${suspici} ${index + 1}` }, (name == null ? void 0 : name.name) || name || index)) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "police-note", children: (data == null ? void 0 : data.description) ? data.description : lang.nonot }),
              Array.isArray(data == null ? void 0 : data.media) && data.media.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                margin: "18px 0 8px 0",
                background: "#181b23",
                borderRadius: 8,
                border: "1px solid #23263a",
                padding: 12,
                boxShadow: "0 1px 4px #0004"
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, fontSize: 15.5, color: "#82d4ff", marginBottom: 7 }, children: lang.evidence }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 14 }, children: Array.isArray(data == null ? void 0 : data.evidence) && data.evidence.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  margin: "18px 0 8px 0",
                  background: "#181b23",
                  borderRadius: 8,
                  border: "1px solid #23263a",
                  padding: 12,
                  boxShadow: "0 1px 4px #0004"
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, fontSize: 15.5, color: "#82d4ff", marginBottom: 7 }, children: lang.evidence }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 14 }, children: data.evidence.map((e, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    background: "#222632",
                    borderRadius: 7,
                    padding: 8,
                    width: 110,
                    boxShadow: "0 1px 4px #0002"
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: e.url, alt: e.desc || lang.evidence, style: {
                      width: 90,
                      height: 70,
                      objectFit: "cover",
                      borderRadius: 6,
                      border: "1.2px solid #262b3a"
                    } }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                      color: "#bcc7db",
                      fontSize: 12.5,
                      marginTop: 5,
                      textAlign: "center",
                      fontWeight: 500,
                      maxWidth: 100,
                      wordBreak: "break-word"
                    }, children: e.desc || lang.evidence })
                  ] }, e.url || idx)) })
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 8, marginTop: 16 }, children: lang.offpunish }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  className: "modal-search",
                  type: "text",
                  placeholder: lang.crsearch,
                  value: search2,
                  onChange: (e) => setSearch(e.target.value)
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "offense-list", children: filteredCrimes.map((crime) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: `offense-item ${selectedOffenses.includes(crime.id) ? "selected" : ""}`,
                  onClick: () => handleOffenseChange(crime.id),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    crime.name,
                    "  $",
                    crime.fine
                  ] })
                },
                crime.id
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { margin: "14px 0 5px 0", display: "flex", gap: 25, flexWrap: "wrap" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ToggleSwitch,
                  {
                    checked: prison,
                    onChange: (e) => setPrison(e.target.checked),
                    label: lang.sendjail,
                    input: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "number",
                        placeholder: lang.durmonth,
                        style: {
                          width: 66,
                          marginLeft: 7,
                          background: prison ? "#23242b" : "#19191a",
                          color: "#e7eaf5",
                          border: "1px solid #292929",
                          borderRadius: 5,
                          padding: "4px 6px",
                          fontSize: 13,
                          opacity: prison ? 1 : 0.6,
                          transition: "background .16s, opacity .18s"
                        },
                        min: 1,
                        disabled: !prison,
                        value: prisonTime,
                        onChange: (e) => setPrisonTime(e.target.value.replace(/^0+/, ""))
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ToggleSwitch,
                  {
                    checked: communityService,
                    onChange: (e) => setCommunityService(e.target.checked),
                    label: lang.publicceza,
                    input: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "number",
                        placeholder: lang.timeand,
                        style: {
                          width: 66,
                          marginLeft: 7,
                          background: communityService ? "#23242b" : "#19191a",
                          color: "#e7eaf5",
                          border: "1px solid #292929",
                          borderRadius: 5,
                          padding: "4px 6px",
                          fontSize: 13,
                          opacity: communityService ? 1 : 0.6,
                          transition: "background .16s, opacity .18s"
                        },
                        min: 1,
                        disabled: !communityService,
                        value: communityTime,
                        onChange: (e) => setCommunityTime(e.target.value.replace(/^0+/, ""))
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 13 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("b", { children: [
                  lang.totalceza,
                  ":"
                ] }),
                " $",
                totalFine,
                " ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: notes,
                  onChange: (e) => setNotes(e.target.value),
                  placeholder: "Hakim aklamas (opsiyonel)"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modalxx-actions", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modalxx-btn modalxx-btn-primary", onClick: handleSubmit, children: lang.approvedecision }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "modalxx-btn modalxx-btn-secondary", onClick: onClose, children: lang.cancel })
              ] })
            ]
          }
        )
      }
    ) })
  ] });
}
const DOJApp = ({ lang, batteryLevel, allPersonelCrimes, pname, tabJob, courtRooms, allDataCourts, allCrimes }) => {
  const [isDarkMode, setIsDarkMode] = reactExports.useState(true);
  const [activeTab, setActiveTab] = reactExports.useState("dashboard");
  const [userRole, setUserRole] = reactExports.useState("judge");
  const [showModal, setShowModal] = reactExports.useState(false);
  const [selectedCase, setSelectedCase] = reactExports.useState(null);
  const [warrantTab, setWarrantTab] = reactExports.useState("person");
  const [showRejectModal, setShowRejectModal] = reactExports.useState(false);
  const [rejectReason, setRejectReason] = reactExports.useState("");
  const [rejectingItem, setRejectingItem] = reactExports.useState(null);
  const [modalClosing, setModalClosing] = reactExports.useState(false);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const [dataPersonal, setDataPersonal] = reactExports.useState([]);
  const [courtTime, setCourtTime] = reactExports.useState(null);
  const [courtDate, setCourtDate] = reactExports.useState(null);
  const [modalOpen, setModalOpen] = reactExports.useState(false);
  const [allCourts, setAllCourts] = reactExports.useState([]);
  const [courtData, setCourtData] = reactExports.useState([]);
  const [judges, setJudges] = reactExports.useState([]);
  const [selectedJudge, setSelectedJudge] = reactExports.useState([]);
  const [notes, setNotes] = reactExports.useState("");
  const [al, setal] = reactExports.useState(false);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  reactExports.useEffect(() => {
    if (activeTab === "pending") setSelectedCase(null);
  }, [activeTab]);
  const handleVerdictSubmit = (verdict) => {
  };
  const approveCase = () => {
    callNui("approveCase", {
      id: selectedCase.crime_id
    });
    setSelectedCase(null);
  };
  reactExports.useEffect(() => {
    setAllCourts(allDataCourts);
  }, [allDataCourts]);
  const closeModal = (modalType) => {
    setModalClosing(true);
    setTimeout(() => {
      if (modalType === "reject") {
        setShowRejectModal(false);
        setRejectReason("");
        setRejectingItem(null);
      } else {
        setShowModal(false);
      }
      setModalClosing(false);
    }, 300);
  };
  const openHodal = (casex) => {
    setSelectedCase(casex);
    setModalOpen(true);
  };
  const createNewCourt = () => {
    if (!selectedCase || !courtDate || !courtTime || !selectedJudge || !courtData) {
      setal(true);
      return;
    }
    callNui("createNewCourt", {
      caseid: selectedCase.crime_id,
      courtDate,
      courtTime,
      judge: selectedJudge,
      courtData,
      notes,
      type: "citizen"
    });
    closeModal("schedule");
  };
  const ConfirmRejectX = () => {
    callNui("RejectCrime", {
      id: selectedCase.crime_id,
      reason: rejectReason
    });
    closeModal("reject");
  };
  reactExports.useEffect(() => {
    if (courtRooms && courtRooms.length > 0) {
      setCourtData(JSON.stringify({
        id: 1,
        name: courtRooms[0].RoomName,
        location: courtRooms[0].location
      }));
    }
  }, [courtRooms]);
  reactExports.useEffect(() => {
    setDataPersonal(allPersonelCrimes);
    callNui("getDojUsers", { type: "judges" }, (data) => {
      setJudges(data);
      if (data && data.length > 0) {
        setSelectedJudge(JSON.stringify({ cid: data[0].cid, name: data[0].name }));
      }
    });
  }, [allPersonelCrimes]);
  const justPendingData = Array.isArray(dataPersonal) ? dataPersonal.filter((item) => item.status === 0) : [];
  const justActiveData = Array.isArray(dataPersonal) ? dataPersonal.filter((item) => item.status === 1) : [];
  const justVerdictedData = Array.isArray(dataPersonal) ? dataPersonal.filter((item) => item.status === 4) : [];
  const mockWarrants = {
    person: [
      { id: "PWR-001", name: "James Miller", requester: "Det. Wilson", date: "2024-03-15", reason: "Armed Robbery Suspect" },
      { id: "PWR-002", name: "Lisa Brown", requester: "Det. Garcia", date: "2024-03-14", reason: "Fraud Investigation" }
    ],
    vehicle: [
      { id: "VWR-001", plate: "ABC-1234", requester: "Officer Smith", date: "2024-03-15", reason: "Vehicle used in robbery" },
      { id: "VWR-002", plate: "XYZ-5678", requester: "Officer Davis", date: "2024-03-14", reason: "Suspected drug transport" }
    ]
  };
  const renderDashboard = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stats-grid", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: lang.pendikcases }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: justPendingData.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-change positive", children: "+12% from last week" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: lang.activecas }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: justActiveData.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-change negative", children: "-5% from last week" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stat-card", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-label", children: lang.caseclo }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-value", children: justVerdictedData.length }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "stat-change positive", children: "+18% this month" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.todaycourttitle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: () => setShowModal(true), children: lang.schedulehearing })
      ] }),
      allCourts.map((hearing, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hearing-card", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hearing-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hearing-time", children: hearing.time }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hearing-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hearing-detail", children: [
            hearing.case_id,
            " - ",
            hearing.type
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hearing-detail", children: hearing.assigned_judge.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hearing-detail", children: [
            hearing.courtroom.salonName,
            " - ",
            hearing.courtroom.location
          ] })
        ] })
      ] }) }) }, idx))
    ] })
  ] });
  const renderPendingCases = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.pendikcases }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-secondary", children: lang.waitingcasepending.replace("%s", justPendingData.length) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.casenumber }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.suspect }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.charge }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.officer }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.status }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.actions })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: justPendingData.map((case_) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: case_.crime_id }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: (() => {
            const names = (case_.offenders || []).map((s) => s.name);
            const joined = names.join(", ");
            return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
          })() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: (() => {
            const names = (case_.offenders || []).map((s) => s.name);
            const joined = names.join(", ");
            return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
          })() }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: case_.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: case_.officer_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge status-pending", children: case_.status === 0 ? lang.pending : lang.approved }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-primary btn-sm",
              onClick: () => setSelectedCase(case_),
              children: lang.viewcase
            }
          ) })
        ] }, case_.crime_id)) })
      ] }) }),
      selectedCase && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "case-details", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { style: { marginBottom: "20px" }, children: [
          lang.casedetails,
          ": ",
          selectedCase.crime_id
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.suspect,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginTop: ".5rem" }, children: (() => {
            const names = ((selectedCase == null ? void 0 : selectedCase.offenders) || []).map((s) => s.name);
            const joined = names.join(", ");
            return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
          })() })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.charge,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginTop: ".5rem" }, children: (() => {
            const names = ((selectedCase == null ? void 0 : selectedCase.articles) || []).map((s) => s.name);
            const joined = names.join(", ");
            return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
          })() })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.arofficer,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedCase.officer_name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail-row", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "detail-label", children: [
            lang.date,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedCase.date })
        ] }),
        (userRole === "judge" || userRole === "prosecutor") && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "action-buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: approveCase, className: "btn btn-success", children: lang.approvecase }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-danger",
              onClick: () => {
                setRejectingItem({ type: "case", item: selectedCase });
                setShowRejectModal(true);
              },
              children: lang.rejcase
            }
          ),
          userRole === "judge" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-secondary", children: lang.aspersonel })
        ] })
      ] }, selectedCase.crime_id)
    ] });
  };
  const renderActiveCases = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.accases }) }),
    justActiveData.map((case_) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", style: { background: "var(--bg-primary)" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
        case_.crime_id,
        " - ",
        (() => {
          const names = (case_.offenders || []).map((s) => s.name);
          const joined = names.join(", ");
          return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
        })()
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "16px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "status-badge status-active", children: case_.status === 1 ? lang.approved : lang.rejected }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid-2", style: { marginTop: "20px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "detail-label", children: lang.prosecutor }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: case_.approved_by })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "detail-label", children: lang.defense }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: case_.lawyer ? case_.lawyer : lang.lawnotyet })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { marginBottom: "16px" }, children: lang.casetimeline }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timeline", children: (case_.timeline || []).map((element, index) => {
          let label = "";
          if (element.type === "created") label = lang.offencecreated.replace("%s", case_.officer_name);
          else if (element.type === "approved") label = lang.caseapprovedfrom.replace("%s", case_.approved_by);
          else if (element.type === "rejected") label = lang.rejectedmsg.replace("%s%s", case_.crime_id, case_.approved_by);
          else if (element.type === "hourtcreated") label = lang.hourtcreated.replace("%s", element.created).replace("%d", element.date);
          else label = element.label;
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timeline-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timeline-dot" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timeline-content", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timeline-date", children: element.date }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: label })
            ] })
          ] }, index);
        }) })
      ] }),
      userRole === "judge" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "action-buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => openHodal(case_), className: "btn btn-primary", children: lang.enterverdict }) })
    ] }, case_.crime_id))
  ] });
  const renderWarrants = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "card-header", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.warreqs }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${warrantTab === "person" ? "active" : ""}`,
          onClick: () => setWarrantTab("person"),
          children: lang.personwarrants
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${warrantTab === "vehicle" ? "active" : ""}`,
          onClick: () => setWarrantTab("vehicle"),
          children: lang.vehwarrants
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "table-container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.id }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: warrantTab === "person" ? "Name" : "License Plate" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.requester }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.date }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.reason }),
        (userRole === "judge" || userRole === "prosecutor") && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: lang.actions })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: mockWarrants[warrantTab].map((warrant) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: warrant.id }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: warrant.name || warrant.plate }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: warrant.requester }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: warrant.date }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: warrant.reason }),
        (userRole === "judge" || userRole === "prosecutor") && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-success btn-sm", children: lang.approve }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "btn btn-danger btn-sm",
              onClick: () => {
                setRejectingItem({ type: "warrant", item: warrant });
                setShowRejectModal(true);
              },
              children: lang.reject
            }
          )
        ] }) })
      ] }, warrant.id)) })
    ] }) })
  ] });
  const renderRejectModal = () => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `modal-overlayra ${modalClosing ? "modal-closing" : ""}`, onClick: () => closeModal("reject"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modalar", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-title", children: lang.rejectreason }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: () => closeModal("reject"), children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: "form-label", children: [
          lang.whyreject,
          " ",
          rejectingItem == null ? void 0 : rejectingItem.type,
          "?"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "textarea",
          {
            className: "form-textarea",
            rows: "5",
            value: rejectReason,
            onChange: (e) => setRejectReason(e.target.value),
            placeholder: "Please provide a detailed reason for rejection..."
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.commonreasons }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "8px", width: "27.5rem" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: () => setRejectReason(lang.reason1),
              children: lang.reason1
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: () => setRejectReason(lang.reason2),
              children: lang.reason2
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: "btn btn-secondary",
              onClick: () => setRejectReason(lang.reason3),
              children: lang.reason3
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "12px", marginTop: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-danger",
            style: { flex: 1 },
            disabled: !rejectReason.trim(),
            onClick: () => {
              ConfirmRejectX();
            },
            children: lang.confirmreject
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: "btn btn-secondary",
            style: { flex: 1 },
            onClick: () => closeModal("reject"),
            children: lang.cancel
          }
        )
      ] })
    ] })
  ] }) });
  const renderModal = () => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `modal-overlayra ${modalClosing ? "modal-closing" : ""}`, onClick: () => closeModal("schedule"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modalt", onClick: (e) => e.stopPropagation(), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "modal-title", children: lang.schcourt }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: () => closeModal("schedule"), children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-groupa", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.casenumber }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            onChange: (e) => {
              const found = justActiveData.find((x) => x.crime_id === e.target.value);
              setSelectedCase(found);
            },
            className: "form-select",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: lang.selectcase }),
              justActiveData.map((c) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "option",
                {
                  value: c.crime_id,
                  children: [
                    c.crime_id,
                    " - ",
                    (() => {
                      const names = c.offenders.map((s) => s.name);
                      const joined = names.join(", ");
                      return joined.length > 40 ? joined.slice(0, 40) + "..." : joined;
                    })()
                  ]
                },
                c.crime_id
              ))
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: "20px", width: "16.5rem" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.date }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { value: courtDate, onChange: (e) => setCourtDate(e.target.value), type: "date", className: "form-input" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { marginBottom: "20px", width: "16.5rem" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.time }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("input", { value: courtTime, onChange: (e) => setCourtTime(e.target.value), type: "time", className: "form-input" })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.assignjudges }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("select", { onChange: (e) => setSelectedJudge(e.target.value), className: "form-select", children: judges.map((element, index) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: JSON.stringify({ cid: element.cid, name: element.name }), children: element.name }, element.cid);
        }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.courtrooms }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            onChange: (e) => setCourtData(e.target.value),
            className: "form-select",
            value: courtData,
            children: courtRooms.map((element, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "option",
              {
                value: JSON.stringify({ id: idx + 1, name: element.RoomName, location: element.location }),
                children: [
                  element.RoomName,
                  " - ",
                  element.location
                ]
              },
              idx
            ))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", style: { width: "34rem" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "form-label", children: lang.addnotes }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { onChange: (e) => setNotes(e.target.value), value: notes, className: "form-textarea", rows: "3" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "12px", marginTop: "24px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: createNewCourt, type: "button", className: "btn btn-primary", style: { flex: 1 }, children: lang.schcourt }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn btn-secondary", style: { flex: 1 }, onClick: () => closeModal("schedule"), children: lang.cancel })
      ] })
    ] })
  ] }) }) });
  const renderContent = () => {
    switch (activeTab) {
      case "dashboard":
        return renderDashboard();
      case "pending":
        return renderPendingCases();
      case "active":
        return renderActiveCases();
      case "warrants":
        return renderWarrants();
      case "history":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.verhistory }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "20px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-secondary)" }, children: lang.closedhisto }) })
        ] }) });
      case "calendar":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "card-header", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "card-title", children: lang.courtcalendar }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn btn-primary", onClick: () => setShowModal(true), children: lang.schedulehearing })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "20px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--text-secondary)" }, children: lang.displayedcourts }) })
        ] });
      default:
        return renderDashboard();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `app-container ${isDarkMode ? "" : "light-mode"}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { margin: "0", height: "0", width: "1rem", top: ".8rem", position: "absolute" }, className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icons battery", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-shell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "battery-level",
              style: {
                width: `${batteryLevel}%`,
                backgroundColor: batteryLevel < 20 ? "red" : "rgb(227 227 227)"
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "battery-percent", children: [
            batteryLevel,
            "%"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: "sidebar", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "logox", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "logo-icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-gavel" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: lang.dojsystem })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "nav-menu", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `nav-link ${activeTab === "dashboard" ? "active" : ""}`,
              onClick: () => setActiveTab("dashboard"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chart-simple" }),
                "  ",
                lang.dashboard
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `nav-link ${activeTab === "pending" ? "active" : ""}`,
              onClick: () => setActiveTab("pending"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-gavel" }),
                "  ",
                lang.pendikcases
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `nav-link ${activeTab === "active" ? "active" : ""}`,
              onClick: () => setActiveTab("active"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-square-check" }),
                "  ",
                lang.accases
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `nav-link ${activeTab === "history" ? "active" : ""}`,
              onClick: () => setActiveTab("history"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-folder-open" }),
                "  ",
                lang.verdicthis
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: "nav-item", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: `nav-link ${activeTab === "calendar" ? "active" : ""}`,
              onClick: () => setActiveTab("calendar"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-calendar" }),
                "  ",
                lang.courtcalendar
              ]
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            className: "form-select",
            value: userRole,
            onChange: (e) => setUserRole(e.target.value),
            style: { marginBottom: "20px" },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "judge", children: "Judge" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "prosecutor", children: "Prosecutor" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "lawyer", children: "Lawyer" })
            ]
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { className: "main-content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("h1", { className: "page-title", children: [
            activeTab === "dashboard" && lang.dashboard,
            activeTab === "pending" && lang.pendikcases,
            activeTab === "active" && lang.accases,
            activeTab === "warrants" && lang.warreqs,
            activeTab === "history" && lang.verdicthis,
            activeTab === "calendar" && lang.courtcalendar
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-rightx", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-infox", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-avatarx", children: userRole === "judge" ? "J" : userRole === "prosecutor" ? "P" : "L" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "user-detailsx", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-namex", children: pname }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "user-rolex", children: userRole.charAt(0).toUpperCase() + userRole.slice(1) })
            ] })
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content-area", children: renderContent() }),
        showModal && renderModal(),
        showRejectModal && renderRejectModal()
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ColdModal,
      {
        appName: "DojApp",
        title: lang.error,
        message: lang.emptyFields,
        isOpen: al,
        onClose: () => setal(false),
        buttons: [
          { label: lang.ok, onClick: () => setal(false) }
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      EnterVerdictModal,
      {
        open: modalOpen,
        onClose: () => setModalOpen(false),
        data: selectedCase,
        lang,
        allCrimes,
        onSubmit: handleVerdictSubmit
      }
    )
  ] });
};
const CustomDropdown = ({ value, onChange, options, placeholder = "Select...", isDarkMode = true, style = {} }) => {
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const dropdownRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const selectedOption = options.find((opt) => opt.value === value);
  const dropdownStyles = {
    container: {
      position: "relative",
      width: "100%",
      ...style
    },
    trigger: {
      width: "100%",
      padding: "12px 16px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      border: "none",
      borderRadius: "10px",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      transition: "all 0.2s ease",
      outline: "none",
      ...isOpen && {
        backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.15)" : "rgba(0, 0, 0, 0.08)"
      }
    },
    dropdown: {
      position: "absolute",
      top: "calc(100% + 4px)",
      left: 0,
      right: 0,
      backgroundColor: isDarkMode ? "#2C2C2E" : "#FFFFFF",
      borderRadius: "10px",
      boxShadow: "0 10px 40px rgba(0, 0, 0, 0.3)",
      overflow: "hidden",
      opacity: isOpen ? 1 : 0,
      transform: isOpen ? "translateY(0)" : "translateY(-10px)",
      visibility: isOpen ? "visible" : "hidden",
      transition: "all 0.2s ease",
      zIndex: 1e3,
      maxHeight: "240px",
      overflowY: "auto"
    },
    option: {
      padding: "12px 16px",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      cursor: "pointer",
      transition: "all 0.15s ease",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      backgroundColor: "transparent"
    },
    chevron: {
      transition: "transform 0.2s ease",
      transform: isOpen ? "rotate(180deg)" : "rotate(0deg)",
      color: isDarkMode ? "rgba(255, 255, 255, 0.6)" : "rgba(0, 0, 0, 0.6)"
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: dropdownRef, style: dropdownStyles.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type: "button",
        style: dropdownStyles.trigger,
        onClick: () => setIsOpen(!isOpen),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedOption ? selectedOption.label : placeholder }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { size: 18, style: dropdownStyles.chevron })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: dropdownStyles.dropdown, children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          ...dropdownStyles.option,
          ...value === option.value ? {
            backgroundColor: isDarkMode ? "rgba(0, 122, 255, 0.3)" : "rgba(0, 122, 255, 0.1)",
            color: "#007AFF"
          } : {}
        },
        onClick: () => {
          onChange(option.value);
          setIsOpen(false);
        },
        onMouseEnter: (e) => {
          if (value !== option.value) {
            e.currentTarget.style.backgroundColor = isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)";
          }
        },
        onMouseLeave: (e) => {
          if (value !== option.value) {
            e.currentTarget.style.backgroundColor = "transparent";
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: option.label }),
          value === option.value && /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 16 })
        ]
      },
      option.value
    )) })
  ] });
};
const ApplicationModal = ({ lang, open, onClose, onSubmit, isDark, isDarkMode, setApplications: setApplications2 }) => {
  const [role, setRole] = reactExports.useState("Muhabir");
  const [name, setName] = reactExports.useState("");
  const [age, setAge] = reactExports.useState("");
  const [experience, setExperience] = reactExports.useState("");
  const [grades, setGrades] = reactExports.useState([]);
  const [motivation, setMotivation] = reactExports.useState("");
  const [submitting, setSubmitting] = reactExports.useState(false);
  reactExports.useEffect(() => {
    callNui("getJournalists", {}, (data) => {
      var _a2;
      if ((_a2 = data.data) == null ? void 0 : _a2.length) setGrades(data.getGrades);
    });
  }, []);
  const roleOptions = reactExports.useMemo(
    () => grades.map((g) => ({ value: g.gradelevel, label: g.label })),
    [grades]
  );
  if (!open) return null;
  const sendReq = () => {
    callNui("createJobApplications", {
      role,
      name,
      age,
      experience,
      motivation
    }, (res) => {
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.38)",
        zIndex: 9999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: (e) => e.stopPropagation(),
            style: {
              minWidth: 350,
              width: "100%",
              maxWidth: 420,
              background: isDark ? "#19191b" : "#f7f7f9",
              borderRadius: 20,
              boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
              padding: 32,
              transform: "translateY(24px) scale(0.98)",
              opacity: 0,
              animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
              border: isDark ? "1px solid #222226" : "1px solid #ebebee",
              color: isDark ? "#fff" : "#19191b",
              position: "relative"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: isDark ? "#222" : "#e4e8ef",
                      color: isDark ? "#fdc70a" : "#9b8800",
                      borderRadius: 12,
                      width: 32,
                      height: 32,
                      alignItems: "center",
                      justifyContent: "center",
                      marginRight: 10,
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user-plus" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 21, fontWeight: 700 }, children: lang.apply })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", flexDirection: "column", gap: 17 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontWeight: 600, fontSize: 14 }, children: [
                    lang.firstName,
                    " ",
                    lang.lastName
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: lang.ne,
                      value: name,
                      onChange: (e) => setName(e.target.value),
                      style: {
                        width: "93%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: isDark ? "1px solid #28282c" : "1px solid #ddd",
                        background: isDark ? "#202024" : "#fff",
                        color: isDark ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: lang.age }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "number",
                        min: 15,
                        placeholder: lang.age,
                        value: age,
                        onChange: (e) => setAge(e.target.value),
                        style: {
                          width: "82%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: isDark ? "1px solid #28282c" : "1px solid #ddd",
                          background: isDark ? "#202024" : "#fff",
                          color: isDark ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none"
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: lang.role }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: ".5rem" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CustomDropdown,
                      {
                        value: role,
                        onChange: (v) => setRole(v),
                        options: roleOptions,
                        isDarkMode,
                        placeholder: lang.selrole
                      }
                    ) })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: lang.experience }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: lang.expp,
                      value: experience,
                      onChange: (e) => setExperience(e.target.value),
                      style: {
                        width: "93%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: isDark ? "1px solid #28282c" : "1px solid #ddd",
                        background: isDark ? "#202024" : "#fff",
                        color: isDark ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: lang.motivation }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      rows: 2,
                      placeholder: lang.whyy,
                      value: motivation,
                      onChange: (e) => setMotivation(e.target.value),
                      style: {
                        width: "93%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: isDark ? "1px solid #28282c" : "1px solid #ddd",
                        background: isDark ? "#202024" : "#fff",
                        color: isDark ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    disabled: submitting,
                    style: {
                      marginTop: 15,
                      background: "#007AFF",
                      color: "#fff",
                      border: "none",
                      borderRadius: 12,
                      fontWeight: 700,
                      fontSize: 16,
                      padding: "13px 0",
                      boxShadow: "0 3px 9px 0 rgba(0,99,255,0.05)",
                      cursor: submitting ? "not-allowed" : "pointer",
                      opacity: submitting ? 0.7 : 1,
                      transition: "all .17s"
                    },
                    onClick: sendReq,
                    children: submitting ? lang.sending : lang.senx
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  style: {
                    position: "absolute",
                    top: 18,
                    right: 22,
                    background: "transparent",
                    border: "none",
                    color: isDark ? "#888" : "#222",
                    fontSize: 22,
                    cursor: "pointer"
                  },
                  onClick: onClose,
                  children: ""
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
      ]
    }
  );
};
const WeazelNewsApp = ({ lang, batteryLevel, news, isBoss, applications, playerGalleryData }) => {
  var _a2;
  const [isDarkMode, setIsDarkMode] = reactExports.useState(true);
  const [activeCategory, setActiveCategory] = reactExports.useState("all");
  const [selectedArticle, setSelectedArticle] = reactExports.useState(null);
  const [showStaffPanel, setShowStaffPanel] = reactExports.useState(false);
  const [showApplications, setShowApplications] = reactExports.useState(false);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  reactExports.useState(true);
  const [isOwner, setIsOwner] = reactExports.useState(false);
  const [applicationsOpen, setApplicationsOpen] = reactExports.useState(true);
  const [showMobileMenu, setShowMobileMenu] = reactExports.useState(false);
  const [selectedMedias, setSelectedMedias] = reactExports.useState([]);
  const [pato, setPato] = reactExports.useState(false);
  reactExports.useState(false);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const [newArticleTags, setNewArticleTags] = reactExports.useState([]);
  const [tagInput, setTagInput] = reactExports.useState("");
  const [showApplyModal, setShowApplyModal] = reactExports.useState(false);
  const [activeStaffTab, setActiveStaffTab] = reactExports.useState("create");
  const [newPoll, setNewPoll] = reactExports.useState({ question: "", options: ["", "", "", ""] });
  const [journalist, setJournalist] = reactExports.useState([]);
  const [getGrades, setGrades] = reactExports.useState([]);
  const [commentText, setCommentText] = reactExports.useState("");
  const [players, setPlayers] = reactExports.useState([]);
  const [nofity, setNofity] = reactExports.useState({
    title: "",
    msg: ""
  });
  const [applikasyons, setNewApplikasyons] = reactExports.useState([]);
  reactExports.useEffect(() => {
    setNewApplikasyons(applications);
  }, [applications]);
  reactExports.useEffect(() => {
    setIsOwner(isBoss);
  }, [isBoss]);
  const openStaffPanel = () => {
    callNui("getJournalists", {}, (data) => {
      if (data.data && data.data.length > 0) {
        setJournalist(data.data);
        setGrades(data.getGrades);
        setPlayers(data.players);
        data.getGrades.map((grade) => ({
          value: grade.gradelevel,
          label: grade.label
        }));
      }
    });
    setShowStaffPanel(true);
  };
  const roleOptions = React.useMemo(() => {
    return (getGrades || []).map((grade) => ({
      value: grade.gradelevel,
      label: grade.label
    }));
  }, [getGrades]);
  const handleUpdateNofity = (title, msg) => {
    setNofity((nofity2) => ({ ...nofity2, title, msg }));
    setPato(true);
  };
  function handleCreatePoll() {
    if (!newPoll.question.trim() || newPoll.options.filter((opt) => opt && opt.trim()).length < 2) return;
    setNewPoll({ question: "", options: ["", "", "", ""] });
  }
  const [galleryOpen, setGalleryOpen] = reactExports.useState(false);
  const [playerGallery, setPlayerGallery] = reactExports.useState([]);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  const [newArticle, setNewArticle] = reactExports.useState({
    headline: "",
    summary: "",
    content: "",
    category: "community",
    image: ""
  });
  const [newStaffName, setNewStaffName] = reactExports.useState("");
  const [newStaffNameInput, setNewStaffNameInput] = reactExports.useState("");
  const [newStaffCid, setNewStaffCid] = reactExports.useState("");
  const [newStaffRole, setNewStaffRole] = reactExports.useState("Kameraman");
  const [newStaffSalary, setNewStaffSalary] = reactExports.useState("");
  reactExports.useState({});
  const [articles, setArticles] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const sortedNews = news.map((article) => ({
      ...article,
      comments: [...article.comments].reverse()
    }));
    setArticles(sortedNews);
  }, [news]);
  const handleAddStaff = () => {
    console.log(newStaffName, newStaffRole);
    if (!newStaffName || !newStaffRole) {
      handleUpdateNofity(lang.error, lang.emptyFields);
      return;
    }
    const staffItem = {
      id: staff.length + 1,
      cid: newStaffCid,
      name: newStaffName,
      role: newStaffRole,
      joinDate: /* @__PURE__ */ new Date()
    };
    callNui("addNewStaff", { staffItem }, (res) => setJournalist(res));
    setStaff([...staff, staffItem]);
    setNewStaffRole("Kameraman");
    setNewStaffSalary("");
  };
  reactExports.useState({
    role: "Muhabir",
    name: "",
    age: "",
    experience: "",
    motivation: ""
  });
  reactExports.useState(false);
  reactExports.useEffect(() => setPlayerGallery(playerGalleryData), [playerGalleryData]);
  reactExports.useEffect(() => {
    const style = document.createElement("style");
    style.textContent = `
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes slideDown {
      from { transform: translateY(-100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .news-card:hover {
      transform: translateY(-4px);
      box-shadow: ${isDarkMode ? "0 8px 30px rgba(0, 0, 0, 0.7)" : "0 8px 30px rgba(0, 0, 0, 0.15)"};
    }
    .icon-button:hover {
      background-color: ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)"};
    }
    .category-button:hover {
      transform: scale(1.05);
    }
    .search-input:focus {
      background-color: ${isDarkMode ? "rgba(255, 255, 255, 0.15)" : "rgba(0, 0, 0, 0.08)"};
    }
    .button:hover {
      background-color: #0051D5;
      transform: scale(1.02);
    }
    .button:active {
      transform: scale(0.98);
    }
    
    /* SCROLL FIX - Mobile override' kaldrld */
    @media (max-width: 768px) {
  .header-actions > *:not(.mobile-menu-button) {
    display: none;
  }
  .mobile-menu-button {
    display: flex !important;
  }
  .search-bar {
    max-width: 200px;
  }
  /* news-grid ksm tamamen kaldrld */
}
  `;
    document.head.appendChild(style);
    return () => document.head.removeChild(style);
  }, [isDarkMode]);
  const [chatMessages, setChatMessages] = reactExports.useState([
    { author: "Anon2244", message: "Selam millet!" },
    { author: "Emir", message: "u yayna bak aw" }
  ]);
  const [chatInput, setChatInput] = reactExports.useState("");
  const [chatNameType, setChatNameType] = reactExports.useState("anon");
  const playerName = "Emir";
  reactExports.useEffect(() => {
    const msgDiv = document.getElementById("live-chat-messages");
    if (msgDiv) msgDiv.scrollTop = msgDiv.scrollHeight;
  }, [chatMessages]);
  const [staff, setStaff] = reactExports.useState([
    { id: 1, name: "Sarah Chen", role: "Senior Reporter", joinDate: new Date(2024, 0, 15) },
    { id: 2, name: "David Kim", role: "Financial Editor", joinDate: new Date(2024, 2, 20) },
    { id: 3, name: "James Rodriguez", role: "Sports Correspondent", joinDate: new Date(2024, 1, 10) }
  ]);
  const categories = [
    { id: "all", name: lang.allnews, icon: Newspaper, color: "#007AFF" },
    { id: "breaking", name: lang.breaking, icon: CircleAlert, color: "#FF3B30" },
    { id: "crime", name: lang.crimea, icon: Shield, color: "#FF9500" },
    { id: "community", name: lang.community, icon: User, color: "#34C759" },
    { id: "economy", name: lang.economy, icon: DollarSign, color: "#5856D6" },
    { id: "sports", name: lang.Sports, icon: Trophy, color: "#00C7BE" },
    { id: "magazine", name: lang.magazine, icon: Newspaper, color: "#FF2D55" }
    // { id: 'live', name: 'Live', icon: 'live', color: '#fd4545ff'}
  ];
  const filteredArticles = news.filter((article) => {
    const matchesCategory = activeCategory === "all" || article.category === activeCategory;
    const matchesSearch = article.data.headline.toLowerCase().includes(searchQuery.toLowerCase()) || article.data.summary.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesCategory && matchesSearch;
  }).reverse();
  const postComment = () => {
    callNui("postComment", {
      postId: selectedArticle.code,
      comment: commentText
    }, (res) => {
      if (res) {
        setSelectedArticle((prev) => ({
          ...prev,
          comments: [res, ...prev.comments]
        }));
        setCommentText("");
      }
    });
  };
  const handleApplicationDecision = (appId, decision) => {
    const application = applications.find((app) => app.id === appId);
    if (decision === "accept" && application) {
      setStaff([...staff, {
        id: staff.length + 1,
        name: application.name,
        role: "Reporter",
        joinDate: /* @__PURE__ */ new Date()
      }]);
    }
    setApplications(applications.filter((app) => app.id !== appId));
  };
  const handleRemoveStaff = (staffId, staffName) => {
    callNui("removeJournalist", { staffId, staffName }, (res) => {
      setJournalist((prev) => prev.filter((j) => j.cid !== staffId));
    });
  };
  const handlePublishArticle = () => {
    if (newArticle.headline && newArticle.summary && newArticle.content && (newArticle.image || selectedMedias.length > 0)) {
      const mainImage = selectedMedias[0] || newArticle.image;
      const extraGallery = selectedMedias.slice(1);
      ({
        id: articles.length + 1,
        ...newArticle,
        image: mainImage,
        gallery: extraGallery,
        author: "Staff Reporter",
        timestamp: /* @__PURE__ */ new Date(),
        likes: 0,
        comments: []
      });
      callNui("createNewHaber", { newArticle, selectedMedias, newArticleTags });
      setSelectedMedias([]);
      setShowStaffPanel(false);
    } else {
      handleUpdateNofity(lang.error, lang.emptyFields);
    }
  };
  const formatTime = (date) => {
    const d = date instanceof Date ? date : new Date(date * 1e3);
    const now2 = /* @__PURE__ */ new Date();
    const diff = now2 - d;
    const hours = Math.floor(diff / 36e5);
    if (hours < 1) return `${Math.floor(diff / 6e4)}m ago`;
    if (hours < 24) return `${hours}h ago`;
    return d.toLocaleDateString();
  };
  const getCategoryColor = (categoryId) => {
    const category = categories.find((cat) => cat.id === categoryId);
    return category ? category.color : "#007AFF";
  };
  const [currentModalIndex, setCurrentModalIndex] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (selectedArticle) setCurrentModalIndex(0);
  }, [selectedArticle]);
  const styles = {
    app: {
      height: "100vh",
      display: "flex",
      flexDirection: "column",
      overflow: "hidden"
      // Eklendi
    },
    mainContent: {
      flex: 1,
      display: "flex",
      flexDirection: "column",
      minHeight: 0,
      overflow: "hidden"
      // Eklendi
    },
    header: {
      backgroundColor: isDarkMode ? "rgba(28, 28, 30, 0.95)" : "rgba(255, 255, 255, 0.95)",
      backdropFilter: "blur(20px)",
      borderBottom: `1px solid ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"}`,
      position: "sticky",
      top: 0,
      flexShrink: 0,
      zIndex: 100
    },
    headerContent: {
      maxWidth: "1200px",
      margin: "0 auto",
      height: "70px",
      padding: "0 32px",
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      gap: "16px",
      position: "relative"
    },
    logo: {
      fontSize: "24px",
      fontWeight: "700",
      letterSpacing: "-0.5px",
      background: "linear-gradient(135deg, rgb(227 32 32) 0%, rgb(223 112 112) 100%) text",
      WebkitTextFillColor: "transparent",
      whiteSpace: "nowrap"
    },
    searchBar: {
      flex: 1,
      maxWidth: "400px",
      position: "relative"
    },
    searchInput: {
      width: "100%",
      padding: "10px 16px 10px 40px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      border: "none",
      borderRadius: "10px",
      marginTop: "1rem",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      outline: "none",
      transition: "all 0.2s ease"
    },
    headerActions: {
      display: "flex",
      alignItems: "center",
      gap: "18px",
      minWidth: "220px",
      justifyContent: "flex-end"
    },
    iconButton: {
      padding: "8px",
      backgroundColor: "transparent",
      border: "none",
      borderRadius: "8px",
      cursor: "pointer",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      transition: "all 0.2s ease",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    breakingNews: {
      backgroundColor: "#FF3B30",
      color: "#FFFFFF",
      padding: "12px 24px",
      display: "flex",
      flexShrink: 0,
      alignItems: "center",
      gap: "12px",
      animation: "slideDown 0.3s ease",
      position: "relative"
    },
    categoryBar: {
      backgroundColor: isDarkMode ? "rgba(28, 28, 30, 0.95)" : "rgba(255, 255, 255, 0.95)",
      borderBottom: `1px solid ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"}`,
      position: "sticky",
      top: "70px",
      zIndex: 90,
      overflowX: "auto",
      flexShrink: 0,
      WebkitOverflowScrolling: "touch"
    },
    categoryContent: {
      maxWidth: "1200px",
      margin: "0 auto",
      padding: "12px 24px",
      display: "flex",
      gap: "8px",
      minWidth: "max-content"
    },
    categoryButton: {
      padding: "8px 16px",
      borderRadius: "20px",
      border: "none",
      fontSize: "14px",
      fontWeight: "500",
      cursor: "pointer",
      transition: "all 0.2s ease",
      display: "flex",
      alignItems: "center",
      gap: "6px",
      whiteSpace: "nowrap"
    },
    newsGrid: {
      flex: 1,
      overflowY: "scroll",
      // EKLE
      height: "60vh",
      // EKLE
      overflowX: "hidden",
      // Yatay scroll'u engelle
      padding: "24px",
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(320px, 1fr))",
      gap: "24px",
      boxSizing: "border-box"
      // Padding dahil hesapla
    },
    newsCard: {
      background: isDarkMode ? "rgba(28, 28, 30, 0.55)" : "rgba(255, 255, 255, 0.55)",
      backdropFilter: "blur(8px)",
      borderRadius: "16px",
      overflow: "hidden",
      cursor: "pointer",
      transition: "all 0.3s ease",
      boxShadow: isDarkMode ? "0 4px 20px rgba(0, 0, 0, 0.5)" : "0 4px 20px rgba(0, 0, 0, 0.1)",
      transform: "translateY(0)"
    },
    cardImage: {
      width: "100%",
      height: "200px",
      objectFit: "cover"
    },
    cardContent: {
      padding: "20px"
    },
    cardCategory: {
      fontSize: "10px",
      fontWeight: "600",
      textTransform: "uppercase",
      letterSpacing: "0.5px",
      marginBottom: "0px",
      display: "inline-block",
      padding: "4px 8px",
      borderRadius: "4px"
    },
    cardHeadline: {
      fontSize: "20px",
      fontWeight: "700",
      lineHeight: "1.3",
      marginBottom: "8px",
      letterSpacing: "-0.3px"
    },
    cardSummary: {
      fontSize: "15px",
      lineHeight: "1.5",
      opacity: 0.7,
      marginBottom: "12px"
    },
    cardMeta: {
      display: "flex",
      alignItems: "center",
      gap: "16px",
      fontSize: "13px",
      opacity: 0.6
    },
    modal: {
      position: "fixed",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      backdropFilter: "blur(10px)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 100,
      padding: "24px",
      animation: "fadeIn 0.2s ease"
    },
    modalContent: {
      backgroundColor: "rgb(28, 28, 30)",
      borderRadius: "20px",
      maxWidth: "800px",
      width: "100%",
      maxHeight: "68vh",
      overflow: "auto",
      animation: "0.3s ease 0s 1 normal none running slideUp",
      boxShadow: "rgba(0, 0, 0, 0.3) 0px 20px 40px"
    },
    articleHeader: {
      position: "relative"
    },
    articleImage: {
      width: "100%",
      height: "16rem",
      objectFit: "cover"
    },
    articleBody: {
      padding: "28px"
    },
    articleHeadline: {
      fontSize: "32px",
      fontWeight: "800",
      lineHeight: "1.2",
      letterSpacing: "-0.5px",
      marginBottom: "16px"
    },
    articleMeta: {
      display: "flex",
      alignItems: "center",
      gap: "24px",
      marginBottom: "24px",
      paddingBottom: "24px",
      borderBottom: `1px solid ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"}`
    },
    articleContent: {
      fontSize: "17px",
      lineHeight: "1.7",
      whiteSpace: "pre-wrap"
    },
    closeButton: {
      position: "absolute",
      top: "16px",
      right: "16px",
      width: "36px",
      height: "36px",
      borderRadius: "50%",
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      color: "#FFFFFF",
      border: "none",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "all 0.2s ease"
    },
    staffPanel: {
      backgroundColor: isDarkMode ? "#1C1C1E" : "#FFFFFF",
      borderRadius: "20px",
      padding: "32px",
      maxWidth: "600px",
      width: "100%",
      maxHeight: "61vh",
      overflow: "auto"
    },
    panelTitle: {
      fontSize: "24px",
      fontWeight: "700",
      marginBottom: "24px",
      letterSpacing: "-0.3px"
    },
    form: {
      display: "flex",
      flexDirection: "column",
      gap: "16px"
    },
    input: {
      padding: "12px 16px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      border: "none",
      borderRadius: "10px",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      outline: "none",
      transition: "all 0.2s ease"
    },
    textarea: {
      padding: "12px 16px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      border: "none",
      borderRadius: "10px",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      outline: "none",
      resize: "vertical",
      minHeight: "120px",
      fontFamily: '-apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif',
      transition: "all 0.2s ease"
    },
    select: {
      padding: "12px 16px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      border: "none",
      borderRadius: "10px",
      fontSize: "15px",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      outline: "none",
      transition: "all 0.2s ease"
    },
    button: {
      padding: "12px 24px",
      backgroundColor: "#007AFF",
      color: "#FFFFFF",
      border: "none",
      borderRadius: "10px",
      fontSize: "15px",
      fontWeight: "600",
      cursor: "pointer",
      transition: "all 0.2s ease"
    },
    applicationCard: {
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.05)" : "rgba(0, 0, 0, 0.03)",
      borderRadius: "12px",
      padding: "20px",
      marginBottom: "16px"
    },
    staffMember: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      padding: "16px",
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.05)" : "rgba(0, 0, 0, 0.03)",
      borderRadius: "10px",
      marginBottom: "8px"
    },
    tabs: {
      display: "flex",
      gap: "8px",
      marginBottom: "24px",
      borderBottom: `1px solid ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"}`,
      paddingBottom: "12px"
    },
    tab: {
      padding: "8px 16px",
      backgroundColor: "transparent",
      border: "none",
      borderRadius: "8px",
      fontSize: "15px",
      fontWeight: "500",
      cursor: "pointer",
      transition: "all 0.2s ease",
      color: isDarkMode ? "#FFFFFF" : "#000000",
      opacity: 0.6
    },
    activeTab: {
      backgroundColor: isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
      opacity: 1
    },
    toggleSwitch: {
      display: "flex",
      alignItems: "center",
      gap: "12px",
      marginBottom: "24px"
    },
    switch: {
      width: "48px",
      height: "28px",
      backgroundColor: applicationsOpen ? "#34C759" : isDarkMode ? "rgba(255, 255, 255, 0.2)" : "rgba(0, 0, 0, 0.2)",
      borderRadius: "14px",
      position: "relative",
      cursor: "pointer",
      transition: "all 0.3s ease"
    },
    switchKnob: {
      width: "24px",
      height: "24px",
      backgroundColor: "#FFFFFF",
      borderRadius: "50%",
      position: "absolute",
      top: "2px",
      left: applicationsOpen ? "22px" : "2px",
      transition: "all 0.3s ease",
      boxShadow: "0 2px 4px rgba(0, 0, 0, 0.2)"
    }
  };
  reactExports.useEffect(() => {
    const style = document.createElement("style");
    style.textContent = `
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      @keyframes slideDown {
        from { transform: translateY(-100%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      .news-card:hover {
        transform: translateY(-4px);
        box-shadow: ${isDarkMode ? "0 8px 30px rgba(0, 0, 0, 0.7)" : "0 8px 30px rgba(0, 0, 0, 0.15)"};
      }
      .icon-button:hover {
        background-color: ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)"};
      }
      .category-button:hover {
        transform: scale(1.05);
      }
      .search-input:focus {
        background-color: ${isDarkMode ? "rgba(255, 255, 255, 0.15)" : "rgba(0, 0, 0, 0.08)"};
      }
      .button:hover {
        background-color: #0051D5;
        transform: scale(1.02);
      }
      .button:active {
        transform: scale(0.98);
      }
      @media (max-width: 768px) {
        .header-actions > *:not(.mobile-menu-button) {
          display: none;
        }
        .mobile-menu-button {
          display: flex !important;
        }
        .search-bar {
          max-width: 200px;
        }
        .news-grid {
          grid-template-columns: 1fr !important;
          overflow-y: visible !important;
        }
      }
    `;
    document.head.appendChild(style);
    return () => document.head.removeChild(style);
  }, [isDarkMode]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "1rem" }, className: "tablet-frame-homescreen-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icons battery", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-shell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "battery-level",
              style: {
                width: `${batteryLevel}%`,
                backgroundColor: batteryLevel < 20 ? "red" : "rgb(227 227 227)"
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "battery-percent", children: [
            batteryLevel,
            "%"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.app, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("header", { style: styles.header, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { ...styles.headerContent, display: "flex", alignItems: "center", flex: 1 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.logo, children: "Weazel News" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.searchBar, className: "search-bar", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { style: { position: "absolute", left: "12px", top: "66%", transform: "translateY(-50%)", width: "18px", height: "18px", opacity: 0.5 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search news...",
              value: searchQuery,
              onChange: (e) => setSearchQuery(e.target.value),
              style: styles.searchInput,
              className: "search-input"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.headerActions, className: "header-actions", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { style: styles.iconButton, className: "icon-button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bell, { size: 20 }) }),
          isOwner && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: styles.iconButton,
              className: "icon-button",
              onClick: () => openStaffPanel(),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 20 })
            }
          ) }),
          applicationsOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: styles.iconButton,
              className: "icon-button",
              onClick: () => setShowApplyModal(true),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user-plus" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: { ...styles.iconButton, display: "none" },
              className: "icon-button mobile-menu-button",
              onClick: () => setShowMobileMenu(!showMobileMenu),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { size: 20 })
            }
          )
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.categoryBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.categoryContent, children: categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          style: {
            ...styles.categoryButton,
            backgroundColor: activeCategory === category.id ? category.color : isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
            color: activeCategory === category.id ? "#FFFFFF" : isDarkMode ? "#FFFFFF" : "#000000"
          },
          className: "category-button",
          onClick: () => setActiveCategory(category.id),
          children: [
            category.icon !== "live" ? /* @__PURE__ */ jsxRuntimeExports.jsx(category.icon, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-microphone-lines" }),
            category.name
          ]
        },
        category.id
      )) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("main", { style: styles.mainContent, children: activeCategory === "live" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-youtube-area", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-broadcast-left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-video-bg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "https://images.unsplash.com/photo-1519125323398-675f0ddb6308?auto=format&fit=crop&w=900&q=80",
                className: "live-video-bgimg",
                alt: "background"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-video-player", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-video-placeholder", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "live-onair-dot" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "live-onair-label", children: "CANLI YAYIN" })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-broadcast-info", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-broadcast-title-row", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-broadcast-title", children: "Weazel News zel Yayn: ehir Gndemi" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "live-viewer-chip", children: "9.632 izleyici" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-broadcast-channel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: "https://yt3.ggpht.com/yti/ANoDKi7A-channelimg=s68-c-k-c0x00ffffff-no-rj",
                  alt: "Weazel News",
                  className: "live-channel-img"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-channel-name", children: "Weazel News" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-broadcast-date", children: "u an Canl" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-broadcast-desc", children: "GTA ehirde bugn neler oluyor? Merak ettiklerinizi chatte sor, ekrana gelsin! Gncel olaylar, son dakika ve izleyici yorumlar bu yaynda." })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-chat-right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-chat-header", children: "Canl Sohbet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "live-chat-messages", id: "live-chat-messages", children: chatMessages.map((m, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "live-chat-msg", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "live-chat-author", children: m.author }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "live-chat-text", children: m.message })
          ] }, i)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "form",
            {
              className: "live-chat-form",
              onSubmit: (e) => {
                e.preventDefault();
                if (!chatInput.trim()) return;
                setChatMessages([
                  ...chatMessages,
                  {
                    author: chatNameType === "anon" ? `Anon${Math.floor(Math.random() * 9e3 + 1e3)}` : playerName,
                    message: chatInput
                  }
                ]);
                setChatInput("");
              },
              autoComplete: "off",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    className: "live-chat-input",
                    type: "text",
                    placeholder: "Sohbete mesaj gnder...",
                    value: chatInput,
                    onChange: (e) => setChatInput(e.target.value)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "select",
                  {
                    className: "live-chat-select",
                    value: chatNameType,
                    onChange: (e) => setChatNameType(e.target.value),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "anon", children: lang.anonymous }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "real", children: lang.withyourname })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "live-chat-send", type: "submit", children: lang.send })
              ]
            }
          )
        ] })
      ] }) : filteredArticles.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", padding: "60px 0", opacity: 0.5 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Newspaper, { size: 48, style: { marginBottom: "16px" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: lang.noarticles })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            maxHeight: "37rem",
            overflow: "hidden scroll",
            padding: "24px",
            display: "flex",
            gap: "16px",
            flexWrap: "wrap",
            background: "rgba(0, 0, 0, 0.05)"
          },
          id: "news-container-final",
          children: filteredArticles.map((article) => {
            var _a3;
            const images = Array.isArray(article.media) ? article.media : [article.media];
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "article",
              {
                className: "news-card",
                onClick: () => setSelectedArticle(article),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: images[0],
                      alt: article.headline,
                      style: styles.cardImage
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.cardContent, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          ...styles.cardCategory,
                          backgroundColor: getCategoryColor(article.category) + "20",
                          color: getCategoryColor(article.category)
                        },
                        children: ((_a3 = categories.find((cat) => cat.id === article.category)) == null ? void 0 : _a3.name) || article.category
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles.cardHeadline, children: article.data.headline }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: styles.cardSummary, children: article.data.summary }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.cardMeta, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: article.author }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatTime(article.timestamp) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                        article.likes,
                        " likes"
                      ] })
                    ] })
                  ] })
                ]
              },
              article.id
            );
          })
        }
      ) }),
      selectedArticle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.modal, onClick: () => setSelectedArticle(null), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.modalContent, onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.articleHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", width: "100%" }, children: [
          (() => {
            const images = Array.isArray(selectedArticle.media) ? selectedArticle.media : [selectedArticle.media];
            const src = images[currentModalIndex];
            const isVideo = (src == null ? void 0 : src.endsWith(".mp4")) || (src == null ? void 0 : src.endsWith(".webm")) || (src == null ? void 0 : src.includes("video"));
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              isVideo ? /* @__PURE__ */ jsxRuntimeExports.jsx("video", { controls: true, style: styles.articleImage, children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src, alt: selectedArticle.headline, style: styles.articleImage }),
              images.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      setCurrentModalIndex((i) => (i - 1 + images.length) % images.length);
                    },
                    style: {
                      position: "absolute",
                      left: 8,
                      top: "50%",
                      transform: "translateY(-50%)",
                      zIndex: 2,
                      background: "#0008",
                      color: "#fff",
                      border: "none",
                      borderRadius: 16,
                      width: 36,
                      height: 36,
                      fontSize: 24,
                      cursor: "pointer"
                    },
                    children: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      setCurrentModalIndex((i) => (i + 1) % images.length);
                    },
                    style: {
                      position: "absolute",
                      right: 8,
                      top: "50%",
                      transform: "translateY(-50%)",
                      zIndex: 2,
                      background: "#0008",
                      color: "#fff",
                      border: "none",
                      borderRadius: 16,
                      width: 36,
                      height: 36,
                      fontSize: 24,
                      cursor: "pointer"
                    },
                    children: ""
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  position: "absolute",
                  bottom: 12,
                  left: "50%",
                  transform: "translateX(-50%)",
                  display: "flex",
                  gap: 6
                }, children: images.map((_, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                  width: 8,
                  height: 8,
                  borderRadius: "50%",
                  background: idx === currentModalIndex ? "#fff" : "#fff6",
                  border: "1px solid #0004",
                  display: "inline-block"
                } }, idx)) })
              ] })
            ] });
          })(),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { style: styles.closeButton, onClick: () => setSelectedArticle(null), children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 20 }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.articleBody, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                ...styles.cardCategory,
                backgroundColor: getCategoryColor(selectedArticle.category) + "20",
                color: getCategoryColor(selectedArticle.category),
                marginBottom: "16px"
              },
              children: ((_a2 = categories.find((cat) => cat.id === selectedArticle.category)) == null ? void 0 : _a2.name) || selectedArticle.category
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: styles.articleHeadline, children: selectedArticle.data.headline }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.articleMeta, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedArticle.author }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatTime(selectedArticle.timestamp) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              selectedArticle.likes,
              " ",
              lang.likes
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.articleContent, children: selectedArticle.data.content }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: "48px" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { style: { fontSize: "20px", fontWeight: "700", marginBottom: "24px" }, children: [
              lang.comments,
              " (",
              selectedArticle.comments.length,
              ")"
            ] }),
            selectedArticle.comments.map((comment) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px", paddingBottom: "16px", borderBottom: `1px solid ${isDarkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)"}` }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px", marginBottom: "8px" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: comment.author }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { opacity: 0.5, fontSize: "13px" }, children: formatTime(comment.timestamp) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: "15px", lineHeight: "1.5" }, children: comment.content })
            ] }, comment.id)),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.form, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  onChange: (e) => setCommentText(e.target.value),
                  placeholder: lang.acomment,
                  value: commentText,
                  style: styles.textarea
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: postComment, style: styles.button, className: "button", children: lang.postcomment })
            ] })
          ] })
        ] })
      ] }) }),
      showStaffPanel && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.modal, onClick: () => setShowStaffPanel(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.staffPanel, onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles.panelTitle, children: lang.smana }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.tabs, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: { ...styles.tab, ...activeStaffTab === "create" ? styles.activeTab : {} },
              onClick: () => setActiveStaffTab("create"),
              children: lang.cnews
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: { ...styles.tab, ...activeStaffTab === "manage" ? styles.activeTab : {} },
              onClick: () => setActiveStaffTab("manage"),
              children: lang.mstaff
            }
          )
        ] }),
        activeStaffTab === "poll" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.form, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Anket Sorusu",
              value: newPoll.question,
              onChange: (e) => setNewPoll({ ...newPoll, question: e.target.value }),
              style: styles.input
            }
          ),
          [0, 1, 2, 3].map((i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: `Seenek ${i + 1}`,
              value: newPoll.options[i] || "",
              onChange: (e) => {
                const options = [...newPoll.options || []];
                options[i] = e.target.value;
                setNewPoll({ ...newPoll, options });
              },
              style: styles.input
            },
            i
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              style: styles.button,
              onClick: handleCreatePoll,
              disabled: !newPoll.question || !newPoll.options || newPoll.options.filter((opt) => opt).length < 2,
              children: "Anketi Payla"
            }
          )
        ] }),
        activeStaffTab === "create" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.form, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Headline",
              value: newArticle.headline,
              onChange: (e) => setNewArticle({ ...newArticle, headline: e.target.value }),
              style: styles.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Summary",
              value: newArticle.summary,
              onChange: (e) => setNewArticle({ ...newArticle, summary: e.target.value }),
              style: styles.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              placeholder: "Full article content...",
              value: newArticle.content,
              onChange: (e) => setNewArticle({ ...newArticle, content: e.target.value }),
              style: { ...styles.textarea, minHeight: "200px" }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomDropdown,
            {
              value: newArticle.category,
              onChange: (value) => setNewArticle({ ...newArticle, category: value }),
              options: categories.filter((cat) => cat.id !== "all" && cat.id !== "breaking" && cat.id !== "live").map((cat) => ({
                value: cat.id,
                label: cat.name
              })),
              isDarkMode,
              placeholder: lang.selcat
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap", alignItems: "center" }, children: [
            newArticleTags.map((tag, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: {
              background: "#007aff22",
              color: "#007aff",
              padding: "4px 12px",
              borderRadius: "12px",
              fontSize: 13,
              marginRight: 4,
              display: "flex",
              alignItems: "center"
            }, children: [
              "#",
              tag,
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  onClick: () => setNewArticleTags((tags) => tags.filter((_, idx) => idx !== i)),
                  style: { marginLeft: 6, cursor: "pointer", fontWeight: 700 },
                  children: ""
                }
              )
            ] }, i)),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", width: "90%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: tagInput,
                style: { ...styles.input, width: "100%", minWidth: 60 },
                placeholder: "tag ekle",
                onChange: (e) => setTagInput(e.target.value),
                onKeyDown: (e) => {
                  if ((e.key === "Enter" || e.key === "," || e.key === " " || e.key === ";") && tagInput.trim()) {
                    const val = tagInput.replace(/[,;]/g, "").trim();
                    if (val.length > 0 && !newArticleTags.includes(val)) {
                      setNewArticleTags([...newArticleTags, val]);
                      setTagInput("");
                    }
                    e.preventDefault();
                  } else if (e.key === "Backspace" && tagInput.length === 0) {
                    setNewArticleTags((tags) => tags.slice(0, -1));
                  }
                }
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                style: { ...styles.button, minWidth: 32, padding: "11px 11px", marginLeft: ".5rem" },
                onClick: () => setGalleryOpen(true),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-images" })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: "8px", flexWrap: "wrap", marginTop: "8px" }, children: selectedMedias.map((url) => {
            const isVideo = /\.(mp4|webm|ogg)$/i.test(url);
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
              isVideo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "video",
                {
                  src: url,
                  width: 120,
                  height: 90,
                  style: { objectFit: "cover", borderRadius: 8 },
                  controls: true
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: url,
                  width: 120,
                  height: 90,
                  style: { objectFit: "cover", borderRadius: 8 }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => setSelectedMedias((prev) => prev.filter((u) => u !== url)),
                  style: {
                    position: "absolute",
                    top: 4,
                    right: 4,
                    background: "rgba(0,0,0,0.5)",
                    border: "none",
                    borderRadius: "50%",
                    width: 24,
                    height: 24,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    cursor: "pointer"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 12, color: "#fff" })
                }
              )
            ] }, url);
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { style: styles.button, onClick: handlePublishArticle, children: lang.particle })
        ] }),
        galleryOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              position: "fixed",
              top: 0,
              left: 0,
              width: "100vw",
              height: "100vh",
              background: "rgba(0,0,0,0.32)",
              zIndex: 999,
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            onClick: () => setGalleryOpen(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  background: "#fff",
                  borderRadius: 16,
                  padding: 24,
                  minWidth: 320,
                  minHeight: 220,
                  maxWidth: 600,
                  boxShadow: "0 8px 24px rgba(0,0,0,0.08)",
                  display: "flex",
                  flexWrap: "wrap",
                  gap: 16
                },
                onClick: (e) => e.stopPropagation(),
                children: [
                  playerGallery.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Galeri bo." }),
                  playerGallery.map((photo) => {
                    const isVideo = /\.(mp4|webm|ogg)$/i.test(photo.url);
                    const selected = selectedMedias.includes(photo.url);
                    const borderStyle = selected ? "3px solid #1886fd" : "2px solid #eee";
                    const handleSelect = () => {
                      setSelectedMedias(
                        (prev) => prev.includes(photo.url) ? prev.filter((u) => u !== photo.url) : [...prev, photo.url]
                      );
                    };
                    return /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "newsapp-thumb",
                        onClick: handleSelect,
                        style: { border: borderStyle, cursor: "pointer" },
                        children: isVideo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "video",
                          {
                            src: photo.url,
                            width: 120,
                            height: 90,
                            style: { objectFit: "cover", borderRadius: 8 }
                          }
                        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "img",
                          {
                            src: photo.url,
                            alt: photo.location,
                            width: 120,
                            height: 90,
                            style: { objectFit: "cover", borderRadius: 8 }
                          }
                        )
                      },
                      photo.url
                    );
                  })
                ]
              }
            )
          }
        ),
        activeStaffTab === "manage" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontSize: "18px", fontWeight: "600", marginBottom: "16px" }, children: lang.curstaff }),
          journalist.map((member) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.staffMember, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "600" }, children: member.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", opacity: 0.6 }, children: [
                member.name,
                " ",
                member.grade ? `- ${member.grade}` : ""
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                style: { ...styles.iconButton, color: "#FF3B30" },
                onClick: () => handleRemoveStaff(member.cid, member.name),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { size: 18 })
              }
            )
          ] }, member.cid)),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: "16px", fontWeight: "600", marginTop: "24px" }, children: lang.addstaff }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px", marginBottom: "16px", position: "relative" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", flex: 1 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  placeholder: lang.firstName,
                  value: newStaffNameInput,
                  onChange: (e) => setNewStaffNameInput(e.target.value),
                  style: { ...styles.input, width: "17rem" }
                }
              ),
              newStaffNameInput && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                position: "absolute",
                top: "calc(100% + 4px)",
                left: 0,
                width: "100%",
                background: "#2c2c2e",
                border: "1px solid #444",
                borderRadius: 4,
                maxHeight: "150px",
                overflowY: "auto",
                boxShadow: "0 4px 8px rgba(0,0,0,0.3)",
                zIndex: 10
              }, children: players.filter((p) => p.name.toLowerCase().includes(newStaffNameInput.toLowerCase())).map((player) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  onClick: () => {
                    setNewStaffName(player.name);
                    setNewStaffCid(player.cid);
                    setNewStaffNameInput("");
                  },
                  style: {
                    padding: "8px 12px",
                    cursor: "pointer",
                    color: "#fff"
                  },
                  onMouseEnter: (e) => e.currentTarget.style.background = "#3a3a3c",
                  onMouseLeave: (e) => e.currentTarget.style.background = "transparent",
                  children: player.name
                },
                player.name
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CustomDropdown,
              {
                value: newStaffRole,
                onChange: (value) => {
                  const fakeEvent = { target: { value } };
                  setNewStaffRole(fakeEvent.target.value);
                },
                options: roleOptions,
                isDarkMode,
                placeholder: lang.selrole
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { style: styles.button, onClick: handleAddStaff, children: lang.add })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ColdModal,
        {
          appName: "News",
          title: nofity.title,
          message: nofity.msg,
          isOpen: pato,
          onClose: () => setPato(false),
          buttons: [
            { label: lang.ok, onClick: () => setPato(false) }
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ApplicationModal,
        {
          open: showApplyModal,
          onClose: () => setShowApplyModal(false),
          lang,
          isDarkMode,
          onSubmit: async (data) => {
            setApplications((apps) => [
              ...apps,
              {
                id: Date.now(),
                ...data,
                status: "pending",
                timestamp: /* @__PURE__ */ new Date()
              }
            ]);
          },
          isDark: isDarkMode
        }
      ),
      showApplications && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.modal, onClick: () => setShowApplications(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.staffPanel, onClick: (e) => e.stopPropagation(), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: styles.panelTitle, children: lang.jobapplics }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.toggleSwitch, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: "500" }, children: lang.openapplics }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: styles.switch,
              onClick: () => setApplicationsOpen(!applicationsOpen),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: styles.switchKnob })
            }
          )
        ] }),
        applications.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center", padding: "40px 0", opacity: 0.5 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(User, { size: 48, style: { marginBottom: "16px" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: lang.nopenx })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { style: { fontSize: "18px", fontWeight: "600", marginBottom: "16px" }, children: [
            lang.penx,
            " (",
            applications.length,
            ")"
          ] }),
          applikasyons.map((app) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: styles.applicationCard, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: "600", fontSize: "16px" }, children: app.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", opacity: 0.6 }, children: [
                lang.age,
                ": ",
                app.age
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "12px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", fontWeight: "500", marginBottom: "4px" }, children: [
                lang.experience,
                ":"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "14px", opacity: 0.8 }, children: app.experience })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "16px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: "14px", fontWeight: "500", marginBottom: "4px" }, children: [
                lang.motivation,
                ":"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: "14px", opacity: 0.8 }, children: app.motivation })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  style: { ...styles.button, backgroundColor: "#34C759", display: "flex", alignItems: "center" },
                  className: "button",
                  onClick: () => handleApplicationDecision(app.id, "accept"),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { size: 18, style: { marginRight: "4px" } }),
                    lang.accept
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  style: { ...styles.button, backgroundColor: "#FF3B30", display: "flex", alignItems: "center" },
                  className: "button",
                  onClick: () => handleApplicationDecision(app.id, "reject"),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(X, { size: 18, style: { marginRight: "4px" } }),
                    lang.reject
                  ]
                }
              )
            ] })
          ] }, app.id))
        ] })
      ] }) })
    ] })
  ] });
};
const HackerMinigame = ({ batteryLevel, lang, openApp }) => {
  const [timeRemaining, setTimeRemaining] = reactExports.useState(300);
  const [grid, setGrid] = reactExports.useState([]);
  const [selectedRow, setSelectedRow] = reactExports.useState(10);
  const [selectedCol, setSelectedCol] = reactExports.useState(10);
  const [targetWord, setTargetWord] = reactExports.useState("JNH");
  const [gameStatus, setGameStatus] = reactExports.useState("playing");
  const [currentTargetRow, setCurrentTargetRow] = reactExports.useState(-1);
  const [currentTargetStartCol, setCurrentTargetStartCol] = reactExports.useState(-1);
  const [attemptsLeft, setAttemptsLeft] = reactExports.useState(3);
  const inputRef = reactExports.useRef(null);
  const [time2, setTime] = reactExports.useState(/* @__PURE__ */ new Date());
  const moveSound = reactExports.useRef(null);
  const successSound = reactExports.useRef(null);
  const failSound = reactExports.useRef(null);
  const generateRandomWord = () => {
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let word = "";
    for (let i = 0; i < 3; i++) {
      word += letters[Math.floor(Math.random() * letters.length)];
    }
    return word;
  };
  const resetGame = () => {
    setTargetWord(generateRandomWord());
    setAttemptsLeft(3);
    setSelectedRow(10);
    setSelectedCol(10);
    setGameStatus("playing");
    setTimeRemaining(300);
  };
  reactExports.useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  const formattedTime = `${time2.getHours().toString().padStart(2, "0")}:${time2.getMinutes().toString().padStart(2, "0")}`;
  reactExports.useEffect(() => {
    const generateGrid = () => {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      const newGrid = [];
      let targetRowIndex = -1;
      let targetStartCol = -1;
      const shouldShowTarget = Math.random() < 0.4;
      if (shouldShowTarget) {
        targetRowIndex = Math.floor(Math.random() * 20);
        targetStartCol = Math.floor(Math.random() * (20 - 3));
      }
      for (let i = 0; i < 20; i++) {
        const row = [];
        const showTargetInThisRow = i === targetRowIndex;
        for (let j = 0; j < 20; j++) {
          const isTargetPosition = showTargetInThisRow && j >= targetStartCol && j < targetStartCol + 3;
          const letter = isTargetPosition ? targetWord[j - targetStartCol] : letters[Math.floor(Math.random() * letters.length)];
          const isRandomGreen = !isTargetPosition && Math.random() < 0.05;
          row.push({
            letter,
            isRandomGreen,
            isTargetLetter: isTargetPosition
          });
        }
        newGrid.push(row);
      }
      setCurrentTargetRow(targetRowIndex);
      setCurrentTargetStartCol(targetStartCol);
      return newGrid;
    };
    const initialGrid = generateGrid();
    setGrid(initialGrid);
    const interval = setInterval(() => {
      if (gameStatus === "playing") {
        const newGrid = generateGrid();
        setGrid(newGrid);
      }
    }, 3e3);
    return () => clearInterval(interval);
  }, [targetWord, gameStatus]);
  reactExports.useEffect(() => {
    const timer = setInterval(() => {
      if (gameStatus === "playing") {
        setTimeRemaining((prev) => {
          if (prev <= 1) {
            setTimeout(() => {
              resetGame();
            }, 1500);
            return 0;
          }
          return prev - 1;
        });
      }
    }, 1e3);
    return () => clearInterval(timer);
  }, [gameStatus]);
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
  };
  const playSound = (soundRef) => {
    if (soundRef.current) {
      soundRef.current.currentTime = 0;
      soundRef.current.play().catch((e) => console.log("Ses alma hatas:", e));
    }
  };
  const handleKeyDown = (e) => {
    if (gameStatus !== "playing") return;
    if (e.key === "Enter") {
      if (selectedRow === currentTargetRow && selectedCol === currentTargetStartCol && currentTargetRow !== -1) {
        playSound(successSound);
        setGameStatus("granted");
        callNui("getMiniGameResult", { result: true }, (res) => {
          if (res) {
            openApp("mainsc");
          }
        });
      } else {
        playSound(failSound);
        const newAttemptsLeft = attemptsLeft - 1;
        setAttemptsLeft(newAttemptsLeft);
        if (newAttemptsLeft === 0) {
          setGameStatus("denied");
          callNui("getMiniGameResult", { result: false });
          setTimeout(() => {
            resetGame();
          }, 1500);
        }
      }
    } else if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
      e.preventDefault();
      playSound(moveSound);
      setSelectedRow((prev) => (prev - 1 + 20) % 20);
    } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
      e.preventDefault();
      playSound(moveSound);
      setSelectedRow((prev) => (prev + 1) % 20);
    } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
      e.preventDefault();
      playSound(moveSound);
      setSelectedCol((prev) => (prev - 1 + 20) % 20);
    } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
      e.preventDefault();
      playSound(moveSound);
      setSelectedCol((prev) => (prev + 1) % 20);
    }
  };
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [selectedRow, selectedCol, gameStatus, currentTargetRow, currentTargetStartCol, attemptsLeft]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hacker-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: "1rem" }, className: "tablet-frame-homescreen-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icon-time-part", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "time-string", children: formattedTime }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icon-part", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "18", height: "10", viewBox: "0 0 18 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.5227 0.617317C14.4465 0.801088 14.4465 1.03406 14.4465 1.5V8.5C14.4465 8.96594 14.4465 9.19891 14.5227 9.38268C14.6241 9.62771 14.8188 9.82239 15.0638 9.92388C15.2476 10 15.4806 10 15.9465 10C16.4125 10 16.6454 10 16.8292 9.92388C17.0742 9.82239 17.2689 9.62771 17.3704 9.38268C17.4465 9.19891 17.4465 8.96594 17.4465 8.5V1.5C17.4465 1.03406 17.4465 0.801088 17.3704 0.617317C17.2689 0.372288 17.0742 0.177614 16.8292 0.0761205C16.6454 0 16.4125 0 15.9465 0C15.4806 0 15.2476 0 15.0638 0.0761205C14.8188 0.177614 14.6241 0.372288 14.5227 0.617317Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.94653 3.5C9.94653 3.03406 9.94653 2.80109 10.0227 2.61732C10.1241 2.37229 10.3188 2.17761 10.5638 2.07612C10.7476 2 10.9806 2 11.4465 2C11.9125 2 12.1454 2 12.3292 2.07612C12.5742 2.17761 12.7689 2.37229 12.8704 2.61732C12.9465 2.80109 12.9465 3.03406 12.9465 3.5V8.5C12.9465 8.96594 12.9465 9.19891 12.8704 9.38268C12.7689 9.62771 12.5742 9.82239 12.3292 9.92388C12.1454 10 11.9125 10 11.4465 10C10.9806 10 10.7476 10 10.5638 9.92388C10.3188 9.82239 10.1241 9.62771 10.0227 9.38268C9.94653 9.19891 9.94653 8.96594 9.94653 8.5V3.5Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5.52265 4.61732C5.44653 4.80109 5.44653 5.03406 5.44653 5.5V8.5C5.44653 8.96594 5.44653 9.19891 5.52265 9.38268C5.62415 9.62771 5.81882 9.82239 6.06385 9.92388C6.24762 10 6.48059 10 6.94653 10C7.41247 10 7.64545 10 7.82922 9.92388C8.07424 9.82239 8.26892 9.62771 8.37041 9.38268C8.44653 9.19891 8.44653 8.96594 8.44653 8.5V5.5C8.44653 5.03406 8.44653 4.80109 8.37041 4.61732C8.26892 4.37229 8.07424 4.17761 7.82922 4.07612C7.64545 4 7.41247 4 6.94653 4C6.48059 4 6.24762 4 6.06385 4.07612C5.81882 4.17761 5.62415 4.37229 5.52265 4.61732Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M1.02265 6.11732C0.946533 6.30109 0.946533 6.53406 0.946533 7V8.5C0.946533 8.96594 0.946533 9.19891 1.02265 9.38268C1.12415 9.62771 1.31882 9.82239 1.56385 9.92388C1.74762 10 1.98059 10 2.44653 10C2.91247 10 3.14545 10 3.32922 9.92388C3.57424 9.82239 3.76892 9.62771 3.87041 9.38268C3.94653 9.19891 3.94653 8.96594 3.94653 8.5V7C3.94653 6.53406 3.94653 6.30109 3.87041 6.11732C3.76892 5.87229 3.57424 5.67761 3.32922 5.57612C3.14545 5.5 2.91247 5.5 2.44653 5.5C1.98059 5.5 1.74762 5.5 1.56385 5.57612C1.31882 5.67761 1.12415 5.87229 1.02265 6.11732Z", fill: "white" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-icons battery", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "battery-shell", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "battery-level",
              style: {
                width: `${batteryLevel}%`,
                backgroundColor: batteryLevel < 20 ? "red" : "rgb(227 227 227)"
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "battery-percent", children: [
            batteryLevel,
            "%"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-icons", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", width: "15", height: "10", viewBox: "0 0 15 10", fill: "none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.9512 4.246C13.0647 4.3525 13.2397 4.353 13.3502 4.243L14.4142 3.179C14.5287 3.064 14.5292 2.8745 14.4112 2.763C12.6022 1.0505 10.1607 0 7.47322 0C4.78572 0 2.34422 1.0505 0.535223 2.763C0.417223 2.8745 0.417723 3.064 0.532223 3.179L1.59622 4.243C1.70672 4.353 1.88172 4.3525 1.99522 4.246C3.42972 2.9015 5.35672 2.077 7.47322 2.077C9.58972 2.077 11.5167 2.9015 12.9512 4.246Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.5043 6.69645C10.6198 6.79945 10.7923 6.80045 10.9018 6.69095L11.9643 5.62845C12.0798 5.51295 12.0803 5.32045 11.9603 5.20995C10.7793 4.12445 9.20385 3.46145 7.47334 3.46145C5.74285 3.46145 4.16735 4.12445 2.98635 5.20995C2.86635 5.32045 2.86685 5.51295 2.98235 5.62845L4.04485 6.69095C4.15435 6.80045 4.32685 6.79945 4.44235 6.69645C5.24835 5.97695 6.31035 5.53845 7.47334 5.53845C8.63634 5.53845 9.69835 5.97695 10.5043 6.69645Z", fill: "white" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5082 7.6611C9.6337 7.7661 9.6327 7.9616 9.5167 8.0776L7.6787 9.9156C7.5662 10.0281 7.3832 10.0281 7.2707 9.9156L5.4327 8.0776C5.3167 7.9616 5.3152 7.7661 5.4412 7.6611C5.9917 7.2006 6.7007 6.9231 7.4747 6.9231C8.2487 6.9231 8.9572 7.2006 9.5082 7.6611Z", fill: "white" })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "command-prompt", children: "/Command Prompt" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tagline", children: "BUSTING THROUGH BACKDOOR SINCE 2024" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "target-info", style: {
      textAlign: "center",
      color: "#00ff00",
      fontSize: "1.2rem",
      marginBottom: "10px",
      fontFamily: "monospace",
      textShadow: "0 0 10px #00ff00"
    }, children: [
      "TARGET: ",
      targetWord
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "letter-grid", children: grid.map((row, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `grid-row ${i === selectedRow ? "selected-row" : ""}`, children: row.map((cell, j) => {
      const isSelected = i === selectedRow && j >= selectedCol && j < selectedCol + 3;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: `grid-letter ${cell.isRandomGreen ? "random-green" : ""} ${cell.isTargetLetter ? "target-letter-visible" : ""} ${isSelected ? "selected-letter" : ""}`,
          children: cell.letter
        },
        j
      );
    }) }, i)) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "footer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "timer-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timer-label", children: "Time remaining" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "timer", children: formatTime(timeRemaining) })
      ] }),
      gameStatus === "playing" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "attempts-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attempts-label", children: "Attempts left" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "attempts", children: attemptsLeft })
      ] })
    ] }),
    gameStatus !== "playing" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overlay", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `result ${gameStatus}`, children: gameStatus === "granted" ? "ACCESS GRANTED" : "ACCESS DENIED" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        ref: inputRef,
        type: "text",
        className: "hidden-input",
        value: "",
        onChange: () => {
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { ref: moveSound, preload: "auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { ref: successSound, preload: "auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: "data:audio/wav;base64,UklGRoAHAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YVwHAAAAAAC7/7sA//+7ALv/uwC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7/7v/u/+7/7v/u/+7/7v/u/+7/7v/AAC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwC7ALsAuwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("audio", { ref: failSound, preload: "auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: "data:audio/wav;base64,UklGRqwCAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YYgCAAAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAC7/wAAAAA=" }) })
  ] });
};
const SmartTabBrowser = () => {
  const [tabs, setTabs] = reactExports.useState([
    { id: 1, url: "", title: "New Tab", isPrivate: false, loading: false, error: null }
  ]);
  const [activeTabId, setActiveTabId] = reactExports.useState(1);
  const [searchHistory, setSearchHistory] = reactExports.useState([]);
  const [showHistory, setShowHistory] = reactExports.useState(false);
  const [darkMode, setDarkMode] = reactExports.useState(true);
  const [showBookmarks, setShowBookmarks] = reactExports.useState(true);
  const [inputValue, setInputValue] = reactExports.useState("");
  const inputRef = reactExports.useRef(null);
  const bookmarks = [
    { name: "Google", url: "https://www.google.com", icon: "" },
    { name: "YouTube", url: "https://www.youtube.com", icon: "" },
    { name: "GitHub", url: "https://github.com", icon: "" },
    { name: "Twitter", url: "https://twitter.com", icon: "" },
    { name: "Reddit", url: "https://www.reddit.com", icon: "" },
    { name: "Stack Overflow", url: "https://stackoverflow.com", icon: "" }
  ];
  reactExports.useEffect(() => {
    document.documentElement.className = darkMode ? "dark-mode" : "light-mode";
  }, [darkMode]);
  reactExports.useEffect(() => {
    const saved = JSON.parse(localStorage.getItem("searchHistory") || "[]");
    setSearchHistory(saved);
  }, []);
  const activeTab = tabs.find((tab) => tab.id === activeTabId);
  const formatUrl = (input) => {
    if (!input) return "";
    if (input.startsWith("http://") || input.startsWith("https://")) {
      return input;
    }
    if (input.includes(".") && !input.includes(" ")) {
      return `https://${input}`;
    }
    return `https://www.google.com/search?q=${encodeURIComponent(input)}`;
  };
  const navigate = (url) => {
    const formattedUrl = formatUrl(url);
    setTabs(tabs.map(
      (tab) => tab.id === activeTabId ? { ...tab, url: formattedUrl, loading: true, error: null, title: url || "Loading..." } : tab
    ));
    const newHistory = [url, ...searchHistory.filter((item) => item !== url)].slice(0, 10);
    setSearchHistory(newHistory);
    localStorage.setItem("searchHistory", JSON.stringify(newHistory));
    setTimeout(() => {
      setTabs(tabs.map(
        (tab) => tab.id === activeTabId ? { ...tab, loading: false, title: url || "New Tab" } : tab
      ));
    }, 1500);
    setShowHistory(false);
    setShowBookmarks(false);
  };
  const addTab = (isPrivate = false) => {
    const newTab = {
      id: Date.now(),
      url: "",
      title: isPrivate ? "Private Tab" : "New Tab",
      isPrivate,
      loading: false,
      error: null
    };
    setTabs([...tabs, newTab]);
    setActiveTabId(newTab.id);
    setInputValue("");
    setShowBookmarks(true);
  };
  const closeTab = (tabId) => {
    if (tabs.length === 1) return;
    const newTabs = tabs.filter((tab) => tab.id !== tabId);
    setTabs(newTabs);
    if (tabId === activeTabId) {
      setActiveTabId(newTabs[newTabs.length - 1].id);
    }
  };
  const handleBack = () => {
    setShowBookmarks(true);
    setTabs(tabs.map(
      (tab) => tab.id === activeTabId ? { ...tab, url: "", title: "New Tab" } : tab
    ));
    setInputValue("");
  };
  const handleRefresh = () => {
    if (activeTab == null ? void 0 : activeTab.url) {
      setTabs(tabs.map(
        (tab) => tab.id === activeTabId ? { ...tab, loading: true } : tab
      ));
      setTimeout(() => {
        setTabs(tabs.map(
          (tab) => tab.id === activeTabId ? { ...tab, loading: false } : tab
        ));
      }, 1e3);
    }
  };
  const clearHistory = () => {
    setSearchHistory([]);
    localStorage.removeItem("searchHistory");
    setShowHistory(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `browser-container ${(activeTab == null ? void 0 : activeTab.isPrivate) ? "private-mode" : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "browser-title", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-icon", children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "app-name", children: "SmartTab Browser" }),
        (activeTab == null ? void 0 : activeTab.isPrivate) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "private-badge", children: "Private" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "tabs-container", children: [
        tabs.map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `tab ${tab.id === activeTabId ? "active" : ""} ${tab.isPrivate ? "private" : ""}`,
            onClick: () => setActiveTabId(tab.id),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "tab-title", children: [
                tab.isPrivate && " ",
                tab.title
              ] }),
              tabs.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "tab-close",
                  onClick: (e) => {
                    e.stopPropagation();
                    closeTab(tab.id);
                  },
                  children: ""
                }
              )
            ]
          },
          tab.id
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "new-tab-btn", onClick: () => addTab(false), children: "+" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "icon-btn private-btn",
            onClick: () => addTab(true),
            title: "New Private Tab",
            children: ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "icon-btn theme-btn",
            onClick: () => setDarkMode(!darkMode),
            title: "Toggle Theme",
            children: darkMode ? "" : ""
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "navigation-bar", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "nav-btn",
          onClick: handleBack,
          disabled: !(activeTab == null ? void 0 : activeTab.url),
          children: ""
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "nav-btn",
          onClick: handleRefresh,
          disabled: !(activeTab == null ? void 0 : activeTab.url),
          children: ""
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "url-bar-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            ref: inputRef,
            type: "text",
            className: "url-input",
            placeholder: "Search or enter address",
            value: inputValue,
            onChange: (e) => setInputValue(e.target.value),
            onFocus: () => setShowHistory(true),
            onBlur: () => setTimeout(() => setShowHistory(false), 200),
            onKeyPress: (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                if (inputValue.trim()) {
                  navigate(inputValue);
                }
              }
            }
          }
        ),
        (activeTab == null ? void 0 : activeTab.url) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ssl-indicator", children: "" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "nav-btn menu-btn", children: "" })
    ] }),
    (activeTab == null ? void 0 : activeTab.loading) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "progress-fill" }) }),
    showHistory && searchHistory.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "history-dropdown", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "history-header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Recent Searches" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: clearHistory, className: "clear-history", children: "Clear" })
      ] }),
      searchHistory.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "history-item",
          onClick: () => {
            setInputValue(item);
            navigate(item);
          },
          children: [
            " ",
            item
          ]
        },
        index
      ))
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "browser-content", children: showBookmarks && !(activeTab == null ? void 0 : activeTab.url) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bookmarks-grid", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "bookmarks-title", children: "Quick Access" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bookmarks-container", children: bookmarks.map((bookmark, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "bookmark-item",
          onClick: () => {
            setInputValue(bookmark.url);
            navigate(bookmark.url);
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bookmark-icon", children: bookmark.icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bookmark-name", children: bookmark.name })
          ]
        },
        index
      )) })
    ] }) : (activeTab == null ? void 0 : activeTab.error) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "error-page", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-icon", children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "error-title", children: "Unable to connect" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: "Check your connection and try again" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "error-btn", onClick: handleRefresh, children: "Try Again" })
    ] }) : (activeTab == null ? void 0 : activeTab.url) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "iframe",
      {
        src: activeTab.url,
        className: "browser-iframe",
        title: "Browser Content",
        sandbox: "allow-scripts allow-same-origin allow-forms"
      }
    ) : null })
  ] });
};
const PolicyApplicationModal = ({ open, onClose, onSuccess, darkMode, plans }) => {
  const [formData, setFormData] = reactExports.useState({
    insurance_type: "",
    start_date: "",
    end_date: "",
    monthly_premium: "",
    coverage_amount: "",
    emergency_contact: "",
    emergency_phone: "",
    selected_plan: null
  });
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [showPlanDropdown, setShowPlanDropdown] = reactExports.useState(false);
  const [planSearchQuery, setPlanSearchQuery] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (open) {
      setFormData({
        insurance_type: "",
        start_date: "",
        end_date: "",
        monthly_premium: "",
        coverage_amount: "",
        emergency_contact: "",
        emergency_phone: "",
        selected_plan: null
      });
      setPlanSearchQuery("");
      setShowPlanDropdown(false);
    }
  }, [open]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (!event.target.closest("[data-modal-dropdown]")) {
        setShowPlanDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const filteredPlans = plans.filter(
    (plan) => plan.plan_name.toLowerCase().includes(planSearchQuery.toLowerCase()) || plan.category.toLowerCase().includes(planSearchQuery.toLowerCase())
  );
  const handlePlanSelect = (plan) => {
    setFormData({
      ...formData,
      insurance_type: plan.category,
      monthly_premium: plan.monthly_premium,
      coverage_amount: plan.coverage_amount,
      selected_plan: plan
    });
    setShowPlanDropdown(false);
    setPlanSearchQuery("");
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.selected_plan || !formData.start_date || !formData.end_date) {
      alert("Please fill in all required fields");
      return;
    }
    setSubmitting(true);
    const newPolicy = {
      policy_number: "POL-" + Math.random().toString(36).substr(2, 9).toUpperCase(),
      citizen_id: "CIT-" + Math.random().toString(36).substr(2, 9).toUpperCase(),
      citizen_name: "John Doe",
      // This would come from player data
      status: "Active",
      created_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...formData
    };
    callNui("createInsurancePolicy", newPolicy, (result) => {
      setSubmitting(false);
      if (result) {
        onSuccess(result);
        onClose();
      } else {
        alert("Failed to create policy. Please try again.");
      }
    });
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.38)",
        zIndex: 99999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: (e) => e.stopPropagation(),
            style: {
              minWidth: 400,
              width: "100%",
              maxWidth: 500,
              background: darkMode ? "#19191b" : "#f7f7f9",
              borderRadius: 20,
              boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
              padding: 32,
              transform: "translateY(24px) scale(0.98)",
              opacity: 0,
              animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
              border: darkMode ? "1px solid #222226" : "1px solid #ebebee",
              color: darkMode ? "#fff" : "#19191b",
              position: "relative",
              maxHeight: "90vh",
              overflow: "auto"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: darkMode ? "#222" : "#e4e8ef",
                      color: darkMode ? "#fdc70a" : "#9b8800",
                      borderRadius: 12,
                      width: 32,
                      height: 32,
                      alignItems: "center",
                      justifyContent: "center",
                      marginRight: 10,
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-shield-halved" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 21, fontWeight: 700 }, children: "New Insurance Policy" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", flexDirection: "column", gap: 17 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, "data-modal-dropdown": true, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Choose Insurance Plan *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", marginTop: 5 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        placeholder: "Search and select a plan...",
                        value: planSearchQuery,
                        onChange: (e) => {
                          setPlanSearchQuery(e.target.value);
                          setShowPlanDropdown(true);
                        },
                        onFocus: () => setShowPlanDropdown(true),
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          outline: "none",
                          transition: "border 0.18s",
                          paddingRight: "40px"
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          right: 12,
                          top: "50%",
                          transform: "translateY(-50%)",
                          color: darkMode ? "#888" : "#666",
                          cursor: "pointer",
                          transition: "transform 0.2s ease",
                          transform: showPlanDropdown ? "translateY(-50%) rotate(180deg)" : "translateY(-50%) rotate(0deg)"
                        },
                        onClick: () => setShowPlanDropdown(!showPlanDropdown),
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-down" })
                      }
                    )
                  ] }),
                  showPlanDropdown && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        top: "100%",
                        left: 0,
                        right: 0,
                        background: darkMode ? "#2C2C2E" : "#FFFFFF",
                        borderRadius: 10,
                        boxShadow: "0 10px 40px rgba(0, 0, 0, 0.3)",
                        overflow: "hidden",
                        zIndex: 1e3,
                        maxHeight: "200px",
                        overflowY: "auto",
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd"
                      },
                      children: filteredPlans.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                        padding: "12px 16px",
                        fontSize: 15,
                        color: darkMode ? "#888" : "#666",
                        textAlign: "center"
                      }, children: "No plans found" }) : filteredPlans.map((plan) => {
                        var _a2;
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            onClick: () => handlePlanSelect(plan),
                            style: {
                              padding: "12px 16px",
                              fontSize: 15,
                              color: darkMode ? "#FFFFFF" : "#000000",
                              cursor: "pointer",
                              transition: "all 0.15s ease",
                              borderBottom: darkMode ? "1px solid #28282c" : "1px solid #f0f0f0",
                              background: ((_a2 = formData.selected_plan) == null ? void 0 : _a2.id) === plan.id ? darkMode ? "rgba(0, 122, 255, 0.3)" : "rgba(0, 122, 255, 0.1)" : "transparent"
                            },
                            onMouseEnter: (e) => {
                              var _a3;
                              if (((_a3 = formData.selected_plan) == null ? void 0 : _a3.id) !== plan.id) {
                                e.currentTarget.style.background = darkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)";
                              }
                            },
                            onMouseLeave: (e) => {
                              var _a3;
                              if (((_a3 = formData.selected_plan) == null ? void 0 : _a3.id) !== plan.id) {
                                e.currentTarget.style.background = "transparent";
                              }
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 4 }, children: plan.plan_name }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666", marginBottom: 4 }, children: [
                                plan.category,
                                "  ",
                                formatCurrency(plan.monthly_premium),
                                "/month"
                              ] }),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: [
                                "Coverage: ",
                                formatCurrency(plan.coverage_amount)
                              ] })
                            ]
                          },
                          plan.id
                        );
                      })
                    }
                  )
                ] }),
                formData.selected_plan && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  padding: 12,
                  borderRadius: 8,
                  background: darkMode ? "rgba(0, 122, 255, 0.1)" : "rgba(0, 122, 255, 0.05)",
                  border: "1px solid #007AFF",
                  marginBottom: 8
                }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: 600, fontSize: 14, marginBottom: 4 }, children: [
                    "Selected: ",
                    formData.selected_plan.plan_name
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: [
                    formatCurrency(formData.selected_plan.monthly_premium),
                    "/month  Coverage: ",
                    formatCurrency(formData.selected_plan.coverage_amount)
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Start Date *" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "date",
                        value: formData.start_date,
                        onChange: (e) => setFormData({ ...formData, start_date: e.target.value }),
                        required: true,
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "End Date *" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "date",
                        value: formData.end_date,
                        onChange: (e) => setFormData({ ...formData, end_date: e.target.value }),
                        required: true,
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        }
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Emergency Contact" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        placeholder: "Contact name",
                        value: formData.emergency_contact,
                        onChange: (e) => setFormData({ ...formData, emergency_contact: e.target.value }),
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Emergency Phone" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "tel",
                        placeholder: "Phone number",
                        value: formData.emergency_phone,
                        onChange: (e) => setFormData({ ...formData, emergency_phone: e.target.value }),
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        }
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    disabled: submitting || !formData.selected_plan || !formData.start_date || !formData.end_date,
                    onClick: handleSubmit,
                    style: {
                      marginTop: 15,
                      background: formData.selected_plan && formData.start_date && formData.end_date ? "#007AFF" : "#666",
                      color: "#fff",
                      border: "none",
                      borderRadius: 12,
                      fontWeight: 700,
                      fontSize: 16,
                      padding: "13px 0",
                      boxShadow: "0 3px 9px 0 rgba(0,99,255,0.05)",
                      cursor: submitting || !formData.selected_plan || !formData.start_date || !formData.end_date ? "not-allowed" : "pointer",
                      opacity: submitting || !formData.selected_plan || !formData.start_date || !formData.end_date ? 0.7 : 1,
                      transition: "all .17s"
                    },
                    children: submitting ? "Creating Policy..." : "Create Policy"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  style: {
                    position: "absolute",
                    top: 18,
                    right: 22,
                    background: "transparent",
                    border: "none",
                    color: darkMode ? "#888" : "#222",
                    fontSize: 22,
                    cursor: "pointer"
                  },
                  onClick: onClose,
                  children: ""
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
      ]
    }
  );
};
const ClaimApplicationModal = ({ open, onClose, onSuccess, darkMode, policies }) => {
  const [formData, setFormData] = reactExports.useState({
    policy_id: "",
    amount: "",
    description: "",
    notes: ""
  });
  const [submitting, setSubmitting] = reactExports.useState(false);
  const [showPolicyDropdown, setShowPolicyDropdown] = reactExports.useState(false);
  const [policySearchQuery, setPolicySearchQuery] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (open) {
      setFormData({
        policy_id: "",
        amount: "",
        description: "",
        notes: ""
      });
      setPolicySearchQuery("");
      setShowPolicyDropdown(false);
    }
  }, [open]);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (!event.target.closest("[data-modal-dropdown]")) {
        setShowPolicyDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const filteredPolicies = policies.filter(
    (policy) => policy.policy_number.toLowerCase().includes(policySearchQuery.toLowerCase()) || policy.insurance_type.toLowerCase().includes(policySearchQuery.toLowerCase()) || policy.citizen_name.toLowerCase().includes(policySearchQuery.toLowerCase())
  );
  const handlePolicySelect = (policy) => {
    setFormData({
      ...formData,
      policy_id: policy.id
    });
    setShowPolicyDropdown(false);
    setPolicySearchQuery("");
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.policy_id || !formData.amount || !formData.description) {
      alert("Please fill in all required fields");
      return;
    }
    setSubmitting(true);
    const selectedPolicy = policies.find((p) => p.id == formData.policy_id);
    const newClaim = {
      claim_number: "CLM-" + Math.random().toString(36).substr(2, 9).toUpperCase(),
      policy_number: selectedPolicy == null ? void 0 : selectedPolicy.policy_number,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      status: "Pending",
      ...formData
    };
    callNui("createInsuranceClaim", newClaim, (result) => {
      setSubmitting(false);
      if (result) {
        onSuccess(result);
        onClose();
      } else {
        alert("Failed to create claim. Please try again.");
      }
    });
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.38)",
        zIndex: 99999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: (e) => e.stopPropagation(),
            style: {
              minWidth: 400,
              width: "100%",
              maxWidth: 500,
              background: darkMode ? "#19191b" : "#f7f7f9",
              borderRadius: 20,
              boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
              padding: 32,
              transform: "translateY(24px) scale(0.98)",
              opacity: 0,
              animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
              border: darkMode ? "1px solid #222226" : "1px solid #ebebee",
              color: darkMode ? "#fff" : "#19191b",
              position: "relative"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: darkMode ? "#222" : "#e4e8ef",
                      color: darkMode ? "#EF4444" : "#DC2626",
                      borderRadius: 12,
                      width: 32,
                      height: 32,
                      alignItems: "center",
                      justifyContent: "center",
                      marginRight: 10,
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-file-medical" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 21, fontWeight: 700 }, children: "New Insurance Claim" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", flexDirection: "column", gap: 17 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, "data-modal-dropdown": true, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Select Policy *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative", marginTop: 5 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        placeholder: "Search and select a policy...",
                        value: policySearchQuery,
                        onChange: (e) => {
                          setPolicySearchQuery(e.target.value);
                          setShowPolicyDropdown(true);
                        },
                        onFocus: () => setShowPolicyDropdown(true),
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          outline: "none",
                          transition: "border 0.18s",
                          paddingRight: "40px"
                        }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          right: 12,
                          top: "50%",
                          transform: "translateY(-50%)",
                          color: darkMode ? "#888" : "#666",
                          cursor: "pointer",
                          transition: "transform 0.2s ease",
                          transform: showPolicyDropdown ? "translateY(-50%) rotate(180deg)" : "translateY(-50%) rotate(0deg)"
                        },
                        onClick: () => setShowPolicyDropdown(!showPolicyDropdown),
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-chevron-down" })
                      }
                    )
                  ] }),
                  showPolicyDropdown && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        top: "100%",
                        left: 0,
                        right: 0,
                        background: darkMode ? "#2C2C2E" : "#FFFFFF",
                        borderRadius: 10,
                        boxShadow: "0 10px 40px rgba(0, 0, 0, 0.3)",
                        overflow: "hidden",
                        zIndex: 1e3,
                        maxHeight: "200px",
                        overflowY: "auto",
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd"
                      },
                      children: filteredPolicies.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                        padding: "12px 16px",
                        fontSize: 15,
                        color: darkMode ? "#888" : "#666",
                        textAlign: "center"
                      }, children: policies.length === 0 ? "No policies available" : "No policies found" }) : filteredPolicies.map((policy) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "div",
                        {
                          onClick: () => handlePolicySelect(policy),
                          style: {
                            padding: "12px 16px",
                            fontSize: 15,
                            color: darkMode ? "#FFFFFF" : "#000000",
                            cursor: "pointer",
                            transition: "all 0.15s ease",
                            borderBottom: darkMode ? "1px solid #28282c" : "1px solid #f0f0f0",
                            background: formData.policy_id == policy.id ? darkMode ? "rgba(0, 122, 255, 0.3)" : "rgba(0, 122, 255, 0.1)" : "transparent"
                          },
                          onMouseEnter: (e) => {
                            if (formData.policy_id != policy.id) {
                              e.currentTarget.style.background = darkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)";
                            }
                          },
                          onMouseLeave: (e) => {
                            if (formData.policy_id != policy.id) {
                              e.currentTarget.style.background = "transparent";
                            }
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 4 }, children: policy.policy_number }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666", marginBottom: 4 }, children: [
                              policy.insurance_type,
                              "  ",
                              policy.citizen_name
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: [
                              "Valid until: ",
                              formatDate(policy.end_date)
                            ] })
                          ]
                        },
                        policy.id
                      ))
                    }
                  )
                ] }),
                formData.policy_id && (() => {
                  const selectedPolicy = policies.find((p) => p.id == formData.policy_id);
                  return selectedPolicy ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    padding: 12,
                    borderRadius: 8,
                    background: darkMode ? "rgba(0, 122, 255, 0.1)" : "rgba(0, 122, 255, 0.05)",
                    border: "1px solid #007AFF",
                    marginBottom: 8
                  }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: 600, fontSize: 14, marginBottom: 4 }, children: [
                      "Selected: ",
                      selectedPolicy.policy_number
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: [
                      selectedPolicy.insurance_type,
                      "  ",
                      selectedPolicy.citizen_name,
                      "  Valid until: ",
                      formatDate(selectedPolicy.end_date)
                    ] })
                  ] }) : null;
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Claim Amount ($) *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "Enter amount",
                      value: formData.amount,
                      onChange: (e) => setFormData({ ...formData, amount: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Description *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Describe your claim...",
                      value: formData.description,
                      onChange: (e) => setFormData({ ...formData, description: e.target.value }),
                      required: true,
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Additional Notes" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Any additional information...",
                      value: formData.notes,
                      onChange: (e) => setFormData({ ...formData, notes: e.target.value }),
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    disabled: submitting || !formData.policy_id || !formData.amount || !formData.description,
                    onClick: handleSubmit,
                    style: {
                      marginTop: 15,
                      background: formData.policy_id && formData.amount && formData.description ? "#007AFF" : "#666",
                      color: "#fff",
                      border: "none",
                      borderRadius: 12,
                      fontWeight: 700,
                      fontSize: 16,
                      padding: "13px 0",
                      boxShadow: "0 3px 9px 0 rgba(0,99,255,0.05)",
                      cursor: submitting || !formData.policy_id || !formData.amount || !formData.description ? "not-allowed" : "pointer",
                      opacity: submitting || !formData.policy_id || !formData.amount || !formData.description ? 0.7 : 1,
                      transition: "all .17s"
                    },
                    children: submitting ? "Submitting Claim..." : "Submit Claim"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  style: {
                    position: "absolute",
                    top: 18,
                    right: 22,
                    background: "transparent",
                    border: "none",
                    color: darkMode ? "#888" : "#222",
                    fontSize: 22,
                    cursor: "pointer"
                  },
                  onClick: onClose,
                  children: ""
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
      ]
    }
  );
};
const ClaimApprovalModal = ({ open, onClose, onSuccess, darkMode, claim }) => {
  const [formData, setFormData] = reactExports.useState({
    status: "Approved",
    approved_amount: "",
    notes: "",
    approved_by: ""
  });
  const [submitting, setSubmitting] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (open && claim) {
      setFormData({
        status: "Approved",
        approved_amount: claim.amount || "",
        notes: "",
        approved_by: ""
      });
    }
  }, [open, claim]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.approved_by) {
      alert("Please enter your name as the approver");
      return;
    }
    setSubmitting(true);
    const approvalData = {
      claim_id: claim.id,
      claim_number: claim.claim_number,
      status: formData.status,
      approved_amount: formData.status === "Approved" ? parseFloat(formData.approved_amount) : 0,
      notes: formData.notes,
      approved_by: formData.approved_by,
      approved_date: (/* @__PURE__ */ new Date()).toISOString()
    };
    callNui("approveInsuranceClaim", approvalData, (result) => {
      setSubmitting(false);
      if (result) {
        onSuccess(result);
        onClose();
      } else {
        alert("Failed to process claim. Please try again.");
      }
    });
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  if (!open || !claim) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.38)",
        zIndex: 99999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: (e) => e.stopPropagation(),
            style: {
              minWidth: 400,
              width: "100%",
              maxWidth: 500,
              background: darkMode ? "#19191b" : "#f7f7f9",
              borderRadius: 20,
              boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
              padding: 32,
              transform: "translateY(24px) scale(0.98)",
              opacity: 0,
              animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
              border: darkMode ? "1px solid #222226" : "1px solid #ebebee",
              color: darkMode ? "#fff" : "#19191b",
              position: "relative"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: darkMode ? "#222" : "#e4e8ef",
                      color: darkMode ? "#3B82F6" : "#2563EB",
                      borderRadius: 12,
                      width: 32,
                      height: 32,
                      alignItems: "center",
                      justifyContent: "center",
                      marginRight: 10,
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check-circle" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 21, fontWeight: 700 }, children: "Process Insurance Claim" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                padding: 16,
                borderRadius: 12,
                background: darkMode ? "rgba(59, 130, 246, 0.1)" : "rgba(37, 99, 235, 0.05)",
                border: "1px solid #3B82F6",
                marginBottom: 20
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: 600, fontSize: 16, marginBottom: 8 }, children: [
                  "Claim: ",
                  claim.claim_number
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#888" : "#666", marginBottom: 4 }, children: [
                  "Policy: ",
                  claim.policy_number
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#888" : "#666", marginBottom: 4 }, children: [
                  "Amount: ",
                  formatCurrency(claim.amount)
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#888" : "#666", marginBottom: 4 }, children: [
                  "Date: ",
                  formatDate(claim.date)
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#888" : "#666" }, children: [
                  "Description: ",
                  claim.description
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", flexDirection: "column", gap: 17 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Decision *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: formData.status,
                      onChange: (e) => setFormData({ ...formData, status: e.target.value }),
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Approved", children: "Approve" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Rejected", children: "Reject" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Under Review", children: "Under Review" })
                      ]
                    }
                  )
                ] }),
                formData.status === "Approved" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Approved Amount *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "Enter approved amount",
                      value: formData.approved_amount,
                      onChange: (e) => setFormData({ ...formData, approved_amount: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Approver Name *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "Your name",
                      value: formData.approved_by,
                      onChange: (e) => setFormData({ ...formData, approved_by: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Notes" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Additional notes or comments...",
                      value: formData.notes,
                      onChange: (e) => setFormData({ ...formData, notes: e.target.value }),
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    disabled: submitting || !formData.approved_by || formData.status === "Approved" && !formData.approved_amount,
                    onClick: handleSubmit,
                    style: {
                      marginTop: 15,
                      background: formData.status === "Approved" ? "#10B981" : formData.status === "Rejected" ? "#EF4444" : "#3B82F6",
                      color: "#fff",
                      border: "none",
                      borderRadius: 12,
                      fontWeight: 700,
                      fontSize: 16,
                      padding: "13px 0",
                      boxShadow: "0 3px 9px 0 rgba(0,0,0,0.1)",
                      cursor: submitting || !formData.approved_by || formData.status === "Approved" && !formData.approved_amount ? "not-allowed" : "pointer",
                      opacity: submitting || !formData.approved_by || formData.status === "Approved" && !formData.approved_amount ? 0.7 : 1,
                      transition: "all .17s"
                    },
                    children: submitting ? "Processing..." : `Process Claim as ${formData.status}`
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  style: {
                    position: "absolute",
                    top: 18,
                    right: 22,
                    background: "transparent",
                    border: "none",
                    color: darkMode ? "#888" : "#222",
                    fontSize: 22,
                    cursor: "pointer"
                  },
                  onClick: onClose,
                  children: ""
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
      ]
    }
  );
};
const MedicalRecordsModal = ({ open, onClose, onSuccess, darkMode, playerId, playerName }) => {
  const [formData, setFormData] = reactExports.useState({
    condition: "",
    diagnosis: "",
    treatment: "",
    doctor: "",
    notes: "",
    severity: "Low"
  });
  const [submitting, setSubmitting] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (open) {
      setFormData({
        condition: "",
        diagnosis: "",
        treatment: "",
        doctor: "",
        notes: "",
        severity: "Low"
      });
    }
  }, [open]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.condition || !formData.diagnosis || !formData.treatment || !formData.doctor) {
      alert("Please fill in all required fields");
      return;
    }
    setSubmitting(true);
    const medicalRecord = {
      player_id: playerId,
      player_name: playerName,
      condition: formData.condition,
      diagnosis: formData.diagnosis,
      treatment: formData.treatment,
      doctor: formData.doctor,
      notes: formData.notes,
      severity: formData.severity,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      status: "Active"
    };
    callNui("createMedicalRecord", medicalRecord, (result) => {
      setSubmitting(false);
      if (result) {
        onSuccess(result);
        onClose();
      } else {
        alert("Failed to create medical record. Please try again.");
      }
    });
  };
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.38)",
        zIndex: 99999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onClick: (e) => e.stopPropagation(),
            style: {
              minWidth: 400,
              width: "100%",
              maxWidth: 500,
              background: darkMode ? "#19191b" : "#f7f7f9",
              borderRadius: 20,
              boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
              padding: 32,
              transform: "translateY(24px) scale(0.98)",
              opacity: 0,
              animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
              border: darkMode ? "1px solid #222226" : "1px solid #ebebee",
              color: darkMode ? "#fff" : "#19191b",
              position: "relative"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", marginBottom: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: darkMode ? "#222" : "#e4e8ef",
                      color: darkMode ? "#10B981" : "#059669",
                      borderRadius: 12,
                      width: 32,
                      height: 32,
                      alignItems: "center",
                      justifyContent: "center",
                      marginRight: 10,
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user-md" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 21, fontWeight: 700 }, children: "Add Medical Record" })
              ] }),
              playerName && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                padding: 12,
                borderRadius: 8,
                background: darkMode ? "rgba(16, 185, 129, 0.1)" : "rgba(5, 150, 105, 0.05)",
                border: "1px solid #10B981",
                marginBottom: 16
              }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: 600, fontSize: 14, marginBottom: 4 }, children: [
                  "Patient: ",
                  playerName
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: [
                  "ID: ",
                  playerId
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { style: { display: "flex", flexDirection: "column", gap: 17 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Medical Condition *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "e.g., Hypertension, Diabetes, etc.",
                      value: formData.condition,
                      onChange: (e) => setFormData({ ...formData, condition: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Diagnosis *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Detailed diagnosis...",
                      value: formData.diagnosis,
                      onChange: (e) => setFormData({ ...formData, diagnosis: e.target.value }),
                      required: true,
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Treatment *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Treatment plan and medications...",
                      value: formData.treatment,
                      onChange: (e) => setFormData({ ...formData, treatment: e.target.value }),
                      required: true,
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Doctor Name *" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "text",
                        placeholder: "Doctor's name",
                        value: formData.doctor,
                        onChange: (e) => setFormData({ ...formData, doctor: e.target.value }),
                        required: true,
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Severity" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        value: formData.severity,
                        onChange: (e) => setFormData({ ...formData, severity: e.target.value }),
                        style: {
                          width: "100%",
                          padding: "12px 14px",
                          borderRadius: 10,
                          border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                          background: darkMode ? "#202024" : "#fff",
                          color: darkMode ? "#fff" : "#222",
                          fontSize: 15,
                          marginTop: 5,
                          outline: "none",
                          transition: "border 0.18s"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Low", children: "Low" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Medium", children: "Medium" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "High", children: "High" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Critical", children: "Critical" })
                        ]
                      }
                    )
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14 }, children: "Additional Notes" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textarea",
                    {
                      placeholder: "Any additional notes or observations...",
                      value: formData.notes,
                      onChange: (e) => setFormData({ ...formData, notes: e.target.value }),
                      rows: 3,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
                        background: darkMode ? "#202024" : "#fff",
                        color: darkMode ? "#fff" : "#222",
                        fontSize: 15,
                        marginTop: 5,
                        outline: "none",
                        resize: "vertical",
                        fontFamily: "inherit"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    disabled: submitting || !formData.condition || !formData.diagnosis || !formData.treatment || !formData.doctor,
                    onClick: handleSubmit,
                    style: {
                      marginTop: 15,
                      background: formData.condition && formData.diagnosis && formData.treatment && formData.doctor ? "#10B981" : "#666",
                      color: "#fff",
                      border: "none",
                      borderRadius: 12,
                      fontWeight: 700,
                      fontSize: 16,
                      padding: "13px 0",
                      boxShadow: "0 3px 9px 0 rgba(16,185,129,0.05)",
                      cursor: submitting || !formData.condition || !formData.diagnosis || !formData.treatment || !formData.doctor ? "not-allowed" : "pointer",
                      opacity: submitting || !formData.condition || !formData.diagnosis || !formData.treatment || !formData.doctor ? 0.7 : 1,
                      transition: "all .17s"
                    },
                    children: submitting ? "Creating Record..." : "Create Medical Record"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  style: {
                    position: "absolute",
                    top: 18,
                    right: 22,
                    background: "transparent",
                    border: "none",
                    color: darkMode ? "#888" : "#222",
                    fontSize: 22,
                    cursor: "pointer"
                  },
                  onClick: onClose,
                  children: ""
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
      ]
    }
  );
};
function PolicyDetailsModal({ policy, onClose, darkMode }) {
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `modal-overlay ${darkMode ? "dark" : "light"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content large", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Policy Details" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "policy-details-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "policy-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Policy Information" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Policy Number:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: policy.policy_number })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Type:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: policy.insurance_type })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Status:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: policy.status })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Start Date:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: formatDate(policy.start_date) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "End Date:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: formatDate(policy.end_date) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Monthly Premium:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: formatCurrency(policy.monthly_premium) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Coverage Amount:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: formatCurrency(policy.coverage_amount) })
          ] })
        ] })
      ] }),
      policy.emergency_contact && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "emergency-info", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Emergency Contact" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-grid", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Contact:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: policy.emergency_contact })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "info-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Phone:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: policy.emergency_phone })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "modal-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: onClose, children: "Close" }) })
  ] }) });
}
function PolicyRenewalModal({ policy, onClose, onRenew, darkMode }) {
  const [renewalData, setRenewalData] = reactExports.useState({
    new_end_date: "",
    renewal_amount: policy.monthly_premium,
    auto_renewal: false
  });
  const handleSubmit = (e) => {
    e.preventDefault();
    onRenew(renewalData);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `modal-overlay ${darkMode ? "dark" : "light"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-content", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "Renew Policy" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "close-btn", onClick: onClose, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Policy Number" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "text", value: policy.policy_number, disabled: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "New End Date" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "date",
            value: renewalData.new_end_date,
            onChange: (e) => setRenewalData({ ...renewalData, new_end_date: e.target.value }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "form-group", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Renewal Amount" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "number",
            value: renewalData.renewal_amount,
            onChange: (e) => setRenewalData({ ...renewalData, renewal_amount: e.target.value }),
            required: true
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "form-group", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "checkbox",
            checked: renewalData.auto_renewal,
            onChange: (e) => setRenewalData({ ...renewalData, auto_renewal: e.target.checked })
          }
        ),
        "Enable Auto-Renewal"
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: "btn-secondary", onClick: onClose, children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "submit", className: "btn-primary", children: "Renew Policy" })
      ] })
    ] })
  ] }) });
}
const InsurancePlansModal = ({ open, onClose, onSuccess, darkMode, plans = [] }) => {
  const [isCreating, setIsCreating] = reactExports.useState(false);
  const [formData, setFormData] = reactExports.useState({
    plan_name: "",
    category: "Basic",
    monthly_premium: "",
    coverage_amount: "",
    description: "",
    features: "",
    deductible: "",
    max_claims_per_year: ""
  });
  const [submitting, setSubmitting] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (open) {
      setFormData({
        plan_name: "",
        category: "Basic",
        monthly_premium: "",
        coverage_amount: "",
        description: "",
        features: "",
        deductible: "",
        max_claims_per_year: ""
      });
    }
  }, [open]);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!formData.plan_name || !formData.monthly_premium || !formData.coverage_amount) {
      alert("Please fill in all required fields");
      return;
    }
    setSubmitting(true);
    const newPlan = {
      plan_name: formData.plan_name,
      category: formData.category,
      monthly_premium: parseFloat(formData.monthly_premium),
      coverage_amount: parseFloat(formData.coverage_amount),
      description: formData.description,
      features: formData.features,
      deductible: parseFloat(formData.deductible) || 0,
      max_claims_per_year: parseInt(formData.max_claims_per_year) || 10,
      is_active: 1
    };
    callNui("createInsurancePlan", newPlan, (result) => {
      setSubmitting(false);
      if (result && result.success) {
        onSuccess(result);
        onClose();
        setIsCreating(false);
      } else {
        alert("Failed to create insurance plan. Please try again.");
      }
    });
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.5)",
        zIndex: 99999,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transition: "background 0.2s ease"
      },
      onClick: onClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          onClick: (e) => e.stopPropagation(),
          style: {
            width: "90%",
            maxWidth: 800,
            maxHeight: "90vh",
            background: darkMode ? "#1f1f23" : "#fff",
            borderRadius: 20,
            boxShadow: "0 8px 36px rgba(0,0,0,0.16)",
            padding: 32,
            transform: "translateY(24px) scale(0.98)",
            opacity: 0,
            animation: "smoothModalIn 0.35s cubic-bezier(.58,1.7,.38,.92) forwards",
            border: darkMode ? "1px solid #2a2a2e" : "1px solid #e5e7eb",
            color: darkMode ? "#fff" : "#1e293b",
            position: "relative",
            overflow: "auto"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 24 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 12 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "span",
                  {
                    style: {
                      display: "inline-flex",
                      background: darkMode ? "#222" : "#e4e8ef",
                      color: darkMode ? "#10B981" : "#059669",
                      borderRadius: 12,
                      width: 40,
                      height: 40,
                      alignItems: "center",
                      justifyContent: "center",
                      fontSize: 18
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-shield-halved" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 24, fontWeight: 700 }, children: isCreating ? "Create New Insurance Plan" : "Insurance Plans" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8 }, children: [
                !isCreating && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    onClick: () => setIsCreating(true),
                    style: {
                      background: "#10B981",
                      color: "#fff",
                      border: "none",
                      padding: "10px 16px",
                      borderRadius: 8,
                      fontWeight: 600,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      gap: 6
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
                      "Add Plan"
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    style: {
                      position: "absolute",
                      top: 18,
                      right: 22,
                      background: "transparent",
                      border: "none",
                      color: darkMode ? "#888" : "#666",
                      fontSize: 24,
                      cursor: "pointer",
                      width: 32,
                      height: 32,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center"
                    },
                    onClick: onClose,
                    children: ""
                  }
                )
              ] })
            ] }),
            isCreating ? /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, style: { display: "flex", flexDirection: "column", gap: 20 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Plan Name *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      placeholder: "e.g., Premium Health Elite",
                      value: formData.plan_name,
                      onChange: (e) => setFormData({ ...formData, plan_name: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Category *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "select",
                    {
                      value: formData.category,
                      onChange: (e) => setFormData({ ...formData, category: e.target.value }),
                      required: true,
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Basic", children: "Basic" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Premium", children: "Premium" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Family", children: "Family" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Emergency", children: "Emergency" })
                      ]
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Monthly Premium ($) *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "150.00",
                      value: formData.monthly_premium,
                      onChange: (e) => setFormData({ ...formData, monthly_premium: e.target.value }),
                      required: true,
                      min: "0",
                      step: "0.01",
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Coverage Amount ($) *" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "50000.00",
                      value: formData.coverage_amount,
                      onChange: (e) => setFormData({ ...formData, coverage_amount: e.target.value }),
                      required: true,
                      min: "0",
                      step: "0.01",
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Description" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    placeholder: "Brief description of the plan...",
                    value: formData.description,
                    onChange: (e) => setFormData({ ...formData, description: e.target.value }),
                    rows: 3,
                    style: {
                      width: "100%",
                      padding: "12px 14px",
                      borderRadius: 10,
                      border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                      background: darkMode ? "#2a2a2e" : "#fff",
                      color: darkMode ? "#fff" : "#1e293b",
                      fontSize: 15,
                      outline: "none",
                      resize: "vertical",
                      fontFamily: "inherit"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Features (comma-separated)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    placeholder: "Emergency room visits, Basic doctor visits, Prescription drugs",
                    value: formData.features,
                    onChange: (e) => setFormData({ ...formData, features: e.target.value }),
                    rows: 3,
                    style: {
                      width: "100%",
                      padding: "12px 14px",
                      borderRadius: 10,
                      border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                      background: darkMode ? "#2a2a2e" : "#fff",
                      color: darkMode ? "#fff" : "#1e293b",
                      fontSize: 15,
                      outline: "none",
                      resize: "vertical",
                      fontFamily: "inherit"
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 16 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Deductible ($)" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "500.00",
                      value: formData.deductible,
                      onChange: (e) => setFormData({ ...formData, deductible: e.target.value }),
                      min: "0",
                      step: "0.01",
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontWeight: 600, fontSize: 14, marginBottom: 6, display: "block" }, children: "Max Claims per Year" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "number",
                      placeholder: "10",
                      value: formData.max_claims_per_year,
                      onChange: (e) => setFormData({ ...formData, max_claims_per_year: e.target.value }),
                      min: "1",
                      style: {
                        width: "100%",
                        padding: "12px 14px",
                        borderRadius: 10,
                        border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                        background: darkMode ? "#2a2a2e" : "#fff",
                        color: darkMode ? "#fff" : "#1e293b",
                        fontSize: 15,
                        outline: "none",
                        transition: "border 0.18s"
                      }
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 12, marginTop: 20 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: () => setIsCreating(false),
                    style: {
                      flex: 1,
                      padding: "12px 20px",
                      background: "transparent",
                      color: darkMode ? "#fff" : "#1e293b",
                      border: `1px solid ${darkMode ? "#2a2a2e" : "#d1d5db"}`,
                      borderRadius: 10,
                      fontWeight: 600,
                      cursor: "pointer",
                      transition: "all 0.2s"
                    },
                    children: "Cancel"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "submit",
                    disabled: submitting || !formData.plan_name || !formData.monthly_premium || !formData.coverage_amount,
                    style: {
                      flex: 1,
                      padding: "12px 20px",
                      background: formData.plan_name && formData.monthly_premium && formData.coverage_amount ? "#10B981" : "#6B7280",
                      color: "#fff",
                      border: "none",
                      borderRadius: 10,
                      fontWeight: 600,
                      cursor: submitting || !formData.plan_name || !formData.monthly_premium || !formData.coverage_amount ? "not-allowed" : "pointer",
                      opacity: submitting || !formData.plan_name || !formData.monthly_premium || !formData.coverage_amount ? 0.7 : 1,
                      transition: "all 0.2s"
                    },
                    children: submitting ? "Creating Plan..." : "Create Plan"
                  }
                )
              ] })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))", gap: 20 }, children: plans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  background: darkMode ? "#2a2a2e" : "#f8fafc",
                  borderRadius: 12,
                  padding: 20,
                  border: `1px solid ${darkMode ? "#3a3a3e" : "#e5e7eb"}`,
                  cursor: "pointer",
                  transition: "all 0.2s"
                },
                onMouseEnter: (e) => {
                  e.target.style.transform = "translateY(-2px)";
                  e.target.style.boxShadow = "0 8px 25px rgba(0,0,0,0.1)";
                },
                onMouseLeave: (e) => {
                  e.target.style.transform = "translateY(0)";
                  e.target.style.boxShadow = "none";
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", marginBottom: 12 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { style: { fontSize: 18, fontWeight: 600, margin: "0 0 4px 0", color: darkMode ? "#fff" : "#1e293b" }, children: plan.plan_name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                        padding: "4px 8px",
                        borderRadius: 6,
                        fontSize: 12,
                        fontWeight: 600,
                        background: "#10B98120",
                        color: "#10B981",
                        border: "1px solid #10B98140"
                      }, children: plan.category })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "right" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 20, fontWeight: 700, color: "#10B981" }, children: formatCurrency(plan.monthly_premium) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: darkMode ? "#888" : "#666" }, children: "/month" })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 12 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#ccc" : "#555", marginBottom: 4 }, children: [
                      "Coverage: ",
                      formatCurrency(plan.coverage_amount)
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 14, color: darkMode ? "#ccc" : "#555" }, children: [
                      "Deductible: ",
                      formatCurrency(plan.deductible)
                    ] })
                  ] }),
                  plan.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: 14, color: darkMode ? "#ddd" : "#333", marginBottom: 12, lineHeight: 1.4 }, children: plan.description }),
                  plan.features && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 600, color: darkMode ? "#ccc" : "#555", marginBottom: 6 }, children: "Features:" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { fontSize: 12, color: darkMode ? "#ddd" : "#333", margin: 0, paddingLeft: 16 }, children: [
                      plan.features.split(", ").slice(0, 3).map((feature, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: feature }, index)),
                      plan.features.split(", ").length > 3 && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                        "+",
                        plan.features.split(", ").length - 3,
                        " more"
                      ] })
                    ] })
                  ] })
                ]
              },
              plan.id
            )) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `@keyframes smoothModalIn {
            from { opacity: 0; transform: translateY(60px) scale(.92); }
            to { opacity: 1; transform: translateY(0) scale(1); }
          }` })
          ]
        }
      )
    }
  );
};
function PolicyCard({ policy, onClick, onRenew, darkMode }) {
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "Active":
        return "#10B981";
      case "Expired":
        return "#EF4444";
      case "Cancelled":
        return "#F59E0B";
      case "Pending":
        return "#3B82F6";
      default:
        return "#6B7280";
    }
  };
  const getInsuranceTypeColor = (type) => {
    switch (type) {
      case "Basic":
        return "#6B7280";
      case "Premium":
        return "#10B981";
      case "Family":
        return "#3B82F6";
      case "Emergency":
        return "#EF4444";
      default:
        return "#6B7280";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "policy-card",
      onClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "policy-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "policy-type", style: { backgroundColor: getInsuranceTypeColor(policy.insurance_type) }, children: policy.insurance_type }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "policy-status", style: { backgroundColor: getStatusColor(policy.status) }, children: policy.status })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "policy-body", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
            "Policy #",
            policy.policy_number
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "policy-name", children: policy.citizen_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "policy-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Premium:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                formatCurrency(policy.monthly_premium),
                "/month"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Coverage:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatCurrency(policy.coverage_amount) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "detail", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Valid Until:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: formatDate(policy.end_date) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "policy-actions", children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-small", onClick: (e) => {
          e.stopPropagation();
          onRenew(policy);
        }, children: "Renew" }) })
      ]
    }
  );
}
function ClaimItem({ claim, darkMode, onApprove }) {
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "Active":
        return "#10B981";
      case "Expired":
        return "#EF4444";
      case "Cancelled":
        return "#F59E0B";
      case "Pending":
        return "#3B82F6";
      default:
        return "#6B7280";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "claim-item", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "claim-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { children: [
        "Claim #",
        claim.claim_number
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "claim-status", style: { backgroundColor: getStatusColor(claim.status) }, children: claim.status })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "claim-details", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Date:" }),
        " ",
        formatDate(claim.date)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Amount:" }),
        " ",
        formatCurrency(claim.amount)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Description:" }),
        " ",
        claim.description
      ] }),
      claim.notes && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Notes:" }),
        " ",
        claim.notes
      ] })
    ] }),
    claim.status === "Pending" && onApprove && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 12, textAlign: "right" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => onApprove(claim),
        style: {
          background: "#10B981",
          color: "#fff",
          border: "none",
          padding: "8px 16px",
          borderRadius: 6,
          fontSize: 12,
          fontWeight: 500,
          cursor: "pointer",
          transition: "all 0.2s ease"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-check", style: { marginRight: 6 } }),
          "Process Claim"
        ]
      }
    ) })
  ] });
}
function PlanCard({ plan, onClick, isSelected, darkMode }) {
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `plan-card ${isSelected ? "selected" : ""}`,
      onClick,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: plan.plan_name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "plan-category", children: plan.category })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-price", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "price", children: formatCurrency(plan.monthly_premium) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "period", children: "/month" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-coverage", children: [
          "Coverage: ",
          formatCurrency(plan.coverage_amount)
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-features", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: plan.description }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: plan.features.split(", ").map((feature, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: feature }, index)) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-details", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Deductible:" }),
            " ",
            formatCurrency(plan.deductible)
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Max Claims:" }),
            " ",
            plan.max_claims_per_year,
            "/year"
          ] })
        ] }),
        onClick && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", style: { marginTop: "16px", width: "100%" }, children: "Select This Plan" }),
        isSelected && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "selected-indicator", children: " Selected" })
      ]
    }
  );
}
function DropdownButton({
  icon,
  text,
  isOpen,
  onClick,
  children,
  darkMode
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "dropdown-button", onClick, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: `fa-solid fa-chevron-down ${isOpen ? "rotated" : ""}` })
    ] }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dropdown-menu", children })
  ] });
}
function DropdownItem({ icon, text, onClick, darkMode }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown-item", onClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text })
  ] });
}
function EmptyState({
  icon,
  title,
  description,
  buttonText,
  onButtonClick,
  darkMode
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "empty-state", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "empty-icon", children: icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: description }),
    buttonText && onButtonClick && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "btn-primary", onClick: onButtonClick, children: buttonText })
  ] });
}
const TransactionHistory = ({ darkMode }) => {
  const [transactions, setTransactions] = reactExports.useState([]);
  const [filteredTransactions, setFilteredTransactions] = reactExports.useState([]);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [filterType, setFilterType] = reactExports.useState("all");
  const [loading2, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    loadTransactions();
  }, []);
  reactExports.useEffect(() => {
    filterTransactions();
  }, [transactions, searchQuery, filterType]);
  const loadTransactions = () => {
    setLoading(true);
    callNui("getInsuranceTransactions", {}, (result) => {
      setLoading(false);
      if (result && result.transactions) {
        setTransactions(result.transactions || []);
      } else {
        setTransactions([
          {
            id: 1,
            transaction_id: "TXN-001",
            policy_number: "POL-ABC123",
            type: "Premium Payment",
            amount: -150,
            description: "Monthly premium payment for Basic Health Plus",
            date: new Date(Date.now() - 864e5).toISOString(),
            status: "Completed"
          },
          {
            id: 2,
            transaction_id: "TXN-002",
            policy_number: "POL-ABC123",
            type: "Claim Payout",
            amount: 2500,
            description: "Claim payout for medical expenses",
            date: new Date(Date.now() - 1728e5).toISOString(),
            status: "Completed"
          },
          {
            id: 3,
            transaction_id: "TXN-003",
            policy_number: "POL-DEF456",
            type: "Premium Payment",
            amount: -350,
            description: "Monthly premium payment for Premium Health Elite",
            date: new Date(Date.now() - 2592e5).toISOString(),
            status: "Completed"
          }
        ]);
      }
    });
  };
  const filterTransactions = () => {
    let filtered = transactions;
    if (filterType !== "all") {
      filtered = filtered.filter((t) => t.type === filterType);
    }
    if (searchQuery) {
      filtered = filtered.filter(
        (t) => t.transaction_id.toLowerCase().includes(searchQuery.toLowerCase()) || t.policy_number.toLowerCase().includes(searchQuery.toLowerCase()) || t.description.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }
    setFilteredTransactions(filtered);
  };
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(Math.abs(amount));
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  const getTransactionIcon = (type) => {
    switch (type) {
      case "Premium Payment":
        return "fa-solid fa-credit-card";
      case "Claim Payout":
        return "fa-solid fa-hand-holding-dollar";
      case "Policy Refund":
        return "fa-solid fa-arrow-left";
      case "Late Fee":
        return "fa-solid fa-exclamation-triangle";
      default:
        return "fa-solid fa-exchange-alt";
    }
  };
  const getTransactionColor = (type, amount) => {
    if (amount > 0) return "#10B981";
    if (amount < 0) return "#EF4444";
    return "#6B7280";
  };
  const getStatusColor = (status) => {
    switch (status) {
      case "Completed":
        return "#10B981";
      case "Pending":
        return "#F59E0B";
      case "Failed":
        return "#EF4444";
      default:
        return "#6B7280";
    }
  };
  if (loading2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: 200,
      color: darkMode ? "#888" : "#666"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-spinner fa-spin", style: { fontSize: 24, marginRight: 12 } }),
      "Loading transactions..."
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: 20 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 24 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: {
        fontSize: 24,
        fontWeight: 600,
        margin: "0 0 8px 0",
        color: darkMode ? "#fff" : "#1e293b"
      }, children: "Transaction History" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: {
        fontSize: 16,
        margin: 0,
        color: darkMode ? "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.7)"
      }, children: "View all insurance-related transactions" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      display: "flex",
      gap: 16,
      marginBottom: 24,
      flexWrap: "wrap"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1, minWidth: 300 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search by transaction ID, policy number, or description...",
          value: searchQuery,
          onChange: (e) => setSearchQuery(e.target.value),
          style: {
            width: "100%",
            padding: "12px 16px",
            borderRadius: 10,
            border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
            background: darkMode ? "#202024" : "#fff",
            color: darkMode ? "#fff" : "#222",
            fontSize: 15,
            outline: "none",
            transition: "border 0.18s"
          }
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "select",
        {
          value: filterType,
          onChange: (e) => setFilterType(e.target.value),
          style: {
            padding: "12px 16px",
            borderRadius: 10,
            border: darkMode ? "1px solid #28282c" : "1px solid #ddd",
            background: darkMode ? "#202024" : "#fff",
            color: darkMode ? "#fff" : "#222",
            fontSize: 15,
            outline: "none",
            transition: "border 0.18s",
            minWidth: 150
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Transactions" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Premium Payment", children: "Premium Payments" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Claim Payout", children: "Claim Payouts" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Policy Refund", children: "Policy Refunds" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "Late Fee", children: "Late Fees" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: loadTransactions,
          style: {
            padding: "12px 16px",
            borderRadius: 10,
            background: "#007AFF",
            color: "#fff",
            border: "none",
            fontSize: 15,
            fontWeight: 500,
            cursor: "pointer",
            transition: "all 0.2s ease"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-rotate", style: { marginRight: 8 } }),
            "Refresh"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      background: darkMode ? "rgba(255, 255, 255, 0.05)" : "rgba(255, 255, 255, 0.8)",
      borderRadius: 12,
      border: darkMode ? "1px solid rgba(255, 255, 255, 0.1)" : "1px solid rgba(0, 0, 0, 0.1)",
      overflow: "hidden"
    }, children: filteredTransactions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      padding: 40,
      textAlign: "center",
      color: darkMode ? "rgba(255, 255, 255, 0.6)" : "rgba(0, 0, 0, 0.6)"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-receipt", style: { fontSize: 48, marginBottom: 16, opacity: 0.5 } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 18, fontWeight: 600, marginBottom: 8 }, children: "No transactions found" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14 }, children: searchQuery || filterType !== "all" ? "Try adjusting your search or filters" : "Transactions will appear here once you have insurance activity" })
    ] }) : filteredTransactions.map((transaction) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          padding: 20,
          borderBottom: darkMode ? "1px solid rgba(255, 255, 255, 0.1)" : "1px solid rgba(0, 0, 0, 0.1)",
          display: "flex",
          alignItems: "center",
          gap: 16,
          transition: "background 0.2s ease"
        },
        onMouseEnter: (e) => {
          e.currentTarget.style.background = darkMode ? "rgba(255, 255, 255, 0.05)" : "rgba(0, 0, 0, 0.02)";
        },
        onMouseLeave: (e) => {
          e.currentTarget.style.background = "transparent";
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            width: 48,
            height: 48,
            borderRadius: 12,
            background: darkMode ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.05)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: getTransactionColor(transaction.type, transaction.amount)
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: getTransactionIcon(transaction.type), style: { fontSize: 20 } }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "flex-start",
              marginBottom: 8
            }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  fontSize: 16,
                  fontWeight: 600,
                  marginBottom: 4,
                  color: darkMode ? "#fff" : "#1e293b"
                }, children: transaction.type }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  fontSize: 14,
                  marginBottom: 4,
                  color: darkMode ? "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.7)"
                }, children: transaction.description }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  fontSize: 12,
                  color: darkMode ? "rgba(255, 255, 255, 0.5)" : "rgba(0, 0, 0, 0.5)"
                }, children: [
                  "Policy: ",
                  transaction.policy_number,
                  "  ",
                  transaction.transaction_id
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "right" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  fontSize: 18,
                  fontWeight: 700,
                  marginBottom: 4,
                  color: getTransactionColor(transaction.type, transaction.amount)
                }, children: [
                  transaction.amount > 0 ? "+" : "",
                  formatCurrency(transaction.amount)
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  fontSize: 12,
                  color: getStatusColor(transaction.status)
                }, children: transaction.status })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
              fontSize: 12,
              color: darkMode ? "rgba(255, 255, 255, 0.5)" : "rgba(0, 0, 0, 0.5)"
            }, children: formatDate(transaction.date) })
          ] })
        ]
      },
      transaction.id
    )) }),
    filteredTransactions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      marginTop: 20,
      padding: 16,
      borderRadius: 10,
      background: darkMode ? "rgba(0, 122, 255, 0.1)" : "rgba(0, 122, 255, 0.05)",
      border: "1px solid #007AFF"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        fontSize: 14,
        fontWeight: 600,
        marginBottom: 8,
        color: darkMode ? "#fff" : "#1e293b"
      }, children: "Summary" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        gap: 24,
        fontSize: 12,
        color: darkMode ? "rgba(255, 255, 255, 0.7)" : "rgba(0, 0, 0, 0.7)"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Total Transactions: ",
          filteredTransactions.length
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Total Incoming: ",
          formatCurrency(
            filteredTransactions.filter((t) => t.amount > 0).reduce((sum2, t) => sum2 + t.amount, 0)
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Total Outgoing: ",
          formatCurrency(
            Math.abs(filteredTransactions.filter((t) => t.amount < 0).reduce((sum2, t) => sum2 + t.amount, 0))
          )
        ] })
      ] })
    ] })
  ] });
};
const MedicalRecordsViewer = ({ darkMode, onAddMedicalRecord }) => {
  var _a2;
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [selectedPlayerId, setSelectedPlayerId] = reactExports.useState("");
  const [selectedPlayerName, setSelectedPlayerName] = reactExports.useState("");
  const [medicalRecords, setMedicalRecords] = reactExports.useState([]);
  const [loading2, setLoading] = reactExports.useState(false);
  const [error, setError] = reactExports.useState("");
  const [searchResults, setSearchResults] = reactExports.useState([]);
  const [showSearchResults, setShowSearchResults] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (showSearchResults && !event.target.closest(".search-container")) {
        setShowSearchResults(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [showSearchResults]);
  const handleSearchPlayer = async () => {
    if (!searchQuery.trim()) {
      setError("Please enter a player ID or name");
      return;
    }
    setLoading(true);
    setError("");
    callNui("searchPlayer", { searchQuery: searchQuery.trim() }, (searchResult) => {
      setLoading(false);
      if (searchResult && searchResult.success && searchResult.players.length > 0) {
        setSearchResults(searchResult.players);
        setShowSearchResults(true);
        setError("");
      } else {
        setError("No players found with that name or ID");
        setSearchResults([]);
        setShowSearchResults(false);
        setMedicalRecords([]);
        setSelectedPlayerId("");
        setSelectedPlayerName("");
      }
    });
  };
  const handleSelectPlayer = (player) => {
    setSelectedPlayerId(player.citizen_id);
    setSelectedPlayerName(player.name);
    setSearchQuery(player.name);
    setShowSearchResults(false);
    setError("");
    if (player.canCreateRecord) {
      setMedicalRecords([]);
      setError("This player has no medical records yet. You can create a new record.");
      return;
    }
    callNui("getMedicalRecords", { targetPlayerId: player.citizen_id }, (result) => {
      if (result && result.success) {
        setMedicalRecords(result.records || []);
        if (result.records.length === 0) {
          setError("No medical records found for this player. You can create a new record.");
        }
      } else {
        setError("No medical records found for this player. You can create a new record.");
        setMedicalRecords([]);
      }
    });
  };
  const handleAddRecord = () => {
    if (selectedPlayerId && onAddMedicalRecord) {
      onAddMedicalRecord(selectedPlayerId, selectedPlayerName || selectedPlayerId);
    }
  };
  const getSeverityColor = (severity) => {
    switch (severity) {
      case "Low":
        return "#10B981";
      case "Medium":
        return "#F59E0B";
      case "High":
        return "#EF4444";
      case "Critical":
        return "#DC2626";
      default:
        return "#6B7280";
    }
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  };
  if (loading2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      height: 200,
      color: darkMode ? "#fff" : "#333"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 24, marginBottom: 10 }, children: "" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading medical records..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: 20 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      background: darkMode ? "#1f1f23" : "#fff",
      borderRadius: 12,
      padding: 20,
      marginBottom: 20,
      border: darkMode ? "1px solid #2a2a2e" : "1px solid #e5e7eb"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        alignItems: "center",
        marginBottom: 15,
        gap: 10
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
          display: "inline-flex",
          background: darkMode ? "#222" : "#e4e8ef",
          color: darkMode ? "#10B981" : "#059669",
          borderRadius: 8,
          width: 28,
          height: 28,
          alignItems: "center",
          justifyContent: "center",
          fontSize: 14
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-search" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 18, fontWeight: 600 }, children: "Search Medical Records" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10, flexWrap: "wrap", position: "relative" }, className: "search-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1, minWidth: 200, position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Enter Player Name",
              value: searchQuery,
              onChange: (e) => setSearchQuery(e.target.value),
              onKeyPress: (e) => e.key === "Enter" && handleSearchPlayer(),
              onFocus: () => searchResults.length > 0 && setShowSearchResults(true),
              style: {
                width: "100%",
                padding: "12px 14px",
                borderRadius: 8,
                border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                background: darkMode ? "#2a2a2e" : "#fff",
                color: darkMode ? "#fff" : "#333",
                fontSize: 14,
                outline: "none"
              }
            }
          ),
          showSearchResults && searchResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
            position: "absolute",
            top: "100%",
            left: 0,
            right: 0,
            background: darkMode ? "#2a2a2e" : "#fff",
            border: darkMode ? "1px solid #3a3a3e" : "1px solid #d1d5db",
            borderRadius: 8,
            maxHeight: 200,
            overflowY: "auto",
            zIndex: 1e3,
            marginTop: 4
          }, children: searchResults.map((player, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onClick: () => handleSelectPlayer(player),
              style: {
                padding: "12px 14px",
                cursor: "pointer",
                borderBottom: index < searchResults.length - 1 ? darkMode ? "1px solid #3a3a3e" : "1px solid #f3f4f6" : "none",
                color: darkMode ? "#fff" : "#333",
                fontSize: 14,
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center"
              },
              onMouseEnter: (e) => {
                e.target.style.background = darkMode ? "#3a3a3e" : "#f9fafb";
              },
              onMouseLeave: (e) => {
                e.target.style.background = "transparent";
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600 }, children: player.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                    fontSize: 12,
                    color: darkMode ? "#9ca3af" : "#6b7280",
                    marginTop: 2
                  }, children: [
                    "ID: ",
                    player.citizen_id
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  padding: "4px 8px",
                  borderRadius: 4,
                  fontSize: 11,
                  fontWeight: 600,
                  background: player.online ? "#10B981" : player.canCreateRecord ? "#F59E0B" : "#6B7280",
                  color: "#fff"
                }, children: player.online ? "ONLINE" : player.canCreateRecord ? "NEW PLAYER" : "OFFLINE" })
              ]
            },
            index
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleSearchPlayer,
            disabled: !searchQuery.trim(),
            style: {
              padding: "12px 20px",
              background: searchQuery.trim() ? "#10B981" : "#6B7280",
              color: "#fff",
              border: "none",
              borderRadius: 8,
              fontWeight: 600,
              cursor: searchQuery.trim() ? "pointer" : "not-allowed",
              opacity: searchQuery.trim() ? 1 : 0.6,
              whiteSpace: "nowrap"
            },
            children: "Search"
          }
        ),
        onAddMedicalRecord && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleAddRecord,
            disabled: !selectedPlayerId,
            style: {
              padding: "12px 20px",
              background: !selectedPlayerId ? "#6B7280" : "#3B82F6",
              color: "#fff",
              border: "none",
              borderRadius: 8,
              fontWeight: 600,
              cursor: !selectedPlayerId ? "not-allowed" : "pointer",
              opacity: !selectedPlayerId ? 0.6 : 1,
              whiteSpace: "nowrap",
              display: "flex",
              alignItems: "center",
              gap: 6
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
              selectedPlayerId && ((_a2 = searchResults.find((p) => p.citizen_id === selectedPlayerId)) == null ? void 0 : _a2.canCreateRecord) ? "Create Record" : "Add Record"
            ]
          }
        )
      ] }),
      error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
        marginTop: 10,
        padding: 10,
        background: error.includes("create a new record") ? "rgba(59, 130, 246, 0.1)" : "rgba(239, 68, 68, 0.1)",
        border: error.includes("create a new record") ? "1px solid #3B82F6" : "1px solid #EF4444",
        borderRadius: 6,
        color: error.includes("create a new record") ? "#3B82F6" : "#EF4444",
        fontSize: 14
      }, children: error }),
      selectedPlayerId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        marginTop: 10,
        padding: 10,
        background: "rgba(16, 185, 129, 0.1)",
        border: "1px solid #10B981",
        borderRadius: 6,
        color: "#10B981",
        fontSize: 14
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Selected Patient:" }),
        " ",
        selectedPlayerName || selectedPlayerId,
        " (ID: ",
        selectedPlayerId,
        ")"
      ] })
    ] }),
    selectedPlayerId && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
      background: darkMode ? "#1f1f23" : "#fff",
      borderRadius: 12,
      padding: 20,
      border: darkMode ? "1px solid #2a2a2e" : "1px solid #e5e7eb"
    }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: 20,
        gap: 10
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 10 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
            display: "inline-flex",
            background: darkMode ? "#222" : "#e4e8ef",
            color: darkMode ? "#10B981" : "#059669",
            borderRadius: 8,
            width: 28,
            height: 28,
            alignItems: "center",
            justifyContent: "center",
            fontSize: 14
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user-md" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 18, fontWeight: 600 }, children: [
            "Medical Records for: ",
            selectedPlayerName || selectedPlayerId
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 14, color: darkMode ? "#888" : "#666" }, children: [
            medicalRecords.length,
            " record",
            medicalRecords.length !== 1 ? "s" : ""
          ] }),
          onAddMedicalRecord && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleAddRecord,
              style: {
                padding: "8px 16px",
                background: "#3B82F6",
                color: "#fff",
                border: "none",
                borderRadius: 6,
                fontWeight: 600,
                cursor: "pointer",
                fontSize: 12,
                display: "flex",
                alignItems: "center",
                gap: 4
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
                "Add New"
              ]
            }
          )
        ] })
      ] }),
      medicalRecords.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
        textAlign: "center",
        padding: 40,
        color: darkMode ? "#888" : "#666"
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 24, marginBottom: 10 }, children: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "No medical records found for this player." }),
        onAddMedicalRecord && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleAddRecord,
            style: {
              marginTop: 16,
              padding: "12px 24px",
              background: "#3B82F6",
              color: "#fff",
              border: "none",
              borderRadius: 8,
              fontWeight: 600,
              cursor: "pointer",
              display: "flex",
              alignItems: "center",
              gap: 8,
              margin: "16px auto 0"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
              "Add First Record"
            ]
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: 15 }, children: medicalRecords.map((record, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            background: darkMode ? "#2a2a2e" : "#f9fafb",
            borderRadius: 10,
            padding: 16,
            border: `1px solid ${darkMode ? "#3a3a3e" : "#e5e7eb"}`
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", marginBottom: 12 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                  fontSize: 16,
                  fontWeight: 600,
                  marginBottom: 4,
                  color: darkMode ? "#fff" : "#111"
                }, children: record.condition }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
                  fontSize: 12,
                  color: darkMode ? "#888" : "#666",
                  marginBottom: 8
                }, children: [
                  "Doctor: ",
                  record.doctor,
                  "  ",
                  formatDate(record.date)
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                padding: "4px 8px",
                borderRadius: 6,
                fontSize: 11,
                fontWeight: 600,
                background: `${getSeverityColor(record.severity)}20`,
                color: getSeverityColor(record.severity),
                border: `1px solid ${getSeverityColor(record.severity)}40`
              }, children: record.severity })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 10 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 13,
                fontWeight: 600,
                marginBottom: 4,
                color: darkMode ? "#ccc" : "#555"
              }, children: "Diagnosis:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 14,
                color: darkMode ? "#ddd" : "#333",
                lineHeight: 1.4
              }, children: record.diagnosis })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginBottom: 10 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 13,
                fontWeight: 600,
                marginBottom: 4,
                color: darkMode ? "#ccc" : "#555"
              }, children: "Treatment:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 14,
                color: darkMode ? "#ddd" : "#333",
                lineHeight: 1.4
              }, children: record.treatment })
            ] }),
            record.notes && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 13,
                fontWeight: 600,
                marginBottom: 4,
                color: darkMode ? "#ccc" : "#555"
              }, children: "Notes:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
                fontSize: 14,
                color: darkMode ? "#ddd" : "#333",
                lineHeight: 1.4,
                fontStyle: "italic"
              }, children: record.notes })
            ] })
          ]
        },
        record.id || index
      )) })
    ] })
  ] });
};
function InsuranceApp({ lang, insuranceData, tabOwner, tabletTheme }) {
  const [activeTab, setActiveTab] = reactExports.useState("policies");
  const [policies, setPolicies] = reactExports.useState([]);
  const [claims, setClaims] = reactExports.useState([]);
  const [medicalHistory, setMedicalHistory] = reactExports.useState([]);
  const [selectedPolicy, setSelectedPolicy] = reactExports.useState(null);
  const [showPolicyApplicationModal, setShowPolicyApplicationModal] = reactExports.useState(false);
  const [showClaimApplicationModal, setShowClaimApplicationModal] = reactExports.useState(false);
  const [showClaimApprovalModal, setShowClaimApprovalModal] = reactExports.useState(false);
  const [showMedicalRecordsModal, setShowMedicalRecordsModal] = reactExports.useState(false);
  const [showPolicyDetails, setShowPolicyDetails] = reactExports.useState(false);
  const [darkMode, setDarkMode] = reactExports.useState(true);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [activeCategory, setActiveCategory] = reactExports.useState("all");
  const [showPlansModal, setShowPlansModal] = reactExports.useState(false);
  reactExports.useState(false);
  const [selectedPlans, setSelectedPlans] = reactExports.useState([]);
  const [insurancePlans, setInsurancePlans] = reactExports.useState([]);
  const [showRenewalModal, setShowRenewalModal] = reactExports.useState(false);
  reactExports.useState(false);
  const [providers, setProviders] = reactExports.useState([]);
  const [showPolicyDropdown, setShowPolicyDropdown] = reactExports.useState(false);
  const [showClaimDropdown, setShowClaimDropdown] = reactExports.useState(false);
  const [selectedClaim, setSelectedClaim] = reactExports.useState(null);
  const [selectedPlayer, setSelectedPlayer] = reactExports.useState(null);
  const [plansLoaded, setPlansLoaded] = reactExports.useState(false);
  const [playerPermissions, setPlayerPermissions] = reactExports.useState({
    canApproveClaims: false,
    canAccessMedicalRecords: false,
    canWriteMedicalRecords: false,
    canSeeMedicalRecordsTab: false,
    playerJob: ""
  });
  const [medicalHistoryStartDate, setMedicalHistoryStartDate] = reactExports.useState("");
  const [medicalHistoryEndDate, setMedicalHistoryEndDate] = reactExports.useState("");
  const [filteredMedicalHistory, setFilteredMedicalHistory] = reactExports.useState([]);
  const [showMedicalHistoryFilter, setShowMedicalHistoryFilter] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (insuranceData) {
      setPolicies(insuranceData.insuranceData_policies || insuranceData.policies || []);
      setClaims(insuranceData.insuranceData_claims || insuranceData.claims || []);
      setMedicalHistory(insuranceData.insuranceData_medicalHistory || insuranceData.medicalHistory || []);
      const permissions = {
        canApproveClaims: insuranceData.canApproveClaims || false,
        canAccessMedicalRecords: insuranceData.canAccessMedicalRecords || false,
        canWriteMedicalRecords: insuranceData.canWriteMedicalRecords || false,
        canSeeMedicalRecordsTab: insuranceData.canSeeMedicalRecordsTab || false,
        playerJob: insuranceData.playerJob || ""
      };
      setPlayerPermissions(permissions);
    }
    if (tabletTheme === "light") {
      setDarkMode(false);
    }
  }, [insuranceData, tabletTheme]);
  reactExports.useEffect(() => {
    setFilteredMedicalHistory(medicalHistory);
  }, [medicalHistory]);
  const applyMedicalHistoryDateFilter = () => {
    if (!medicalHistoryStartDate && !medicalHistoryEndDate) {
      setFilteredMedicalHistory(medicalHistory);
      return;
    }
    const filtered = medicalHistory.filter((record) => {
      const recordDate = new Date(record.date);
      const start2 = medicalHistoryStartDate ? new Date(medicalHistoryStartDate) : null;
      const end = medicalHistoryEndDate ? new Date(medicalHistoryEndDate) : null;
      if (start2 && end) {
        return recordDate >= start2 && recordDate <= end;
      } else if (start2) {
        return recordDate >= start2;
      } else if (end) {
        return recordDate <= end;
      }
      return true;
    });
    setFilteredMedicalHistory(filtered);
  };
  const clearMedicalHistoryDateFilter = () => {
    setMedicalHistoryStartDate("");
    setMedicalHistoryEndDate("");
    setFilteredMedicalHistory(medicalHistory);
  };
  const toggleMedicalHistoryFilter = () => {
    setShowMedicalHistoryFilter(!showMedicalHistoryFilter);
  };
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (!event.target.closest(".dropdown-container")) {
        setShowPolicyDropdown(false);
        setShowClaimDropdown(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      const modalDropdowns = document.querySelectorAll("[data-modal-dropdown]");
      modalDropdowns.forEach((dropdown) => {
        if (!dropdown.contains(event.target)) ;
      });
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  reactExports.useEffect(() => {
    if (!plansLoaded) {
      callNui("getInsurancePlans", {}, (result) => {
        if (result && result.plans) {
          setInsurancePlans(result.plans || []);
        } else {
          setInsurancePlans([
            {
              id: 1,
              plan_name: "Basic Health Plus",
              category: "Basic",
              monthly_premium: 150,
              coverage_amount: 5e4,
              description: "Essential health coverage for individuals",
              features: "Emergency room visits, Basic doctor visits, Prescription drugs",
              deductible: 500,
              max_claims_per_year: 10
            },
            {
              id: 2,
              plan_name: "Premium Health Elite",
              category: "Premium",
              monthly_premium: 350,
              coverage_amount: 15e4,
              description: "Comprehensive health coverage",
              features: "All doctor visits, Specialist consultations, Surgery coverage, Mental health",
              deductible: 250,
              max_claims_per_year: 25
            },
            {
              id: 3,
              plan_name: "Family Health Plus",
              category: "Family",
              monthly_premium: 400,
              coverage_amount: 1e5,
              description: "Complete family health coverage",
              features: "Family doctor, Pediatric care, Maternity coverage, Dental",
              deductible: 400,
              max_claims_per_year: 20
            },
            {
              id: 4,
              plan_name: "Emergency Response",
              category: "Emergency",
              monthly_premium: 75,
              coverage_amount: 5e4,
              description: "Emergency medical coverage",
              features: "Emergency room, Ambulance, Urgent care, Trauma care",
              deductible: 500,
              max_claims_per_year: 10
            }
          ]);
        }
        setPlansLoaded(true);
      });
    }
  }, [plansLoaded]);
  reactExports.useEffect(() => {
    callNui("getInsuranceProviders", {}, (result) => {
      if (result && result.providers) {
        setProviders(result.providers || []);
      } else {
        setProviders([
          {
            id: 1,
            provider_name: "HealthFirst Insurance",
            provider_code: "HFI001",
            contact_email: "contact@healthfirst.com",
            contact_phone: "555-0100"
          },
          {
            id: 2,
            provider_name: "MediCare Plus",
            provider_code: "MCP002",
            contact_email: "info@medicareplus.com",
            contact_phone: "555-0200"
          }
        ]);
      }
    });
  }, []);
  const refreshInsuranceData = () => {
    callNui("getInsuranceData", {}, (result) => {
      if (result) {
        setPolicies(result.policies || result.insuranceData_policies || []);
        setClaims(result.claims || result.insuranceData_claims || []);
        setMedicalHistory(result.medicalHistory || result.insuranceData_medicalHistory || []);
      }
    });
  };
  const handlePolicyDetails = (policy) => {
    setSelectedPolicy(policy);
    setShowPolicyDetails(true);
  };
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString();
  };
  const formatCurrency2 = (amount) => {
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD"
    }).format(amount);
  };
  const categories = [
    { id: "all", name: "All Policies", color: "#007AFF" },
    { id: "Basic", name: "Basic", color: "#6B7280" },
    { id: "Premium", name: "Premium", color: "#10B981" },
    { id: "Family", name: "Family", color: "#3B82F6" },
    { id: "Emergency", name: "Emergency", color: "#EF4444" }
  ];
  const filteredPolicies = policies.filter((policy) => {
    const matchesCategory = activeCategory === "all" || policy.insurance_type === activeCategory;
    const matchesSearch = policy.policy_number.toLowerCase().includes(searchQuery.toLowerCase()) || policy.citizen_name.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesCategory && matchesSearch;
  });
  const filteredClaims = claims.filter((claim) => {
    const matchesSearch = claim.claim_number.toLowerCase().includes(searchQuery.toLowerCase()) || claim.description.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesSearch;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `insurance-app ${darkMode ? "dark" : "light"}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "insurance-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-content", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-left", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "Health Insurance" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "header-subtitle", children: "Manage your health coverage" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "header-actions", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          DropdownButton,
          {
            icon: "fa-solid fa-shield-halved",
            text: "New Policy",
            isOpen: showPolicyDropdown,
            onClick: () => setShowPolicyDropdown(!showPolicyDropdown),
            darkMode,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-plus",
                  text: "Create New Policy",
                  onClick: () => {
                    setShowPolicyDropdown(false);
                    setShowPolicyApplicationModal(true);
                  },
                  darkMode
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-list",
                  text: "View All Plans",
                  onClick: () => {
                    setShowPolicyDropdown(false);
                    setActiveTab("plans");
                  },
                  darkMode
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-chart-line",
                  text: "Compare Plans",
                  onClick: () => {
                    setShowPolicyDropdown(false);
                    setActiveTab("compare");
                  },
                  darkMode
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          DropdownButton,
          {
            icon: "fa-solid fa-file-medical",
            text: "New Claim",
            isOpen: showClaimDropdown,
            onClick: () => setShowClaimDropdown(!showClaimDropdown),
            darkMode,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-plus",
                  text: "File New Claim",
                  onClick: () => {
                    setShowClaimDropdown(false);
                    setShowClaimApplicationModal(true);
                  },
                  darkMode
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-history",
                  text: "View Claims History",
                  onClick: () => {
                    setShowClaimDropdown(false);
                    setActiveTab("claims");
                  },
                  darkMode
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DropdownItem,
                {
                  icon: "fa-solid fa-user-md",
                  text: "Medical Records",
                  onClick: () => {
                    setShowClaimDropdown(false);
                    setActiveTab("medical");
                  },
                  darkMode
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "btn-secondary", onClick: refreshInsuranceData, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-rotate" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Refresh" })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "search-categories-section", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-bar", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          placeholder: "Search policies, claims...",
          value: searchQuery,
          onChange: (e) => setSearchQuery(e.target.value),
          className: "search-input"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "categories-bar", children: categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `category-button ${activeCategory === category.id ? "active" : ""}`,
          onClick: () => setActiveCategory(category.id),
          style: { "--category-color": category.color },
          children: category.name
        },
        category.id
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "insurance-tabs", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab ${activeTab === "policies" ? "active" : ""}`,
          onClick: () => setActiveTab("policies"),
          children: [
            "My Policies (",
            policies.length,
            ")"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab ${activeTab === "claims" ? "active" : ""}`,
          onClick: () => setActiveTab("claims"),
          children: [
            "Claims History (",
            claims.length,
            ")"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab ${activeTab === "plans" ? "active" : ""}`,
          onClick: () => setActiveTab("plans"),
          children: [
            "View Plans (",
            insurancePlans.length,
            ")"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "compare" ? "active" : ""}`,
          onClick: () => setActiveTab("compare"),
          children: "Compare Plans"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: `tab ${activeTab === "medical" ? "active" : ""}`,
          onClick: () => setActiveTab("medical"),
          children: [
            "Medical Records History (",
            medicalHistory.length,
            ")"
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "renewals" ? "active" : ""}`,
          onClick: () => setActiveTab("renewals"),
          children: "Renewals"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "transactions" ? "active" : ""}`,
          onClick: () => setActiveTab("transactions"),
          children: "Transactions"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `tab ${activeTab === "medical-records" ? "active" : ""}`,
          onClick: () => setActiveTab("medical-records"),
          children: "Medical Records"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "insurance-content", children: [
      activeTab === "policies" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "policies-section", children: filteredPolicies.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmptyState,
        {
          icon: "",
          title: "No Insurance Policies",
          description: "You don't have any active insurance policies. Create your first policy to get started.",
          buttonText: "Get Insurance",
          onButtonClick: () => setShowPolicyApplicationModal(true),
          darkMode
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "policies-grid", children: filteredPolicies.map((policy) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        PolicyCard,
        {
          policy,
          onClick: () => handlePolicyDetails(policy),
          onRenew: (policy2) => {
            setShowRenewalModal(true);
            setSelectedPolicy(policy2);
          },
          darkMode
        },
        policy.id
      )) }) }),
      activeTab === "claims" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "claims-section", children: filteredClaims.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmptyState,
        {
          icon: "",
          title: "No Claims History",
          description: "You haven't filed any insurance claims yet.",
          buttonText: "File a Claim",
          onButtonClick: () => setShowClaimApplicationModal(true),
          darkMode
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "claims-list", children: filteredClaims.map((claim) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ClaimItem,
          {
            claim,
            darkMode,
            onApprove: (claim2) => {
              setSelectedClaim(claim2);
              setShowClaimApprovalModal(true);
            }
          },
          claim.id
        );
      }) }) }),
      activeTab === "medical" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "medical-section", children: medicalHistory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmptyState,
        {
          icon: "",
          title: "No Medical Records",
          description: "Your medical records will appear here once you have medical records created.",
          darkMode
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
          background: darkMode ? "#1f1f23" : "#fff",
          borderRadius: 12,
          padding: 20,
          marginBottom: 20,
          border: darkMode ? "1px solid #2a2a2e" : "1px solid #e5e7eb"
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          marginBottom: 15
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
              display: "inline-flex",
              background: darkMode ? "#222" : "#e4e8ef",
              color: darkMode ? "#10B981" : "#059669",
              borderRadius: 8,
              width: 28,
              height: 28,
              alignItems: "center",
              justifyContent: "center",
              fontSize: 14
            }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-heartbeat" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 18, fontWeight: 600 }, children: "Medical Records History" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: refreshInsuranceData,
              style: {
                padding: "8px 12px",
                background: darkMode ? "#2a2a2e" : "#f3f4f6",
                color: darkMode ? "#fff" : "#333",
                border: darkMode ? "1px solid #3a3a3e" : "1px solid #d1d5db",
                borderRadius: 6,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: 6,
                fontSize: 12,
                fontWeight: 500
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-sync-alt" }),
                "Refresh"
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          background: darkMode ? "#1f1f23" : "#fff",
          borderRadius: 12,
          padding: 20,
          marginBottom: 20,
          border: darkMode ? "1px solid #2a2a2e" : "1px solid #e5e7eb"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            marginBottom: 15
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 10 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                display: "inline-flex",
                background: darkMode ? "#222" : "#e4e8ef",
                color: darkMode ? "#10B981" : "#059669",
                borderRadius: 8,
                width: 28,
                height: 28,
                alignItems: "center",
                justifyContent: "center",
                fontSize: 14
              }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-calendar" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 16, fontWeight: 600 }, children: "Filter Medical Records" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: toggleMedicalHistoryFilter,
                style: {
                  padding: "8px 16px",
                  background: showMedicalHistoryFilter ? "#EF4444" : "#3B82F6",
                  color: "#fff",
                  border: "none",
                  borderRadius: 6,
                  fontWeight: 600,
                  cursor: "pointer",
                  fontSize: 12,
                  display: "flex",
                  alignItems: "center",
                  gap: 4
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: `fa-solid ${showMedicalHistoryFilter ? "fa-times" : "fa-filter"}` }),
                  showMedicalHistoryFilter ? "Hide Filter" : "Show Filter"
                ]
              }
            )
          ] }),
          showMedicalHistoryFilter && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10, flexWrap: "wrap", alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontSize: 14, fontWeight: 500, color: darkMode ? "#ccc" : "#555" }, children: "From:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "date",
                  value: medicalHistoryStartDate,
                  onChange: (e) => setMedicalHistoryStartDate(e.target.value),
                  style: {
                    padding: "8px 12px",
                    borderRadius: 6,
                    border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                    background: darkMode ? "#2a2a2e" : "#fff",
                    color: darkMode ? "#fff" : "#333",
                    fontSize: 14,
                    outline: "none"
                  }
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { style: { fontSize: 14, fontWeight: 500, color: darkMode ? "#ccc" : "#555" }, children: "To:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "date",
                  value: medicalHistoryEndDate,
                  onChange: (e) => setMedicalHistoryEndDate(e.target.value),
                  style: {
                    padding: "8px 12px",
                    borderRadius: 6,
                    border: darkMode ? "1px solid #2a2a2e" : "1px solid #d1d5db",
                    background: darkMode ? "#2a2a2e" : "#fff",
                    color: darkMode ? "#fff" : "#333",
                    fontSize: 14,
                    outline: "none"
                  }
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: applyMedicalHistoryDateFilter,
                style: {
                  padding: "8px 16px",
                  background: "#10B981",
                  color: "#fff",
                  border: "none",
                  borderRadius: 6,
                  fontWeight: 600,
                  cursor: "pointer",
                  fontSize: 12,
                  display: "flex",
                  alignItems: "center",
                  gap: 4
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-search" }),
                  "Apply Filter"
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "button",
              {
                onClick: clearMedicalHistoryDateFilter,
                style: {
                  padding: "8px 16px",
                  background: "#6B7280",
                  color: "#fff",
                  border: "none",
                  borderRadius: 6,
                  fontWeight: 600,
                  cursor: "pointer",
                  fontSize: 12,
                  display: "flex",
                  alignItems: "center",
                  gap: 4
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-times" }),
                  "Clear Filter"
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
            marginTop: 10,
            padding: 8,
            background: darkMode ? "rgba(59, 130, 246, 0.1)" : "rgba(59, 130, 246, 0.05)",
            border: "1px solid #3B82F6",
            borderRadius: 6,
            fontSize: 12,
            color: darkMode ? "#93C5FD" : "#1E40AF"
          }, children: [
            "Showing ",
            filteredMedicalHistory.length,
            " of ",
            medicalHistory.length,
            " records",
            (medicalHistoryStartDate || medicalHistoryEndDate) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: 8 }, children: " Filtered by date range" })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "medical-list", children: filteredMedicalHistory.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: {
          textAlign: "center",
          padding: 40,
          color: darkMode ? "#888" : "#666"
        }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 24, marginBottom: 10 }, children: "" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "No medical records found for the selected date range." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: clearMedicalHistoryDateFilter,
              style: {
                marginTop: 16,
                padding: "12px 24px",
                background: "#3B82F6",
                color: "#fff",
                border: "none",
                borderRadius: 8,
                fontWeight: 600,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: 8,
                margin: "16px auto 0"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-times" }),
                "Clear Filter"
              ]
            }
          )
        ] }) : filteredMedicalHistory.map((record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "medical-item", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "medical-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", width: "100%" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: record.condition }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
              record.severity && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: {
                padding: "4px 8px",
                borderRadius: 6,
                fontSize: 11,
                fontWeight: 600,
                background: record.severity === "Low" ? "#10B98120" : record.severity === "Medium" ? "#F59E0B20" : record.severity === "High" ? "#EF444420" : "#DC262620",
                color: record.severity === "Low" ? "#10B981" : record.severity === "Medium" ? "#F59E0B" : record.severity === "High" ? "#EF4444" : "#DC2626",
                border: `1px solid ${record.severity === "Low" ? "#10B98140" : record.severity === "Medium" ? "#F59E0B40" : record.severity === "High" ? "#EF444440" : "#DC262640"}`
              }, children: record.severity }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "medical-date", children: formatDate(record.date) })
            ] })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "medical-details", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Diagnosis:" }),
              " ",
              record.diagnosis
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Treatment:" }),
              " ",
              record.treatment
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Doctor:" }),
              " ",
              record.doctor
            ] }),
            record.notes && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Notes:" }),
              " ",
              record.notes
            ] })
          ] })
        ] }, record.id)) })
      ] }) }),
      activeTab === "transactions" && /* @__PURE__ */ jsxRuntimeExports.jsx(TransactionHistory, { darkMode }),
      activeTab === "medical-records" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        MedicalRecordsViewer,
        {
          darkMode,
          onAddMedicalRecord: (playerId, playerName) => {
            setSelectedPlayer({ id: playerId, name: playerName });
            setShowMedicalRecordsModal(true);
          }
        }
      ),
      activeTab === "plans" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plans-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "plans-header", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 20 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Available Insurance Plans" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Choose from our comprehensive range of health insurance plans" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => setShowPlansModal(true),
              style: {
                background: "#10B981",
                color: "#fff",
                border: "none",
                padding: "12px 20px",
                borderRadius: 8,
                fontWeight: 600,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                gap: 8
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-plus" }),
                "Add Plan"
              ]
            }
          )
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "plans-grid", children: insurancePlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          PlanCard,
          {
            plan,
            onClick: () => {
              setShowPolicyApplicationModal(true);
            },
            darkMode
          },
          plan.id
        )) })
      ] }),
      activeTab === "compare" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "compare-section", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "compare-header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "Compare Insurance Plans" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Select up to 3 plans to compare their features and benefits" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "plan-selection", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Select Plans to Compare (Max 3)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "plans-grid", children: insurancePlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            PlanCard,
            {
              plan,
              isSelected: selectedPlans.find((p) => p.id === plan.id),
              onClick: () => {
                if (selectedPlans.find((p) => p.id === plan.id)) {
                  setSelectedPlans(selectedPlans.filter((p) => p.id !== plan.id));
                } else if (selectedPlans.length < 3) {
                  setSelectedPlans([...selectedPlans, plan]);
                }
              },
              darkMode
            },
            plan.id
          )) })
        ] }),
        selectedPlans.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "comparison-table", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "Comparison" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: "Feature" }),
              selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: plan.plan_name }, plan.id))
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Monthly Premium" }),
                selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: formatCurrency2(plan.monthly_premium) }, plan.id))
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Coverage Amount" }),
                selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: formatCurrency2(plan.coverage_amount) }, plan.id))
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Deductible" }),
                selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: formatCurrency2(plan.deductible) }, plan.id))
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Max Claims/Year" }),
                selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: plan.max_claims_per_year }, plan.id))
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: "Features" }),
                selectedPlans.map((plan) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: plan.features.split(", ").map((feature, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: feature }, index)) }) }, plan.id))
              ] })
            ] })
          ] })
        ] })
      ] }),
      activeTab === "renewals" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "renewals-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        EmptyState,
        {
          icon: "",
          title: "Policy Renewals",
          description: "Manage your policy renewals and automatic payments here.",
          buttonText: "Set Up Renewals",
          onButtonClick: () => setShowRenewalModal(true),
          darkMode
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PolicyApplicationModal,
      {
        open: showPolicyApplicationModal,
        onClose: () => setShowPolicyApplicationModal(false),
        onSuccess: refreshInsuranceData,
        darkMode,
        plans: insurancePlans
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ClaimApplicationModal,
      {
        open: showClaimApplicationModal,
        onClose: () => setShowClaimApplicationModal(false),
        onSuccess: refreshInsuranceData,
        darkMode,
        policies
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ClaimApprovalModal,
      {
        open: showClaimApprovalModal,
        onClose: () => setShowClaimApprovalModal(false),
        onSuccess: refreshInsuranceData,
        darkMode,
        claim: selectedClaim
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MedicalRecordsModal,
      {
        open: showMedicalRecordsModal,
        onClose: () => setShowMedicalRecordsModal(false),
        onSuccess: refreshInsuranceData,
        darkMode,
        playerId: selectedPlayer == null ? void 0 : selectedPlayer.id,
        playerName: selectedPlayer == null ? void 0 : selectedPlayer.name
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      InsurancePlansModal,
      {
        open: showPlansModal,
        onClose: () => setShowPlansModal(false),
        onSuccess: (result) => {
          callNui("getInsurancePlans", {}, (result2) => {
            if (result2 && result2.plans) {
              setInsurancePlans(result2.plans || []);
            }
          });
        },
        darkMode,
        plans: insurancePlans
      }
    ),
    showPolicyDetails && selectedPolicy && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PolicyDetailsModal,
      {
        policy: selectedPolicy,
        onClose: () => {
          setShowPolicyDetails(false);
          setSelectedPolicy(null);
        },
        darkMode
      }
    ),
    showRenewalModal && selectedPolicy && /* @__PURE__ */ jsxRuntimeExports.jsx(
      PolicyRenewalModal,
      {
        policy: selectedPolicy,
        onClose: () => {
          setShowRenewalModal(false);
          setSelectedPolicy(null);
        },
        onRenew: (renewalData) => {
          setShowRenewalModal(false);
          setSelectedPolicy(null);
        },
        darkMode
      }
    )
  ] });
}
function App() {
  const [tabletVisible, setTabletVisible] = reactExports.useState(false);
  const [lockScreenShow, SetLockScreen] = reactExports.useState(true);
  const [newPad, setNewPad] = reactExports.useState(false);
  const [prefixMail, setPrefixMail] = reactExports.useState("0resmon.com");
  const [mailAppX, setMailApp] = reactExports.useState(false);
  const [setupScreen, setSetupScreen] = reactExports.useState(false);
  const [openedNoteApp, setNoteApp] = reactExports.useState(false);
  const [cameraOpened, setCameraOpen] = reactExports.useState(false);
  const [bossDeskApp, setBossDeskApp] = reactExports.useState(false);
  const [minigame, setMiniGame] = reactExports.useState(false);
  const [dojApp, setDojApp] = reactExports.useState(false);
  const [galleryOpened, setGalleryOpen] = reactExports.useState(false);
  const [MainScreen$1, setMainScreen] = reactExports.useState(false);
  const [allMails, setAllMails] = reactExports.useState([]);
  const [hackMode, setHackMode] = reactExports.useState(false);
  const [invoiceBoss, setInvoiceBoss] = reactExports.useState(false);
  const [currentWeatherData, setWeatherData] = reactExports.useState([]);
  const [isPolice, setPolice] = reactExports.useState(false);
  const [isDojApp, setDoj] = reactExports.useState(false);
  const [MdtApp$1, setMdtApp] = reactExports.useState(false);
  const [sentedMails, setSentedMails] = reactExports.useState([]);
  const [tabletNews, setTabletNews] = reactExports.useState([]);
  const [calApp, setCalApp] = reactExports.useState(false);
  const [mapApp, setMapApp] = reactExports.useState(false);
  const [tabletInvoices, setInvoices] = reactExports.useState([]);
  const [browser2, setBrowserApp] = reactExports.useState(false);
  const [judMode, setJustMode] = reactExports.useState("POLICE");
  const [isNews, setNewsApp] = reactExports.useState(false);
  const [tabletLang, setTabletLang] = reactExports.useState("en");
  const [applications, setApplications2] = reactExports.useState([]);
  const [mdtChatData, setMdtChatData] = reactExports.useState([]);
  const [noteLimit, setNotLimit] = reactExports.useState(0);
  const [isClosing, setIsClosing] = reactExports.useState(false);
  const [billingApp, setBillingApp] = reactExports.useState(false);
  const [courtRooms, setCourtRooms] = reactExports.useState(false);
  const [loading2, setLoading] = reactExports.useState(false);
  reactExports.useState(/* @__PURE__ */ new Date());
  const [housing, setHousing] = reactExports.useState(false);
  const [bright, setBright] = reactExports.useState(100);
  const [allNotes, setAllNotes] = reactExports.useState([]);
  const [emsData, setEmsData] = reactExports.useState([]);
  const [emsDispatches, setEmsDispatches] = reactExports.useState(false);
  const [mug, setMug] = reactExports.useState("pimg/default.png");
  const [allDataMails, setAllDataMails] = reactExports.useState([]);
  const [animate, setIsAnimating] = reactExports.useState(false);
  const [allGallery, setGallery] = reactExports.useState([]);
  const [startY, setStartY] = reactExports.useState([]);
  const [allLang, setAllLang] = reactExports.useState([]);
  const [days, setDays] = reactExports.useState([]);
  const [tabMails, setTabMails] = reactExports.useState([]);
  const [emsChatData, setEmsChatData] = reactExports.useState([]);
  const [judgeCourts, setCourtJudges] = reactExports.useState([]);
  const [months, setMonths] = reactExports.useState([]);
  const [tabletData, setTabletData] = reactExports.useState([]);
  const [isEmsApp, setEmsApp] = reactExports.useState(false);
  const [tabletNotifications, setNotifys] = reactExports.useState([]);
  const [settingsAppScreen, setSettingsApp] = reactExports.useState(false);
  const [allBackgrounds, setAllBackgrounds] = reactExports.useState([]);
  const [IsCreatingHersey, SetCreatingHersey] = reactExports.useState(false);
  const [tabletBackground, setTabletBackground] = reactExports.useState("city");
  const [tabletTheme, setThemeMode] = reactExports.useState("light");
  const [tabletApps, setApps] = reactExports.useState([]);
  const [isMdtLoaded, setIsMdtLoaded] = reactExports.useState(false);
  const [dispatches, setDispatches] = reactExports.useState([]);
  const [dbMails, setDatabaseMails] = reactExports.useState([]);
  const [mdtMail, setMdtMail] = reactExports.useState("");
  const [dojMail, setDojMail] = reactExports.useState("");
  const [padress, setPadress] = reactExports.useState("");
  const [insuranceApp, setInsuranceApp] = reactExports.useState(false);
  const [insuranceData, setInsuranceData] = reactExports.useState({});
  const [isMainScreenLoaded, setIsMainScreenLoaded] = reactExports.useState(false);
  const [logined, setLogined] = reactExports.useState(false);
  const [isSettingsLoaded, setIsSettingsLoaded] = reactExports.useState(false);
  const [showModal, setShowModal] = reactExports.useState(false);
  const [customDurum, setCustomDurum] = reactExports.useState("");
  const [batteryLevel, setBatteryLevel] = reactExports.useState(100);
  const batteryRef = reactExports.useRef(batteryLevel);
  const [newBoss, setNewBoss] = reactExports.useState(false);
  const [tabJob, setTabJob] = reactExports.useState("");
  const [mdtCrimes, setMDTCrimes] = reactExports.useState([]);
  const [mdtVehCrimes, setMDTVehCrimes] = reactExports.useState([]);
  const [clientJobGrade, setJobGrade] = reactExports.useState("");
  const [gunCardLang, setGunCardLang] = reactExports.useState([]);
  const [settings, setSettings] = reactExports.useState([]);
  const [notificationData, setNotificationData] = reactExports.useState({
    message: "",
    title: "",
    options: []
  });
  const [batteryDrainInterval, setBatteryTime] = reactExports.useState(6e4);
  const [showGunCard, setGunCard] = reactExports.useState(false);
  const [weaponLicenseData, setWeaponData] = reactExports.useState([]);
  const [mdtData, setMdtData] = reactExports.useState([]);
  reactExports.useEffect(() => {
    if (!tabletVisible || batteryLevel <= 0) return;
    const interval = setInterval(() => {
      setBatteryLevel((prev) => Math.max(0, prev - 1));
    }, batteryDrainInterval);
    return () => clearInterval(interval);
  }, [tabletVisible, batteryDrainInterval, batteryLevel]);
  reactExports.useEffect(() => {
    batteryRef.current = batteryLevel;
  }, [batteryLevel]);
  reactExports.useEffect(() => {
    if (tabletVisible && batteryLevel <= 0) {
      setEmsApp(false);
      setNoteApp(false);
      setBrowserApp(false);
      setMiniGame(false);
      setNewsApp(false);
      setDojApp(false);
      setBossDeskApp(false);
      setMapApp(false);
      setCalApp(false);
      setMailApp(false);
      setCameraOpen(false);
      setBillingApp(false);
      setGalleryOpen(false);
      setSettingsApp(false);
      SetLockScreen(false);
      setMdtApp(false);
      setMainScreen(false);
      callNui("updateBatteryLevel", {});
    }
  }, [batteryLevel, tabletVisible]);
  reactExports.useEffect(() => {
    if (batteryLevel <= 0) {
      setEmsApp(false);
      setNoteApp(false);
      setBrowserApp(false);
      setMiniGame(false);
      setNewsApp(false);
      setDojApp(false);
      setBossDeskApp(false);
      setMapApp(false);
      setCalApp(false);
      setMailApp(false);
      setCameraOpen(false);
      setBillingApp(false);
      setGalleryOpen(false);
      setSettingsApp(false);
      SetLockScreen(false);
      setMdtApp(false);
      setMainScreen(false);
    }
  }, []);
  reactExports.useEffect(() => {
    if (MdtApp$1) {
      setTimeout(() => setIsMdtLoaded(true), 300);
    } else {
      setIsMdtLoaded(false);
    }
    if (MainScreen$1) {
      setTimeout(() => setIsMainScreenLoaded(true), 300);
    } else {
      setIsMainScreenLoaded(false);
    }
    if (settingsAppScreen) {
      setTimeout(() => setIsSettingsLoaded(true), 300);
    } else {
      setIsSettingsLoaded(false);
    }
  }, [MdtApp$1, MainScreen$1, settingsAppScreen]);
  const updateNotification = (newData) => {
    setNotificationData((prevData) => ({
      ...prevData,
      ...newData
    }));
    setShowModal(true);
  };
  const NotificationX = reactExports.useCallback((titleOrObj, msg) => {
    if (titleOrObj && typeof titleOrObj === "object") {
      setNotificationData({
        title: titleOrObj.title || "",
        message: titleOrObj.message || "",
        options: titleOrObj.options || []
      });
    } else {
      setNotificationData({
        title: titleOrObj,
        message: msg,
        options: []
      });
    }
    setShowModal(true);
  }, []);
  const [clientTabletDefData, setDefDataFromLua] = reactExports.useState([]);
  const apps = [
    { name: "Settings", icon: "/web/build/appicons/settings.png", appName: "settings" },
    { name: "MDT", icon: "/web/build/appicons/mdt.png", appName: "mdt" },
    { name: "Housing", icon: "/web/build/appicons/houseapp.png", appName: "housing" },
    { name: "MyApartment", icon: "/web/build/appicons/myapartment.png", appName: "apartment" },
    { name: "EMS", icon: "/web/build/appicons/ems.png", appName: "ems" }
  ];
  const openSetupScreen = () => {
    if (!newPad) return;
    SetLockScreen(false);
    setLoading(true);
    setTimeout(() => {
      setLoading(false);
      setSetupScreen(true);
    }, 400);
  };
  const updateLogined = (logined2) => {
    setLogined((prev) => {
      if (prev === logined2) return prev;
      return logined2;
    });
  };
  const hideSetupScreen = () => {
    setSetupScreen(false);
  };
  const showCreatingHersey = () => {
    SetCreatingHersey(true);
    setTimeout(() => {
      SetCreatingHersey(false);
      setMainScreen(true);
    }, 5e3);
  };
  const handleTouchStart = (e) => {
    var _a2;
    setStartY((_a2 = e.touches[0]) == null ? void 0 : _a2.clientY);
  };
  const handleTouchMove = (e) => {
    var _a2;
    const currentY = (_a2 = e.touches[0]) == null ? void 0 : _a2.clientY;
    if (startY !== null && startY - currentY > 50) {
      handleHomeIndicatorAction();
    }
  };
  const handleMouseMove = (e) => {
    if (startY !== null) {
      const currentY = e.clientY;
      if (startY - currentY > 50) {
        handleHomeIndicatorAction();
      }
    }
  };
  const handleHomeIndicatorAction = () => {
    SetLockScreen(true);
    setSettingsApp(false);
    setEmsApp(false);
    setMapApp(false);
    setNoteApp(false);
    setBrowserApp(false);
    setMiniGame(false);
    setNewsApp(false);
    setDojApp(false);
    setBossDeskApp(false);
    setCalApp(false);
    setBillingApp(false);
    setMailApp(false);
    setMainScreen(false);
    setMdtApp(false);
    SetCreatingHersey(false);
    callNui("CloseCameraApp", {});
    if (window.MainRender) {
      window.MainRender.stop();
      window.isAnimated = false;
    }
    callNui("mapAppState", { state: false });
  };
  const handleTouchEnd = () => {
    setStartY(null);
  };
  const handleMouseDown = (e) => {
    setStartY(e.clientY);
  };
  const handleMouseUp = () => {
    setStartY(null);
  };
  reactExports.useEffect(() => {
    useNui("updateallNote", (data) => {
      setAllNotes(data.data);
    });
    useNui("openMiniGame", (data) => {
    });
    useNui("updateCharge", (data) => {
      setBatteryLevel(data.batteryLevel);
    });
    useNui("updateBills", (data) => {
      setInvoices([...data.data].reverse());
    });
    useNui("updateMails", (data) => {
      setTabMails([...data.data].reverse());
      setSentedMails([...data.data2].reverse());
    });
    useNui("updateLang", (data) => {
      setTabletLang(data.data);
    });
    useNui("updateCrimeData", (data) => {
      setMDTCrimes(
        (prev) => prev.map(
          (crime) => crime.crime_id === data.id ? { ...crime, ...data.dataLand } : crime
        )
      );
    });
    useNui("addNewCourt", (data) => {
      setCourtJudges(
        (prev) => prev.map(
          (crime) => crime.case_id === data.id ? { ...crime, ...data.dataa } : crime
        )
      );
    });
    useNui("openTablet", (data) => {
      setNewPad(data.newTablet);
      setBatteryTime(data.chargeDrainInterval);
      setTabletVisible(true);
      setTabletLang(data.lang);
      setAllBackgrounds(data.backgrounds);
      setAllLang(data.allLang);
      setPrefixMail(data.prefix);
      setAllDataMails(data.dbmails);
      setDefDataFromLua(data.tabletDefaultData);
      setCourtRooms(data.courtrooms);
      if (data.tabletData) {
        setHackMode(data.hackMode);
        if (data.hackMode === void 0) {
          setMiniGame(false);
          SetLockScreen(true);
        } else {
          SetLockScreen(false);
          setMiniGame(true);
        }
        setBatteryLevel(data.tabCharge);
        setApps(data.apps);
        setGallery(data.tabletData.gallery);
        setTabJob(data.tabletData.job);
        setTabletData(data.tabletData);
        setNewBoss(data.newsBoss);
        setNotifys(data.tabletData.notifications);
        setJustMode(data.justMode);
        setWeatherData(data.currentData);
        setTabletNews(data.news);
        setDatabaseMails(data.dataMails);
        setApplications2(data.applicationsnews);
        setInvoiceBoss(data.checkInvoice);
        setNotLimit(data.noteLimit);
        setSentedMails([...data.sentedMails].reverse());
        setAllMails(data.allmails);
        setJobGrade(data.myJobGrade);
        setSettings({
          planemode: data.tabletData.data.planemode,
          notifications: data.tabletData.data.notifications,
          walkanduse: data.tabletData.data.walkanduse,
          widgets: data.tabletData.data.widgets
        });
        setAllNotes([...data.allNotes].reverse());
        setInvoices([...data.tabletData.invoices].reverse());
        setTabMails([...data.tabletData.mails].reverse());
        setThemeMode(data.tabletData.data.theme);
        setTabletBackground(data.tabletData.data.background);
        setPadress(data.padress);
        if (data.anyLaw) {
          setDoj(true);
        } else {
          setDoj(false);
        }
        if (data.anyMdt) {
          setPolice(true);
        } else {
          setPolice(false);
        }
        if (data.anyMdt || data.anyLaw) {
          setMdtData(data.mdtData);
          setMDTCrimes(data.mdtData.mdtDatabase.mdtData_crimeRecords);
          setCourtJudges(data.mdtData.mdtDatabase.governmentData_court_hearings);
          setMdtMail(data.policeMail);
          setDojMail(data.dojMail);
          setMDTVehCrimes(data.mdtData.mdtDatabase.mdtData_vehicleCrimes);
          setDispatches(data.dispatches);
          setMdtChatData(data.mdtData.mdtchat);
        }
        if (data.anyEms) {
          setEmsData(data.emsData);
          setEmsChatData(data.emsData.emschat);
          setEmsDispatches(data.emsData.emsDispatches);
        }
        if (data.insuranceData) {
          setInsuranceData(data.insuranceData);
        }
      } else {
        setTabletBackground(data.tabletDefaultData.defaultTheme);
      }
      setMonths(data.aylar);
      setDays(data.gunler);
    });
    useNui("newGallery", (data) => {
      setGallery(data.data);
    });
    useNui("updateApplications", (data) => {
      setApplications2((prev) => [...prev, data.data]);
    });
    useNui("updateMessages", (data) => {
      setEmsChatData((prev) => [...prev, data.messageData]);
    });
    useNui("updateMessagesMdt", (data) => {
      setMdtChatData((prev) => [...prev, data.messageData]);
    });
    useNui("showGunCard", (data) => {
      setGunCardLang(data.lang);
      setWeaponData(data.data);
      setGunCard(true);
    });
    useNui("closeGunCard", (data) => {
      setWeaponData([]);
      setGunCard(false);
    });
    useNui("refreshMug", (id2) => {
      setMug(`pimg/${id2}.png?ts=${Date.now()}`);
    });
    const handleKeyDown = (event) => {
      if (event.key === "Escape" && !isClosing) {
        closeTablet();
      }
    };
    useNui("updtbck", (data) => {
      setTabletBackground(data.data);
    });
    useNui("updateGallery", (data) => {
      setGallery(data.gallery);
    });
    useNui("usedPowerbank", (data) => {
      setBatteryLevel(data.charge);
      SetLockScreen(true);
    });
    useNui("closeTablet", (data) => {
      closeTablet();
    });
    useNui("updateTabletData", (data) => {
      setTabletData(data.alldata);
      setApps(data.apps);
    });
    useNui("updateTabletMainData", (data) => {
      setTabletData(data.data);
    });
    useNui("addNewComments", (data) => {
      setTabletNews(
        (prev) => prev.map((article) => {
          if (article.code === data.code) {
            return {
              ...article,
              comments: [...article.comments, data.datax]
            };
          }
          return article;
        })
      );
    });
    useNui("tabletNotify", (data) => {
      updateNotification({
        message: data.message,
        title: data.title,
        options: data.options
      });
    });
    useNui("setAllNews", (data) => {
      setTabletNews((prev) => [...prev, data]);
    });
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [isClosing]);
  reactExports.useEffect(() => {
    if (MainScreen$1) {
      setGalleryOpen(false);
      setCameraOpen(false);
      setSettingsApp(false);
      setEmsApp(false);
      setMapApp(false);
      setNoteApp(false);
      setBrowserApp(false);
      setMiniGame(false);
      setNewsApp(false);
      setDojApp(false);
      setBossDeskApp(false);
      setCalApp(false);
      setMailApp(false);
      setBillingApp(false);
      setMdtApp(false);
      SetLockScreen(false);
      callNui("CloseCameraApp", {});
      callNui("mapAppState", { state: false });
    }
  }, [MainScreen$1]);
  const closeTablet = () => {
    setIsClosing(true);
    setTimeout(() => {
      setEmsApp(false);
      setMapApp(false);
      setSettingsApp(false);
      setMdtApp(false);
      setNoteApp(false);
      setBrowserApp(false);
      setMiniGame(false);
      setNewsApp(false);
      setDojApp(false);
      setBossDeskApp(false);
      setCalApp(false);
      setMailApp(false);
      setBillingApp(false);
      setGalleryOpen(false);
      setCameraOpen(false);
      setMainScreen(false);
      setLogined(false);
      setGallery([]);
      SetLockScreen(true);
      setTabletVisible(false);
      setIsClosing(false);
      callNui("mapAppState", { state: false });
      callNui("closeTablet", { batteryLevel: batteryRef.current });
    }, 500);
  };
  const openApp = (app, custom) => {
    setIsAnimating(true);
    switch (app) {
      case "mdt":
        if (custom == "openmdtforcamera") {
          setCameraOpen(false);
          setCustomDurum(custom);
        }
        setMainScreen(false);
        setTimeout(() => {
          setMdtApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "mainsc":
        setEmsApp(false);
        setNoteApp(false);
        setBrowserApp(false);
        setMiniGame(false);
        setNewsApp(false);
        setDojApp(false);
        setBossDeskApp(false);
        setMapApp(false);
        setCalApp(false);
        setMailApp(false);
        setCameraOpen(false);
        setBillingApp(false);
        setGalleryOpen(false);
        setSettingsApp(false);
        SetLockScreen(false);
        setMdtApp(false);
        callNui("mapAppState", { state: false });
        callNui("CloseCameraApp", {});
        if (window.MainRender) {
          window.MainRender.stop();
          window.isAnimated = false;
        }
        setTimeout(() => {
          setMainScreen(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "settings":
        setMainScreen(false);
        setTimeout(() => {
          setSettingsApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "dojapp":
        setMainScreen(false);
        setTimeout(() => {
          setDojApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "bossdesk":
        setMainScreen(false);
        setTimeout(() => {
          setBossDeskApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "mail":
        setMainScreen(false);
        setTimeout(() => {
          setMailApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "housing":
        setHousing(true);
        break;
      case "myapartment":
        setHousing(true);
        break;
      case "notes":
        setMainScreen(false);
        setTimeout(() => {
          setNoteApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "browser":
        setMainScreen(false);
        setTimeout(() => {
          setBrowserApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "minigame":
        setMainScreen(false);
        setTimeout(() => {
          setMiniGame(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "news":
        setMainScreen(false);
        setTimeout(() => {
          setNewsApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "calculator":
        setMainScreen(false);
        setTimeout(() => {
          setCalApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "billing":
        setMainScreen(false);
        setTimeout(() => {
          setBillingApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "map":
        setMainScreen(false);
        setTimeout(() => {
          setMapApp(true);
          callNui("mapAppState", { state: true });
          setIsAnimating(false);
        }, 500);
        break;
      case "gallery":
        setCameraOpen(false);
        setMainScreen(false);
        setTimeout(() => {
          setGalleryOpen(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "ems":
        setMainScreen(false);
        setTimeout(() => {
          setEmsApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "insurance":
        setMainScreen(false);
        setTimeout(() => {
          setInsuranceApp(true);
          setIsAnimating(false);
        }, 500);
        break;
      case "camera":
        if (custom == "forMdt") {
          setMdtApp(false);
          setCustomDurum(custom);
        }
        setMainScreen(false);
        setTimeout(() => {
          setCameraOpen(true);
          setIsAnimating(false);
          callNui("ToggleCameraAppModule", {});
          const canvas = document.getElementById("gameview-canvas");
          if (canvas && MainRender) {
            MainRender.renderToTarget(canvas);
          }
        }, 1e3);
        break;
    }
  };
  const screenVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: { opacity: 1, scale: 1 },
    exit: { opacity: 0, scale: 0.9 }
  };
  const handleHomeIndicatorClick = () => {
    setMainScreen(true);
    setMdtApp(false);
    SetLockScreen(false);
    setEmsApp(false);
    setMapApp(false);
    callNui("mapAppState", { state: false });
    setNoteApp(false);
    setMiniGame(false);
    setDojApp(false);
    setBossDeskApp(false);
    setCalApp(false);
    setMailApp(false);
    setBillingApp(false);
    setSettingsApp(false);
    setInsuranceApp(false);
  };
  const dragControls = useDragControls();
  const TABLET_W = 1400;
  const TABLET_H = 900;
  const [tabletTranslation, setTabletTranslation] = reactExports.useState({
    x: (window.innerWidth - TABLET_W) / 2,
    y: (window.innerHeight - TABLET_H) / 2
  });
  reactExports.useEffect(() => {
    const cx = (window.innerWidth - TABLET_W) / 2;
    const cy = (window.innerHeight - TABLET_H) / 2;
    setTabletTranslation({ x: cx, y: cy });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    tabletVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      motion.div,
      {
        className: "tablet-frame",
        initial: {
          x: tabletTranslation.x,
          y: tabletTranslation.y,
          opacity: 0,
          scale: 0.9
        },
        animate: {
          x: tabletTranslation.x,
          y: tabletTranslation.y,
          opacity: 1,
          scale: 1
        },
        style: { filter: `brightness(${bright}%)` },
        transition: { duration: 0.6, ease: [0.22, 1, 0.36, 1] },
        drag: true,
        dragListener: false,
        dragControls,
        exit: {
          opacity: 0,
          scale: 0.95,
          transition: { duration: 0.5, ease: "easeInOut" }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "tablet-notch macbook-notch", onPointerDown: (e) => dragControls.start(e), style: { cursor: "grab" } }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(AnimatePresence, { children: [
            lockScreenShow && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              LockScreen,
              {
                newPad,
                StartSetupScreen: openSetupScreen,
                isloading: loading2,
                setNewPad,
                Notification: NotificationX,
                batteryLevel,
                data: tabletData,
                lang: tabletLang,
                months,
                days,
                notifications: tabletNotifications,
                background: tabletBackground,
                setLoginX: updateLogined,
                logined
              }
            ),
            cameraOpened && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CameraApp,
                  {
                    allGallery,
                    batteryLevel,
                    galleryLastPhoto: tabletData.gallery.at(-1),
                    customState: customDurum,
                    lang: tabletLang
                  }
                )
              },
              "cameraopened"
            ),
            calApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CalculatorApp,
                  {
                    batteryLevel
                  }
                )
              },
              "calapp"
            ),
            mapApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MapApp,
                  {
                    pName: tabletData.data.ownername,
                    lang: tabletLang,
                    batteryLevel
                  }
                )
              },
              "mapapp"
            ),
            billingApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  BillingApp,
                  {
                    checkInvoice: invoiceBoss,
                    batteryLevel,
                    players: tabletData.players,
                    ownerJob: tabJob,
                    invoices: tabletInvoices,
                    lang: tabletLang
                  }
                )
              },
              "billingapp"
            ),
            isEmsApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  EmsApp,
                  {
                    lang: tabletLang,
                    emsData,
                    batteryLevel,
                    allMessages: emsChatData,
                    tabOwnerName: tabletData.data.ownername,
                    emsDispatch: emsDispatches
                  }
                )
              },
              "emsapp"
            ),
            insuranceApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  InsuranceApp,
                  {
                    lang: tabletLang,
                    insuranceData,
                    tabOwner: tabletData.data.ownername,
                    tabletTheme
                  }
                )
              },
              "insuranceapp"
            ),
            openedNoteApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NotesApp,
                  {
                    lang: tabletLang,
                    tabletTheme,
                    batteryLevel,
                    allNotes,
                    myLimit: noteLimit
                  }
                )
              },
              "noteapp"
            ),
            isNews && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  WeazelNewsApp,
                  {
                    lang: tabletLang,
                    tabletTheme,
                    batteryLevel,
                    allNotes,
                    myLimit: noteLimit,
                    isBoss: newBoss,
                    news: tabletNews,
                    applications,
                    playerGalleryData: tabletData.gallery
                  }
                )
              },
              "noteapp"
            ),
            browser2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SmartTabBrowser,
                  {}
                )
              },
              "noteapp"
            ),
            minigame && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  HackerMinigame,
                  {
                    lang: tabletLang,
                    batteryLevel,
                    openApp
                  }
                )
              },
              "minigame"
            ),
            galleryOpened && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NewGallery,
                  {
                    allGallery,
                    lang: tabletLang,
                    batteryLevel,
                    theme: tabletTheme,
                    pname: tabletData.data.ownername,
                    albumsv: tabletData.albums
                  }
                )
              },
              "galleryOpened"
            ),
            dojApp && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DOJApp,
                  {
                    lang: tabletLang,
                    batteryLevel,
                    allPersonelCrimes: mdtCrimes,
                    allVehicleCrimes: mdtVehCrimes,
                    allCourtCalendar: mdtData.mdtDatabase.governmentData_court_hearings,
                    allPlayers: mdtData.players,
                    courtRooms,
                    allDataCourts: judgeCourts,
                    allVehicles: mdtData.vehicles,
                    allWeaponLicenses: mdtData.mdtDatabase.mdtData_weaponLicenses,
                    allCrimes: mdtData.cidcrimes,
                    tabJob,
                    pname: tabletData.data.ownername
                  }
                )
              },
              "dojapp"
            ),
            batteryLevel <= 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  BatteryDeadScreen,
                  {
                    lang: tabletLang
                  }
                )
              },
              "galleryOpened"
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ColdModal,
              {
                appName: "SmartPad",
                title: tabletLang.success,
                message: tabletLang.soon,
                isOpen: housing,
                onClose: () => setHousing(false),
                buttons: [
                  { label: tabletLang.ok, onClick: () => setHousing(false) }
                ]
              }
            ),
            mailAppX && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  MailApp,
                  {
                    batteryLevel,
                    lang: tabletLang,
                    allMails,
                    sentedMails,
                    tabOwner: tabletData.owner,
                    policeMail: mdtMail,
                    dojMail,
                    dbMails,
                    tabMails,
                    myMail: tabletData.email,
                    isPolice,
                    isDojApp
                  }
                )
              },
              "galleryOpened"
            ),
            bossDeskApp && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  BossDeskApp,
                  {}
                )
              },
              "bossdesk"
            ),
            showModal && /* @__PURE__ */ jsxRuntimeExports.jsx(
              AlertModal,
              {
                title: notificationData.title,
                message: notificationData.message,
                okay: "Ok",
                onCancel: () => setShowModal(false),
                onConfirm: () => {
                  setShowModal(false);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SetupScreen,
              {
                isOpened: setupScreen,
                setLoading: showCreatingHersey,
                onCloseV2: hideSetupScreen,
                allmails: allDataMails,
                Notification: NotificationX,
                setLoginX: updateLogined,
                prefix: prefixMail,
                lang: tabletLang,
                allLang
              },
              setupScreen ? "setup" : "closed"
            ),
            IsCreatingHersey && /* @__PURE__ */ jsxRuntimeExports.jsx(CreatingHersey, { isVisible: showCreatingHersey }),
            MdtApp$1 && isMdtLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.3 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MdtApp, { judMode, batteryLevel, setMdtPersonelCrimes: setMDTCrimes, setMdtVehCrimes: setMDTVehCrimes, mdtCrimes, mdtVehCrimes, tabOwnerName: tabletData.data.ownername, allMessages: mdtChatData, theme: tabletTheme, lang: tabletLang, mdtData, disData: dispatches, padres: padress, NotificationX, openApp, clientJobGrade })
              },
              "mdtapp"
            ),
            MainScreen$1 && isMainScreenLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainScreen, { batteryLevel, widgets: settings.widgets, lang: tabletLang, mails: tabMails, currentData: currentWeatherData, openApp, apps, playerApps: tabletApps, background: tabletBackground, days, months })
              },
              "mainscreen"
            ),
            settingsAppScreen && isSettingsLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(
              motion.div,
              {
                variants: screenVariants,
                initial: "hidden",
                animate: "visible",
                exit: "exit",
                transition: { duration: 0.5 },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsApp, { batteryLevel, settings, setSettings, bright, setBright, tabletTheme, job: tabJob, openApp, apps, themeMode: tabletTheme, setThemeMode, background: tabletBackground, setBackground: setTabletBackground, allBackgrounds, lang: tabletLang, tabData: tabletData, allLang, Notification: NotificationX })
              },
              "settingsapp"
            )
          ] }),
          logined && batteryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "home-indicator",
              onTouchStart: handleTouchStart,
              onTouchMove: handleTouchMove,
              onTouchEnd: handleTouchEnd,
              onMouseDown: handleMouseDown,
              onMouseMove: handleMouseMove,
              onMouseUp: handleMouseUp,
              onClick: handleHomeIndicatorClick
            }
          ),
          tabletVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs(Notification, { children: [
            "tabletOpened=",
            tabletVisible
          ] })
        ]
      }
    ),
    !tabletVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs(Notification, { children: [
      "tabletOpened=",
      tabletVisible
    ] }),
    showGunCard && /* @__PURE__ */ jsxRuntimeExports.jsx(GunLicenseCard, { lang: gunCardLang, isOpen: showGunCard, data: weaponLicenseData })
  ] });
}
clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
const photoUrl = "https://fivemanage.com/media/photo1.jpg";
const videoUrl$1 = "https://fivemanage.com/media/video1.mp4";
const urls = {
  photoUrl,
  videoUrl: videoUrl$1
};
if (Number.EPSILON === void 0) {
  Number.EPSILON = Math.pow(2, -52);
}
if (Number.isInteger === void 0) {
  Number.isInteger = function(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
}
if (Math.sign === void 0) {
  Math.sign = function(x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}
if ("name" in Function.prototype === false) {
  Object.defineProperty(Function.prototype, "name", {
    get: function() {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}
if (Object.assign === void 0) {
  (function() {
    Object.assign = function(target) {
      if (target === void 0 || target === null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var output = Object(target);
      for (var index = 1; index < arguments.length; index++) {
        var source = arguments[index];
        if (source !== void 0 && source !== null) {
          for (var nextKey in source) {
            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      }
      return output;
    };
  })();
}
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
  addEventListener: function(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    var listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function(type, listener) {
    if (this._listeners === void 0) return false;
    var listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function(type, listener) {
    if (this._listeners === void 0) return;
    var listeners = this._listeners;
    var listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      var index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function(event) {
    if (this._listeners === void 0) return;
    var listeners = this._listeners;
    var listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      var array = listenerArray.slice(0);
      for (var i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var ACESFilmicToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var _Math = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function() {
    var lut = [];
    for (var i = 0; i < 256; i++) {
      lut[i] = (i < 16 ? "0" : "") + i.toString(16);
    }
    return function generateUUID() {
      var d0 = Math.random() * 4294967295 | 0;
      var d1 = Math.random() * 4294967295 | 0;
      var d2 = Math.random() * 4294967295 | 0;
      var d3 = Math.random() * 4294967295 | 0;
      var uuid = lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255] + "-" + lut[d1 & 255] + lut[d1 >> 8 & 255] + "-" + lut[d1 >> 16 & 15 | 64] + lut[d1 >> 24 & 255] + "-" + lut[d2 & 63 | 128] + lut[d2 >> 8 & 255] + "-" + lut[d2 >> 16 & 255] + lut[d2 >> 24 & 255] + lut[d3 & 255] + lut[d3 >> 8 & 255] + lut[d3 >> 16 & 255] + lut[d3 >> 24 & 255];
      return uuid.toUpperCase();
    };
  }(),
  clamp: function(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function(n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function(x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function(x, min2, max2) {
    if (x <= min2) return 0;
    if (x >= max2) return 1;
    x = (x - min2) / (max2 - min2);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function(x, min2, max2) {
    if (x <= min2) return 0;
    if (x >= max2) return 1;
    x = (x - min2) / (max2 - min2);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function(low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function(range2) {
    return range2 * (0.5 - Math.random());
  },
  degToRad: function(degrees2) {
    return degrees2 * _Math.DEG2RAD;
  },
  radToDeg: function(radians) {
    return radians * _Math.RAD2DEG;
  },
  isPowerOfTwo: function(value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
};
function Vector2(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}
Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function() {
      return this.x;
    },
    set: function(value) {
      this.x = value;
    }
  },
  "height": {
    get: function() {
      return this.y;
    },
    set: function(value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setComponent: function(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    return this;
  },
  divide: function(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  },
  applyMatrix3: function(m) {
    var x = this.x, y = this.y;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    return this;
  },
  clampScalar: function() {
    var min2 = new Vector2();
    var max2 = new Vector2();
    return function clampScalar(minVal, maxVal) {
      min2.set(minVal, minVal);
      max2.set(maxVal, maxVal);
      return this.clamp(min2, max2);
    };
  }(),
  clampLength: function(min2, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y;
  },
  cross: function(v) {
    return this.x * v.y - this.y * v.x;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  angle: function() {
    var angle = Math.atan2(this.y, this.x);
    if (angle < 0) angle += 2 * Math.PI;
    return angle;
  },
  distanceTo: function(v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function(v) {
    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    return this;
  },
  lerpVectors: function(v1, v2, alpha2) {
    return this.subVectors(v2, v1).multiplyScalar(alpha2).add(v1);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function(center, angle) {
    var c = Math.cos(angle), s = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
});
function Matrix4() {
  this.elements = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    var te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  clone: function() {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function(m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function(m) {
    var te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  extractRotation: function() {
    var v1 = new Vector3();
    return function extractRotation(m) {
      var te = this.elements;
      var me = m.elements;
      var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
      var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
      var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
      te[0] = me[0] * scaleX;
      te[1] = me[1] * scaleX;
      te[2] = me[2] * scaleX;
      te[3] = 0;
      te[4] = me[4] * scaleY;
      te[5] = me[5] * scaleY;
      te[6] = me[6] * scaleY;
      te[7] = 0;
      te[8] = me[8] * scaleZ;
      te[9] = me[9] * scaleZ;
      te[10] = me[10] * scaleZ;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    };
  }(),
  makeRotationFromEuler: function(euler) {
    if (!(euler && euler.isEuler)) {
      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    }
    var te = this.elements;
    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos(x), b = Math.sin(x);
    var c = Math.cos(y), d = Math.sin(y);
    var e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      var ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      var ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function() {
    var zero = new Vector3(0, 0, 0);
    var one = new Vector3(1, 1, 1);
    return function makeRotationFromQuaternion(q) {
      return this.compose(zero, q, one);
    };
  }(),
  lookAt: function() {
    var x = new Vector3();
    var y = new Vector3();
    var z = new Vector3();
    return function lookAt(eye2, target, up) {
      var te = this.elements;
      z.subVectors(eye2, target);
      if (z.lengthSq() === 0) {
        z.z = 1;
      }
      z.normalize();
      x.crossVectors(up, z);
      if (x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          z.x += 1e-4;
        } else {
          z.z += 1e-4;
        }
        z.normalize();
        x.crossVectors(up, z);
      }
      x.normalize();
      y.crossVectors(z, x);
      te[0] = x.x;
      te[4] = y.x;
      te[8] = z.x;
      te[1] = x.y;
      te[5] = y.y;
      te[9] = z.y;
      te[2] = x.z;
      te[6] = y.z;
      te[10] = z.z;
      return this;
    };
  }(),
  multiply: function(m, n) {
    if (n !== void 0) {
      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
      return this.multiplyMatrices(m, n);
    }
    return this.multiplyMatrices(this, m);
  },
  premultiply: function(m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function(a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function(s) {
    var te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix4(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  determinant: function() {
    var te = this.elements;
    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function() {
    var te = this.elements;
    var tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  },
  setPosition: function(v) {
    var te = this.elements;
    te[12] = v.x;
    te[13] = v.y;
    te[14] = v.z;
    return this;
  },
  getInverse: function(m, throwOnDegenerate) {
    var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) {
      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function(v) {
    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function() {
    var te = this.elements;
    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function(x, y, z) {
    this.set(
      1,
      0,
      0,
      x,
      0,
      1,
      0,
      y,
      0,
      0,
      1,
      z,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeRotationX: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeRotationY: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeRotationZ: function(theta) {
    var c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeRotationAxis: function(axis, angle) {
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeScale: function(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  makeShear: function(x, y, z) {
    this.set(
      1,
      y,
      z,
      0,
      x,
      1,
      z,
      0,
      x,
      y,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  },
  compose: function(position, quaternion, scale2) {
    var te = this.elements;
    var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    var sx = scale2.x, sy = scale2.y, sz = scale2.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function() {
    var vector = new Vector3();
    var matrix = new Matrix4();
    return function decompose(position, quaternion, scale2) {
      var te = this.elements;
      var sx = vector.set(te[0], te[1], te[2]).length();
      var sy = vector.set(te[4], te[5], te[6]).length();
      var sz = vector.set(te[8], te[9], te[10]).length();
      var det = this.determinant();
      if (det < 0) sx = -sx;
      position.x = te[12];
      position.y = te[13];
      position.z = te[14];
      matrix.copy(this);
      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;
      matrix.elements[0] *= invSX;
      matrix.elements[1] *= invSX;
      matrix.elements[2] *= invSX;
      matrix.elements[4] *= invSY;
      matrix.elements[5] *= invSY;
      matrix.elements[6] *= invSY;
      matrix.elements[8] *= invSZ;
      matrix.elements[9] *= invSZ;
      matrix.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(matrix);
      scale2.x = sx;
      scale2.y = sy;
      scale2.z = sz;
      return this;
    };
  }(),
  makePerspective: function(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    }
    var te = this.elements;
    var x = 2 * near / (right - left);
    var y = 2 * near / (top - bottom);
    var a = (right + left) / (right - left);
    var b = (top + bottom) / (top - bottom);
    var c = -(far + near) / (far - near);
    var d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function(left, right, top, bottom, near, far) {
    var te = this.elements;
    var w = 1 / (right - left);
    var h = 1 / (top - bottom);
    var p = 1 / (far - near);
    var x = (right + left) * w;
    var y = (top + bottom) * h;
    var z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function(matrix) {
    var te = this.elements;
    var me = matrix.elements;
    for (var i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    for (var i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});
function Quaternion(x, y, z, w) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = w !== void 0 ? w : 1;
}
Object.assign(Quaternion, {
  slerp: function(qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      var s = 1 - t, cos2 = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos2 >= 0 ? 1 : -1, sqrSin = 1 - cos2 * cos2;
      if (sqrSin > Number.EPSILON) {
        var sin2 = Math.sqrt(sqrSin), len = Math.atan2(sin2, cos2 * dir);
        s = Math.sin(s * len) / sin2;
        t = Math.sin(t * len) / sin2;
      }
      var tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  w: {
    get: function() {
      return this._w;
    },
    set: function(value) {
      this._w = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: true,
  set: function(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this.onChangeCallback();
    return this;
  },
  setFromEuler: function(euler, update2) {
    if (!(euler && euler.isEuler)) {
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    }
    var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
    var cos2 = Math.cos;
    var sin2 = Math.sin;
    var c12 = cos2(x / 2);
    var c22 = cos2(y / 2);
    var c32 = cos2(z / 2);
    var s1 = sin2(x / 2);
    var s2 = sin2(y / 2);
    var s3 = sin2(z / 2);
    if (order === "XYZ") {
      this._x = s1 * c22 * c32 + c12 * s2 * s3;
      this._y = c12 * s2 * c32 - s1 * c22 * s3;
      this._z = c12 * c22 * s3 + s1 * s2 * c32;
      this._w = c12 * c22 * c32 - s1 * s2 * s3;
    } else if (order === "YXZ") {
      this._x = s1 * c22 * c32 + c12 * s2 * s3;
      this._y = c12 * s2 * c32 - s1 * c22 * s3;
      this._z = c12 * c22 * s3 - s1 * s2 * c32;
      this._w = c12 * c22 * c32 + s1 * s2 * s3;
    } else if (order === "ZXY") {
      this._x = s1 * c22 * c32 - c12 * s2 * s3;
      this._y = c12 * s2 * c32 + s1 * c22 * s3;
      this._z = c12 * c22 * s3 + s1 * s2 * c32;
      this._w = c12 * c22 * c32 - s1 * s2 * s3;
    } else if (order === "ZYX") {
      this._x = s1 * c22 * c32 - c12 * s2 * s3;
      this._y = c12 * s2 * c32 + s1 * c22 * s3;
      this._z = c12 * c22 * s3 - s1 * s2 * c32;
      this._w = c12 * c22 * c32 + s1 * s2 * s3;
    } else if (order === "YZX") {
      this._x = s1 * c22 * c32 + c12 * s2 * s3;
      this._y = c12 * s2 * c32 + s1 * c22 * s3;
      this._z = c12 * c22 * s3 - s1 * s2 * c32;
      this._w = c12 * c22 * c32 - s1 * s2 * s3;
    } else if (order === "XZY") {
      this._x = s1 * c22 * c32 - c12 * s2 * s3;
      this._y = c12 * s2 * c32 - s1 * c22 * s3;
      this._z = c12 * c22 * s3 + s1 * s2 * c32;
      this._w = c12 * c22 * c32 + s1 * s2 * s3;
    }
    if (update2 !== false) this.onChangeCallback();
    return this;
  },
  setFromAxisAngle: function(axis, angle) {
    var halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m) {
    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this.onChangeCallback();
    return this;
  },
  setFromUnitVectors: function() {
    var v1 = new Vector3();
    var r;
    var EPS = 1e-6;
    return function setFromUnitVectors(vFrom, vTo) {
      if (v1 === void 0) v1 = new Vector3();
      r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }
      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;
      return this.normalize();
    };
  }(),
  angleTo: function(q) {
    return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function(q, step2) {
    var angle = this.angleTo(q);
    if (angle === 0) return this;
    var t = Math.min(1, step2 / angle);
    this.slerp(q, t);
    return this;
  },
  inverse: function() {
    return this.conjugate();
  },
  conjugate: function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this;
  },
  dot: function(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function() {
    var l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this.onChangeCallback();
    return this;
  },
  multiply: function(q, p) {
    if (p !== void 0) {
      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
      return this.multiplyQuaternions(q, p);
    }
    return this.multiplyQuaternions(this, q);
  },
  premultiply: function(q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function(a, b) {
    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this.onChangeCallback();
    return this;
  },
  slerp: function(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    var x = this._x, y = this._y, z = this._z, w = this._w;
    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      var s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      return this.normalize();
    }
    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this.onChangeCallback();
    return this;
  },
  equals: function(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
}
Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    this.z = scalar2;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z) {
    this.z = z;
    return this;
  },
  setComponent: function(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
      return this.multiplyVectors(v, w);
    }
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    this.z *= scalar2;
    return this;
  },
  multiplyVectors: function(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function() {
    var quaternion = new Quaternion();
    return function applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(quaternion.setFromEuler(euler));
    };
  }(),
  applyAxisAngle: function() {
    var quaternion = new Quaternion();
    return function applyAxisAngle(axis, angle) {
      return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
    };
  }(),
  applyMatrix3: function(m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyMatrix4: function(m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function(q) {
    var x = this.x, y = this.y, z = this.z;
    var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function() {
    var matrix = new Matrix4();
    return function unproject(camera) {
      return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
    };
  }(),
  transformDirection: function(m) {
    var x = this.x, y = this.y, z = this.z;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    this.z = Math.max(min2.z, Math.min(max2.z, this.z));
    return this;
  },
  clampScalar: function() {
    var min2 = new Vector3();
    var max2 = new Vector3();
    return function clampScalar(minVal, maxVal) {
      min2.set(minVal, minVal, minVal);
      max2.set(maxVal, maxVal, maxVal);
      return this.clamp(min2, max2);
    };
  }(),
  clampLength: function(min2, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  // TODO lengthSquared?
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    this.z += (v.z - this.z) * alpha2;
    return this;
  },
  lerpVectors: function(v1, v2, alpha2) {
    return this.subVectors(v2, v1).multiplyScalar(alpha2).add(v1);
  },
  cross: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
      return this.crossVectors(v, w);
    }
    return this.crossVectors(this, v);
  },
  crossVectors: function(a, b) {
    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function(vector) {
    var scalar2 = vector.dot(this) / vector.lengthSq();
    return this.copy(vector).multiplyScalar(scalar2);
  },
  projectOnPlane: function() {
    var v1 = new Vector3();
    return function projectOnPlane(planeNormal) {
      v1.copy(this).projectOnVector(planeNormal);
      return this.sub(v1);
    };
  }(),
  reflect: function() {
    var v1 = new Vector3();
    return function reflect(normal) {
      return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
    };
  }(),
  angleTo: function(v) {
    var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
    return Math.acos(_Math.clamp(theta, -1, 1));
  },
  distanceTo: function(v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function(v) {
    var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  },
  setFromSphericalCoords: function(radius, phi, theta) {
    var sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  },
  setFromCylindricalCoords: function(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function(m) {
    var e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function(m) {
    var sx = this.setFromMatrixColumn(m, 0).length();
    var sy = this.setFromMatrixColumn(m, 1).length();
    var sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function(m, index) {
    return this.fromArray(m.elements, index * 4);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
});
function Matrix3() {
  this.elements = [
    1,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1
  ];
  if (arguments.length > 0) {
    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
}
Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    var te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  },
  clone: function() {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function(m) {
    var te = this.elements;
    var me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  setFromMatrix4: function(m) {
    var me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  },
  applyToBufferAttribute: function() {
    var v1 = new Vector3();
    return function applyToBufferAttribute(attribute) {
      for (var i = 0, l = attribute.count; i < l; i++) {
        v1.x = attribute.getX(i);
        v1.y = attribute.getY(i);
        v1.z = attribute.getZ(i);
        v1.applyMatrix3(this);
        attribute.setXYZ(i, v1.x, v1.y, v1.z);
      }
      return attribute;
    };
  }(),
  multiply: function(m) {
    return this.multiplyMatrices(this, m);
  },
  premultiply: function(m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function(a, b) {
    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;
    var a11 = ae[0], a12 = ae[3], a13 = ae[6];
    var a21 = ae[1], a22 = ae[4], a23 = ae[7];
    var a31 = ae[2], a32 = ae[5], a33 = ae[8];
    var b11 = be[0], b12 = be[3], b13 = be[6];
    var b21 = be[1], b22 = be[4], b23 = be[7];
    var b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function(s) {
    var te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function() {
    var te = this.elements;
    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function(matrix, throwOnDegenerate) {
    if (matrix && matrix.isMatrix4) {
      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    }
    var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) {
      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
      if (throwOnDegenerate === true) {
        throw new Error(msg);
      } else {
        console.warn(msg);
      }
      return this.identity();
    }
    var detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function() {
    var tmp2, m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  },
  getNormalMatrix: function(matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function(r) {
    var m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
    var c = Math.cos(rotation);
    var s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
  },
  scale: function(sx, sy) {
    var te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function(theta) {
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var te = this.elements;
    var a11 = te[0], a12 = te[3], a13 = te[6];
    var a21 = te[1], a22 = te[4], a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  },
  translate: function(tx, ty) {
    var te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function(matrix) {
    var te = this.elements;
    var me = matrix.elements;
    for (var i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    for (var i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    var te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});
var _canvas;
var ImageUtils = {
  getDataURL: function(image2) {
    var canvas;
    if (typeof HTMLCanvasElement == "undefined") {
      return image2.src;
    } else if (image2 instanceof HTMLCanvasElement) {
      canvas = image2;
    } else {
      if (_canvas === void 0) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      _canvas.width = image2.width;
      _canvas.height = image2.height;
      var context2 = _canvas.getContext("2d");
      if (image2 instanceof ImageData) {
        context2.putImageData(image2, 0, 0);
      } else {
        context2.drawImage(image2, 0, 0, image2.width, image2.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
};
var textureId = 0;
function Texture(image2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, "id", { value: textureId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.image = image2 !== void 0 ? image2 : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearMipMapLinearFilter;
  this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
  this.format = format !== void 0 ? format : RGBAFormat;
  this.type = type !== void 0 ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4;
  this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = void 0;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function(meta) {
    var isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    var output = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (this.image !== void 0) {
      var image2 = this.image;
      if (image2.uuid === void 0) {
        image2.uuid = _Math.generateUUID();
      }
      if (!isRootObject && meta.images[image2.uuid] === void 0) {
        var url;
        if (Array.isArray(image2)) {
          url = [];
          for (var i = 0, l = image2.length; i < l; i++) {
            url.push(ImageUtils.getDataURL(image2[i]));
          }
        } else {
          url = ImageUtils.getDataURL(image2);
        }
        meta.images[image2.uuid] = {
          uuid: image2.uuid,
          url
        };
      }
      output.image = image2.uuid;
    }
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  },
  transformUv: function(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true) this.version++;
  }
});
function Vector4(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== void 0 ? w : 1;
}
Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function(scalar2) {
    this.x = scalar2;
    this.y = scalar2;
    this.z = scalar2;
    this.w = scalar2;
    return this;
  },
  setX: function(x) {
    this.x = x;
    return this;
  },
  setY: function(y) {
    this.y = y;
    return this;
  },
  setZ: function(z) {
    this.z = z;
    return this;
  },
  setW: function(w) {
    this.w = w;
    return this;
  },
  setComponent: function(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  },
  getComponent: function(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  },
  clone: function() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  },
  add: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
      return this.addVectors(v, w);
    }
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function(v, w) {
    if (w !== void 0) {
      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
      return this.subVectors(v, w);
    }
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function(scalar2) {
    this.x *= scalar2;
    this.y *= scalar2;
    this.z *= scalar2;
    this.w *= scalar2;
    return this;
  },
  applyMatrix4: function(m) {
    var x = this.x, y = this.y, z = this.z, w = this.w;
    var e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function(scalar2) {
    return this.multiplyScalar(1 / scalar2);
  },
  setAxisAngleFromQuaternion: function(q) {
    this.w = 2 * Math.acos(q.w);
    var s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  },
  setAxisAngleFromRotationMatrix: function(m) {
    var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      var xx = (m11 + 1) / 2;
      var yy = (m22 + 1) / 2;
      var zz = (m33 + 1) / 2;
      var xy = (m12 + m21) / 4;
      var xz = (m13 + m31) / 4;
      var yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function(min2, max2) {
    this.x = Math.max(min2.x, Math.min(max2.x, this.x));
    this.y = Math.max(min2.y, Math.min(max2.y, this.y));
    this.z = Math.max(min2.z, Math.min(max2.z, this.z));
    this.w = Math.max(min2.w, Math.min(max2.w, this.w));
    return this;
  },
  clampScalar: /* @__PURE__ */ function() {
    var min2, max2;
    return function clampScalar(minVal, maxVal) {
      if (min2 === void 0) {
        min2 = new Vector4();
        max2 = new Vector4();
      }
      min2.set(minVal, minVal, minVal, minVal);
      max2.set(maxVal, maxVal, maxVal, maxVal);
      return this.clamp(min2, max2);
    };
  }(),
  clampLength: function(min2, max2) {
    var length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min2, Math.min(max2, length)));
  },
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function() {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function(length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function(v, alpha2) {
    this.x += (v.x - this.x) * alpha2;
    this.y += (v.y - this.y) * alpha2;
    this.z += (v.z - this.z) * alpha2;
    this.w += (v.w - this.w) * alpha2;
    return this;
  },
  lerpVectors: function(v1, v2, alpha2) {
    return this.subVectors(v2, v1).multiplyScalar(alpha2).add(v1);
  },
  equals: function(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
    }
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
});
function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function(width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function(source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});
function WebGLRenderTargetCube(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.activeCubeFace = 0;
  this.activeMipMapLevel = 0;
}
WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = { data, width, height };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}
DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
function Box3(min2, max2) {
  this.min = min2 !== void 0 ? min2 : new Vector3(Infinity, Infinity, Infinity);
  this.max = max2 !== void 0 ? max2 : new Vector3(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box3.prototype, {
  isBox3: true,
  set: function(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  },
  setFromArray: function(array) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i = 0, l = array.length; i < l; i += 3) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function(attribute) {
    var minX = Infinity;
    var minY = Infinity;
    var minZ = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    var maxZ = -Infinity;
    for (var i = 0, l = attribute.count; i < l; i++) {
      var x = attribute.getX(i);
      var y = attribute.getY(i);
      var z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }
    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function(points) {
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector3();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  setFromObject: function(object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getCenter() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getSize() target is now required");
      target = new Vector3();
    }
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar2) {
    this.min.addScalar(-scalar2);
    this.max.addScalar(scalar2);
    return this;
  },
  expandByObject: function() {
    var scope, i, l;
    var v1 = new Vector3();
    function traverse(node) {
      var geometry2 = node.geometry;
      if (geometry2 !== void 0) {
        if (geometry2.isGeometry) {
          var vertices = geometry2.vertices;
          for (i = 0, l = vertices.length; i < l; i++) {
            v1.copy(vertices[i]);
            v1.applyMatrix4(node.matrixWorld);
            scope.expandByPoint(v1);
          }
        } else if (geometry2.isBufferGeometry) {
          var attribute = geometry2.attributes.position;
          if (attribute !== void 0) {
            for (i = 0, l = attribute.count; i < l; i++) {
              v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          }
        }
      }
    }
    return function expandByObject(object) {
      scope = this;
      object.updateMatrixWorld(true);
      object.traverse(traverse);
      return this;
    };
  }(),
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .getParameter() target is now required");
      target = new Vector3();
    }
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function() {
    var closestPoint = new Vector3();
    return function intersectsSphere(sphere) {
      this.clampPoint(sphere.center, closestPoint);
      return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    };
  }(),
  intersectsPlane: function(plane) {
    var min2, max2;
    if (plane.normal.x > 0) {
      min2 = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min2 = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min2 += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min2 += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min2 += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min2 += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min2 <= -plane.constant && max2 >= -plane.constant;
  },
  intersectsTriangle: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    var f0 = new Vector3();
    var f1 = new Vector3();
    var f2 = new Vector3();
    var testAxis = new Vector3();
    var center = new Vector3();
    var extents = new Vector3();
    var triangleNormal = new Vector3();
    function satForAxes(axes) {
      var i, j;
      for (i = 0, j = axes.length - 3; i <= j; i += 3) {
        testAxis.fromArray(axes, i);
        var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
        var p0 = v0.dot(testAxis);
        var p1 = v1.dot(testAxis);
        var p2 = v2.dot(testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
          return false;
        }
      }
      return true;
    }
    return function intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(center);
      extents.subVectors(this.max, center);
      v0.subVectors(triangle.a, center);
      v1.subVectors(triangle.b, center);
      v2.subVectors(triangle.c, center);
      f0.subVectors(v1, v0);
      f1.subVectors(v2, v1);
      f2.subVectors(v0, v2);
      var axes = [
        0,
        -f0.z,
        f0.y,
        0,
        -f1.z,
        f1.y,
        0,
        -f2.z,
        f2.y,
        f0.z,
        0,
        -f0.x,
        f1.z,
        0,
        -f1.x,
        f2.z,
        0,
        -f2.x,
        -f0.y,
        f0.x,
        0,
        -f1.y,
        f1.x,
        0,
        -f2.y,
        f2.x,
        0
      ];
      if (!satForAxes(axes)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes)) {
        return false;
      }
      triangleNormal.crossVectors(f0, f1);
      axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
      return satForAxes(axes);
    };
  }(),
  clampPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box3: .clampPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector3();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  getBoundingSphere: function() {
    var v1 = new Vector3();
    return function getBoundingSphere(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getBoundingSphere() target is now required");
        target = new Sphere();
      }
      this.getCenter(target.center);
      target.radius = this.getSize(v1).length() * 0.5;
      return target;
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function() {
    var points = [
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3(),
      new Vector3()
    ];
    return function applyMatrix4(matrix) {
      if (this.isEmpty()) return this;
      points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(points);
      return this;
    };
  }(),
  translate: function(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function Sphere(center, radius) {
  this.center = center !== void 0 ? center : new Vector3();
  this.radius = radius !== void 0 ? radius : 0;
}
Object.assign(Sphere.prototype, {
  set: function(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function() {
    var box = new Box3();
    return function setFromPoints(points, optionalCenter) {
      var center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        box.setFromPoints(points).getCenter(center);
      }
      var maxRadiusSq = 0;
      for (var i = 0, il = points.length; i < il; i++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  empty: function() {
    return this.radius <= 0;
  },
  containsPoint: function(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function(point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function(sphere) {
    var radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function(box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function(point, target) {
    var deltaLengthSq = this.center.distanceToSquared(point);
    if (target === void 0) {
      console.warn("THREE.Sphere: .clampPoint() target is now required");
      target = new Vector3();
    }
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  },
  getBoundingBox: function(target) {
    if (target === void 0) {
      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
      target = new Box3();
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function(offset) {
    this.center.add(offset);
    return this;
  },
  equals: function(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});
function Plane(normal, constant) {
  this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== void 0 ? constant : 0;
}
Object.assign(Plane.prototype, {
  set: function(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function setFromCoplanarPoints(a, b, c) {
      var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function() {
    var inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function(point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .projectPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function() {
    var v1 = new Vector3();
    return function intersectLine(line3, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .intersectLine() target is now required");
        target = new Vector3();
      }
      var direction = line3.delta(v1);
      var denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line3.start) === 0) {
          return target.copy(line3.start);
        }
        return void 0;
      }
      var t = -(line3.start.dot(this.normal) + this.constant) / denominator;
      if (t < 0 || t > 1) {
        return void 0;
      }
      return target.copy(direction).multiplyScalar(t).add(line3.start);
    };
  }(),
  intersectsLine: function(line3) {
    var startSign = this.distanceToPoint(line3.start);
    var endSign = this.distanceToPoint(line3.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function(box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function(sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function(target) {
    if (target === void 0) {
      console.warn("THREE.Plane: .coplanarPoint() target is now required");
      target = new Vector3();
    }
    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function() {
    var v1 = new Vector3();
    var m1 = new Matrix3();
    return function applyMatrix4(matrix, optionalNormalMatrix) {
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
      var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
      var normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    };
  }(),
  translate: function(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  },
  equals: function(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [
    p0 !== void 0 ? p0 : new Plane(),
    p1 !== void 0 ? p1 : new Plane(),
    p2 !== void 0 ? p2 : new Plane(),
    p3 !== void 0 ? p3 : new Plane(),
    p4 !== void 0 ? p4 : new Plane(),
    p5 !== void 0 ? p5 : new Plane()
  ];
}
Object.assign(Frustum.prototype, {
  set: function(p0, p1, p2, p3, p4, p5) {
    var planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(frustum) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  },
  setFromMatrix: function(m) {
    var planes = this.planes;
    var me = m.elements;
    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function() {
    var sphere = new Sphere();
    return function intersectsObject(object) {
      var geometry2 = object.geometry;
      if (geometry2.boundingSphere === null)
        geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSprite: function() {
    var sphere = new Sphere();
    return function intersectsSprite(sprite) {
      sphere.center.set(0, 0, 0);
      sphere.radius = 0.7071067811865476;
      sphere.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(sphere);
    };
  }(),
  intersectsSphere: function(sphere) {
    var planes = this.planes;
    var center = sphere.center;
    var negRadius = -sphere.radius;
    for (var i = 0; i < 6; i++) {
      var distance2 = planes[i].distanceToPoint(center);
      if (distance2 < negRadius) {
        return false;
      }
    }
    return true;
  },
  intersectsBox: function() {
    var p = new Vector3();
    return function intersectsBox(box) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        var plane = planes[i];
        p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(p) < 0) {
          return false;
        }
      }
      return true;
    };
  }(),
  containsPoint: function(point) {
    var planes = this.planes;
    for (var i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
});
const alphamap_fragment = (
  /* glsl */
  `
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`
);
const alphamap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`
);
const alphatest_fragment = (
  /* glsl */
  `
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`
);
const aomap_fragment = (
  /* glsl */
  `
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( PHYSICAL )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`
);
const aomap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`
);
const begin_vertex = (
  /* glsl */
  `
vec3 transformed = vec3( position );
`
);
const beginnormal_vertex = (
  /* glsl */
  `
vec3 objectNormal = vec3( normal );
`
);
const bsdfs = (
  /* glsl */
  `
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE  = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS  = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;

	return specularColor * AB.x + AB.y;

} // validated


float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
`
);
const bumpmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 );

		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`
);
const clipping_planes_fragment = (
  /* glsl */
  `
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;

	}

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;

		}

		if ( clipped ) discard;

	#endif

#endif
`
);
const clipping_planes_pars_fragment = (
  /* glsl */
  `
#if NUM_CLIPPING_PLANES > 0

	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
		varying vec3 vViewPosition;
	#endif

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`
);
const clipping_planes_pars_vertex = (
  /* glsl */
  `
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	varying vec3 vViewPosition;
#endif
`
);
const clipping_planes_vertex = (
  /* glsl */
  `
#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )
	vViewPosition = - mvPosition.xyz;
#endif
`
);
const color_fragment = (
  /* glsl */
  `
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif
`
);
const color_pars_fragment = (
  /* glsl */
  `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`
);
const color_pars_vertex = (
  /* glsl */
  `
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`
);
const color_vertex = (
  /* glsl */
  `
#ifdef USE_COLOR

	vColor.xyz = color.xyz;

#endif
`
);
const common = (
  /* glsl */
  `
#define PI 3.14159265359
#define PI2 6.28318530718
#define PI_HALF 1.5707963267949
#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494
#define LOG2 1.442695
#define EPSILON 1e-6

#define saturate(a) clamp( a, 0.0, 1.0 )
#define whiteCompliment(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}
`
);
const cube_uv_reflection_fragment = (
  /* glsl */
  `
#ifdef ENVMAP_TYPE_CUBE_UV

#define cubeUV_textureSize (1024.0)

int getFaceFromDirection(vec3 direction) {
	vec3 absDirection = abs(direction);
	int face = -1;
	if( absDirection.x > absDirection.z ) {
		if(absDirection.x > absDirection.y )
			face = direction.x > 0.0 ? 0 : 3;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	else {
		if(absDirection.z > absDirection.y )
			face = direction.z > 0.0 ? 2 : 5;
		else
			face = direction.y > 0.0 ? 1 : 4;
	}
	return face;
}
#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)
#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))

vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {
	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);
	float dxRoughness = dFdx(roughness);
	float dyRoughness = dFdy(roughness);
	vec3 dx = dFdx( vec * scale * dxRoughness );
	vec3 dy = dFdy( vec * scale * dyRoughness );
	float d = max( dot( dx, dx ), dot( dy, dy ) );
	// Clamp the value to the max mip level counts. hard coded to 6 mips
	d = clamp(d, 1.0, cubeUV_rangeClamp);
	float mipLevel = 0.5 * log2(d);
	return vec2(floor(mipLevel), fract(mipLevel));
}

#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)
#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)

vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {
	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;
	float a = 16.0 * cubeUV_rcpTextureSize;

	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );
	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;
	// float powScale = exp2(roughnessLevel + mipLevel);
	float powScale = exp2_packed.x * exp2_packed.y;
	// float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);
	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;
	// float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);
	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;

	bool bRes = mipLevel == 0.0;
	scale =  bRes && (scale < a) ? a : scale;

	vec3 r;
	vec2 offset;
	int face = getFaceFromDirection(direction);

	float rcpPowScale = 1.0 / powScale;

	if( face == 0) {
		r = vec3(direction.x, -direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 1) {
		r = vec3(direction.y, direction.x, direction.z);
		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 2) {
		r = vec3(direction.z, direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;
	}
	else if( face == 3) {
		r = vec3(direction.x, direction.z, direction.y);
		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else if( face == 4) {
		r = vec3(direction.y, direction.x, -direction.z);
		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	else {
		r = vec3(direction.z, -direction.x, direction.y);
		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);
		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;
	}
	r = normalize(r);
	float texelOffset = 0.5 * cubeUV_rcpTextureSize;
	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;
	vec2 base = offset + vec2( texelOffset );
	return base + s * ( scale - 2.0 * texelOffset );
}

#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)

vec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {
	float roughnessVal = roughness* cubeUV_maxLods3;
	float r1 = floor(roughnessVal);
	float r2 = r1 + 1.0;
	float t = fract(roughnessVal);
	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);
	float s = mipInfo.y;
	float level0 = mipInfo.x;
	float level1 = level0 + 1.0;
	level1 = level1 > 5.0 ? 5.0 : level1;

	// round to nearest mipmap if we are not interpolating.
	level0 += min( floor( s + 0.5 ), 5.0 );

	// Tri linear interpolation.
	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);
	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));

	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);
	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));

	vec4 result = mix(color10, color20, t);

	return vec4(result.rgb, 1.0);
}

#endif
`
);
const defaultnormal_vertex = (
  /* glsl */
  `
vec3 transformedNormal = normalMatrix * objectNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif
`
);
const displacementmap_pars_vertex = (
  /* glsl */
  `
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`
);
const displacementmap_vertex = (
  /* glsl */
  `
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );

#endif
`
);
const emissivemap_fragment = (
  /* glsl */
  `
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`
);
const emissivemap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`
);
const encodings_fragment = (
  /* glsl */
  `
  gl_FragColor = linearToOutputTexel( gl_FragColor );
`
);
const encodings_pars_fragment = (
  /* glsl */
  `
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = min( floor( D ) / 255.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value )  {
	vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`
);
const envmap_fragment = (
  /* glsl */
  `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToVertex, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_EQUIREC )

		vec2 sampleUV;

		reflectVec = normalize( reflectVec );

		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;

		vec4 envColor = texture2D( envMap, sampleUV );

	#elif defined( ENVMAP_TYPE_SPHERE )

		reflectVec = normalize( reflectVec );

		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );

		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	envColor = envMapTexelToLinear( envColor );

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`
);
const envmap_pars_fragment = (
  /* glsl */
  `
#if defined( USE_ENVMAP ) || defined( PHYSICAL )
	uniform float reflectivity;
	uniform float envMapIntensity;
#endif

#ifdef USE_ENVMAP

	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )
		varying vec3 vWorldPosition;
	#endif

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`
);
const envmap_pars_vertex = (
  /* glsl */
  `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`
);
const envmap_vertex = (
  /* glsl */
  `
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`
);
const fog_vertex = (
  /* glsl */
  `
#ifdef USE_FOG

	fogDepth = -mvPosition.z;

#endif
`
);
const fog_pars_vertex = (
  /* glsl */
  `
#ifdef USE_FOG

	varying float fogDepth;

#endif
`
);
const fog_fragment = (
  /* glsl */
  `
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`
);
const fog_pars_fragment = (
  /* glsl */
  `
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`
);
const gradientmap_pars_fragment = (
  /* glsl */
  `
#ifdef TOON

	uniform sampler2D gradientMap;

	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

		// dotNL will be from -1.0 to 1.0
		float dotNL = dot( normal, lightDirection );
		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

		#ifdef USE_GRADIENTMAP

			return texture2D( gradientMap, coord ).rgb;

		#else

			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

		#endif


	}

#endif
`
);
const lightmap_fragment = (
  /* glsl */
  `
#ifdef USE_LIGHTMAP

	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`
);
const lightmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`
);
const lights_lambert_vertex = (
  /* glsl */
  `
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );

#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}

#endif
`
);
const lights_pars_begin = (
  /* glsl */
  `
uniform vec3 ambientLightColor;

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;

		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;

		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
		float shadowCameraNear;
		float shadowCameraFar;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;

		int shadow;
		float shadowBias;
		float shadowRadius;
		vec2 shadowMapSize;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`
);
const envmap_physical_pars_fragment = (
  /* glsl */
  `
#if defined( USE_ENVMAP ) && defined( PHYSICAL )

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {

		//float envMapWidth = pow( 2.0, maxMIPLevelScalar );
		//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );

		float maxMIPLevelScalar = float( maxMIPLevel );
		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );

		#else

			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));

		#elif defined( ENVMAP_TYPE_EQUIREC )

			vec2 sampleUV;
			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );

			#else

				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_SPHERE )

			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );

			#else

				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`
);
const lights_phong_fragment = (
  /* glsl */
  `
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`
);
const lights_phong_pars_fragment = (
  /* glsl */
  `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3	diffuseColor;
	vec3	specularColor;
	float	specularShininess;
	float	specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	#ifdef TOON

		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#else

		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
		vec3 irradiance = dotNL * directLight.color;

	#endif

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`
);
const lights_physical_fragment = (
  /* glsl */
  `
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
#ifdef STANDARD
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
	material.clearCoat = saturate( clearCoat ); // Burley clearcoat model
	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );
#endif
`
);
const lights_physical_pars_fragment = (
  /* glsl */
  `
struct PhysicalMaterial {

	vec3	diffuseColor;
	float	specularRoughness;
	vec3	specularColor;

	#ifndef STANDARD
		float clearCoat;
		float clearCoatRoughness;
	#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearCoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifndef STANDARD
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif

	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );

	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	#ifndef STANDARD

		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );

	#endif

}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	#ifndef STANDARD
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		float dotNL = dotNV;
		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );
	#else
		float clearCoatDHR = 0.0;
	#endif

	reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );

	#ifndef STANDARD

		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );

	#endif

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )
#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`
);
const lights_fragment_begin = (
  /* glsl */
  `
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = normalize( vViewPosition );

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#ifdef USE_SHADOWMAP
		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}

#endif

#if defined( RE_IndirectDiffuse )

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearCoatRadiance = vec3( 0.0 );

#endif
`
);
const lights_fragment_maps = (
  /* glsl */
  `
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )

		irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );

	#ifndef STANDARD
		clearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );
	#endif

#endif
`
);
const lights_fragment_end = (
  /* glsl */
  `
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );

#endif
`
);
const logdepthbuf_fragment = (
  /* glsl */
  `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`
);
const logdepthbuf_pars_fragment = (
  /* glsl */
  `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;

#endif
`
);
const logdepthbuf_pars_vertex = (
  /* glsl */
  `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`
);
const logdepthbuf_vertex = (
  /* glsl */
  `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;

	#else

		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

		gl_Position.z *= gl_Position.w;

	#endif

#endif
`
);
const map_fragment = (
  /* glsl */
  `
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`
);
const map_pars_fragment = (
  /* glsl */
  `
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`
);
const map_particle_fragment = (
  /* glsl */
  `
#ifdef USE_MAP

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif
`
);
const map_particle_pars_fragment = (
  /* glsl */
  `
#ifdef USE_MAP

	uniform mat3 uvTransform;
	uniform sampler2D map;

#endif
`
);
const metalnessmap_fragment = (
  /* glsl */
  `
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`
);
const metalnessmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`
);
const morphnormal_vertex = (
  /* glsl */
  `
#ifdef USE_MORPHNORMALS

	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];
	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];
	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];
	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];

#endif
`
);
const morphtarget_pars_vertex = (
  /* glsl */
  `
#ifdef USE_MORPHTARGETS

	#ifndef USE_MORPHNORMALS

	uniform float morphTargetInfluences[ 8 ];

	#else

	uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`
);
const morphtarget_vertex = (
  /* glsl */
  `
#ifdef USE_MORPHTARGETS

	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];
	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];
	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];
	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];
	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];
	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];
	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];

	#endif

#endif
`
);
const normal_fragment_begin = (
  /* glsl */
  `
#ifdef FLAT_SHADED

	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

	#endif

#endif
`
);
const normal_fragment_maps = (
  /* glsl */
  `
#ifdef USE_NORMALMAP

	#ifdef OBJECTSPACE_NORMALMAP

		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

		#ifdef FLIP_SIDED

			normal = - normal;

		#endif

		#ifdef DOUBLE_SIDED

			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );

		#endif

		normal = normalize( normalMatrix * normal );

	#else // tangent-space normal map

		normal = perturbNormal2Arb( -vViewPosition, normal );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );

#endif
`
);
const normalmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

	#ifdef OBJECTSPACE_NORMALMAP

		uniform mat3 normalMatrix;

	#else

		// Per-Pixel Tangent Space Normal Mapping
		// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

			// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
			vec2 st0 = dFdx( vUv.st );
			vec2 st1 = dFdy( vUv.st );

			float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude

			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
			vec3 N = normalize( surf_norm );
			mat3 tsn = mat3( S, T, N );

			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;

			mapN.xy *= normalScale;
			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );

			return normalize( tsn * mapN );

		}

	#endif

#endif
`
);
const packing = (
  /* glsl */
  `
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`
);
const premultiplied_alpha_fragment = (
  /* glsl */
  `
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`
);
const project_vertex = (
  /* glsl */
  `
vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

gl_Position = projectionMatrix * mvPosition;
`
);
const dithering_fragment = (
  /* glsl */
  `
#if defined( DITHERING )

  gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`
);
const dithering_pars_fragment = (
  /* glsl */
  `
#if defined( DITHERING )

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`
);
const roughnessmap_fragment = (
  /* glsl */
  `
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`
);
const roughnessmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`
);
const shadowmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHTS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];

	#endif

	#if NUM_SPOT_LIGHTS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];

	#endif

	#if NUM_POINT_LIGHTS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {

		const vec2 offset = vec2( 0.0, 1.0 );

		vec2 texelSize = vec2( 1.0 ) / size;
		vec2 centroidUV = floor( uv * size + 0.5 ) / size;

		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );
		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );
		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );
		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );

		vec2 f = fract( uv * size + 0.5 );

		float a = mix( lb, lt, f.y );
		float b = mix( rb, rt, f.y );
		float c = mix( a, b, f.x );

		return c;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;

			shadow = (
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`
);
const shadowmap_pars_vertex = (
  /* glsl */
  `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHTS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];

	#endif

	#if NUM_SPOT_LIGHTS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];

	#endif

	#if NUM_POINT_LIGHTS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`
);
const shadowmap_vertex = (
  /* glsl */
  `
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;

	}

	#endif

	#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;

	}

	#endif

	#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;

	}

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`
);
const shadowmask_pars_fragment = (
  /* glsl */
  `
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHTS > 0

	DirectionalLight directionalLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}

	#endif

	#if NUM_SPOT_LIGHTS > 0

	SpotLight spotLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];
		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}

	#endif

	#if NUM_POINT_LIGHTS > 0

	PointLight pointLight;

	#pragma unroll_loop
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];
		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`
);
const skinbase_vertex = (
  /* glsl */
  `
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`
);
const skinning_pars_vertex = (
  /* glsl */
  `
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`
);
const skinning_vertex = (
  /* glsl */
  `
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`
);
const skinnormal_vertex = (
  /* glsl */
  `
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

#endif
`
);
const specularmap_fragment = (
  /* glsl */
  `
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`
);
const specularmap_pars_fragment = (
  /* glsl */
  `
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`
);
const tonemapping_fragment = (
  /* glsl */
  `
#if defined( TONE_MAPPING )

  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`
);
const tonemapping_pars_fragment = (
  /* glsl */
  `
#ifndef saturate
	#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;
uniform float toneMappingWhitePoint;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicgames.com/archives/75
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {

	// John Hable's filmic operator from Uncharted 2 video game
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );

}

// source: http://filmicgames.com/archives/75
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACESFilmicToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );

}
`
);
const uv_pars_fragment = (
  /* glsl */
  `
#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )

	varying vec2 vUv;

#endif
`
);
const uv_pars_vertex = (
  /* glsl */
  `
#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )

	varying vec2 vUv;
	uniform mat3 uvTransform;

#endif
`
);
const uv_vertex = (
  /* glsl */
  `
#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`
);
const uv2_pars_fragment = (
  /* glsl */
  `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`
);
const uv2_pars_vertex = (
  /* glsl */
  `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

#endif
`
);
const uv2_vertex = (
  /* glsl */
  `
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = uv2;

#endif
`
);
const worldpos_vertex = (
  /* glsl */
  `
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

#endif
`
);
const background_frag = (
  /* glsl */
  `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`
);
const background_vert = (
  /* glsl */
  `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`
);
const cube_frag = (
  /* glsl */
  `
uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;

varying vec3 vWorldDirection;

void main() {

	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );

	gl_FragColor = mapTexelToLinear( texColor );
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`
);
const cube_vert = (
  /* glsl */
  `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`
);
const depth_frag = (
  /* glsl */
  `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );

	#endif

}
`
);
const depth_vert = (
  /* glsl */
  `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

}
`
);
const distanceRGBA_frag = (
  /* glsl */
  `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`
);
const distanceRGBA_vert = (
  /* glsl */
  `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`
);
const equirect_frag = (
  /* glsl */
  `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV;

	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`
);
const equirect_vert = (
  /* glsl */
  `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`
);
const linedashed_frag = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`
);
const linedashed_vert = (
  /* glsl */
  `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>

	vLineDistance = scale * lineDistance;

	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`
);
const meshbasic_frag = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`
);
const meshbasic_vert = (
  /* glsl */
  `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`
);
const meshlambert_frag = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;

#ifdef DOUBLE_SIDED

	varying vec3 vLightBack;

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
);
const meshlambert_vert = (
  /* glsl */
  `
#define LAMBERT

varying vec3 vLightFront;

#ifdef DOUBLE_SIDED

	varying vec3 vLightBack;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
);
const meshmatcap_frag = (
  /* glsl */
  `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`
);
const meshmatcap_vert = (
  /* glsl */
  `
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`
);
const meshphong_frag = (
  /* glsl */
  `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
);
const meshphong_vert = (
  /* glsl */
  `
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
);
const meshphysical_frag = (
  /* glsl */
  `
#define PHYSICAL

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifndef STANDARD
	uniform float clearCoat;
	uniform float clearCoatRoughness;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`
);
const meshphysical_vert = (
  /* glsl */
  `
#define PHYSICAL

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
);
const normal_frag = (
  /* glsl */
  `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`
);
const normal_vert = (
  /* glsl */
  `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )

	vViewPosition = - mvPosition.xyz;

#endif

}
`
);
const points_frag = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`
);
const points_vert = (
  /* glsl */
  `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`
);
const shadow_frag = (
  /* glsl */
  `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <fog_fragment>

}
`
);
const shadow_vert = (
  /* glsl */
  `
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`
);
const sprite_frag = (
  /* glsl */
  `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`
);
const sprite_vert = (
  /* glsl */
  `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`
);
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normalmap_pars_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_frag,
  background_vert,
  cube_frag,
  cube_vert,
  depth_frag,
  depth_vert,
  distanceRGBA_frag,
  distanceRGBA_vert,
  equirect_frag,
  equirect_vert,
  linedashed_frag,
  linedashed_vert,
  meshbasic_frag,
  meshbasic_vert,
  meshlambert_frag,
  meshlambert_vert,
  meshmatcap_frag,
  meshmatcap_vert,
  meshphong_frag,
  meshphong_vert,
  meshphysical_frag,
  meshphysical_vert,
  normal_frag,
  normal_vert,
  points_frag,
  points_vert,
  shadow_frag,
  shadow_vert,
  sprite_frag,
  sprite_vert
};
function cloneUniforms(src) {
  var dst = {};
  for (var u in src) {
    dst[u] = {};
    for (var p in src[u]) {
      var property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  var merged = {};
  for (var u = 0; u < uniforms.length; u++) {
    var tmp2 = cloneUniforms(uniforms[u]);
    for (var p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
var ColorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
function Color(r, g, b) {
  if (g === void 0 && b === void 0) {
    return this.set(r);
  }
  return this.setRGB(r, g, b);
}
Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function(value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === "number") {
      this.setHex(value);
    } else if (typeof value === "string") {
      this.setStyle(value);
    }
    return this;
  },
  setScalar: function(scalar2) {
    this.r = scalar2;
    this.g = scalar2;
    this.b = scalar2;
    return this;
  },
  setHex: function(hex2) {
    hex2 = Math.floor(hex2);
    this.r = (hex2 >> 16 & 255) / 255;
    this.g = (hex2 >> 8 & 255) / 255;
    this.b = (hex2 & 255) / 255;
    return this;
  },
  setRGB: function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: /* @__PURE__ */ function() {
    function hue2rgb2(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
      return p;
    }
    return function setHSL(h, s, l) {
      h = _Math.euclideanModulo(h, 1);
      s = _Math.clamp(s, 0, 1);
      l = _Math.clamp(l, 0, 1);
      if (s === 0) {
        this.r = this.g = this.b = l;
      } else {
        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        var q = 2 * l - p;
        this.r = hue2rgb2(q, p, h + 1 / 3);
        this.g = hue2rgb2(q, p, h);
        this.b = hue2rgb2(q, p, h - 1 / 3);
      }
      return this;
    };
  }(),
  setStyle: function(style) {
    function handleAlpha(string2) {
      if (string2 === void 0) return;
      if (parseFloat(string2) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    var m;
    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      var color2;
      var name = m[1];
      var components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color2 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(255, parseInt(color2[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color2[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color2[3], 10)) / 255;
            handleAlpha(color2[5]);
            return this;
          }
          if (color2 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            this.r = Math.min(100, parseInt(color2[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color2[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color2[3], 10)) / 100;
            handleAlpha(color2[5]);
            return this;
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            var h = parseFloat(color2[1]) / 360;
            var s = parseInt(color2[2], 10) / 100;
            var l = parseInt(color2[3], 10) / 100;
            handleAlpha(color2[5]);
            return this.setHSL(h, s, l);
          }
          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      var hex2 = m[1];
      var size = hex2.length;
      if (size === 3) {
        this.r = parseInt(hex2.charAt(0) + hex2.charAt(0), 16) / 255;
        this.g = parseInt(hex2.charAt(1) + hex2.charAt(1), 16) / 255;
        this.b = parseInt(hex2.charAt(2) + hex2.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        this.r = parseInt(hex2.charAt(0) + hex2.charAt(1), 16) / 255;
        this.g = parseInt(hex2.charAt(2) + hex2.charAt(3), 16) / 255;
        this.b = parseInt(hex2.charAt(4) + hex2.charAt(5), 16) / 255;
        return this;
      }
    }
    if (style && style.length > 0) {
      var hex2 = ColorKeywords[style];
      if (hex2 !== void 0) {
        this.setHex(hex2);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
    }
    return this;
  },
  clone: function() {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  },
  copyGammaToLinear: function(color2, gammaFactor) {
    if (gammaFactor === void 0) gammaFactor = 2;
    this.r = Math.pow(color2.r, gammaFactor);
    this.g = Math.pow(color2.g, gammaFactor);
    this.b = Math.pow(color2.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function(color2, gammaFactor) {
    if (gammaFactor === void 0) gammaFactor = 2;
    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    this.r = Math.pow(color2.r, safeInverse);
    this.g = Math.pow(color2.g, safeInverse);
    this.b = Math.pow(color2.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function(gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function(gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: /* @__PURE__ */ function() {
    function SRGBToLinear(c) {
      return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
    }
    return function copySRGBToLinear(color2) {
      this.r = SRGBToLinear(color2.r);
      this.g = SRGBToLinear(color2.g);
      this.b = SRGBToLinear(color2.b);
      return this;
    };
  }(),
  copyLinearToSRGB: /* @__PURE__ */ function() {
    function LinearToSRGB(c) {
      return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
    }
    return function copyLinearToSRGB(color2) {
      this.r = LinearToSRGB(color2.r);
      this.g = LinearToSRGB(color2.g);
      this.b = LinearToSRGB(color2.b);
      return this;
    };
  }(),
  convertSRGBToLinear: function() {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function() {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function() {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function(target) {
    if (target === void 0) {
      console.warn("THREE.Color: .getHSL() target is now required");
      target = { h: 0, s: 0, l: 0 };
    }
    var r = this.r, g = this.g, b = this.b;
    var max2 = Math.max(r, g, b);
    var min2 = Math.min(r, g, b);
    var hue, saturation;
    var lightness = (min2 + max2) / 2;
    if (min2 === max2) {
      hue = 0;
      saturation = 0;
    } else {
      var delta = max2 - min2;
      saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
      switch (max2) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function() {
    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
  },
  offsetHSL: /* @__PURE__ */ function() {
    var hsl2 = {};
    return function(h, s, l) {
      this.getHSL(hsl2);
      hsl2.h += h;
      hsl2.s += s;
      hsl2.l += l;
      this.setHSL(hsl2.h, hsl2.s, hsl2.l);
      return this;
    };
  }(),
  add: function(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  },
  addColors: function(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  },
  multiply: function(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  },
  multiplyScalar: function(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function(color2, alpha2) {
    this.r += (color2.r - this.r) * alpha2;
    this.g += (color2.g - this.g) * alpha2;
    this.b += (color2.b - this.b) * alpha2;
    return this;
  },
  lerpHSL: /* @__PURE__ */ function() {
    var hslA = { h: 0, s: 0, l: 0 };
    var hslB = { h: 0, s: 0, l: 0 };
    return function lerpHSL(color2, alpha2) {
      this.getHSL(hslA);
      color2.getHSL(hslB);
      var h = _Math.lerp(hslA.h, hslB.h, alpha2);
      var s = _Math.lerp(hslA.s, hslB.s, alpha2);
      var l = _Math.lerp(hslA.l, hslB.l, alpha2);
      this.setHSL(h, s, l);
      return this;
    };
  }(),
  equals: function(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function(array, offset) {
    if (offset === void 0) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  toJSON: function() {
    return this.getHex();
  }
});
var UniformsLib = {
  common: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() },
    alphaMap: { value: null }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    refractionRatio: { value: 0.98 },
    maxMipLevel: { value: 0 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {},
      shadow: {},
      shadowBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } }
  },
  points: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(15658734) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    uvTransform: { value: new Matrix3() }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 0.5 },
        metalness: { value: 0.5 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearCoat: { value: 0 },
      clearCoatRoughness: { value: 0 }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
function WebGLAnimation() {
  var context2 = null;
  var isAnimating2 = false;
  var animationLoop = null;
  function onAnimationFrame(time2, frame2) {
    if (isAnimating2 === false) return;
    animationLoop(time2, frame2);
    context2.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating2 === true) return;
      if (animationLoop === null) return;
      context2.requestAnimationFrame(onAnimationFrame);
      isAnimating2 = true;
    },
    stop: function() {
      isAnimating2 = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context2 = value;
    }
  };
}
function WebGLAttributes(gl) {
  var buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    var array = attribute.array;
    var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
    var buffer2 = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer2);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    var type = gl.FLOAT;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Float64Array) {
      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
    } else if (array instanceof Uint16Array) {
      type = gl.UNSIGNED_SHORT;
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    }
    return {
      buffer: buffer2,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer2, attribute, bufferType) {
    var array = attribute.array;
    var updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer2);
    if (attribute.dynamic === false) {
      gl.bufferData(bufferType, array, gl.STATIC_DRAW);
    } else if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else if (updateRange.count === 0) {
      console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
    } else {
      gl.bufferSubData(
        bufferType,
        updateRange.offset * array.BYTES_PER_ELEMENT,
        array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
      );
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    var data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update: update2
  };
}
function Face3(a, b, c, normal, color2, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color2 && color2.isColor ? color2 : new Color();
  this.vertexColors = Array.isArray(color2) ? color2 : [];
  this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
}
Object.assign(Face3.prototype, {
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;
    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }
    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }
    return this;
  }
});
function Euler(x, y, z, order) {
  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || Euler.DefaultOrder;
}
Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
Euler.DefaultOrder = "XYZ";
Object.defineProperties(Euler.prototype, {
  x: {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this.onChangeCallback();
    }
  },
  y: {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this.onChangeCallback();
    }
  },
  z: {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this.onChangeCallback();
    }
  },
  order: {
    get: function() {
      return this._order;
    },
    set: function(value) {
      this._order = value;
      this.onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function(x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;
    this.onChangeCallback();
    return this;
  },
  clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this.onChangeCallback();
    return this;
  },
  setFromRotationMatrix: function(m, order, update2) {
    var clamp2 = _Math.clamp;
    var te = m.elements;
    var m11 = te[0], m12 = te[4], m13 = te[8];
    var m21 = te[1], m22 = te[5], m23 = te[9];
    var m31 = te[2], m32 = te[6], m33 = te[10];
    order = order || this._order;
    if (order === "XYZ") {
      this._y = Math.asin(clamp2(m13, -1, 1));
      if (Math.abs(m13) < 0.99999) {
        this._x = Math.atan2(-m23, m33);
        this._z = Math.atan2(-m12, m11);
      } else {
        this._x = Math.atan2(m32, m22);
        this._z = 0;
      }
    } else if (order === "YXZ") {
      this._x = Math.asin(-clamp2(m23, -1, 1));
      if (Math.abs(m23) < 0.99999) {
        this._y = Math.atan2(m13, m33);
        this._z = Math.atan2(m21, m22);
      } else {
        this._y = Math.atan2(-m31, m11);
        this._z = 0;
      }
    } else if (order === "ZXY") {
      this._x = Math.asin(clamp2(m32, -1, 1));
      if (Math.abs(m32) < 0.99999) {
        this._y = Math.atan2(-m31, m33);
        this._z = Math.atan2(-m12, m22);
      } else {
        this._y = 0;
        this._z = Math.atan2(m21, m11);
      }
    } else if (order === "ZYX") {
      this._y = Math.asin(-clamp2(m31, -1, 1));
      if (Math.abs(m31) < 0.99999) {
        this._x = Math.atan2(m32, m33);
        this._z = Math.atan2(m21, m11);
      } else {
        this._x = 0;
        this._z = Math.atan2(-m12, m22);
      }
    } else if (order === "YZX") {
      this._z = Math.asin(clamp2(m21, -1, 1));
      if (Math.abs(m21) < 0.99999) {
        this._x = Math.atan2(-m23, m22);
        this._y = Math.atan2(-m31, m11);
      } else {
        this._x = 0;
        this._y = Math.atan2(m13, m33);
      }
    } else if (order === "XZY") {
      this._z = Math.asin(-clamp2(m12, -1, 1));
      if (Math.abs(m12) < 0.99999) {
        this._x = Math.atan2(m32, m22);
        this._y = Math.atan2(m13, m11);
      } else {
        this._x = Math.atan2(-m23, m33);
        this._y = 0;
      }
    } else {
      console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
    }
    this._order = order;
    if (update2 !== false) this.onChangeCallback();
    return this;
  },
  setFromQuaternion: function() {
    var matrix = new Matrix4();
    return function setFromQuaternion(q, order, update2) {
      matrix.makeRotationFromQuaternion(q);
      return this.setFromRotationMatrix(matrix, order, update2);
    };
  }(),
  setFromVector3: function(v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function() {
    var q = new Quaternion();
    return function reorder(newOrder) {
      q.setFromEuler(this);
      return this.setFromQuaternion(q, newOrder);
    };
  }(),
  equals: function(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this.onChangeCallback();
    return this;
  },
  toArray: function(array, offset) {
    if (array === void 0) array = [];
    if (offset === void 0) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function(optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  onChange: function(callback) {
    this.onChangeCallback = callback;
    return this;
  },
  onChangeCallback: function() {
  }
});
function Layers() {
  this.mask = 1 | 0;
}
Object.assign(Layers.prototype, {
  set: function(channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function(channel) {
    this.mask |= 1 << channel | 0;
  },
  toggle: function(channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function(channel) {
    this.mask &= ~(1 << channel | 0);
  },
  test: function(layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
var object3DId = 0;
function Object3D() {
  Object.defineProperty(this, "id", { value: object3DId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  var position = new Vector3();
  var rotation = new Euler();
  var quaternion = new Quaternion();
  var scale2 = new Vector3(1, 1, 1);
  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }
  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, void 0, false);
  }
  rotation.onChange(onRotationChange);
  quaternion.onChange(onQuaternionChange);
  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale2
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}
Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function() {
  },
  onAfterRender: function() {
  },
  applyMatrix: function(matrix) {
    this.matrix.multiplyMatrices(matrix, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function(q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function(euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function(m) {
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function(q) {
    this.quaternion.copy(q);
  },
  rotateOnAxis: function() {
    var q1 = new Quaternion();
    return function rotateOnAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(q1);
      return this;
    };
  }(),
  rotateOnWorldAxis: function() {
    var q1 = new Quaternion();
    return function rotateOnWorldAxis(axis, angle) {
      q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(q1);
      return this;
    };
  }(),
  rotateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function rotateX(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function rotateY(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  rotateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function rotateZ(angle) {
      return this.rotateOnAxis(v1, angle);
    };
  }(),
  translateOnAxis: function() {
    var v1 = new Vector3();
    return function translateOnAxis(axis, distance2) {
      v1.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(v1.multiplyScalar(distance2));
      return this;
    };
  }(),
  translateX: function() {
    var v1 = new Vector3(1, 0, 0);
    return function translateX(distance2) {
      return this.translateOnAxis(v1, distance2);
    };
  }(),
  translateY: function() {
    var v1 = new Vector3(0, 1, 0);
    return function translateY(distance2) {
      return this.translateOnAxis(v1, distance2);
    };
  }(),
  translateZ: function() {
    var v1 = new Vector3(0, 0, 1);
    return function translateZ(distance2) {
      return this.translateOnAxis(v1, distance2);
    };
  }(),
  localToWorld: function(vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function() {
    var m1 = new Matrix4();
    return function worldToLocal(vector) {
      return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function() {
    var q1 = new Quaternion();
    var m1 = new Matrix4();
    var target = new Vector3();
    var position = new Vector3();
    return function lookAt(x, y, z) {
      if (x.isVector3) {
        target.copy(x);
      } else {
        target.set(x, y, z);
      }
      var parent = this.parent;
      this.updateWorldMatrix(true, false);
      position.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        m1.lookAt(position, target, this.up);
      } else {
        m1.lookAt(target, position, this.up);
      }
      this.quaternion.setFromRotationMatrix(m1);
      if (parent) {
        m1.extractRotation(parent.matrixWorld);
        q1.setFromRotationMatrix(m1);
        this.quaternion.premultiply(q1.inverse());
      }
    };
  }(),
  add: function(object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      object.dispatchEvent({ type: "added" });
      this.children.push(object);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  },
  remove: function(object) {
    if (arguments.length > 1) {
      for (var i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    var index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      object.dispatchEvent({ type: "removed" });
      this.children.splice(index, 1);
    }
    return this;
  },
  getObjectById: function(id2) {
    return this.getObjectByProperty("id", id2);
  },
  getObjectByName: function(name) {
    return this.getObjectByProperty("name", name);
  },
  getObjectByProperty: function(name, value) {
    if (this[name] === value) return this;
    for (var i = 0, l = this.children.length; i < l; i++) {
      var child = this.children[i];
      var object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  },
  getWorldPosition: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function() {
    var position = new Vector3();
    var scale2 = new Vector3();
    return function getWorldQuaternion(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
        target = new Quaternion();
      }
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, target, scale2);
      return target;
    };
  }(),
  getWorldScale: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    return function getWorldScale(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldScale() target is now required");
        target = new Vector3();
      }
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(position, quaternion, target);
      return target;
    };
  }(),
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function() {
  },
  traverse: function(callback) {
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function(callback) {
    if (this.visible === false) return;
    callback(this);
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function(callback) {
    var parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    var children = this.children;
    for (var i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function(updateParents, updateChildren) {
    var parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      var children = this.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function(meta) {
    var isRootObject = meta === void 0 || typeof meta === "string";
    var output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    var object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      var parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        var shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        var uuids = [];
        for (var i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (var i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (isRootObject) {
      var geometries = extractFromCache(meta.geometries);
      var materials = extractFromCache(meta.materials);
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      var shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  },
  clone: function(recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function(source, recursive) {
    if (recursive === void 0) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (var i = 0; i < source.children.length; i++) {
        var child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
});
var geometryId = 0;
function Geometry() {
  Object.defineProperty(this, "id", { value: geometryId += 2 });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Geometry";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix: function(matrix) {
    var normalMatrix = new Matrix3().getNormalMatrix(matrix);
    for (var i = 0, il = this.vertices.length; i < il; i++) {
      var vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }
    for (var i = 0, il = this.faces.length; i < il; i++) {
      var face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();
      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  fromBufferGeometry: function(geometry2) {
    var scope = this;
    var indices = geometry2.index !== null ? geometry2.index.array : void 0;
    var attributes = geometry2.attributes;
    var positions = attributes.position.array;
    var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
    var colors3 = attributes.color !== void 0 ? attributes.color.array : void 0;
    var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
    var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
    if (uvs2 !== void 0) this.faceVertexUvs[1] = [];
    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
      scope.vertices.push(new Vector3().fromArray(positions, i));
      if (colors3 !== void 0) {
        scope.colors.push(new Color().fromArray(colors3, i));
      }
    }
    function addFace(a, b, c, materialIndex) {
      var vertexColors = colors3 === void 0 ? [] : [
        scope.colors[a].clone(),
        scope.colors[b].clone(),
        scope.colors[c].clone()
      ];
      var vertexNormals = normals === void 0 ? [] : [
        new Vector3().fromArray(normals, a * 3),
        new Vector3().fromArray(normals, b * 3),
        new Vector3().fromArray(normals, c * 3)
      ];
      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);
      if (uvs !== void 0) {
        scope.faceVertexUvs[0].push([
          new Vector2().fromArray(uvs, a * 2),
          new Vector2().fromArray(uvs, b * 2),
          new Vector2().fromArray(uvs, c * 2)
        ]);
      }
      if (uvs2 !== void 0) {
        scope.faceVertexUvs[1].push([
          new Vector2().fromArray(uvs2, a * 2),
          new Vector2().fromArray(uvs2, b * 2),
          new Vector2().fromArray(uvs2, c * 2)
        ]);
      }
    }
    var groups = geometry2.groups;
    if (groups.length > 0) {
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var start2 = group.start;
        var count2 = group.count;
        for (var j = start2, jl = start2 + count2; j < jl; j += 3) {
          if (indices !== void 0) {
            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (indices !== void 0) {
        for (var i = 0; i < indices.length; i += 3) {
          addFace(indices[i], indices[i + 1], indices[i + 2]);
        }
      } else {
        for (var i = 0; i < positions.length / 3; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }
    this.computeFaceNormals();
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    return this;
  },
  center: function() {
    var offset = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  normalize: function() {
    this.computeBoundingSphere();
    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;
    var s = radius === 0 ? 1 : 1 / radius;
    var matrix = new Matrix4();
    matrix.set(
      s,
      0,
      0,
      -s * center.x,
      0,
      s,
      0,
      -s * center.y,
      0,
      0,
      s,
      -s * center.z,
      0,
      0,
      0,
      1
    );
    this.applyMatrix(matrix);
    return this;
  },
  computeFaceNormals: function() {
    var cb = new Vector3(), ab = new Vector3();
    for (var f = 0, fl = this.faces.length; f < fl; f++) {
      var face = this.faces[f];
      var vA = this.vertices[face.a];
      var vB = this.vertices[face.b];
      var vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function(areaWeighted) {
    if (areaWeighted === void 0) areaWeighted = true;
    var v, vl, f, fl, face, vertices;
    vertices = new Array(this.vertices.length);
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }
    if (areaWeighted) {
      var vA, vB, vC;
      var cb = new Vector3(), ab = new Vector3();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vA = this.vertices[face.a];
        vB = this.vertices[face.b];
        vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }
    for (v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function() {
    var f, fl, face;
    this.computeFaceNormals();
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }
    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function() {
    var i, il, f, fl, face;
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }
      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
      for (i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    }
    var tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;
    for (i = 0, il = this.morphTargets.length; i < il; i++) {
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        var dstNormalsFace = this.morphNormals[i].faceNormals;
        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          faceNormal = new Vector3();
          vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }
      var morphNormals = this.morphNormals[i];
      tmpGeo.vertices = this.morphTargets[i].vertices;
      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();
      var faceNormal, vertexNormals;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        faceNormal = morphNormals.faceNormals[f];
        vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    }
    for (f = 0, fl = this.faces.length; f < fl; f++) {
      face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function(geometry2, matrix, materialIndexOffset) {
    if (!(geometry2 && geometry2.isGeometry)) {
      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry2);
      return;
    }
    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry2.vertices, faces1 = this.faces, faces2 = geometry2.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0], colors1 = this.colors, colors22 = geometry2.colors;
    if (materialIndexOffset === void 0) materialIndexOffset = 0;
    if (matrix !== void 0) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    }
    for (var i = 0, il = vertices2.length; i < il; i++) {
      var vertex = vertices2[i];
      var vertexCopy = vertex.clone();
      if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    }
    for (var i = 0, il = colors22.length; i < il; i++) {
      colors1.push(colors22[i].clone());
    }
    for (i = 0, il = faces2.length; i < il; i++) {
      var face = faces2[i], faceCopy, normal, color2, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);
      if (normalMatrix !== void 0) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }
      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();
        if (normalMatrix !== void 0) {
          normal.applyMatrix3(normalMatrix).normalize();
        }
        faceCopy.vertexNormals.push(normal);
      }
      faceCopy.color.copy(face.color);
      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color2 = faceVertexColors[j];
        faceCopy.vertexColors.push(color2.clone());
      }
      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    }
    for (i = 0, il = uvs2.length; i < il; i++) {
      var uv = uvs2[i], uvCopy = [];
      if (uv === void 0) {
        continue;
      }
      for (var j = 0, jl = uv.length; j < jl; j++) {
        uvCopy.push(uv[j].clone());
      }
      uvs1.push(uvCopy);
    }
  },
  mergeMesh: function(mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
      return;
    }
    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },
  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function() {
    var verticesMap = {};
    var unique2 = [], changes = [];
    var v, key;
    var precisionPoints = 4;
    var precision = Math.pow(10, precisionPoints);
    var i, il, face;
    var indices, j, jl;
    for (i = 0, il = this.vertices.length; i < il; i++) {
      v = this.vertices[i];
      key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
      if (verticesMap[key] === void 0) {
        verticesMap[key] = i;
        unique2.push(this.vertices[i]);
        changes[i] = unique2.length - 1;
      } else {
        changes[i] = changes[verticesMap[key]];
      }
    }
    var faceIndicesToRemove = [];
    for (i = 0, il = this.faces.length; i < il; i++) {
      face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      indices = [face.a, face.b, face.c];
      for (var n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }
    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      var idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);
      for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    }
    var diff = this.vertices.length - unique2.length;
    this.vertices = unique2;
    return diff;
  },
  setFromPoints: function(points) {
    this.vertices = [];
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function() {
    var faces = this.faces;
    var length = faces.length;
    for (var i = 0; i < length; i++) {
      faces[i]._id = i;
    }
    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }
    faces.sort(materialIndexSort);
    var uvs1 = this.faceVertexUvs[0];
    var uvs2 = this.faceVertexUvs[1];
    var newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];
    for (var i = 0; i < length; i++) {
      var id2 = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id2]);
      if (newUvs2) newUvs2.push(uvs2[id2]);
    }
    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    var vertices = [];
    for (var i = 0; i < this.vertices.length; i++) {
      var vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors3 = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};
    for (var i = 0; i < this.faces.length; i++) {
      var face = this.faces[i];
      var hasMaterial = true;
      var hasFaceUv = false;
      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;
      var faceType = 0;
      faceType = setBit(faceType, 0, 0);
      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);
      if (hasFaceVertexUv) {
        var faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(
          getUvIndex(faceVertexUvs[0]),
          getUvIndex(faceVertexUvs[1]),
          getUvIndex(faceVertexUvs[2])
        );
      }
      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }
      if (hasFaceVertexNormal) {
        var vertexNormals = face.vertexNormals;
        faces.push(
          getNormalIndex(vertexNormals[0]),
          getNormalIndex(vertexNormals[1]),
          getNormalIndex(vertexNormals[2])
        );
      }
      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }
      if (hasFaceVertexColor) {
        var vertexColors = face.vertexColors;
        faces.push(
          getColorIndex(vertexColors[0]),
          getColorIndex(vertexColors[1]),
          getColorIndex(vertexColors[2])
        );
      }
    }
    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }
    function getNormalIndex(normal) {
      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
      if (normalsHash[hash] !== void 0) {
        return normalsHash[hash];
      }
      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }
    function getColorIndex(color2) {
      var hash = color2.r.toString() + color2.g.toString() + color2.b.toString();
      if (colorsHash[hash] !== void 0) {
        return colorsHash[hash];
      }
      colorsHash[hash] = colors3.length;
      colors3.push(color2.getHex());
      return colorsHash[hash];
    }
    function getUvIndex(uv) {
      var hash = uv.x.toString() + uv.y.toString();
      if (uvsHash[hash] !== void 0) {
        return uvsHash[hash];
      }
      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }
    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors3.length > 0) data.data.colors = colors3;
    if (uvs.length > 0) data.data.uvs = [uvs];
    data.data.faces = faces;
    return data;
  },
  clone: function() {
    return new Geometry().copy(this);
  },
  copy: function(source) {
    var i, il, j, jl, k, kl;
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var vertices = source.vertices;
    for (i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    }
    var colors3 = source.colors;
    for (i = 0, il = colors3.length; i < il; i++) {
      this.colors.push(colors3[i].clone());
    }
    var faces = source.faces;
    for (i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    }
    for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      var faceVertexUvs = source.faceVertexUvs[i];
      if (this.faceVertexUvs[i] === void 0) {
        this.faceVertexUvs[i] = [];
      }
      for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        var uvs = faceVertexUvs[j], uvsCopy = [];
        for (k = 0, kl = uvs.length; k < kl; k++) {
          var uv = uvs[k];
          uvsCopy.push(uv.clone());
        }
        this.faceVertexUvs[i].push(uvsCopy);
      }
    }
    var morphTargets = source.morphTargets;
    for (i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = {};
      morphTarget.name = morphTargets[i].name;
      if (morphTargets[i].vertices !== void 0) {
        morphTarget.vertices = [];
        for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      }
      if (morphTargets[i].normals !== void 0) {
        morphTarget.normals = [];
        for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }
      this.morphTargets.push(morphTarget);
    }
    var morphNormals = source.morphNormals;
    for (i = 0, il = morphNormals.length; i < il; i++) {
      var morphNormal = {};
      if (morphNormals[i].vertexNormals !== void 0) {
        morphNormal.vertexNormals = [];
        for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          var srcVertexNormal = morphNormals[i].vertexNormals[j];
          var destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      }
      if (morphNormals[i].faceNormals !== void 0) {
        morphNormal.faceNormals = [];
        for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }
      this.morphNormals.push(morphNormal);
    }
    var skinWeights = source.skinWeights;
    for (i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    }
    var skinIndices = source.skinIndices;
    for (i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    }
    var lineDistances = source.lineDistances;
    for (i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  }
  this.name = "";
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== void 0 ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.dynamic = false;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function() {
  },
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.itemSize : 0;
    this.array = array;
    return this;
  },
  setDynamic: function(value) {
    this.dynamic = value;
    return this;
  },
  copy: function(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (var i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  copyArray: function(array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function(colors3) {
    var array = this.array, offset = 0;
    for (var i = 0, l = colors3.length; i < l; i++) {
      var color2 = colors3[i];
      if (color2 === void 0) {
        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
        color2 = new Color();
      }
      array[offset++] = color2.r;
      array[offset++] = color2.g;
      array[offset++] = color2.b;
    }
    return this;
  },
  copyVector2sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
        vector = new Vector2();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }
    return this;
  },
  copyVector3sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
        vector = new Vector3();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }
    return this;
  },
  copyVector4sArray: function(vectors) {
    var array = this.array, offset = 0;
    for (var i = 0, l = vectors.length; i < l; i++) {
      var vector = vectors[i];
      if (vector === void 0) {
        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
        vector = new Vector4();
      }
      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }
    return this;
  },
  set: function(value, offset) {
    if (offset === void 0) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function(index) {
    return this.array[index * this.itemSize];
  },
  setX: function(index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function(index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function(index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function(index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function(index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function(index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function(index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function(index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
});
function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}
Object.assign(DirectGeometry.prototype, {
  computeGroups: function(geometry2) {
    var group;
    var groups = [];
    var materialIndex = void 0;
    var faces = geometry2.faces;
    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;
        if (group !== void 0) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }
        group = {
          start: i * 3,
          materialIndex
        };
      }
    }
    if (group !== void 0) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }
    this.groups = groups;
  },
  fromGeometry: function(geometry2) {
    var faces = geometry2.faces;
    var vertices = geometry2.vertices;
    var faceVertexUvs = geometry2.faceVertexUvs;
    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
    var morphTargets = geometry2.morphTargets;
    var morphTargetsLength = morphTargets.length;
    var morphTargetsPosition;
    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];
      for (var i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }
      this.morphTargets.position = morphTargetsPosition;
    }
    var morphNormals = geometry2.morphNormals;
    var morphNormalsLength = morphNormals.length;
    var morphTargetsNormal;
    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];
      for (var i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }
      this.morphTargets.normal = morphTargetsNormal;
    }
    var skinIndices = geometry2.skinIndices;
    var skinWeights = geometry2.skinWeights;
    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;
    if (vertices.length > 0 && faces.length === 0) {
      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
    }
    for (var i = 0; i < faces.length; i++) {
      var face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      var vertexNormals = face.vertexNormals;
      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        var normal = face.normal;
        this.normals.push(normal, normal, normal);
      }
      var vertexColors = face.vertexColors;
      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        var color2 = face.color;
        this.colors.push(color2, color2, color2);
      }
      if (hasFaceVertexUv === true) {
        var vertexUvs = faceVertexUvs[0][i];
        if (vertexUvs !== void 0) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      if (hasFaceVertexUv2 === true) {
        var vertexUvs = faceVertexUvs[1][i];
        if (vertexUvs !== void 0) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      }
      for (var j = 0; j < morphTargetsLength; j++) {
        var morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }
      for (var j = 0; j < morphNormalsLength; j++) {
        var morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      }
      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }
      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }
    this.computeGroups(geometry2);
    this.verticesNeedUpdate = geometry2.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry2.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry2.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry2.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry2.groupsNeedUpdate;
    return this;
  }
});
function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  var max2 = array[0];
  for (var i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max2) max2 = array[i];
  }
  return max2;
}
var bufferGeometryId = 1;
function BufferGeometry() {
  Object.defineProperty(this, "id", { value: bufferGeometryId += 2 });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = { start: 0, count: Infinity };
  this.userData = {};
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function() {
    return this.index;
  },
  setIndex: function(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  addAttribute: function(name, attribute) {
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return this;
    }
    this.attributes[name] = attribute;
    return this;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  removeAttribute: function(name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function(start2, count2, materialIndex) {
    this.groups.push({
      start: start2,
      count: count2,
      materialIndex: materialIndex !== void 0 ? materialIndex : 0
    });
  },
  clearGroups: function() {
    this.groups = [];
  },
  setDrawRange: function(start2, count2) {
    this.drawRange.start = start2;
    this.drawRange.count = count2;
  },
  applyMatrix: function(matrix) {
    var position = this.attributes.position;
    if (position !== void 0) {
      matrix.applyToBufferAttribute(position);
      position.needsUpdate = true;
    }
    var normal = this.attributes.normal;
    if (normal !== void 0) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normalMatrix.applyToBufferAttribute(normal);
      normal.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  },
  rotateX: function() {
    var m1 = new Matrix4();
    return function rotateX(angle) {
      m1.makeRotationX(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateY: function() {
    var m1 = new Matrix4();
    return function rotateY(angle) {
      m1.makeRotationY(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  rotateZ: function() {
    var m1 = new Matrix4();
    return function rotateZ(angle) {
      m1.makeRotationZ(angle);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  translate: function() {
    var m1 = new Matrix4();
    return function translate(x, y, z) {
      m1.makeTranslation(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  scale: function() {
    var m1 = new Matrix4();
    return function scale2(x, y, z) {
      m1.makeScale(x, y, z);
      this.applyMatrix(m1);
      return this;
    };
  }(),
  lookAt: function() {
    var obj = new Object3D();
    return function lookAt(vector) {
      obj.lookAt(vector);
      obj.updateMatrix();
      this.applyMatrix(obj.matrix);
    };
  }(),
  center: function() {
    var offset = new Vector3();
    return function center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(offset).negate();
      this.translate(offset.x, offset.y, offset.z);
      return this;
    };
  }(),
  setFromObject: function(object) {
    var geometry2 = object.geometry;
    if (object.isPoints || object.isLine) {
      var positions = new Float32BufferAttribute(geometry2.vertices.length * 3, 3);
      var colors3 = new Float32BufferAttribute(geometry2.colors.length * 3, 3);
      this.addAttribute("position", positions.copyVector3sArray(geometry2.vertices));
      this.addAttribute("color", colors3.copyColorsArray(geometry2.colors));
      if (geometry2.lineDistances && geometry2.lineDistances.length === geometry2.vertices.length) {
        var lineDistances = new Float32BufferAttribute(geometry2.lineDistances.length, 1);
        this.addAttribute("lineDistance", lineDistances.copyArray(geometry2.lineDistances));
      }
      if (geometry2.boundingSphere !== null) {
        this.boundingSphere = geometry2.boundingSphere.clone();
      }
      if (geometry2.boundingBox !== null) {
        this.boundingBox = geometry2.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry2 && geometry2.isGeometry) {
        this.fromGeometry(geometry2);
      }
    }
    return this;
  },
  setFromPoints: function(points) {
    var position = [];
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.addAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function(object) {
    var geometry2 = object.geometry;
    if (object.isMesh) {
      var direct = geometry2.__directGeometry;
      if (geometry2.elementsNeedUpdate === true) {
        direct = void 0;
        geometry2.elementsNeedUpdate = false;
      }
      if (direct === void 0) {
        return this.fromGeometry(geometry2);
      }
      direct.verticesNeedUpdate = geometry2.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry2.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry2.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry2.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry2.groupsNeedUpdate;
      geometry2.verticesNeedUpdate = false;
      geometry2.normalsNeedUpdate = false;
      geometry2.colorsNeedUpdate = false;
      geometry2.uvsNeedUpdate = false;
      geometry2.groupsNeedUpdate = false;
      geometry2 = direct;
    }
    var attribute;
    if (geometry2.verticesNeedUpdate === true) {
      attribute = this.attributes.position;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry2.vertices);
        attribute.needsUpdate = true;
      }
      geometry2.verticesNeedUpdate = false;
    }
    if (geometry2.normalsNeedUpdate === true) {
      attribute = this.attributes.normal;
      if (attribute !== void 0) {
        attribute.copyVector3sArray(geometry2.normals);
        attribute.needsUpdate = true;
      }
      geometry2.normalsNeedUpdate = false;
    }
    if (geometry2.colorsNeedUpdate === true) {
      attribute = this.attributes.color;
      if (attribute !== void 0) {
        attribute.copyColorsArray(geometry2.colors);
        attribute.needsUpdate = true;
      }
      geometry2.colorsNeedUpdate = false;
    }
    if (geometry2.uvsNeedUpdate) {
      attribute = this.attributes.uv;
      if (attribute !== void 0) {
        attribute.copyVector2sArray(geometry2.uvs);
        attribute.needsUpdate = true;
      }
      geometry2.uvsNeedUpdate = false;
    }
    if (geometry2.lineDistancesNeedUpdate) {
      attribute = this.attributes.lineDistance;
      if (attribute !== void 0) {
        attribute.copyArray(geometry2.lineDistances);
        attribute.needsUpdate = true;
      }
      geometry2.lineDistancesNeedUpdate = false;
    }
    if (geometry2.groupsNeedUpdate) {
      geometry2.computeGroups(object.geometry);
      this.groups = geometry2.groups;
      geometry2.groupsNeedUpdate = false;
    }
    return this;
  },
  fromGeometry: function(geometry2) {
    geometry2.__directGeometry = new DirectGeometry().fromGeometry(geometry2);
    return this.fromDirectGeometry(geometry2.__directGeometry);
  },
  fromDirectGeometry: function(geometry2) {
    var positions = new Float32Array(geometry2.vertices.length * 3);
    this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry2.vertices));
    if (geometry2.normals.length > 0) {
      var normals = new Float32Array(geometry2.normals.length * 3);
      this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry2.normals));
    }
    if (geometry2.colors.length > 0) {
      var colors3 = new Float32Array(geometry2.colors.length * 3);
      this.addAttribute("color", new BufferAttribute(colors3, 3).copyColorsArray(geometry2.colors));
    }
    if (geometry2.uvs.length > 0) {
      var uvs = new Float32Array(geometry2.uvs.length * 2);
      this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry2.uvs));
    }
    if (geometry2.uvs2.length > 0) {
      var uvs2 = new Float32Array(geometry2.uvs2.length * 2);
      this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry2.uvs2));
    }
    this.groups = geometry2.groups;
    for (var name in geometry2.morphTargets) {
      var array = [];
      var morphTargets = geometry2.morphTargets[name];
      for (var i = 0, l = morphTargets.length; i < l; i++) {
        var morphTarget = morphTargets[i];
        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }
      this.morphAttributes[name] = array;
    }
    if (geometry2.skinIndices.length > 0) {
      var skinIndices = new Float32BufferAttribute(geometry2.skinIndices.length * 4, 4);
      this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry2.skinIndices));
    }
    if (geometry2.skinWeights.length > 0) {
      var skinWeights = new Float32BufferAttribute(geometry2.skinWeights.length * 4, 4);
      this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry2.skinWeights));
    }
    if (geometry2.boundingSphere !== null) {
      this.boundingSphere = geometry2.boundingSphere.clone();
    }
    if (geometry2.boundingBox !== null) {
      this.boundingBox = geometry2.boundingBox.clone();
    }
    return this;
  },
  computeBoundingBox: function() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    var position = this.attributes.position;
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function() {
    var box = new Box3();
    var vector = new Vector3();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      var position = this.attributes.position;
      if (position) {
        var center = this.boundingSphere.center;
        box.setFromBufferAttribute(position);
        box.getCenter(center);
        var maxRadiusSq = 0;
        for (var i = 0, il = position.count; i < il; i++) {
          vector.x = position.getX(i);
          vector.y = position.getY(i);
          vector.z = position.getZ(i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    };
  }(),
  computeFaceNormals: function() {
  },
  computeVertexNormals: function() {
    var index = this.index;
    var attributes = this.attributes;
    if (attributes.position) {
      var positions = attributes.position.array;
      if (attributes.normal === void 0) {
        this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
      } else {
        var array = attributes.normal.array;
        for (var i = 0, il = array.length; i < il; i++) {
          array[i] = 0;
        }
      }
      var normals = attributes.normal.array;
      var vA, vB, vC;
      var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      var cb = new Vector3(), ab = new Vector3();
      if (index) {
        var indices = index.array;
        for (var i = 0, il = index.count; i < il; i += 3) {
          vA = indices[i + 0] * 3;
          vB = indices[i + 1] * 3;
          vC = indices[i + 2] * 3;
          pA.fromArray(positions, vA);
          pB.fromArray(positions, vB);
          pC.fromArray(positions, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[vA] += cb.x;
          normals[vA + 1] += cb.y;
          normals[vA + 2] += cb.z;
          normals[vB] += cb.x;
          normals[vB + 1] += cb.y;
          normals[vB + 2] += cb.z;
          normals[vC] += cb.x;
          normals[vC + 1] += cb.y;
          normals[vC + 2] += cb.z;
        }
      } else {
        for (var i = 0, il = positions.length; i < il; i += 9) {
          pA.fromArray(positions, i);
          pB.fromArray(positions, i + 3);
          pC.fromArray(positions, i + 6);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normals[i] = cb.x;
          normals[i + 1] = cb.y;
          normals[i + 2] = cb.z;
          normals[i + 3] = cb.x;
          normals[i + 4] = cb.y;
          normals[i + 5] = cb.z;
          normals[i + 6] = cb.x;
          normals[i + 7] = cb.y;
          normals[i + 8] = cb.z;
        }
      }
      this.normalizeNormals();
      attributes.normal.needsUpdate = true;
    }
  },
  merge: function(geometry2, offset) {
    if (!(geometry2 && geometry2.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry2);
      return;
    }
    if (offset === void 0) {
      offset = 0;
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      );
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      if (geometry2.attributes[key] === void 0) continue;
      var attribute1 = attributes[key];
      var attributeArray1 = attribute1.array;
      var attribute2 = geometry2.attributes[key];
      var attributeArray2 = attribute2.array;
      var attributeSize = attribute2.itemSize;
      for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }
    return this;
  },
  normalizeNormals: function() {
    var vector = new Vector3();
    return function normalizeNormals() {
      var normals = this.attributes.normal;
      for (var i = 0, il = normals.count; i < il; i++) {
        vector.x = normals.getX(i);
        vector.y = normals.getY(i);
        vector.z = normals.getZ(i);
        vector.normalize();
        normals.setXYZ(i, vector.x, vector.y, vector.z);
      }
    };
  }(),
  toNonIndexed: function() {
    function convertBufferAttribute(attribute2, indices2) {
      var array = attribute2.array;
      var itemSize = attribute2.itemSize;
      var array2 = new array.constructor(indices2.length * itemSize);
      var index = 0, index2 = 0;
      for (var i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        index = indices2[i2] * itemSize;
        for (var j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
      return this;
    }
    var geometry2 = new BufferGeometry();
    var indices = this.index.array;
    var attributes = this.attributes;
    for (var name in attributes) {
      var attribute = attributes[name];
      var newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.addAttribute(name, newAttribute);
    }
    var morphAttributes = this.morphAttributes;
    for (name in morphAttributes) {
      var morphArray = [];
      var morphAttribute = morphAttributes[name];
      for (var i = 0, il = morphAttribute.length; i < il; i++) {
        var attribute = morphAttribute[i];
        var newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    var groups = this.groups;
    for (var i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      var parameters = this.parameters;
      for (var key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    var index = this.index;
    if (index !== null) {
      var array = Array.prototype.slice.call(index.array);
      data.data.index = {
        type: index.array.constructor.name,
        array
      };
    }
    var attributes = this.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var array = Array.prototype.slice.call(attribute.array);
      data.data.attributes[key] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array,
        normalized: attribute.normalized
      };
    }
    var groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    var boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  },
  clone: function() {
    return new BufferGeometry().copy(this);
  },
  copy: function(source) {
    var name, i, l;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.name = source.name;
    var index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    var attributes = source.attributes;
    for (name in attributes) {
      var attribute = attributes[name];
      this.addAttribute(name, attribute.clone());
    }
    var morphAttributes = source.morphAttributes;
    for (name in morphAttributes) {
      var array = [];
      var morphAttribute = morphAttributes[name];
      for (i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone());
      }
      this.morphAttributes[name] = array;
    }
    var groups = source.groups;
    for (i = 0, l = groups.length; i < l; i++) {
      var group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    var boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    var boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  Geometry.call(this);
  this.type = "BoxGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
  this.mergeVertices();
}
BoxGeometry.prototype = Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor = BoxGeometry;
function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
  BufferGeometry.call(this);
  this.type = "BoxBufferGeometry";
  this.parameters = {
    width,
    height,
    depth,
    widthSegments,
    heightSegments,
    depthSegments
  };
  var scope = this;
  width = width || 1;
  height = height || 1;
  depth = depth || 1;
  widthSegments = Math.floor(widthSegments) || 1;
  heightSegments = Math.floor(heightSegments) || 1;
  depthSegments = Math.floor(depthSegments) || 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var numberOfVertices = 0;
  var groupStart = 0;
  buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
  buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
  buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
  buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
  buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
  buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
    var segmentWidth = width2 / gridX;
    var segmentHeight = height2 / gridY;
    var widthHalf = width2 / 2;
    var heightHalf = height2 / 2;
    var depthHalf = depth2 / 2;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var vertexCounter = 0;
    var groupCount = 0;
    var ix, iy;
    var vector = new Vector3();
    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segmentHeight - heightHalf;
      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segmentWidth - widthHalf;
        vector[u] = x * udir;
        vector[v] = y * vdir;
        vector[w] = depthHalf;
        vertices.push(vector.x, vector.y, vector.z);
        vector[u] = 0;
        vector[v] = 0;
        vector[w] = depth2 > 0 ? 1 : -1;
        normals.push(vector.x, vector.y, vector.z);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
        vertexCounter += 1;
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = numberOfVertices + ix + gridX1 * iy;
        var b = numberOfVertices + ix + gridX1 * (iy + 1);
        var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
        var d = numberOfVertices + (ix + 1) + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, materialIndex);
    groupStart += groupCount;
    numberOfVertices += vertexCounter;
  }
}
BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = "PlaneGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}
PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry;
function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = "PlaneBufferGeometry";
  this.parameters = {
    width,
    height,
    widthSegments,
    heightSegments
  };
  width = width || 1;
  height = height || 1;
  var width_half = width / 2;
  var height_half = height / 2;
  var gridX = Math.floor(widthSegments) || 1;
  var gridY = Math.floor(heightSegments) || 1;
  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;
  var segment_width = width / gridX;
  var segment_height = height / gridY;
  var ix, iy;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy < gridY1; iy++) {
    var y = iy * segment_height - height_half;
    for (ix = 0; ix < gridX1; ix++) {
      var x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  }
  for (iy = 0; iy < gridY; iy++) {
    for (ix = 0; ix < gridX; ix++) {
      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * (iy + 1);
      var c = ix + 1 + gridX1 * (iy + 1);
      var d = ix + 1 + gridX1 * iy;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
var materialId = 0;
function Material() {
  Object.defineProperty(this, "id", { value: materialId++ });
  this.uuid = _Math.generateUUID();
  this.name = "";
  this.type = "Material";
  this.fog = true;
  this.lights = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexColors = NoColors;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null;
  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.userData = {};
  this.needsUpdate = true;
}
Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function() {
  },
  setValues: function(values) {
    if (values === void 0) return;
    for (var key in values) {
      var newValue = values[key];
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      }
      if (key === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }
      var currentValue = this[key];
      if (currentValue === void 0) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function(meta) {
    var isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }
    var data = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearCoat !== void 0) data.clearCoat = this.clearCoat;
    if (this.clearCoatRoughness !== void 0) data.clearCoatRoughness = this.clearCoatRoughness;
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity;
      if (this.combine !== void 0) data.combine = this.combine;
      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    }
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.size !== void 0) data.size = this.size;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    if (this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;
    function extractFromCache(cache) {
      var values = [];
      for (var key in cache) {
        var data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      var textures = extractFromCache(meta.textures);
      var images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.name = source.name;
    this.fog = source.fog;
    this.lights = source.lights;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.clipShadows = source.clipShadows;
    this.clipIntersection = source.clipIntersection;
    var srcPlanes = source.clippingPlanes, dstPlanes = null;
    if (srcPlanes !== null) {
      var n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (var i = 0; i !== n; ++i)
        dstPlanes[i] = srcPlanes[i].clone();
    }
    this.clippingPlanes = dstPlanes;
    this.shadowSide = source.shadowSide;
    return this;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.clipping = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false
    // set to use shader texture LOD
  };
  this.defaultAttributeValues = {
    "color": [1, 1, 1],
    "uv": [0, 0],
    "uv2": [0, 0]
  };
  this.index0AttributeName = void 0;
  this.uniformsNeedUpdate = false;
  if (parameters !== void 0) {
    if (parameters.attributes !== void 0) {
      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
    }
    this.setValues(parameters);
  }
}
ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;
ShaderMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = source.extensions;
  return this;
};
ShaderMaterial.prototype.toJSON = function(meta) {
  var data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = {};
  for (var name in this.uniforms) {
    var uniform = this.uniforms[name];
    var value = uniform.value;
    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: "t",
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: "c",
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: "v2",
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: "v3",
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: "v4",
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: "m3",
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: "m4",
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value
      };
    }
  }
  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  var extensions = {};
  for (var key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }
  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};
function Ray(origin, direction) {
  this.origin = origin !== void 0 ? origin : new Vector3();
  this.direction = direction !== void 0 ? direction : new Vector3();
}
Object.assign(Ray.prototype, {
  set: function(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function(t, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .at() target is now required");
      target = new Vector3();
    }
    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function() {
    var v1 = new Vector3();
    return function recast(t) {
      this.origin.copy(this.at(t, v1));
      return this;
    };
  }(),
  closestPointToPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    target.subVectors(point, this.origin);
    var directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function() {
    var v1 = new Vector3();
    return function distanceSqToPoint(point) {
      var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return v1.distanceToSquared(point);
    };
  }(),
  distanceSqToSegment: function() {
    var segCenter = new Vector3();
    var segDir = new Vector3();
    var diff = new Vector3();
    return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      segDir.copy(v1).sub(v0).normalize();
      diff.copy(this.origin).sub(segCenter);
      var segExtent = v0.distanceTo(v1) * 0.5;
      var a01 = -this.direction.dot(segDir);
      var b0 = diff.dot(this.direction);
      var b1 = -diff.dot(segDir);
      var c = diff.lengthSq();
      var det = Math.abs(1 - a01 * a01);
      var s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
      }
      return sqrDist;
    };
  }(),
  intersectSphere: function() {
    var v1 = new Vector3();
    return function intersectSphere(sphere, target) {
      v1.subVectors(sphere.center, this.origin);
      var tca = v1.dot(this.direction);
      var d2 = v1.dot(v1) - tca * tca;
      var radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2) return null;
      var thc = Math.sqrt(radius2 - d2);
      var t0 = tca - thc;
      var t1 = tca + thc;
      if (t0 < 0 && t1 < 0) return null;
      if (t0 < 0) return this.at(t1, target);
      return this.at(t0, target);
    };
  }(),
  intersectsSphere: function(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function(plane) {
    var denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  },
  intersectPlane: function(plane, target) {
    var t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  },
  intersectsPlane: function(plane) {
    var distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    var denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  },
  intersectBox: function(box, target) {
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    var origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function() {
    var v = new Vector3();
    return function intersectsBox(box) {
      return this.intersectBox(box, v) !== null;
    };
  }(),
  intersectTriangle: function() {
    var diff = new Vector3();
    var edge1 = new Vector3();
    var edge2 = new Vector3();
    var normal = new Vector3();
    return function intersectTriangle(a, b, c, backfaceCulling, target) {
      edge1.subVectors(b, a);
      edge2.subVectors(c, a);
      normal.crossVectors(edge1, edge2);
      var DdN = this.direction.dot(normal);
      var sign2;
      if (DdN > 0) {
        if (backfaceCulling) return null;
        sign2 = 1;
      } else if (DdN < 0) {
        sign2 = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      diff.subVectors(this.origin, a);
      var DdQxE2 = sign2 * this.direction.dot(edge2.crossVectors(diff, edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      var DdE1xQ = sign2 * this.direction.dot(edge1.cross(diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      var QdN = -sign2 * diff.dot(normal);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    };
  }(),
  applyMatrix4: function(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
function Triangle(a, b, c) {
  this.a = a !== void 0 ? a : new Vector3();
  this.b = b !== void 0 ? b : new Vector3();
  this.c = c !== void 0 ? c : new Vector3();
}
Object.assign(Triangle, {
  getNormal: function() {
    var v0 = new Vector3();
    return function getNormal(a, b, c, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getNormal() target is now required");
        target = new Vector3();
      }
      target.subVectors(c, b);
      v0.subVectors(a, b);
      target.cross(v0);
      var targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    };
  }(),
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function getBarycoord(point, a, b, c, target) {
      v0.subVectors(c, a);
      v1.subVectors(b, a);
      v2.subVectors(point, a);
      var dot00 = v0.dot(v0);
      var dot01 = v0.dot(v1);
      var dot02 = v0.dot(v2);
      var dot11 = v1.dot(v1);
      var dot12 = v1.dot(v2);
      var denom = dot00 * dot11 - dot01 * dot01;
      if (target === void 0) {
        console.warn("THREE.Triangle: .getBarycoord() target is now required");
        target = new Vector3();
      }
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      var invDenom = 1 / denom;
      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
      var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u - v, v, u);
    };
  }(),
  containsPoint: function() {
    var v1 = new Vector3();
    return function containsPoint(point, a, b, c) {
      Triangle.getBarycoord(point, a, b, c, v1);
      return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
    };
  }(),
  getUV: function() {
    var barycoord = new Vector3();
    return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, barycoord);
      target.set(0, 0);
      target.addScaledVector(uv1, barycoord.x);
      target.addScaledVector(uv2, barycoord.y);
      target.addScaledVector(uv3, barycoord.z);
      return target;
    };
  }()
});
Object.assign(Triangle.prototype, {
  set: function(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function() {
    var v0 = new Vector3();
    var v1 = new Vector3();
    return function getArea() {
      v0.subVectors(this.c, this.b);
      v1.subVectors(this.a, this.b);
      return v0.cross(v1).length() * 0.5;
    };
  }(),
  getMidpoint: function(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getMidpoint() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function(target) {
    if (target === void 0) {
      console.warn("THREE.Triangle: .getPlane() target is now required");
      target = new Vector3();
    }
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  containsPoint: function(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  getUV: function(point, uv1, uv2, uv3, result) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
  },
  intersectsBox: function(box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function() {
    var vab = new Vector3();
    var vac = new Vector3();
    var vbc = new Vector3();
    var vap = new Vector3();
    var vbp = new Vector3();
    var vcp = new Vector3();
    return function closestPointToPoint(p, target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      var a = this.a, b = this.b, c = this.c;
      var v, w;
      vab.subVectors(b, a);
      vac.subVectors(c, a);
      vap.subVectors(p, a);
      var d1 = vab.dot(vap);
      var d2 = vac.dot(vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a);
      }
      vbp.subVectors(p, b);
      var d3 = vab.dot(vbp);
      var d4 = vac.dot(vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b);
      }
      var vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v = d1 / (d1 - d3);
        return target.copy(a).addScaledVector(vab, v);
      }
      vcp.subVectors(p, c);
      var d5 = vab.dot(vcp);
      var d6 = vac.dot(vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c);
      }
      var vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w = d2 / (d2 - d6);
        return target.copy(a).addScaledVector(vac, w);
      }
      var va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        vbc.subVectors(c, b);
        w = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b).addScaledVector(vbc, w);
      }
      var denom = 1 / (va + vb + vc);
      v = vb * denom;
      w = vc * denom;
      return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
    };
  }(),
  equals: function(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = "MeshBasicMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
function Mesh(geometry2, material) {
  Object3D.call(this);
  this.type = "Mesh";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new MeshBasicMaterial({ color: Math.random() * 16777215 });
  this.drawMode = TrianglesDrawMode;
  this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  setDrawMode: function(value) {
    this.drawMode = value;
  },
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.drawMode = source.drawMode;
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    return this;
  },
  updateMorphTargets: function() {
    var geometry2 = this.geometry;
    var m, ml, name;
    if (geometry2.isBufferGeometry) {
      var morphAttributes = geometry2.morphAttributes;
      var keys = Object.keys(morphAttributes);
      if (keys.length > 0) {
        var morphAttribute = morphAttributes[keys[0]];
        if (morphAttribute !== void 0) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};
          for (m = 0, ml = morphAttribute.length; m < ml; m++) {
            name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      var morphTargets = geometry2.morphTargets;
      if (morphTargets !== void 0 && morphTargets.length > 0) {
        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  },
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var tempA = new Vector3();
    var tempB = new Vector3();
    var tempC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    var intersectionPoint = new Vector3();
    var intersectionPointWorld = new Vector3();
    function checkIntersection(object, material, raycaster, ray2, pA, pB, pC, point) {
      var intersect;
      if (material.side === BackSide) {
        intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
      } else {
        intersect = ray2.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
      }
      if (intersect === null) return null;
      intersectionPointWorld.copy(point);
      intersectionPointWorld.applyMatrix4(object.matrixWorld);
      var distance2 = raycaster.ray.origin.distanceTo(intersectionPointWorld);
      if (distance2 < raycaster.near || distance2 > raycaster.far) return null;
      return {
        distance: distance2,
        point: intersectionPointWorld.clone(),
        object
      };
    }
    function checkBufferGeometryIntersection(object, material, raycaster, ray2, position, uv, a, b, c) {
      vA.fromBufferAttribute(position, a);
      vB.fromBufferAttribute(position, b);
      vC.fromBufferAttribute(position, c);
      var intersection = checkIntersection(object, material, raycaster, ray2, vA, vB, vC, intersectionPoint);
      if (intersection) {
        if (uv) {
          uvA.fromBufferAttribute(uv, a);
          uvB.fromBufferAttribute(uv, b);
          uvC.fromBufferAttribute(uv, c);
          intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
        }
        var face = new Face3(a, b, c);
        Triangle.getNormal(vA, vB, vC, face.normal);
        intersection.face = face;
      }
      return intersection;
    }
    return function raycast(raycaster, intersects2) {
      var geometry2 = this.geometry;
      var material = this.material;
      var matrixWorld = this.matrixWorld;
      if (material === void 0) return;
      if (geometry2.boundingSphere === null) geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(sphere) === false) return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      if (geometry2.boundingBox !== null) {
        if (ray.intersectsBox(geometry2.boundingBox) === false) return;
      }
      var intersection;
      if (geometry2.isBufferGeometry) {
        var a, b, c;
        var index = geometry2.index;
        var position = geometry2.attributes.position;
        var uv = geometry2.attributes.uv;
        var groups = geometry2.groups;
        var drawRange = geometry2.drawRange;
        var i, j, il, jl;
        var group, groupMaterial;
        var start2, end;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start2 = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (j = start2, jl = end; j < jl; j += 3) {
                a = index.getX(j);
                b = index.getX(j + 1);
                c = index.getX(j + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            start2 = Math.max(0, drawRange.start);
            end = Math.min(index.count, drawRange.start + drawRange.count);
            for (i = start2, il = end; i < il; i += 3) {
              a = index.getX(i);
              b = index.getX(i + 1);
              c = index.getX(i + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (i = 0, il = groups.length; i < il; i++) {
              group = groups[i];
              groupMaterial = material[group.materialIndex];
              start2 = Math.max(group.start, drawRange.start);
              end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
              for (j = start2, jl = end; j < jl; j += 3) {
                a = j;
                b = j + 1;
                c = j + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            start2 = Math.max(0, drawRange.start);
            end = Math.min(position.count, drawRange.start + drawRange.count);
            for (i = start2, il = end; i < il; i += 3) {
              a = i;
              b = i + 1;
              c = i + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);
              if (intersection) {
                intersection.faceIndex = Math.floor(i / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry2.isGeometry) {
        var fvA, fvB, fvC;
        var isMultiMaterial = Array.isArray(material);
        var vertices = geometry2.vertices;
        var faces = geometry2.faces;
        var uvs;
        var faceVertexUvs = geometry2.faceVertexUvs[0];
        if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
        for (var f = 0, fl = faces.length; f < fl; f++) {
          var face = faces[f];
          var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
          if (faceMaterial === void 0) continue;
          fvA = vertices[face.a];
          fvB = vertices[face.b];
          fvC = vertices[face.c];
          if (faceMaterial.morphTargets === true) {
            var morphTargets = geometry2.morphTargets;
            var morphInfluences = this.morphTargetInfluences;
            vA.set(0, 0, 0);
            vB.set(0, 0, 0);
            vC.set(0, 0, 0);
            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
              var influence = morphInfluences[t];
              if (influence === 0) continue;
              var targets = morphTargets[t].vertices;
              vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
              vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
              vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
            }
            vA.add(fvA);
            vB.add(fvB);
            vC.add(fvC);
            fvA = vA;
            fvB = vB;
            fvC = vC;
          }
          intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
          if (intersection) {
            if (uvs && uvs[f]) {
              var uvs_f = uvs[f];
              uvA.copy(uvs_f[0]);
              uvB.copy(uvs_f[1]);
              uvC.copy(uvs_f[2]);
              intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
            }
            intersection.face = face;
            intersection.faceIndex = f;
            intersects2.push(intersection);
          }
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  var clearColor = new Color(0);
  var clearAlpha = 0;
  var planeMesh;
  var boxMesh;
  var currentBackground = null;
  var currentBackgroundVersion = 0;
  function render(renderList, scene, camera, forceClear) {
    var background = scene.background;
    if (background === null) {
      setClear(clearColor, clearAlpha);
      currentBackground = null;
      currentBackgroundVersion = 0;
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
      currentBackground = null;
      currentBackgroundVersion = 0;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxBufferGeometry(1, 1, 1),
          new ShaderMaterial({
            type: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: true,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.removeAttribute("normal");
        boxMesh.geometry.removeAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {
          this.matrixWorld.copyPosition(camera2.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "map", {
          get: function() {
            return this.uniforms.tCube.value;
          }
        });
        objects.update(boxMesh);
      }
      var texture = background.isWebGLRenderTargetCube ? background.texture : background;
      boxMesh.material.uniforms.tCube.value = texture;
      boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;
      if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneBufferGeometry(2, 2),
          new ShaderMaterial({
            type: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.removeAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha2) {
    state.buffers.color.setClear(color2.r, color2.g, color2.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha2) {
      clearColor.set(color2);
      clearAlpha = alpha2 !== void 0 ? alpha2 : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  function render(start2, count2) {
    gl.drawArrays(mode, start2, count2);
    info.update(count2, mode);
  }
  function renderInstances(geometry2, start2, count2) {
    var extension;
    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[capabilities.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](mode, start2, count2, geometry2.maxInstancedCount);
    info.update(count2, mode, geometry2.maxInstancedCount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  var maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    var extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
  var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  var maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  var vertexTextures = maxVertexTextures > 0;
  var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
  var floatVertexTextures = vertexTextures && floatFragmentTextures;
  var maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping() {
  var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
      for (var i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    return dstArray;
  }
}
function WebGLExtensions(gl) {
  var extensions = {};
  return {
    get: function(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      var extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      extensions[name] = extension;
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info) {
  var geometries = {};
  var wireframeAttributes = {};
  function onGeometryDispose(event) {
    var geometry2 = event.target;
    var buffergeometry = geometries[geometry2.id];
    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }
    for (var name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }
    geometry2.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry2.id];
    var attribute = wireframeAttributes[buffergeometry.id];
    if (attribute) {
      attributes.remove(attribute);
      delete wireframeAttributes[buffergeometry.id];
    }
    info.memory.geometries--;
  }
  function get(object, geometry2) {
    var buffergeometry = geometries[geometry2.id];
    if (buffergeometry) return buffergeometry;
    geometry2.addEventListener("dispose", onGeometryDispose);
    if (geometry2.isBufferGeometry) {
      buffergeometry = geometry2;
    } else if (geometry2.isGeometry) {
      if (geometry2._bufferGeometry === void 0) {
        geometry2._bufferGeometry = new BufferGeometry().setFromObject(object);
      }
      buffergeometry = geometry2._bufferGeometry;
    }
    geometries[geometry2.id] = buffergeometry;
    info.memory.geometries++;
    return buffergeometry;
  }
  function update2(geometry2) {
    var index = geometry2.index;
    var geometryAttributes = geometry2.attributes;
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    for (var name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    var morphAttributes = geometry2.morphAttributes;
    for (var name in morphAttributes) {
      var array = morphAttributes[name];
      for (var i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function getWireframeAttribute(geometry2) {
    var attribute = wireframeAttributes[geometry2.id];
    if (attribute) return attribute;
    var indices = [];
    var geometryIndex = geometry2.index;
    var geometryAttributes = geometry2.attributes;
    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var array = geometryAttributes.position.array;
      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        var a = i + 0;
        var b = i + 1;
        var c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }
    attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
    wireframeAttributes[geometry2.id] = attribute;
    return attribute;
  }
  return {
    get,
    update: update2,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  var mode;
  function setMode(value) {
    mode = value;
  }
  var type, bytesPerElement2;
  function setIndex(value) {
    type = value.type;
    bytesPerElement2 = value.bytesPerElement;
  }
  function render(start2, count2) {
    gl.drawElements(mode, count2, type, start2 * bytesPerElement2);
    info.update(count2, mode);
  }
  function renderInstances(geometry2, start2, count2) {
    var extension;
    if (capabilities.isWebGL2) {
      extension = gl;
    } else {
      var extension = extensions.get("ANGLE_instanced_arrays");
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[capabilities.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](mode, count2, type, start2 * bytesPerElement2, geometry2.maxInstancedCount);
    info.update(count2, mode, geometry2.maxInstancedCount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  var memory2 = {
    geometries: 0,
    textures: 0
  };
  var render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update2(count2, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count2 / 3);
        break;
      case gl.TRIANGLE_STRIP:
      case gl.TRIANGLE_FAN:
        render.triangles += instanceCount * (count2 - 2);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count2 / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count2 - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count2;
        break;
      case gl.POINTS:
        render.points += instanceCount * count2;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory: memory2,
    render,
    programs: null,
    autoReset: true,
    reset,
    update: update2
  };
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl) {
  var influencesList = {};
  var morphInfluences = new Float32Array(8);
  function update2(object, geometry2, material, program) {
    var objectInfluences = object.morphTargetInfluences;
    var length = objectInfluences.length;
    var influences = influencesList[geometry2.id];
    if (influences === void 0) {
      influences = [];
      for (var i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }
      influencesList[geometry2.id] = influences;
    }
    var morphTargets = material.morphTargets && geometry2.morphAttributes.position;
    var morphNormals = material.morphNormals && geometry2.morphAttributes.normal;
    for (var i = 0; i < length; i++) {
      var influence = influences[i];
      if (influence[1] !== 0) {
        if (morphTargets) geometry2.removeAttribute("morphTarget" + i);
        if (morphNormals) geometry2.removeAttribute("morphNormal" + i);
      }
    }
    for (var i = 0; i < length; i++) {
      var influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }
    influences.sort(absNumericalSort);
    for (var i = 0; i < 8; i++) {
      var influence = influences[i];
      if (influence) {
        var index = influence[0];
        var value = influence[1];
        if (value) {
          if (morphTargets) geometry2.addAttribute("morphTarget" + i, morphTargets[index]);
          if (morphNormals) geometry2.addAttribute("morphNormal" + i, morphNormals[index]);
          morphInfluences[i] = value;
          continue;
        }
      }
      morphInfluences[i] = 0;
    }
    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
  }
  return {
    update: update2
  };
}
function WebGLObjects(geometries, info) {
  var updateList = {};
  function update2(object) {
    var frame2 = info.render.frame;
    var geometry2 = object.geometry;
    var buffergeometry = geometries.get(object, geometry2);
    if (updateList[buffergeometry.id] !== frame2) {
      if (geometry2.isGeometry) {
        buffergeometry.updateFromObject(object);
      }
      geometries.update(buffergeometry);
      updateList[buffergeometry.id] = frame2;
    }
    return buffergeometry;
  }
  function dispose2() {
    updateList = {};
  }
  return {
    update: update2,
    dispose: dispose2
  };
}
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== void 0 ? images : [];
  mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, "images", {
  get: function() {
    return this.image;
  },
  set: function(value) {
    this.image = value;
  }
});
function DataTexture3D(data, width, height, depth) {
  Texture.call(this, null);
  this.image = { data, width, height, depth };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
}
DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
var emptyTexture = new Texture();
var emptyTexture3d = new DataTexture3D();
var emptyCubeTexture = new CubeTexture();
function UniformContainer() {
  this.seq = [];
  this.map = {};
}
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  var firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  var n = nBlocks * blockSize, r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (var i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (var i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(renderer, n) {
  var r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (var i = 0; i !== n; ++i)
    r[i] = renderer.allocTextureUnit();
  return r;
}
function setValue1f(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValue1i(gl, v) {
  var cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValue2fv(gl, v) {
  var cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValue3fv(gl, v) {
  var cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValue4fv(gl, v) {
  var cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValue2fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValue3fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValue4fm(gl, v) {
  var cache = this.cache;
  var elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueT1(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  renderer.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  renderer.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, renderer) {
  var cache = this.cache;
  var unit = renderer.allocTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  renderer.setTextureCube(v || emptyCubeTexture, unit);
}
function setValue2iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValue3iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValue4iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValue1f;
    // FLOAT
    case 35664:
      return setValue2fv;
    // _VEC2
    case 35665:
      return setValue3fv;
    // _VEC3
    case 35666:
      return setValue4fv;
    // _VEC4
    case 35674:
      return setValue2fm;
    // _MAT2
    case 35675:
      return setValue3fm;
    // _MAT3
    case 35676:
      return setValue4fm;
    // _MAT4
    case 35678:
    case 36198:
      return setValueT1;
    // SAMPLER_2D, SAMPLER_EXTERNAL_OES
    case 35679:
      return setValueT3D1;
    // SAMPLER_3D
    case 35680:
      return setValueT6;
    // SAMPLER_CUBE
    case 5124:
    case 35670:
      return setValue1i;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValue2iv;
    // _VEC2
    case 35668:
    case 35672:
      return setValue3iv;
    // _VEC3
    case 35669:
    case 35673:
      return setValue4iv;
  }
}
function setValue1fv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1fv(this.addr, v);
  copyArray(cache, v);
}
function setValue1iv(gl, v) {
  var cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform1iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 2);
  if (arraysEqual(cache, data)) return;
  gl.uniform2fv(this.addr, data);
  this.updateCache(data);
}
function setValueV3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 3);
  if (arraysEqual(cache, data)) return;
  gl.uniform3fv(this.addr, data);
  this.updateCache(data);
}
function setValueV4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniform4fv(this.addr, data);
  this.updateCache(data);
}
function setValueM2a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 4);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix2fv(this.addr, false, data);
  this.updateCache(data);
}
function setValueM3a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 9);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix3fv(this.addr, false, data);
  this.updateCache(data);
}
function setValueM4a(gl, v) {
  var cache = this.cache;
  var data = flatten(v, this.size, 16);
  if (arraysEqual(cache, data)) return;
  gl.uniformMatrix4fv(this.addr, false, data);
  this.updateCache(data);
}
function setValueT1a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);
  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    renderer.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT6a(gl, v, renderer) {
  var cache = this.cache;
  var n = v.length;
  var units = allocTexUnits(renderer, n);
  if (arraysEqual(cache, units) === false) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (var i = 0; i !== n; ++i) {
    renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValue1fv;
    // FLOAT
    case 35664:
      return setValueV2a;
    // _VEC2
    case 35665:
      return setValueV3a;
    // _VEC3
    case 35666:
      return setValueV4a;
    // _VEC4
    case 35674:
      return setValueM2a;
    // _MAT2
    case 35675:
      return setValueM3a;
    // _MAT3
    case 35676:
      return setValueM4a;
    // _MAT4
    case 35678:
      return setValueT1a;
    // SAMPLER_2D
    case 35680:
      return setValueT6a;
    // SAMPLER_CUBE
    case 5124:
    case 35670:
      return setValue1iv;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValue2iv;
    // _VEC2
    case 35668:
    case 35672:
      return setValue3iv;
    // _VEC3
    case 35669:
    case 35673:
      return setValue4iv;
  }
}
function SingleUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id2, activeInfo, addr) {
  this.id = id2;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
  var cache = this.cache;
  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }
  copyArray(cache, data);
};
function StructuredUniform(id2) {
  this.id = id2;
  UniformContainer.call(this);
}
StructuredUniform.prototype.setValue = function(gl, value, renderer) {
  var seq = this.seq;
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    u.setValue(gl, value[u.id], renderer);
  }
};
var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  var path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id2 = match[1], idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      var map = container.map, next = map[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program, renderer) {
  UniformContainer.call(this);
  this.renderer = renderer;
  var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (var i = 0; i < n; ++i) {
    var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
WebGLUniforms.prototype.setValue = function(gl, name, value) {
  var u = this.map[name];
  if (u !== void 0) u.setValue(gl, value, this.renderer);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
  var v = object[name];
  if (v !== void 0) this.setValue(gl, name, v);
};
WebGLUniforms.upload = function(gl, seq, values, renderer) {
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i], v = values[u.id];
    if (v.needsUpdate !== false) {
      u.setValue(gl, v.value, renderer);
    }
  }
};
WebGLUniforms.seqWithValue = function(seq, values) {
  var r = [];
  for (var i = 0, n = seq.length; i !== n; ++i) {
    var u = seq[i];
    if (u.id in values) r.push(u);
  }
  return r;
};
function addLineNumbers(string2) {
  var lines = string2.split("\n");
  for (var i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function WebGLShader(gl, type, string2) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, string2);
  gl.compileShader(shader);
  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
    console.error("THREE.WebGLShader: Shader couldn't compile.");
  }
  if (gl.getShaderInfoLog(shader) !== "") {
    console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === gl.VERTEX_SHADER ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string2));
  }
  return shader;
}
var programIdCount = 0;
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    case RGBEEncoding:
      return ["RGBE", "( value )"];
    case RGBM7Encoding:
      return ["RGBM", "( value, 7.0 )"];
    case RGBM16Encoding:
      return ["RGBM", "( value, 16.0 )"];
    case RGBDEncoding:
      return ["RGBD", "( value, 256.0 )"];
    case GammaEncoding:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    default:
      throw new Error("unsupported encoding: " + encoding);
  }
}
function getTexelDecodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
}
function getTexelEncodingFunction(functionName, encoding) {
  var components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  var toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case Uncharted2ToneMapping:
      toneMappingName = "Uncharted2";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    default:
      throw new Error("unsupported toneMapping: " + toneMapping);
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(extensions, parameters, rendererExtensions) {
  extensions = extensions || {};
  var chunks = [
    extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
    (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
    extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
    (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  var chunks = [];
  for (var name in defines) {
    var value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  var attributes = {};
  var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (var i = 0; i < n; i++) {
    var info = gl.getActiveAttrib(program, i);
    var name = info.name;
    attributes[name] = gl.getAttribLocation(program, name);
  }
  return attributes;
}
function filterEmptyLine(string2) {
  return string2 !== "";
}
function replaceLightNums(string2, parameters) {
  return string2.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
}
function replaceClippingPlaneNums(string2, parameters) {
  return string2.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function parseIncludes(string2) {
  var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function replace(match, include) {
    var replace2 = ShaderChunk[include];
    if (replace2 === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return parseIncludes(replace2);
  }
  return string2.replace(pattern, replace);
}
function unrollLoops(string2) {
  var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  function replace(match, start2, end, snippet) {
    var unroll = "";
    for (var i = parseInt(start2); i < parseInt(end); i++) {
      unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
    }
    return unroll;
  }
  return string2.replace(pattern, replace);
}
function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
  var gl = renderer.context;
  var defines = material.defines;
  var vertexShader = shader.vertexShader;
  var fragmentShader = shader.fragmentShader;
  var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  }
  var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
  if (parameters.envMap) {
    switch (material.envMap.mapping) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
        break;
      case SphericalReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
        break;
    }
    switch (material.envMap.mapping) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
    switch (material.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
  var customExtensions = capabilities.isWebGL2 ? "" : generateExtensions(material.extensions, parameters, extensions);
  var customDefines = generateDefines(defines);
  var program = gl.createProgram();
  var prefixVertex, prefixFragment;
  if (material.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      "precision " + parameters.precision + " float;",
      "precision " + parameters.precision + " int;",
      "#define SHADER_NAME " + shader.name,
      customDefines,
      parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
      // add '.0' if integer
      "#define GAMMA_FACTOR " + gammaFactorDefine,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
      parameters.envMap && (capabilities.isWebGL2 || extensions.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
      // this code is required here because it is used by the various encoding/decoding function defined below
      parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
      parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
      parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
      parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
      parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
      parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = parseIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = parseIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
    var isGLSL3ShaderMaterial = false;
    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
    if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, "");
      fragmentShader = fragmentShader.replace(versionRegex, "");
    }
    prefixVertex = [
      "#version 300 es\n",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#version 300 es\n",
      "#define varying in",
      isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;",
      isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  var vertexGlsl = prefixVertex + vertexShader;
  var fragmentGlsl = prefixFragment + fragmentShader;
  var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (material.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, material.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  var programLog = gl.getProgramInfoLog(program).trim();
  var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
  var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
  var runnable = true;
  var haveDiagnostics = true;
  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    runnable = false;
    console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "gl.VALIDATE_STATUS", gl.getProgramParameter(program, gl.VALIDATE_STATUS), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
  } else if (programLog !== "") {
    console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
  } else if (vertexLog === "" || fragmentLog === "") {
    haveDiagnostics = false;
  }
  if (haveDiagnostics) {
    this.diagnostics = {
      runnable,
      material,
      programLog,
      vertexShader: {
        log: vertexLog,
        prefix: prefixVertex
      },
      fragmentShader: {
        log: fragmentLog,
        prefix: prefixFragment
      }
    };
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  var cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program, renderer);
    }
    return cachedUniforms;
  };
  var cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    gl.deleteProgram(program);
    this.program = void 0;
  };
  Object.defineProperties(this, {
    uniforms: {
      get: function() {
        console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
        return this.getUniforms();
      }
    },
    attributes: {
      get: function() {
        console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
        return this.getAttributes();
      }
    }
  });
  this.name = shader.name;
  this.id = programIdCount++;
  this.code = code;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, extensions, capabilities) {
  var programs = [];
  var shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "phong",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  var parameterNames = [
    "precision",
    "supportsVertexTextures",
    "map",
    "mapEncoding",
    "matcap",
    "matcapEncoding",
    "envMap",
    "envMapMode",
    "envMapEncoding",
    "lightMap",
    "aoMap",
    "emissiveMap",
    "emissiveMapEncoding",
    "bumpMap",
    "normalMap",
    "objectSpaceNormalMap",
    "displacementMap",
    "specularMap",
    "roughnessMap",
    "metalnessMap",
    "gradientMap",
    "alphaMap",
    "combine",
    "vertexColors",
    "fog",
    "useFog",
    "fogExp",
    "flatShading",
    "sizeAttenuation",
    "logarithmicDepthBuffer",
    "skinning",
    "maxBones",
    "useVertexTexture",
    "morphTargets",
    "morphNormals",
    "maxMorphTargets",
    "maxMorphNormals",
    "premultipliedAlpha",
    "numDirLights",
    "numPointLights",
    "numSpotLights",
    "numHemiLights",
    "numRectAreaLights",
    "shadowMapEnabled",
    "shadowMapType",
    "toneMapping",
    "physicallyCorrectLights",
    "alphaTest",
    "doubleSided",
    "flipSided",
    "numClippingPlanes",
    "numClipIntersection",
    "depthPacking",
    "dithering"
  ];
  function allocateBones(object) {
    var skeleton = object.skeleton;
    var bones = skeleton.bones;
    if (capabilities.floatVertexTextures) {
      return 1024;
    } else {
      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      var maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getTextureEncodingFromMap(map, gammaOverrideLinear) {
    var encoding;
    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }
    if (encoding === LinearEncoding && gammaOverrideLinear) {
      encoding = GammaEncoding;
    }
    return encoding;
  }
  this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
    var shaderID = shaderIDs[material.type];
    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
    var precision = capabilities.precision;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    var currentRenderTarget = renderer.getRenderTarget();
    var parameters = {
      shaderID,
      precision,
      supportsVertexTextures: capabilities.vertexTextures,
      outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
      envMap: !!material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
      envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      combine: material.combine,
      vertexColors: material.vertexColors,
      fog: !!fog,
      useFog: material.fog,
      fogExp: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones,
      useVertexTexture: capabilities.floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: renderer.toneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false
    };
    return parameters;
  };
  this.getProgramCode = function(material, parameters) {
    var array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(material.fragmentShader);
      array.push(material.vertexShader);
    }
    if (material.defines !== void 0) {
      for (var name in material.defines) {
        array.push(name);
        array.push(material.defines[name]);
      }
    }
    for (var i = 0; i < parameterNames.length; i++) {
      array.push(parameters[parameterNames[i]]);
    }
    array.push(material.onBeforeCompile.toString());
    array.push(renderer.gammaOutput);
    array.push(renderer.gammaFactor);
    return array.join();
  };
  this.acquireProgram = function(material, shader, parameters, code) {
    var program;
    for (var p = 0, pl = programs.length; p < pl; p++) {
      var programInfo = programs[p];
      if (programInfo.code === code) {
        program = programInfo;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);
      programs.push(program);
    }
    return program;
  };
  this.releaseProgram = function(program) {
    if (--program.usedTimes === 0) {
      var i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  };
  this.programs = programs;
}
function WebGLProperties() {
  var properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    var map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update2(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose2() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update: update2,
    dispose: dispose2
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program && b.program && a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  }
  if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  var renderItems = [];
  var renderItemsIndex = 0;
  var opaque = [];
  var transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry2, material, groupOrder, z, group) {
    var renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry: geometry2,
        material,
        program: material.program,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry2;
      renderItem.material = material;
      renderItem.program = material.program;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry2, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }
  function unshift(object, geometry2, material, groupOrder, z, group) {
    var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }
  function sort() {
    if (opaque.length > 1) opaque.sort(painterSortStable);
    if (transparent.length > 1) transparent.sort(reversePainterSortStable);
  }
  return {
    opaque,
    transparent,
    init,
    push,
    unshift,
    sort
  };
}
function WebGLRenderLists() {
  var lists = {};
  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    delete lists[scene.id];
  }
  function get(scene, camera) {
    var cameras = lists[scene.id];
    var list;
    if (cameras === void 0) {
      list = new WebGLRenderList();
      lists[scene.id] = {};
      lists[scene.id][camera.id] = list;
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      list = cameras[camera.id];
      if (list === void 0) {
        list = new WebGLRenderList();
        cameras[camera.id] = list;
      }
    }
    return list;
  }
  function dispose2() {
    lists = {};
  }
  return {
    get,
    dispose: dispose2
  };
}
function UniformsCache() {
  var lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      var uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color(),
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
            // TODO (abelnation): set RectAreaLight shadow uniforms
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var count = 0;
function WebGLLights() {
  var cache = new UniformsCache();
  var state = {
    id: count++,
    hash: {
      stateID: -1,
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      shadowsLength: -1
    },
    ambient: [0, 0, 0],
    directional: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  var vector3 = new Vector3();
  var matrix4 = new Matrix4();
  var matrix42 = new Matrix4();
  function setup(lights, shadows, camera) {
    var r = 0, g = 0, b = 0;
    var directionalLength = 0;
    var pointLength = 0;
    var spotLength = 0;
    var rectAreaLength = 0;
    var hemiLength = 0;
    var viewMatrix = camera.matrixWorldInverse;
    for (var i = 0, l = lights.length; i < l; i++) {
      var light = lights[i];
      var color2 = light.color;
      var intensity = light.intensity;
      var distance2 = light.distance;
      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color2.r * intensity;
        g += color2.g * intensity;
        b += color2.b * intensity;
      } else if (light.isDirectionalLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        state.directionalShadowMap[directionalLength] = shadowMap;
        state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.distance = distance2;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
        }
        state.spotShadowMap[spotLength] = shadowMap;
        state.spotShadowMatrix[spotLength] = light.shadow.matrix;
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        var uniforms = cache.get(light);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        var uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        uniforms.shadow = light.castShadow;
        if (light.castShadow) {
          var shadow = light.shadow;
          uniforms.shadowBias = shadow.bias;
          uniforms.shadowRadius = shadow.radius;
          uniforms.shadowMapSize = shadow.mapSize;
          uniforms.shadowCameraNear = shadow.camera.near;
          uniforms.shadowCameraFar = shadow.camera.far;
        }
        state.pointShadowMap[pointLength] = shadowMap;
        state.pointShadowMatrix[pointLength] = light.shadow.matrix;
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        var uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    state.directional.length = directionalLength;
    state.spot.length = spotLength;
    state.rectArea.length = rectAreaLength;
    state.point.length = pointLength;
    state.hemi.length = hemiLength;
    state.hash.stateID = state.id;
    state.hash.directionalLength = directionalLength;
    state.hash.pointLength = pointLength;
    state.hash.spotLength = spotLength;
    state.hash.rectAreaLength = rectAreaLength;
    state.hash.hemiLength = hemiLength;
    state.hash.shadowsLength = shadows.length;
  }
  return {
    setup,
    state
  };
}
function WebGLRenderState() {
  var lights = new WebGLLights();
  var lightsArray = [];
  var shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }
  var state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates() {
  var renderStates = {};
  function onSceneDispose(event) {
    var scene = event.target;
    scene.removeEventListener("dispose", onSceneDispose);
    delete renderStates[scene.id];
  }
  function get(scene, camera) {
    var renderState;
    if (renderStates[scene.id] === void 0) {
      renderState = new WebGLRenderState();
      renderStates[scene.id] = {};
      renderStates[scene.id][camera.id] = renderState;
      scene.addEventListener("dispose", onSceneDispose);
    } else {
      if (renderStates[scene.id][camera.id] === void 0) {
        renderState = new WebGLRenderState();
        renderStates[scene.id][camera.id] = renderState;
      } else {
        renderState = renderStates[scene.id][camera.id];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = {};
  }
  return {
    get,
    dispose: dispose2
  };
}
function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDepthMaterial";
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = "MeshDistanceMaterial";
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1e3;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
  var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  var cubeDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0)
  ];
  var cubeUps = [
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
  var cube2DViewPorts = [
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4(),
    new Vector4()
  ];
  for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
    var useMorphing = (i & _MorphingFlag) !== 0;
    var useSkinning = (i & _SkinningFlag) !== 0;
    var depthMaterial = new MeshDepthMaterial({
      depthPacking: RGBADepthPacking,
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _depthMaterials[i] = depthMaterial;
    var distanceMaterial = new MeshDistanceMaterial({
      morphTargets: useMorphing,
      skinning: useSkinning
    });
    _distanceMaterials[i] = distanceMaterial;
  }
  var scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    var _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    var faceCount;
    for (var i2 = 0, il = lights.length; i2 < il; i2++) {
      var light = lights[i2];
      var shadow = light.shadow;
      var isPointLight = light && light.isPointLight;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      var shadowCamera = shadow.camera;
      _shadowMapSize.copy(shadow.mapSize);
      _shadowMapSize.min(_maxShadowMapSize);
      if (isPointLight) {
        var vpWidth = _shadowMapSize.x;
        var vpHeight = _shadowMapSize.y;
        cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
        cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
        cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
        _shadowMapSize.x *= 4;
        _shadowMapSize.y *= 2;
      }
      if (shadow.map === null) {
        var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadowCamera.updateProjectionMatrix();
      }
      if (shadow.isSpotLightShadow) {
        shadow.update(light);
      }
      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;
      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld);
      if (isPointLight) {
        faceCount = 6;
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      } else {
        faceCount = 1;
        _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget);
        shadowCamera.updateMatrixWorld();
        shadowMatrix.set(
          0.5,
          0,
          0,
          0.5,
          0,
          0.5,
          0,
          0.5,
          0,
          0,
          0.5,
          0.5,
          0,
          0,
          0,
          1
        );
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      _renderer.setRenderTarget(shadowMap);
      _renderer.clear();
      for (var face = 0; face < faceCount; face++) {
        if (isPointLight) {
          _lookTarget.copy(shadowCamera.position);
          _lookTarget.add(cubeDirections[face]);
          shadowCamera.up.copy(cubeUps[face]);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          var vpDimensions = cube2DViewPorts[face];
          _state.viewport(vpDimensions);
        }
        _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        renderObject(scene, camera, shadowCamera, isPointLight);
      }
    }
    scope.needsUpdate = false;
  };
  function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
    var geometry2 = object.geometry;
    var result = null;
    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;
    if (isPointLight) {
      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;
    }
    if (!customMaterial) {
      var useMorphing2 = false;
      if (material.morphTargets) {
        if (geometry2 && geometry2.isBufferGeometry) {
          useMorphing2 = geometry2.morphAttributes && geometry2.morphAttributes.position && geometry2.morphAttributes.position.length > 0;
        } else if (geometry2 && geometry2.isGeometry) {
          useMorphing2 = geometry2.morphTargets && geometry2.morphTargets.length > 0;
        }
      }
      if (object.isSkinnedMesh && material.skinning === false) {
        console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
      }
      var useSkinning2 = object.isSkinnedMesh && material.skinning;
      var variantIndex = 0;
      if (useMorphing2) variantIndex |= _MorphingFlag;
      if (useSkinning2) variantIndex |= _SkinningFlag;
      result = materialVariants[variantIndex];
    } else {
      result = customMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      var keyA = result.uuid, keyB = material.uuid;
      var materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      var cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (isPointLight && result.isMeshDistanceMaterial) {
      result.referencePosition.copy(lightPositionWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, isPointLight) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        var geometry2 = _objects.update(object);
        var material = object.material;
        if (Array.isArray(material)) {
          var groups = geometry2.groups;
          for (var k = 0, kl = groups.length; k < kl; k++) {
            var group = groups[k];
            var groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              var depthMaterial2 = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
              _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, group);
            }
          }
        } else if (material.visible) {
          var depthMaterial2 = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
          _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, null);
        }
      }
    }
    var children = object.children;
    for (var i2 = 0, l = children.length; i2 < l; i2++) {
      renderObject(children[i2], camera, shadowCamera, isPointLight);
    }
  }
}
function WebGLState(gl, extensions, utils, capabilities) {
  function ColorBuffer() {
    var locked = false;
    var color2 = new Vector4();
    var currentColorMask = null;
    var currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color2.set(r, g, b, a);
        if (currentColorClear.equals(color2) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    var locked = false;
    var currentDepthMask = null;
    var currentDepthFunc = null;
    var currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(gl.NEVER);
                break;
              case AlwaysDepth:
                gl.depthFunc(gl.ALWAYS);
                break;
              case LessDepth:
                gl.depthFunc(gl.LESS);
                break;
              case LessEqualDepth:
                gl.depthFunc(gl.LEQUAL);
                break;
              case EqualDepth:
                gl.depthFunc(gl.EQUAL);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(gl.GEQUAL);
                break;
              case GreaterDepth:
                gl.depthFunc(gl.GREATER);
                break;
              case NotEqualDepth:
                gl.depthFunc(gl.NOTEQUAL);
                break;
              default:
                gl.depthFunc(gl.LEQUAL);
            }
          } else {
            gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    var locked = false;
    var currentStencilMask = null;
    var currentStencilFunc = null;
    var currentStencilRef = null;
    var currentStencilFuncMask = null;
    var currentStencilFail = null;
    var currentStencilZFail = null;
    var currentStencilZPass = null;
    var currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (stencilTest) {
          enable(gl.STENCIL_TEST);
        } else {
          disable(gl.STENCIL_TEST);
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  var colorBuffer = new ColorBuffer();
  var depthBuffer = new DepthBuffer();
  var stencilBuffer = new StencilBuffer();
  var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  var newAttributes = new Uint8Array(maxVertexAttributes);
  var enabledAttributes = new Uint8Array(maxVertexAttributes);
  var attributeDivisors = new Uint8Array(maxVertexAttributes);
  var enabledCapabilities = {};
  var compressedTextureFormats = null;
  var currentProgram = null;
  var currentBlendingEnabled = null;
  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;
  var currentPremultipledAlpha = false;
  var currentFlipSided = null;
  var currentCullFace = null;
  var currentLineWidth = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;
  var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  var lineWidthAvailable = false;
  var version2 = 0;
  var glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  var currentTextureSlot = null;
  var currentBoundTextures = {};
  var currentScissor = new Vector4();
  var currentViewport = new Vector4();
  function createTexture(type, target, count2) {
    var data = new Uint8Array(4);
    var texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (var i = 0; i < count2; i++) {
      gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    }
    return texture;
  }
  var emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function initAttributes() {
    for (var i = 0, l = newAttributes.length; i < l; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      var extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function getCompressedTextureFormats() {
    if (compressedTextureFormats === null) {
      compressedTextureFormats = [];
      if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1") || extensions.get("WEBGL_compressed_texture_astc")) {
        var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
        for (var i = 0; i < formats.length; i++) {
          compressedTextureFormats.push(formats[i]);
        }
      }
    }
    return compressedTextureFormats;
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (!currentBlendingEnabled) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    var flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    var boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    for (var i = 0; i < enabledAttributes.length; i++) {
      if (enabledAttributes[i] === 1) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
    enabledCapabilities = {};
    compressedTextureFormats = null;
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    initAttributes,
    enableAttribute,
    enableAttributeAndDivisor,
    disableUnusedAttributes,
    enable,
    disable,
    getCompressedTextureFormats,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  var _videoTextures = {};
  var _canvas2;
  function resizeImage(image2, needsPowerOfTwo, needsNewCanvas, maxSize) {
    var scale2 = 1;
    if (image2.width > maxSize || image2.height > maxSize) {
      scale2 = maxSize / Math.max(image2.width, image2.height);
    }
    if (scale2 < 1 || needsPowerOfTwo === true) {
      if (image2 instanceof HTMLImageElement || image2 instanceof HTMLCanvasElement || image2 instanceof ImageBitmap) {
        if (_canvas2 === void 0) _canvas2 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        var canvas = needsNewCanvas ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : _canvas2;
        var floor2 = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
        canvas.width = floor2(scale2 * image2.width);
        canvas.height = floor2(scale2 * image2.height);
        var context2 = canvas.getContext("2d");
        context2.drawImage(image2, 0, 0, canvas.width, canvas.height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image2.width + "x" + image2.height + ") to (" + canvas.width + "x" + canvas.height + ").");
        return canvas;
      } else {
        if ("data" in image2) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image2.width + "x" + image2.height + ").");
        }
        return image2;
      }
    }
    return image2;
  }
  function isPowerOfTwo(image2) {
    return _Math.isPowerOfTwo(image2.width) && _Math.isPowerOfTwo(image2.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (capabilities.isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, isPowerOfTwo2) {
    return texture.generateMipmaps && isPowerOfTwo2 && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);
    var textureProperties = properties.get(texture);
    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }
  function getInternalFormat(glFormat, glType) {
    if (!capabilities.isWebGL2) return glFormat;
    var internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
    }
    if (glFormat === _gl.RGBA) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    } else if (internalFormat === _gl.RGB16F || internalFormat === _gl.RGB32F) {
      console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
    }
    return internalFormat;
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      delete _videoTextures[texture.id];
    }
    info.memory.textures--;
  }
  function onRenderTargetDispose(event) {
    var renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  }
  function deallocateTexture(texture) {
    var textureProperties = properties.get(texture);
    if (texture.image && textureProperties.__image__webglTextureCube) {
      _gl.deleteTexture(textureProperties.__image__webglTextureCube);
    } else {
      if (textureProperties.__webglInit === void 0) return;
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    properties.remove(texture);
  }
  function deallocateRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLRenderTargetCube) {
      for (var i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
    }
    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  }
  function setTexture2D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      var image2 = texture.image;
      if (image2 === void 0) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      } else if (image2.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    var textureProperties = properties.get(texture);
    if (texture.image.length === 6) {
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        if (!textureProperties.__image__webglTextureCube) {
          texture.addEventListener("dispose", onTextureDispose);
          textureProperties.__image__webglTextureCube = _gl.createTexture();
          info.memory.textures++;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        var isCompressed = texture && texture.isCompressedTexture;
        var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
        var cubeImage = [];
        for (var i = 0; i < 6; i++) {
          if (!isCompressed && !isDataTexture) {
            cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);
          } else {
            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
          }
        }
        var image2 = cubeImage[0], isPowerOfTwoImage = isPowerOfTwo(image2), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
        for (var i = 0; i < 6; i++) {
          if (!isCompressed) {
            if (isDataTexture) {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
          } else {
            var mipmap, mipmaps = cubeImage[i].mipmaps;
            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
              mipmap = mipmaps[j];
              if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                } else {
                  console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
        if (!isCompressed) {
          textureProperties.__maxMipLevel = 0;
        } else {
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        }
        if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
          generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image2.width, image2.height);
        }
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      } else {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
      }
    }
  }
  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
  }
  function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
    var extension;
    if (isPowerOfTwoImage) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    extension = extensions.get("EXT_texture_filter_anisotropic");
    if (extension) {
      if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) return;
      if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    var textureType;
    if (texture.isDataTexture3D) {
      textureType = _gl.TEXTURE_3D;
    } else {
      textureType = _gl.TEXTURE_2D;
    }
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
    state.activeTexture(_gl.TEXTURE0 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
    var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    var image2 = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);
    var isPowerOfTwoImage = isPowerOfTwo(image2), glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
    setTextureParameters(textureType, texture, isPowerOfTwoImage);
    var mipmap, mipmaps = texture.mipmaps;
    if (texture.isDepthTexture) {
      glInternalFormat = _gl.DEPTH_COMPONENT;
      if (texture.type === FloatType) {
        if (!capabilities.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (capabilities.isWebGL2) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
      if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }
      if (texture.format === DepthStencilFormat) {
        glInternalFormat = _gl.DEPTH_STENCIL;
        if (texture.type !== UnsignedInt248Type) {
          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      }
      state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, image2.data);
        textureProperties.__maxMipLevel = 0;
      }
      if (texture.isCfxTexture) {
        _gl.texParameterf(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
        _gl.texParameterf(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.MIRRORED_REPEAT);
        _gl.texParameterf(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.REPEAT);
      }
    } else if (texture.isCompressedTexture) {
      for (var i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];
        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
          }
        } else {
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }
      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      if (mipmaps.length > 0 && isPowerOfTwoImage) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
        }
        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image2);
        textureProperties.__maxMipLevel = 0;
      }
    }
    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
      generateMipmap(_gl.TEXTURE_2D, texture, image2.width, image2.height);
    }
    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    var glFormat = utils.convert(renderTarget.texture.format);
    var glType = utils.convert(renderTarget.texture.type);
    var glInternalFormat = getInternalFormat(glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      var glFormat = utils.convert(renderTarget.texture.format);
      var glType = utils.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(glFormat, glType);
      if (isMultisample) {
        var samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    if (renderTarget.depthTexture) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (var i = 0; i < 6; i++) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
        }
      } else {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
      }
    }
    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderTarget(renderTarget) {
    var renderTargetProperties = properties.get(renderTarget);
    var textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    var isCube = renderTarget.isWebGLRenderTargetCube === true;
    var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (var i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultisample) {
        if (capabilities.isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
          var glFormat = utils.convert(renderTarget.texture.format);
          var glType = utils.convert(renderTarget.texture.type);
          var glInternalFormat = getInternalFormat(glFormat, glType);
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
      for (var i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      }
      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
    } else {
      state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
      if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
        generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
      }
      state.bindTexture(_gl.TEXTURE_2D, null);
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    var texture = renderTarget.texture;
    var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
    if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
      var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
      var webglTexture = properties.get(texture).__webglTexture;
      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (capabilities.isWebGL2) {
        var renderTargetProperties = properties.get(renderTarget);
        _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        var width = renderTarget.width;
        var height = renderTarget.height;
        var mask = _gl.COLOR_BUFFER_BIT;
        if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
        if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
      } else {
        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
  }
  function updateVideoTexture(texture) {
    var id2 = texture.id;
    var frame2 = info.render.frame;
    if (_videoTextures[id2] !== frame2) {
      _videoTextures[id2] = frame2;
      texture.update();
    }
  }
  this.setTexture2D = setTexture2D;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
}
function WebGLUtils(gl, extensions, capabilities) {
  function convert(p) {
    var extension;
    if (p === RepeatWrapping) return gl.REPEAT;
    if (p === ClampToEdgeWrapping) return gl.CLAMP_TO_EDGE;
    if (p === MirroredRepeatWrapping) return gl.MIRRORED_REPEAT;
    if (p === NearestFilter) return gl.NEAREST;
    if (p === NearestMipMapNearestFilter) return gl.NEAREST_MIPMAP_NEAREST;
    if (p === NearestMipMapLinearFilter) return gl.NEAREST_MIPMAP_LINEAR;
    if (p === LinearFilter) return gl.LINEAR;
    if (p === LinearMipMapNearestFilter) return gl.LINEAR_MIPMAP_NEAREST;
    if (p === LinearMipMapLinearFilter) return gl.LINEAR_MIPMAP_LINEAR;
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) {
      if (capabilities.isWebGL2) return gl.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) return extension.HALF_FLOAT_OES;
    }
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === AddEquation) return gl.FUNC_ADD;
    if (p === SubtractEquation) return gl.FUNC_SUBTRACT;
    if (p === ReverseSubtractEquation) return gl.FUNC_REVERSE_SUBTRACT;
    if (p === ZeroFactor) return gl.ZERO;
    if (p === OneFactor) return gl.ONE;
    if (p === SrcColorFactor) return gl.SRC_COLOR;
    if (p === OneMinusSrcColorFactor) return gl.ONE_MINUS_SRC_COLOR;
    if (p === SrcAlphaFactor) return gl.SRC_ALPHA;
    if (p === OneMinusSrcAlphaFactor) return gl.ONE_MINUS_SRC_ALPHA;
    if (p === DstAlphaFactor) return gl.DST_ALPHA;
    if (p === OneMinusDstAlphaFactor) return gl.ONE_MINUS_DST_ALPHA;
    if (p === DstColorFactor) return gl.DST_COLOR;
    if (p === OneMinusDstColorFactor) return gl.ONE_MINUS_DST_COLOR;
    if (p === SrcAlphaSaturateFactor) return gl.SRC_ALPHA_SATURATE;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get("WEBGL_compressed_texture_s3tc");
      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        return p;
      }
    }
    if (p === MinEquation || p === MaxEquation) {
      if (capabilities.isWebGL2) {
        if (p === MinEquation) return gl.MIN;
        if (p === MaxEquation) return gl.MAX;
      }
      extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        if (p === MinEquation) return extension.MIN_EXT;
        if (p === MaxEquation) return extension.MAX_EXT;
      }
    }
    if (p === UnsignedInt248Type) {
      if (capabilities.isWebGL2) return gl.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
    }
    return 0;
  }
  return { convert };
}
function Group() {
  Object3D.call(this);
  this.type = "Group";
}
Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
function Camera() {
  Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}
Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function(target) {
    if (target === void 0) {
      console.warn("THREE.Camera: .getWorldDirection() target is now required");
      target = new Vector3();
    }
    this.updateMatrixWorld(true);
    var e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function(force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = "PerspectiveCamera";
  this.fov = fov !== void 0 ? fov : 50;
  this.zoom = 1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.focus = 10;
  this.aspect = aspect !== void 0 ? aspect : 1;
  this.view = null;
  this.filmGauge = 35;
  this.filmOffset = 0;
  this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function(focalLength) {
    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function() {
    var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function() {
    return _Math.RAD2DEG * 2 * Math.atan(
      Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  },
  getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function() {
    return this.filmGauge / Math.max(this.aspect, 1);
  },
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   var w = 1920;
   *   var h = 1080;
   *   var fullWidth = w * 3;
   *   var fullHeight = h * 2;
   *
   *   --A--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
    if (this.view !== null && this.view.enabled) {
      var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    var skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
var cameraLPos = new Vector3();
var cameraRPos = new Vector3();
function setProjectionFromUnion(camera, cameraL, cameraR) {
  cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  var ipd = cameraLPos.distanceTo(cameraRPos);
  var projL = cameraL.projectionMatrix.elements;
  var projR = cameraR.projectionMatrix.elements;
  var near = projL[14] / (projL[10] - 1);
  var far = projL[14] / (projL[10] + 1);
  var topFov = (projL[9] + 1) / projL[5];
  var bottomFov = (projL[9] - 1) / projL[5];
  var leftFov = (projL[8] - 1) / projL[0];
  var rightFov = (projR[8] + 1) / projR[0];
  var left = near * leftFov;
  var right = near * rightFov;
  var zOffset = ipd / (-leftFov + rightFov);
  var xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  var near2 = near + zOffset;
  var far2 = far + zOffset;
  var left2 = left - xOffset;
  var right2 = right + (ipd - xOffset);
  var top2 = topFov * far / far2 * near2;
  var bottom2 = bottomFov * far / far2 * near2;
  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
function WebVRManager(renderer) {
  var scope = this;
  var device = null;
  var frameData2 = null;
  var poseTarget = null;
  var controllers = [];
  var standingMatrix = new Matrix4();
  var standingMatrixInverse = new Matrix4();
  var framebufferScaleFactor = 1;
  var frameOfReferenceType = "stage";
  if (typeof window !== "undefined" && "VRFrameData" in window) {
    frameData2 = new window.VRFrameData();
    window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
  }
  var matrixWorldInverse = new Matrix4();
  var tempQuaternion = new Quaternion();
  var tempPosition = new Vector3();
  var cameraL = new PerspectiveCamera();
  cameraL.bounds = new Vector4(0, 0, 0.5, 1);
  cameraL.layers.enable(1);
  var cameraR = new PerspectiveCamera();
  cameraR.bounds = new Vector4(0.5, 0, 0.5, 1);
  cameraR.layers.enable(2);
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  function isPresenting() {
    return device !== null && device.isPresenting === true;
  }
  var currentSize, currentPixelRatio;
  function onVRDisplayPresentChange() {
    if (isPresenting()) {
      var eyeParameters = device.getEyeParameters("left");
      var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
      var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
      currentPixelRatio = renderer.getPixelRatio();
      currentSize = renderer.getSize();
      renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
      animation.start();
    } else {
      if (scope.enabled) {
        renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
      }
      animation.stop();
    }
  }
  var triggers = [];
  function findGamepad(id2) {
    var gamepads = navigator.getGamepads && navigator.getGamepads();
    for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {
      var gamepad = gamepads[i];
      if (gamepad && (gamepad.id === "Daydream Controller" || gamepad.id === "Gear VR Controller" || gamepad.id === "Oculus Go Controller" || gamepad.id === "OpenVR Gamepad" || gamepad.id.startsWith("Oculus Touch") || gamepad.id.startsWith("Spatial Controller"))) {
        if (j === id2) return gamepad;
        j++;
      }
    }
  }
  function updateControllers() {
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var gamepad = findGamepad(i);
      if (gamepad !== void 0 && gamepad.pose !== void 0) {
        if (gamepad.pose === null) return;
        var pose = gamepad.pose;
        if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);
        if (pose.position !== null) controller.position.fromArray(pose.position);
        if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
        controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
        controller.matrix.premultiply(standingMatrix);
        controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
        controller.matrixWorldNeedsUpdate = true;
        controller.visible = true;
        var buttonId = gamepad.id === "Daydream Controller" ? 0 : 1;
        if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
          triggers[i] = gamepad.buttons[buttonId].pressed;
          if (triggers[i] === true) {
            controller.dispatchEvent({ type: "selectstart" });
          } else {
            controller.dispatchEvent({ type: "selectend" });
            controller.dispatchEvent({ type: "select" });
          }
        }
      } else {
        controller.visible = false;
      }
    }
  }
  this.enabled = false;
  this.getController = function(id2) {
    var controller = controllers[id2];
    if (controller === void 0) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id2] = controller;
    }
    return controller;
  };
  this.getDevice = function() {
    return device;
  };
  this.setDevice = function(value) {
    if (value !== void 0) device = value;
    animation.setContext(value);
  };
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
  };
  this.setFrameOfReferenceType = function(value) {
    frameOfReferenceType = value;
  };
  this.setPoseTarget = function(object) {
    if (object !== void 0) poseTarget = object;
  };
  this.getCamera = function(camera) {
    var userHeight = frameOfReferenceType === "stage" ? 1.6 : 0;
    if (device === null) {
      camera.position.set(0, userHeight, 0);
      return camera;
    }
    device.depthNear = camera.near;
    device.depthFar = camera.far;
    device.getFrameData(frameData2);
    if (frameOfReferenceType === "stage") {
      var stageParameters = device.stageParameters;
      if (stageParameters) {
        standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
      } else {
        standingMatrix.makeTranslation(0, userHeight, 0);
      }
    }
    var pose = frameData2.pose;
    var poseObject = poseTarget !== null ? poseTarget : camera;
    poseObject.matrix.copy(standingMatrix);
    poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
    if (pose.orientation !== null) {
      tempQuaternion.fromArray(pose.orientation);
      poseObject.quaternion.multiply(tempQuaternion);
    }
    if (pose.position !== null) {
      tempQuaternion.setFromRotationMatrix(standingMatrix);
      tempPosition.fromArray(pose.position);
      tempPosition.applyQuaternion(tempQuaternion);
      poseObject.position.add(tempPosition);
    }
    poseObject.updateMatrixWorld();
    if (device.isPresenting === false) return camera;
    cameraL.near = camera.near;
    cameraR.near = camera.near;
    cameraL.far = camera.far;
    cameraR.far = camera.far;
    cameraL.matrixWorldInverse.fromArray(frameData2.leftViewMatrix);
    cameraR.matrixWorldInverse.fromArray(frameData2.rightViewMatrix);
    standingMatrixInverse.getInverse(standingMatrix);
    if (frameOfReferenceType === "stage") {
      cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
      cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
    }
    var parent = poseObject.parent;
    if (parent !== null) {
      matrixWorldInverse.getInverse(parent.matrixWorld);
      cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
      cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
    }
    cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
    cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
    cameraL.projectionMatrix.fromArray(frameData2.leftProjectionMatrix);
    cameraR.projectionMatrix.fromArray(frameData2.rightProjectionMatrix);
    setProjectionFromUnion(cameraVR, cameraL, cameraR);
    var layers = device.getLayers();
    if (layers.length) {
      var layer = layers[0];
      if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
        cameraL.bounds.fromArray(layer.leftBounds);
      }
      if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
        cameraR.bounds.fromArray(layer.rightBounds);
      }
    }
    updateControllers();
    return cameraVR;
  };
  this.getStandingMatrix = function() {
    return standingMatrix;
  };
  this.isPresenting = isPresenting;
  var animation = new WebGLAnimation();
  this.setAnimationLoop = function(callback) {
    animation.setAnimationLoop(callback);
  };
  this.submitFrame = function() {
    if (isPresenting()) device.submitFrame();
  };
  this.dispose = function() {
    if (typeof window !== "undefined") {
      window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
    }
  };
}
function WebXRManager(renderer) {
  var gl = renderer.context;
  var device = null;
  var session = null;
  var framebufferScaleFactor = 1;
  var frameOfReference = null;
  var frameOfReferenceType = "stage";
  var pose = null;
  var controllers = [];
  var inputSources = [];
  function isPresenting() {
    return session !== null && frameOfReference !== null;
  }
  var cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  var cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  var cameraVR = new ArrayCamera([cameraL, cameraR]);
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  this.enabled = false;
  this.getController = function(id2) {
    var controller = controllers[id2];
    if (controller === void 0) {
      controller = new Group();
      controller.matrixAutoUpdate = false;
      controller.visible = false;
      controllers[id2] = controller;
    }
    return controller;
  };
  this.getDevice = function() {
    return device;
  };
  this.setDevice = function(value) {
    if (value !== void 0) device = value;
    if (value instanceof XRDevice) gl.setCompatibleXRDevice(value);
  };
  function onSessionEvent(event) {
    var controller = controllers[inputSources.indexOf(event.inputSource)];
    if (controller) controller.dispatchEvent({ type: event.type });
  }
  function onSessionEnd() {
    renderer.setFramebuffer(null);
    animation.stop();
  }
  this.setFramebufferScaleFactor = function(value) {
    framebufferScaleFactor = value;
  };
  this.setFrameOfReferenceType = function(value) {
    frameOfReferenceType = value;
  };
  this.setSession = function(value) {
    session = value;
    if (session !== null) {
      session.addEventListener("select", onSessionEvent);
      session.addEventListener("selectstart", onSessionEvent);
      session.addEventListener("selectend", onSessionEvent);
      session.addEventListener("end", onSessionEnd);
      session.baseLayer = new XRWebGLLayer(session, gl, { framebufferScaleFactor });
      session.requestFrameOfReference(frameOfReferenceType).then(function(value2) {
        frameOfReference = value2;
        renderer.setFramebuffer(session.baseLayer.framebuffer);
        animation.setContext(session);
        animation.start();
      });
      inputSources = session.getInputSources();
      session.addEventListener("inputsourceschange", function() {
        inputSources = session.getInputSources();
        console.log(inputSources);
        for (var i = 0; i < controllers.length; i++) {
          var controller = controllers[i];
          controller.userData.inputSource = inputSources[i];
        }
      });
    }
  };
  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }
  this.getCamera = function(camera) {
    if (isPresenting()) {
      var parent = camera.parent;
      var cameras = cameraVR.cameras;
      updateCamera(cameraVR, parent);
      for (var i = 0; i < cameras.length; i++) {
        updateCamera(cameras[i], parent);
      }
      camera.matrixWorld.copy(cameraVR.matrixWorld);
      var children = camera.children;
      for (var i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true);
      }
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      return cameraVR;
    }
    return camera;
  };
  this.isPresenting = isPresenting;
  var onAnimationFrameCallback = null;
  function onAnimationFrame(time2, frame2) {
    pose = frame2.getDevicePose(frameOfReference);
    if (pose !== null) {
      var layer = session.baseLayer;
      var views = frame2.views;
      for (var i = 0; i < views.length; i++) {
        var view = views[i];
        var viewport = layer.getViewport(view);
        var viewMatrix = pose.getViewMatrix(view);
        var camera = cameraVR.cameras[i];
        camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }
      }
    }
    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i];
      var inputSource = inputSources[i];
      if (inputSource) {
        var inputPose = frame2.getInputPose(inputSource, frameOfReference);
        if (inputPose !== null) {
          if ("targetRay" in inputPose) {
            controller.matrix.elements = inputPose.targetRay.transformMatrix;
          } else if ("pointerMatrix" in inputPose) {
            controller.matrix.elements = inputPose.pointerMatrix;
          }
          controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
          controller.visible = true;
          continue;
        }
      }
      controller.visible = false;
    }
    if (onAnimationFrameCallback) onAnimationFrameCallback(time2);
  }
  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
  };
  this.dispose = function() {
  };
  this.getStandingMatrix = function() {
    console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
    return new THREE.Matrix4();
  };
  this.submitFrame = function() {
  };
}
function WebGLRenderer(parameters) {
  parameters = parameters || {};
  var _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default";
  var currentRenderList = null;
  var currentRenderState = null;
  this.domElement = _canvas2;
  this.context = null;
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.gammaFactor = 2;
  this.gammaInput = false;
  this.gammaOutput = false;
  this.physicallyCorrectLights = false;
  this.toneMapping = LinearToneMapping;
  this.toneMappingExposure = 1;
  this.toneMappingWhitePoint = 1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  var _this = this, _isContextLost = false, _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = {
    geometry: null,
    program: null,
    wireframe: false
  }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _usedTextureUnits = 0, _width = _canvas2.width, _height = _canvas2.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  var _gl;
  try {
    var contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference
    };
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    _gl = _context || _canvas2.getContext("webgl", contextAttributes) || _canvas2.getContext("experimental-webgl", contextAttributes);
    if (_gl === null) {
      if (_canvas2.getContext("webgl") !== null) {
        throw new Error("Error creating WebGL context with your selected attributes.");
      } else {
        throw new Error("Error creating WebGL context.");
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
  }
  var extensions, capabilities, state, info;
  var properties, textures, attributes, geometries, objects;
  var programCache, renderLists, renderStates;
  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
  var utils;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    if (!capabilities.isWebGL2) {
      extensions.get("WEBGL_depth_texture");
      extensions.get("OES_texture_float");
      extensions.get("OES_texture_half_float");
      extensions.get("OES_texture_half_float_linear");
      extensions.get("OES_standard_derivatives");
      extensions.get("OES_element_index_uint");
      extensions.get("ANGLE_instanced_arrays");
    }
    extensions.get("OES_texture_float_linear");
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, utils, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl);
    geometries = new WebGLGeometries(_gl, attributes, info);
    objects = new WebGLObjects(geometries, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.context = _gl;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  var vr = null;
  if (typeof navigator !== "undefined") {
    vr = "xr" in navigator ? new WebXRManager(_this) : new WebVRManager(_this);
  }
  this.vr = vr;
  var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    var extension = extensions.get("WEBGL_lose_context");
    if (extension) extension.loseContext();
  };
  this.forceContextRestore = function() {
    var extension = extensions.get("WEBGL_lose_context");
    if (extension) extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };
  this.getSize = function() {
    return {
      width: _width,
      height: _height
    };
  };
  this.setSize = function(width, height, updateStyle) {
    if (vr.isPresenting()) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width = width;
    _height = height;
    _canvas2.width = width * _pixelRatio;
    _canvas2.height = height * _pixelRatio;
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function() {
    return {
      width: _width * _pixelRatio,
      height: _height * _pixelRatio
    };
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas2.width = width * pixelRatio;
    _canvas2.height = height * pixelRatio;
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function() {
    return _currentViewport;
  };
  this.setViewport = function(x, y, width, height) {
    _viewport.set(x, _height - y - height, width, height);
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
  };
  this.setScissor = function(x, y, width, height) {
    _scissor.set(x, _height - y - height, width, height);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.getClearColor = function() {
    return background.getClearColor();
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color2, depth, stencil) {
    var bits = 0;
    if (color2 === void 0 || color2) bits |= _gl.COLOR_BUFFER_BIT;
    if (depth === void 0 || depth) bits |= _gl.DEPTH_BUFFER_BIT;
    if (stencil === void 0 || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    vr.dispose();
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    initGLContext();
  }
  function onMaterialDispose(event) {
    var material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReference(material) {
    var programInfo = properties.get(material).program;
    material.program = void 0;
    if (programInfo !== void 0) {
      programCache.releaseProgram(programInfo);
    }
  }
  function renderObjectImmediate(object, program) {
    object.render(function(object2) {
      _this.renderBufferImmediate(object2, program);
    });
  }
  this.renderBufferImmediate = function(object, program) {
    state.initAttributes();
    var buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    var programAttributes = program.getAttributes();
    if (object.hasPositions) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.position);
      _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasNormals) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.normal);
      _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasUvs) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.uv);
      _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
    }
    if (object.hasColors) {
      _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
      _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
      state.enableAttribute(programAttributes.color);
      _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
    }
    state.disableUnusedAttributes();
    _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
    object.count = 0;
  };
  this.renderBufferDirect = function(camera, fog, geometry2, material, object, group) {
    var frontFaceCW = object.isMesh && object.normalMatrix.determinant() < 0;
    state.setMaterial(material, frontFaceCW);
    var program = setProgram(camera, fog, material, object);
    var updateBuffers = false;
    if (_currentGeometryProgram.geometry !== geometry2.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
      _currentGeometryProgram.geometry = geometry2.id;
      _currentGeometryProgram.program = program.id;
      _currentGeometryProgram.wireframe = material.wireframe === true;
      updateBuffers = true;
    }
    if (object.morphTargetInfluences) {
      morphtargets.update(object, geometry2, material, program);
      updateBuffers = true;
    }
    var index = geometry2.index;
    var position = geometry2.attributes.position;
    var rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry2);
      rangeFactor = 2;
    }
    var attribute;
    var renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    if (updateBuffers) {
      setupVertexAttributes(material, program, geometry2);
      if (index !== null) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
      }
    }
    var dataCount = Infinity;
    if (index !== null) {
      dataCount = index.count;
    } else if (position !== void 0) {
      dataCount = position.count;
    }
    var rangeStart = geometry2.drawRange.start * rangeFactor;
    var rangeCount = geometry2.drawRange.count * rangeFactor;
    var groupStart = group !== null ? group.start * rangeFactor : 0;
    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    var drawStart = Math.max(rangeStart, groupStart);
    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    var drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(_gl.LINES);
      } else {
        switch (object.drawMode) {
          case TrianglesDrawMode:
            renderer.setMode(_gl.TRIANGLES);
            break;
          case TriangleStripDrawMode:
            renderer.setMode(_gl.TRIANGLE_STRIP);
            break;
          case TriangleFanDrawMode:
            renderer.setMode(_gl.TRIANGLE_FAN);
            break;
        }
      }
    } else if (object.isLine) {
      var lineWidth = material.linewidth;
      if (lineWidth === void 0) lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(_gl.LINES);
      } else if (object.isLineLoop) {
        renderer.setMode(_gl.LINE_LOOP);
      } else {
        renderer.setMode(_gl.LINE_STRIP);
      }
    } else if (object.isPoints) {
      renderer.setMode(_gl.POINTS);
    } else if (object.isSprite) {
      renderer.setMode(_gl.TRIANGLES);
    }
    if (geometry2 && geometry2.isInstancedBufferGeometry) {
      if (geometry2.maxInstancedCount > 0) {
        renderer.renderInstances(geometry2, drawStart, drawCount);
      }
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  function setupVertexAttributes(material, program, geometry2) {
    if (geometry2 && geometry2.isInstancedBufferGeometry & !capabilities.isWebGL2) {
      if (extensions.get("ANGLE_instanced_arrays") === null) {
        console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    state.initAttributes();
    var geometryAttributes = geometry2.attributes;
    var programAttributes = program.getAttributes();
    var materialDefaultAttributeValues = material.defaultAttributeValues;
    for (var name in programAttributes) {
      var programAttribute = programAttributes[name];
      if (programAttribute >= 0) {
        var geometryAttribute = geometryAttributes[name];
        if (geometryAttribute !== void 0) {
          var normalized = geometryAttribute.normalized;
          var size = geometryAttribute.itemSize;
          var attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          var buffer2 = attribute.buffer;
          var type = attribute.type;
          var bytesPerElement2 = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;
            if (data && data.isInstancedInterleavedBuffer) {
              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
              if (geometry2.maxInstancedCount === void 0) {
                geometry2.maxInstancedCount = data.meshPerAttribute * data.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer2);
            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement2, offset * bytesPerElement2);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
              if (geometry2.maxInstancedCount === void 0) {
                geometry2.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              state.enableAttribute(programAttribute);
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer2);
            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          var value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                _gl.vertexAttrib2fv(programAttribute, value);
                break;
              case 3:
                _gl.vertexAttrib3fv(programAttribute, value);
                break;
              case 4:
                _gl.vertexAttrib4fv(programAttribute, value);
                break;
              default:
                _gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }
    state.disableUnusedAttributes();
  }
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function(object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    scene.traverse(function(object) {
      if (object.material) {
        if (Array.isArray(object.material)) {
          for (var i = 0; i < object.material.length; i++) {
            initMaterial(object.material[i], scene.fog, object);
          }
        } else {
          initMaterial(object.material, scene.fog, object);
        }
      }
    });
  };
  var onAnimationFrameCallback = null;
  function onAnimationFrame(time2) {
    if (vr.isPresenting()) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time2);
  }
  var animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== "undefined") animation.setContext(window);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    vr.setAnimationLoop(callback);
    animation.start();
  };
  this.render = function(scene, camera, renderTarget, forceClear) {
    if (!(camera && camera.isCamera)) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost) return;
    _currentGeometryProgram.geometry = null;
    _currentGeometryProgram.program = null;
    _currentGeometryProgram.wireframe = false;
    _currentMaterialId = -1;
    _currentCamera = null;
    if (scene.autoUpdate === true) scene.updateMatrixWorld();
    if (camera.parent === null) camera.updateMatrixWorld();
    if (vr.enabled) {
      camera = vr.getCamera(camera);
    }
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.onBeforeRender(_this, scene, camera, renderTarget);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromMatrix(_projScreenMatrix);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    if (_this.sortObjects === true) {
      currentRenderList.sort();
    }
    if (_clippingEnabled) _clipping.beginShadows();
    var shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled) _clipping.endShadows();
    if (this.info.autoReset) this.info.reset();
    if (renderTarget === void 0) {
      renderTarget = null;
    }
    this.setRenderTarget(renderTarget);
    background.render(currentRenderList, scene, camera, forceClear);
    var opaqueObjects = currentRenderList.opaque;
    var transparentObjects = currentRenderList.transparent;
    if (scene.overrideMaterial) {
      var overrideMaterial = scene.overrideMaterial;
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
    } else {
      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
    }
    if (renderTarget) {
      textures.updateRenderTargetMipmap(renderTarget);
      textures.updateMultisampleRenderTarget(renderTarget);
    }
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
    scene.onAfterRender(_this, scene, camera);
    if (vr.enabled) {
      vr.submitFrame();
    }
    currentRenderList = null;
    currentRenderState = null;
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    var visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          var geometry2 = objects.update(object);
          var material = object.material;
          currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }
        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          object.skeleton.update();
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          var geometry2 = objects.update(object);
          var material = object.material;
          if (Array.isArray(material)) {
            var groups = geometry2.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry2, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }
  function renderObjects(renderList, scene, camera, overrideMaterial) {
    for (var i = 0, l = renderList.length; i < l; i++) {
      var renderItem = renderList[i];
      var object = renderItem.object;
      var geometry2 = renderItem.geometry;
      var material = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
      var group = renderItem.group;
      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        var cameras = camera.cameras;
        for (var j = 0, jl = cameras.length; j < jl; j++) {
          var camera2 = cameras[j];
          if (object.layers.test(camera2.layers)) {
            if ("viewport" in camera2) {
              state.viewport(_currentViewport.copy(camera2.viewport));
            } else {
              var bounds = camera2.bounds;
              var x = bounds.x * _width;
              var y = bounds.y * _height;
              var width = bounds.z * _width;
              var height = bounds.w * _height;
              state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
            }
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry2, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry2, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry2, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry2, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    if (object.isImmediateRenderObject) {
      state.setMaterial(material);
      var program = setProgram(camera, scene.fog, material, object);
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene.fog, geometry2, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry2, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }
  function initMaterial(material, fog, object) {
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var shadowsArray = currentRenderState.state.shadowsArray;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    var parameters2 = programCache.getParameters(
      material,
      lights.state,
      shadowsArray,
      fog,
      _clipping.numPlanes,
      _clipping.numIntersection,
      object
    );
    var code = programCache.getProgramCode(material, parameters2);
    var program = materialProperties.program;
    var programChange = true;
    if (program === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
    } else if (program.code !== code) {
      releaseMaterialProgramReference(material);
    } else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
      lightsHash.stateID = lightsStateHash.stateID;
      lightsHash.directionalLength = lightsStateHash.directionalLength;
      lightsHash.pointLength = lightsStateHash.pointLength;
      lightsHash.spotLength = lightsStateHash.spotLength;
      lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
      lightsHash.hemiLength = lightsStateHash.hemiLength;
      lightsHash.shadowsLength = lightsStateHash.shadowsLength;
      programChange = false;
    } else if (parameters2.shaderID !== void 0) {
      return;
    } else {
      programChange = false;
    }
    if (programChange) {
      if (parameters2.shaderID) {
        var shader = ShaderLib[parameters2.shaderID];
        materialProperties.shader = {
          name: material.type,
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };
      } else {
        materialProperties.shader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };
      }
      material.onBeforeCompile(materialProperties.shader, _this);
      code = programCache.getProgramCode(material, parameters2);
      program = programCache.acquireProgram(material, materialProperties.shader, parameters2, code);
      materialProperties.program = program;
      material.program = program;
    }
    var programAttributes = program.getAttributes();
    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;
      for (var i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes["morphTarget" + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }
    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;
      for (var i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes["morphNormal" + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }
    var uniforms = materialProperties.shader.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }
    materialProperties.fog = fog;
    if (lightsHash === void 0) {
      materialProperties.lightsHash = lightsHash = {};
    }
    lightsHash.stateID = lightsStateHash.stateID;
    lightsHash.directionalLength = lightsStateHash.directionalLength;
    lightsHash.pointLength = lightsStateHash.pointLength;
    lightsHash.spotLength = lightsStateHash.spotLength;
    lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
    lightsHash.hemiLength = lightsStateHash.hemiLength;
    lightsHash.shadowsLength = lightsStateHash.shadowsLength;
    if (material.lights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }
  function setProgram(camera, fog, material, object) {
    _usedTextureUnits = 0;
    var materialProperties = properties.get(material);
    var lights = currentRenderState.state.lights;
    var lightsHash = materialProperties.lightsHash;
    var lightsStateHash = lights.state.hash;
    if (_clippingEnabled) {
      if (_localClippingEnabled || camera !== _currentCamera) {
        var useCache = camera === _currentCamera && material.id === _currentMaterialId;
        _clipping.setState(
          material.clippingPlanes,
          material.clipIntersection,
          material.clipShadows,
          camera,
          materialProperties,
          useCache
        );
      }
    }
    if (material.needsUpdate === false) {
      if (materialProperties.program === void 0) {
        material.needsUpdate = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        material.needsUpdate = true;
      } else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
        material.needsUpdate = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        material.needsUpdate = true;
      }
    }
    if (material.needsUpdate) {
      initMaterial(material, fog, object);
      material.needsUpdate = false;
    }
    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;
    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(
          _gl,
          "logDepthBufFC",
          2 / (Math.log(camera.far + 1) / Math.LN2)
        );
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
        var uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector3.setFromMatrixPosition(camera.matrixWorld)
          );
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      var skeleton = object.skeleton;
      if (skeleton) {
        var bones = skeleton.bones;
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === void 0) {
            var size = Math.sqrt(bones.length * 4);
            size = _Math.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            var boneMatrices = new Float32Array(size * size * 4);
            boneMatrices.set(skeleton.boneMatrices);
            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            boneTexture.needsUpdate = true;
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
      if (material.lights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        refreshUniformsFog(m_uniforms, fog);
      }
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(m_uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsLambert(m_uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        if (material.isMeshToonMaterial) {
          refreshUniformsToon(m_uniforms, material);
        } else {
          refreshUniformsPhong(m_uniforms, material);
        }
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(m_uniforms, material);
        } else {
          refreshUniformsStandard(m_uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsMatcap(m_uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDepth(m_uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsDistance(m_uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(m_uniforms, material);
        refreshUniformsNormal(m_uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(m_uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(m_uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(m_uniforms, material);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(m_uniforms, material);
      } else if (material.isShadowMaterial) {
        m_uniforms.color.value = material.color;
        m_uniforms.opacity.value = material.opacity;
      }
      if (m_uniforms.ltc_1 !== void 0) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== void 0) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value = material.color;
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.envMap) {
      uniforms.envMap.value = material.envMap;
      uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    var uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * _pixelRatio;
    uniforms.scale.value = _height * 0.5;
    uniforms.map.value = material.map;
    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }
      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    uniforms.map.value = material.map;
    if (material.map !== null) {
      if (material.map.matrixAutoUpdate === true) {
        material.map.updateMatrix();
      }
      uniforms.uvTransform.value.copy(material.map.matrix);
    }
  }
  function refreshUniformsFog(uniforms, fog) {
    uniforms.fogColor.value = fog.color;
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsToon(uniforms, material) {
    refreshUniformsPhong(uniforms, material);
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material) {
    refreshUniformsStandard(uniforms, material);
    uniforms.reflectivity.value = material.reflectivity;
    uniforms.clearCoat.value = material.clearCoat;
    uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function allocTextureUnit() {
    var textureUnit = _usedTextureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLRenderer: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    _usedTextureUnits += 1;
    return textureUnit;
  }
  this.allocTextureUnit = allocTextureUnit;
  this.setTexture2D = /* @__PURE__ */ function() {
    var warned = false;
    return function setTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warned = true;
        }
        texture = texture.texture;
      }
      textures.setTexture2D(texture, slot);
    };
  }();
  this.setTexture3D = /* @__PURE__ */ function() {
    return function setTexture3D(texture, slot) {
      textures.setTexture3D(texture, slot);
    };
  }();
  this.setTexture = /* @__PURE__ */ function() {
    var warned = false;
    return function setTexture(texture, slot) {
      if (!warned) {
        console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
        warned = true;
      }
      textures.setTexture2D(texture, slot);
    };
  }();
  this.setTextureCube = /* @__PURE__ */ function() {
    var warned = false;
    return function setTextureCube(texture, slot) {
      if (texture && texture.isWebGLRenderTargetCube) {
        if (!warned) {
          console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warned = true;
        }
        texture = texture.texture;
      }
      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        textures.setTextureCube(texture, slot);
      } else {
        textures.setTextureCubeDynamic(texture, slot);
      }
    };
  }();
  this.setFramebuffer = function(value) {
    _framebuffer = value;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTarget = function(renderTarget) {
    _currentRenderTarget = renderTarget;
    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
      textures.setupRenderTarget(renderTarget);
    }
    var framebuffer = _framebuffer;
    var isCube = false;
    if (renderTarget) {
      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLRenderTargetCube) {
        framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
      _currentScissorTest = _scissorTest;
    }
    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      _currentFramebuffer = framebuffer;
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      var textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
    }
  };
  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer2) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (framebuffer) {
      var restore = false;
      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        restore = true;
      }
      try {
        var texture = renderTarget.texture;
        var textureFormat = texture.format;
        var textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer2);
          }
        } else {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
        }
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level) {
    var width = texture.image.width;
    var height = texture.image.height;
    var glFormat = utils.convert(texture.format);
    this.setTexture2D(texture, 0);
    _gl.copyTexImage2D(_gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0);
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
    var width = srcTexture.image.width;
    var height = srcTexture.image.height;
    var glFormat = utils.convert(dstTexture.format);
    var glType = utils.convert(dstTexture.type);
    this.setTexture2D(dstTexture, 0);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
    }
  };
}
function FogExp2(color2, density) {
  this.name = "";
  this.color = new Color(color2);
  this.density = density !== void 0 ? density : 25e-5;
}
FogExp2.prototype.isFogExp2 = true;
FogExp2.prototype.clone = function() {
  return new FogExp2(this.color, this.density);
};
FogExp2.prototype.toJSON = function() {
  return {
    type: "FogExp2",
    color: this.color.getHex(),
    density: this.density
  };
};
function Fog(color2, near, far) {
  this.name = "";
  this.color = new Color(color2);
  this.near = near !== void 0 ? near : 1;
  this.far = far !== void 0 ? far : 1e3;
}
Fog.prototype.isFog = true;
Fog.prototype.clone = function() {
  return new Fog(this.color, this.near, this.far);
};
Fog.prototype.toJSON = function() {
  return {
    type: "Fog",
    color: this.color.getHex(),
    near: this.near,
    far: this.far
  };
};
function Scene() {
  Object3D.call(this);
  this.type = "Scene";
  this.background = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true;
}
Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  copy: function(source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  },
  dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  }
});
function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== void 0 ? array.length / stride : 0;
  this.dynamic = false;
  this.updateRange = { offset: 0, count: -1 };
  this.version = 0;
}
Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
  set: function(value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function() {
  },
  setArray: function(array) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.count = array !== void 0 ? array.length / this.stride : 0;
    this.array = array;
    return this;
  },
  setDynamic: function(value) {
    this.dynamic = value;
    return this;
  },
  copy: function(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.dynamic = source.dynamic;
    return this;
  },
  copyAt: function(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (var i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  },
  set: function(value, offset) {
    if (offset === void 0) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  onUpload: function(callback) {
    this.onUploadCallback = callback;
    return this;
  }
});
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function() {
      return this.data.count;
    }
  },
  array: {
    get: function() {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  setX: function(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function(index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function(index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function(index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function(index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function(index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
});
function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = "SpriteMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.lights = false;
  this.transparent = true;
  this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
var geometry;
function Sprite(material) {
  Object3D.call(this);
  this.type = "Sprite";
  if (geometry === void 0) {
    geometry = new BufferGeometry();
    var float32Array = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0,
      0.5,
      -0.5,
      0,
      1,
      0,
      0.5,
      0.5,
      0,
      1,
      1,
      -0.5,
      0.5,
      0,
      0,
      1
    ]);
    var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
    geometry.setIndex([0, 1, 2, 0, 2, 3]);
    geometry.addAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
    geometry.addAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }
  this.geometry = geometry;
  this.material = material !== void 0 ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function() {
    var intersectPoint = new Vector3();
    var worldScale = new Vector3();
    var mvPosition = new Vector3();
    var alignedPosition = new Vector2();
    var rotatedPosition = new Vector2();
    var viewWorldMatrix = new Matrix4();
    var vA = new Vector3();
    var vB = new Vector3();
    var vC = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    function transformVertex(vertexPosition, mvPosition2, center, scale2, sin2, cos2) {
      alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale2);
      if (sin2 !== void 0) {
        rotatedPosition.x = cos2 * alignedPosition.x - sin2 * alignedPosition.y;
        rotatedPosition.y = sin2 * alignedPosition.x + cos2 * alignedPosition.y;
      } else {
        rotatedPosition.copy(alignedPosition);
      }
      vertexPosition.copy(mvPosition2);
      vertexPosition.x += rotatedPosition.x;
      vertexPosition.y += rotatedPosition.y;
      vertexPosition.applyMatrix4(viewWorldMatrix);
    }
    return function raycast(raycaster, intersects2) {
      worldScale.setFromMatrixScale(this.matrixWorld);
      viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
      mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      var rotation = this.material.rotation;
      var sin2, cos2;
      if (rotation !== 0) {
        cos2 = Math.cos(rotation);
        sin2 = Math.sin(rotation);
      }
      var center = this.center;
      transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin2, cos2);
      transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin2, cos2);
      transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin2, cos2);
      uvA.set(0, 0);
      uvB.set(1, 0);
      uvC.set(1, 1);
      var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);
      if (intersect === null) {
        transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin2, cos2);
        uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      var distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance2 < raycaster.near || distance2 > raycaster.far) return;
      intersects2.push({
        distance: distance2,
        point: intersectPoint.clone(),
        uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
        face: null,
        object: this
      });
    };
  }(),
  clone: function() {
    return new this.constructor(this.material).copy(this);
  },
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== void 0) this.center.copy(source.center);
    return this;
  }
});
function LOD() {
  Object3D.call(this);
  this.type = "LOD";
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
}
LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source, false);
    var levels = source.levels;
    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }
    return this;
  },
  addLevel: function(object, distance2) {
    if (distance2 === void 0) distance2 = 0;
    distance2 = Math.abs(distance2);
    var levels = this.levels;
    for (var l = 0; l < levels.length; l++) {
      if (distance2 < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, { distance: distance2, object });
    this.add(object);
  },
  getObjectForDistance: function(distance2) {
    var levels = this.levels;
    for (var i = 1, l = levels.length; i < l; i++) {
      if (distance2 < levels[i].distance) {
        break;
      }
    }
    return levels[i - 1].object;
  },
  raycast: function() {
    var matrixPosition = new Vector3();
    return function raycast(raycaster, intersects2) {
      matrixPosition.setFromMatrixPosition(this.matrixWorld);
      var distance2 = raycaster.ray.origin.distanceTo(matrixPosition);
      this.getObjectForDistance(distance2).raycast(raycaster, intersects2);
    };
  }(),
  update: function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    return function update2(camera) {
      var levels = this.levels;
      if (levels.length > 1) {
        v1.setFromMatrixPosition(camera.matrixWorld);
        v2.setFromMatrixPosition(this.matrixWorld);
        var distance2 = v1.distanceTo(v2);
        levels[0].object.visible = true;
        for (var i = 1, l = levels.length; i < l; i++) {
          if (distance2 >= levels[i].distance) {
            levels[i - 1].object.visible = false;
            levels[i].object.visible = true;
          } else {
            break;
          }
        }
        for (; i < l; i++) {
          levels[i].object.visible = false;
        }
      }
    };
  }(),
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.levels = [];
    var levels = this.levels;
    for (var i = 0, l = levels.length; i < l; i++) {
      var level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }
    return data;
  }
});
function SkinnedMesh(geometry2, material) {
  if (geometry2 && geometry2.isGeometry) {
    console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
  Mesh.call(this, geometry2, material);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  bind: function(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function() {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function() {
    var vector = new Vector4();
    var skinWeight = this.geometry.attributes.skinWeight;
    for (var i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      var scale2 = 1 / vector.manhattanLength();
      if (scale2 !== Infinity) {
        vector.multiplyScalar(scale2);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function(force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  },
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function Skeleton(bones, boneInverses) {
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  if (boneInverses === void 0) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn("THREE.Skeleton boneInverses is the wrong length.");
      this.boneInverses = [];
      for (var i = 0, il = this.bones.length; i < il; i++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}
Object.assign(Skeleton.prototype, {
  calculateInverses: function() {
    this.boneInverses = [];
    for (var i = 0, il = this.bones.length; i < il; i++) {
      var inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.getInverse(this.bones[i].matrixWorld);
      }
      this.boneInverses.push(inverse);
    }
  },
  pose: function() {
    var bone, i, il;
    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i]);
      }
    }
    for (i = 0, il = this.bones.length; i < il; i++) {
      bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function() {
    var offsetMatrix = new Matrix4();
    var identityMatrix = new Matrix4();
    return function update2() {
      var bones = this.bones;
      var boneInverses = this.boneInverses;
      var boneMatrices = this.boneMatrices;
      var boneTexture = this.boneTexture;
      for (var i = 0, il = bones.length; i < il; i++) {
        var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
        offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
        offsetMatrix.toArray(boneMatrices, i * 16);
      }
      if (boneTexture !== void 0) {
        boneTexture.needsUpdate = true;
      }
    };
  }(),
  clone: function() {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function(name) {
    for (var i = 0, il = this.bones.length; i < il; i++) {
      var bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
});
function Bone() {
  Object3D.call(this);
  this.type = "Bone";
}
Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = "LineBasicMaterial";
  this.color = new Color(16777215);
  this.linewidth = 1;
  this.linecap = "round";
  this.linejoin = "round";
  this.lights = false;
  this.setValues(parameters);
}
LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;
LineBasicMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  return this;
};
function Line(geometry2, material, mode) {
  if (mode === 1) {
    console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
  }
  Object3D.call(this);
  this.type = "Line";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new LineBasicMaterial({ color: Math.random() * 16777215 });
}
Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  computeLineDistances: function() {
    var start2 = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry2 = this.geometry;
      if (geometry2.isBufferGeometry) {
        if (geometry2.index === null) {
          var positionAttribute = geometry2.attributes.position;
          var lineDistances = [0];
          for (var i = 1, l = positionAttribute.count; i < l; i++) {
            start2.fromBufferAttribute(positionAttribute, i - 1);
            end.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += start2.distanceTo(end);
          }
          geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var lineDistances = geometry2.lineDistances;
        lineDistances[0] = 0;
        for (var i = 1, l = vertices.length; i < l; i++) {
          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
        }
      }
      return this;
    };
  }(),
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var precision = raycaster.linePrecision;
      var geometry2 = this.geometry;
      var matrixWorld = this.matrixWorld;
      if (geometry2.boundingSphere === null) geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += precision;
      if (raycaster.ray.intersectsSphere(sphere) === false) return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localPrecisionSq = localPrecision * localPrecision;
      var vStart = new Vector3();
      var vEnd = new Vector3();
      var interSegment = new Vector3();
      var interRay = new Vector3();
      var step2 = this && this.isLineSegments ? 2 : 1;
      if (geometry2.isBufferGeometry) {
        var index = geometry2.index;
        var attributes = geometry2.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
          var indices = index.array;
          for (var i = 0, l = indices.length - 1; i < l; i += step2) {
            var a = indices[i];
            var b = indices[i + 1];
            vStart.fromArray(positions, a * 3);
            vEnd.fromArray(positions, b * 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance2 = raycaster.ray.origin.distanceTo(interRay);
            if (distance2 < raycaster.near || distance2 > raycaster.far) continue;
            intersects2.push({
              distance: distance2,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          for (var i = 0, l = positions.length / 3 - 1; i < l; i += step2) {
            vStart.fromArray(positions, 3 * i);
            vEnd.fromArray(positions, 3 * i + 3);
            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localPrecisionSq) continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance2 = raycaster.ray.origin.distanceTo(interRay);
            if (distance2 < raycaster.near || distance2 > raycaster.far) continue;
            intersects2.push({
              distance: distance2,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var nbVertices = vertices.length;
        for (var i = 0; i < nbVertices - 1; i += step2) {
          var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
          if (distSq > localPrecisionSq) continue;
          interRay.applyMatrix4(this.matrixWorld);
          var distance2 = raycaster.ray.origin.distanceTo(interRay);
          if (distance2 < raycaster.near || distance2 > raycaster.far) continue;
          intersects2.push({
            distance: distance2,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    };
  }(),
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.geometry.copy(source.geometry);
    this.material.copy(source.material);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function LineSegments(geometry2, material) {
  Line.call(this, geometry2, material);
  this.type = "LineSegments";
}
LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function() {
    var start2 = new Vector3();
    var end = new Vector3();
    return function computeLineDistances() {
      var geometry2 = this.geometry;
      if (geometry2.isBufferGeometry) {
        if (geometry2.index === null) {
          var positionAttribute = geometry2.attributes.position;
          var lineDistances = [];
          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
            start2.fromBufferAttribute(positionAttribute, i);
            end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + start2.distanceTo(end);
          }
          geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry2.isGeometry) {
        var vertices = geometry2.vertices;
        var lineDistances = geometry2.lineDistances;
        for (var i = 0, l = vertices.length; i < l; i += 2) {
          start2.copy(vertices[i]);
          end.copy(vertices[i + 1]);
          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + start2.distanceTo(end);
        }
      }
      return this;
    };
  }()
});
function LineLoop(geometry2, material) {
  Line.call(this, geometry2, material);
  this.type = "LineLoop";
}
LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
function PointsMaterial(parameters) {
  Material.call(this);
  this.type = "PointsMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.lights = false;
  this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
function Points(geometry2, material) {
  Object3D.call(this);
  this.type = "Points";
  this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
  this.material = material !== void 0 ? material : new PointsMaterial({ color: Math.random() * 16777215 });
}
Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  raycast: function() {
    var inverseMatrix = new Matrix4();
    var ray = new Ray();
    var sphere = new Sphere();
    return function raycast(raycaster, intersects2) {
      var object = this;
      var geometry2 = this.geometry;
      var matrixWorld = this.matrixWorld;
      var threshold2 = raycaster.params.Points.threshold;
      if (geometry2.boundingSphere === null) geometry2.computeBoundingSphere();
      sphere.copy(geometry2.boundingSphere);
      sphere.applyMatrix4(matrixWorld);
      sphere.radius += threshold2;
      if (raycaster.ray.intersectsSphere(sphere) === false) return;
      inverseMatrix.getInverse(matrixWorld);
      ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
      var localThreshold = threshold2 / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      var localThresholdSq = localThreshold * localThreshold;
      var position = new Vector3();
      var intersectPoint = new Vector3();
      function testPoint(point, index2) {
        var rayPointDistanceSq = ray.distanceSqToPoint(point);
        if (rayPointDistanceSq < localThresholdSq) {
          ray.closestPointToPoint(point, intersectPoint);
          intersectPoint.applyMatrix4(matrixWorld);
          var distance2 = raycaster.ray.origin.distanceTo(intersectPoint);
          if (distance2 < raycaster.near || distance2 > raycaster.far) return;
          intersects2.push({
            distance: distance2,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint.clone(),
            index: index2,
            face: null,
            object
          });
        }
      }
      if (geometry2.isBufferGeometry) {
        var index = geometry2.index;
        var attributes = geometry2.attributes;
        var positions = attributes.position.array;
        if (index !== null) {
          var indices = index.array;
          for (var i = 0, il = indices.length; i < il; i++) {
            var a = indices[i];
            position.fromArray(positions, a * 3);
            testPoint(position, a);
          }
        } else {
          for (var i = 0, l = positions.length / 3; i < l; i++) {
            position.fromArray(positions, i * 3);
            testPoint(position, i);
          }
        }
      } else {
        var vertices = geometry2.vertices;
        for (var i = 0, l = vertices.length; i < l; i++) {
          testPoint(vertices[i], i);
        }
      }
    };
  }(),
  clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  }
});
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== void 0 ? format : RGBFormat;
  this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
  this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
  this.generateMipmaps = false;
}
VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function() {
    var video = this.image;
    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = { width, height };
  this.mipmaps = mipmaps;
  this.flipY = false;
  this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== void 0 ? format : DepthFormat;
  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
  }
  if (type === void 0 && format === DepthFormat) type = UnsignedShortType;
  if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = { width, height };
  this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
  this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
function CfxTexture() {
  var data = new Uint8Array(3);
  var width = 1;
  var height = 1;
  var format = RGBFormat;
  Texture.call(this, null, void 0, void 0, void 0, void 0, void 0, format, void 0, void 0, void 0);
  this.image = { data, width, height };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
}
CfxTexture.prototype = Object.create(Texture.prototype);
CfxTexture.prototype.constructor = CfxTexture;
CfxTexture.prototype.isDataTexture = true;
CfxTexture.prototype.isCfxTexture = true;
function WireframeGeometry(geometry2) {
  BufferGeometry.call(this);
  this.type = "WireframeGeometry";
  var vertices = [];
  var i, j, l, o, ol;
  var edge = [0, 0], edges = {}, e, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var vertex;
  if (geometry2 && geometry2.isGeometry) {
    var faces = geometry2.faces;
    for (i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + "," + edge[1];
        if (edges[key] === void 0) {
          edges[key] = { index1: edge[0], index2: edge[1] };
        }
      }
    }
    for (key in edges) {
      e = edges[key];
      vertex = geometry2.vertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry2.vertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry2 && geometry2.isBufferGeometry) {
    var position, indices, groups;
    var group, start2, count2;
    var index1, index2;
    vertex = new Vector3();
    if (geometry2.index !== null) {
      position = geometry2.attributes.position;
      indices = geometry2.index;
      groups = geometry2.groups;
      if (groups.length === 0) {
        groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
      }
      for (o = 0, ol = groups.length; o < ol; ++o) {
        group = groups[o];
        start2 = group.start;
        count2 = group.count;
        for (i = start2, l = start2 + count2; i < l; i += 3) {
          for (j = 0; j < 3; j++) {
            edge1 = indices.getX(i + j);
            edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2);
            edge[1] = Math.max(edge1, edge2);
            key = edge[0] + "," + edge[1];
            if (edges[key] === void 0) {
              edges[key] = { index1: edge[0], index2: edge[1] };
            }
          }
        }
      }
      for (key in edges) {
        e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      position = geometry2.attributes.position;
      for (i = 0, l = position.count / 3; i < l; i++) {
        for (j = 0; j < 3; j++) {
          index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = "ParametricBufferGeometry";
  this.parameters = {
    func,
    slices,
    stacks
  };
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var EPS = 1e-5;
  var normal = new Vector3();
  var p0 = new Vector3(), p1 = new Vector3();
  var pu = new Vector3(), pv = new Vector3();
  var i, j;
  if (func.length < 3) {
    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  }
  var sliceCount = slices + 1;
  for (i = 0; i <= stacks; i++) {
    var v = i / stacks;
    for (j = 0; j <= slices; j++) {
      var u = j / slices;
      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z);
      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }
      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      }
      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, v);
    }
  }
  for (i = 0; i < stacks; i++) {
    for (j = 0; j < slices; j++) {
      var a = i * sliceCount + j;
      var b = i * sliceCount + j + 1;
      var c = (i + 1) * sliceCount + j + 1;
      var d = (i + 1) * sliceCount + j;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = "PolyhedronGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}
PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = "PolyhedronBufferGeometry";
  this.parameters = {
    vertices,
    indices,
    radius,
    detail
  };
  radius = radius || 1;
  detail = detail || 0;
  var vertexBuffer = [];
  var uvBuffer = [];
  subdivide(detail);
  appplyRadius(radius);
  generateUVs();
  this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
  this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
  if (detail === 0) {
    this.computeVertexNormals();
  } else {
    this.normalizeNormals();
  }
  function subdivide(detail2) {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    for (var i = 0; i < indices.length; i += 3) {
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c);
      subdivideFace(a, b, c, detail2);
    }
  }
  function subdivideFace(a, b, c, detail2) {
    var cols = Math.pow(2, detail2);
    var v = [];
    var i, j;
    for (i = 0; i <= cols; i++) {
      v[i] = [];
      var aj = a.clone().lerp(c, i / cols);
      var bj = b.clone().lerp(c, i / cols);
      var rows = cols - i;
      for (j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    }
    for (i = 0; i < cols; i++) {
      for (j = 0; j < 2 * (cols - i) - 1; j++) {
        var k = Math.floor(j / 2);
        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }
  function appplyRadius(radius2) {
    var vertex = new Vector3();
    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      vertex.normalize().multiplyScalar(radius2);
      vertexBuffer[i + 0] = vertex.x;
      vertexBuffer[i + 1] = vertex.y;
      vertexBuffer[i + 2] = vertex.z;
    }
  }
  function generateUVs() {
    var vertex = new Vector3();
    for (var i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      var u = azimuth(vertex) / 2 / Math.PI + 0.5;
      var v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }
    correctUVs();
    correctSeam();
  }
  function correctSeam() {
    for (var i = 0; i < uvBuffer.length; i += 6) {
      var x0 = uvBuffer[i + 0];
      var x1 = uvBuffer[i + 2];
      var x2 = uvBuffer[i + 4];
      var max2 = Math.max(x0, x1, x2);
      var min2 = Math.min(x0, x1, x2);
      if (max2 > 0.9 && min2 < 0.1) {
        if (x0 < 0.2) uvBuffer[i + 0] += 1;
        if (x1 < 0.2) uvBuffer[i + 2] += 1;
        if (x2 < 0.2) uvBuffer[i + 4] += 1;
      }
    }
  }
  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }
  function getVertexByIndex(index, vertex) {
    var stride = index * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }
  function correctUVs() {
    var a = new Vector3();
    var b = new Vector3();
    var c = new Vector3();
    var centroid = new Vector3();
    var uvA = new Vector2();
    var uvB = new Vector2();
    var uvC = new Vector2();
    for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      var azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }
  function correctUV(uv, stride, vector, azimuth2) {
    if (azimuth2 < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }
    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  }
  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}
PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "TetrahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
function TetrahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    1,
    -1,
    -1
  ];
  var indices = [
    2,
    1,
    0,
    0,
    3,
    2,
    1,
    3,
    0,
    2,
    3,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "TetrahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "OctahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry;
function OctahedronBufferGeometry(radius, detail) {
  var vertices = [
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    -1
  ];
  var indices = [
    0,
    2,
    4,
    0,
    4,
    3,
    0,
    3,
    5,
    0,
    5,
    2,
    1,
    2,
    5,
    1,
    5,
    3,
    1,
    3,
    4,
    1,
    4,
    2
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "OctahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "IcosahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
function IcosahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var vertices = [
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    t,
    0,
    -1,
    t,
    0,
    1,
    -t,
    0,
    -1,
    -t,
    0,
    1
  ];
  var indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "IcosahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = "DodecahedronGeometry";
  this.parameters = {
    radius,
    detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}
DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
function DodecahedronBufferGeometry(radius, detail) {
  var t = (1 + Math.sqrt(5)) / 2;
  var r = 1 / t;
  var vertices = [
    // (1, 1, 1)
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    -1,
    1,
    1,
    1,
    // (0, 1/, )
    0,
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    // (1/, , 0)
    -r,
    -t,
    0,
    -r,
    t,
    0,
    r,
    -t,
    0,
    r,
    t,
    0,
    // (, 0, 1/)
    -t,
    0,
    -r,
    t,
    0,
    -r,
    -t,
    0,
    r,
    t,
    0,
    r
  ];
  var indices = [
    3,
    11,
    7,
    3,
    7,
    15,
    3,
    15,
    13,
    7,
    19,
    17,
    7,
    17,
    6,
    7,
    6,
    15,
    17,
    4,
    8,
    17,
    8,
    10,
    17,
    10,
    6,
    8,
    0,
    16,
    8,
    16,
    2,
    8,
    2,
    10,
    0,
    12,
    1,
    0,
    1,
    18,
    0,
    18,
    16,
    6,
    10,
    2,
    6,
    2,
    13,
    6,
    13,
    15,
    2,
    16,
    18,
    2,
    18,
    3,
    2,
    3,
    13,
    18,
    1,
    9,
    18,
    9,
    11,
    18,
    11,
    3,
    4,
    14,
    12,
    4,
    12,
    0,
    4,
    0,
    8,
    11,
    9,
    5,
    11,
    5,
    19,
    11,
    19,
    7,
    19,
    5,
    14,
    19,
    14,
    4,
    19,
    4,
    17,
    1,
    12,
    14,
    1,
    14,
    5,
    1,
    5,
    9
  ];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = "DodecahedronBufferGeometry";
  this.parameters = {
    radius,
    detail
  };
}
DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = "TubeGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  if (taper !== void 0) console.warn("THREE.TubeGeometry: taper has been removed.");
  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals;
  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}
TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry;
function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = "TubeBufferGeometry";
  this.parameters = {
    path,
    tubularSegments,
    radius,
    radialSegments,
    closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  var frames = path.computeFrenetFrames(tubularSegments, closed);
  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals;
  var vertex = new Vector3();
  var normal = new Vector3();
  var uv = new Vector2();
  var P2 = new Vector3();
  var i, j;
  var vertices = [];
  var normals = [];
  var uvs = [];
  var indices = [];
  generateBufferData();
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateBufferData() {
    for (i = 0; i < tubularSegments; i++) {
      generateSegment(i);
    }
    generateSegment(closed === false ? tubularSegments : 0);
    generateUVs();
    generateIndices();
  }
  function generateSegment(i2) {
    P2 = path.getPointAt(i2 / tubularSegments, P2);
    var N = frames.normals[i2];
    var B = frames.binormals[i2];
    for (j = 0; j <= radialSegments; j++) {
      var v = j / radialSegments * Math.PI * 2;
      var sin2 = Math.sin(v);
      var cos2 = -Math.cos(v);
      normal.x = cos2 * N.x + sin2 * B.x;
      normal.y = cos2 * N.y + sin2 * B.y;
      normal.z = cos2 * N.z + sin2 * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z);
      vertex.x = P2.x + radius * normal.x;
      vertex.y = P2.y + radius * normal.y;
      vertex.z = P2.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  function generateIndices() {
    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }
  function generateUVs() {
    for (i = 0; i <= tubularSegments; i++) {
      for (j = 0; j <= radialSegments; j++) {
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}
TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = "TorusKnotGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  if (heightScale !== void 0) console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}
TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = "TorusKnotBufferGeometry";
  this.parameters = {
    radius,
    tube,
    tubularSegments,
    radialSegments,
    p,
    q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i, j;
  var vertex = new Vector3();
  var normal = new Vector3();
  var P1 = new Vector3();
  var P2 = new Vector3();
  var B = new Vector3();
  var T = new Vector3();
  var N = new Vector3();
  for (i = 0; i <= tubularSegments; ++i) {
    var u = i / tubularSegments * p * Math.PI * 2;
    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T);
    B.normalize();
    N.normalize();
    for (j = 0; j <= radialSegments; ++j) {
      var v = j / radialSegments * Math.PI * 2;
      var cx = -tube * Math.cos(v);
      var cy = tube * Math.sin(v);
      vertex.x = P1.x + (cx * N.x + cy * B.x);
      vertex.y = P1.y + (cx * N.y + cy * B.y);
      vertex.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= tubularSegments; j++) {
    for (i = 1; i <= radialSegments; i++) {
      var a = (radialSegments + 1) * (j - 1) + (i - 1);
      var b = (radialSegments + 1) * j + (i - 1);
      var c = (radialSegments + 1) * j + i;
      var d = (radialSegments + 1) * (j - 1) + i;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function calculatePositionOnCurve(u2, p2, q2, radius2, position) {
    var cu = Math.cos(u2);
    var su = Math.sin(u2);
    var quOverP = q2 / p2 * u2;
    var cs = Math.cos(quOverP);
    position.x = radius2 * (2 + cs) * 0.5 * cu;
    position.y = radius2 * (2 + cs) * su * 0.5;
    position.z = radius2 * Math.sin(quOverP) * 0.5;
  }
}
TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = "TorusGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}
TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry;
function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = "TorusBufferGeometry";
  this.parameters = {
    radius,
    tube,
    radialSegments,
    tubularSegments,
    arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var center = new Vector3();
  var vertex = new Vector3();
  var normal = new Vector3();
  var j, i;
  for (j = 0; j <= radialSegments; j++) {
    for (i = 0; i <= tubularSegments; i++) {
      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;
      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex.z = tube * Math.sin(v);
      vertices.push(vertex.x, vertex.y, vertex.z);
      center.x = radius * Math.cos(u);
      center.y = radius * Math.sin(u);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  }
  for (j = 1; j <= radialSegments; j++) {
    for (i = 1; i <= tubularSegments; i++) {
      var a = (tubularSegments + 1) * j + i - 1;
      var b = (tubularSegments + 1) * (j - 1) + i - 1;
      var c = (tubularSegments + 1) * (j - 1) + i;
      var d = (tubularSegments + 1) * j + i;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
var Earcut = {
  triangulate: function(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
    if (!outerNode) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
};
function linkedList(data, start2, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start2, end, dim) > 0) {
    for (i = start2; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start2; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end) {
  if (!start2) return start2;
  if (!end) end = start2;
  var p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop2 = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop2 = next.next;
      continue;
    }
    ear = next;
    if (ear === stop2) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  var p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
      return false;
    }
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  var p = ear.nextZ;
  while (p && p.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.nextZ;
  }
  p = ear.prevZ;
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  var p = start2;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return p;
}
function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
  var a = start2;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start2, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start2 = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start2, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    var b = splitPolygon(outerNode, hole);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  if (hx === qx) return m.prev;
  var stop2 = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
  p = m.next;
  while (p !== stop2) {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if ((tan2 < tanMin || tan2 === tanMin && p.x > m.x) && locallyInside(p, hole)) {
        m = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  }
  return m;
}
function indexCurve(start2, minX, minY, invSize) {
  var p = start2;
  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start2) {
  var p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x) leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
      return true;
    }
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x) {
      inside = !inside;
    }
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start2, end, dim) {
  var sum2 = 0;
  for (var i = start2, j = end - dim; i < end; i += dim) {
    sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum2;
}
var ShapeUtils = {
  // calculate area of the contour polygon
  area: function(contour) {
    var n = contour.length;
    var a = 0;
    for (var p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  },
  isClockWise: function(pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function(contour, holes) {
    var vertices = [];
    var holeIndices = [];
    var faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    var holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (var i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    var triangles = Earcut.triangulate(vertices, holeIndices);
    for (var i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  var l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (var i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = "ExtrudeGeometry";
  this.parameters = {
    shapes,
    options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}
ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
ExtrudeGeometry.prototype.toJSON = function() {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON$1(shapes, options, data);
};
function ExtrudeBufferGeometry(shapes, options) {
  BufferGeometry.call(this);
  this.type = "ExtrudeBufferGeometry";
  this.parameters = {
    shapes,
    options
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  var scope = this;
  var verticesArray = [];
  var uvArray = [];
  for (var i = 0, l = shapes.length; i < l; i++) {
    var shape = shapes[i];
    addShape(shape);
  }
  this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals();
  function addShape(shape2) {
    var placeholder = [];
    var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
    var steps2 = options.steps !== void 0 ? options.steps : 1;
    var depth = options.depth !== void 0 ? options.depth : 100;
    var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
    var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
    var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
    var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
    var extrudePath = options.extrudePath;
    var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
    if (options.amount !== void 0) {
      console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
      depth = options.amount;
    }
    var extrudePts, extrudeByPath = false;
    var splineTube, binormal, normal, position2;
    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps2);
      extrudeByPath = true;
      bevelEnabled = false;
      splineTube = extrudePath.computeFrenetFrames(steps2, false);
      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    }
    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
    }
    var ahole, h, hl;
    var shapePoints = shape2.extractPoints(curveSegments);
    var vertices = shapePoints.shape;
    var holes = shapePoints.holes;
    var reverse2 = !ShapeUtils.isClockWise(vertices);
    if (reverse2) {
      vertices = vertices.reverse();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        if (ShapeUtils.isClockWise(ahole)) {
          holes[h] = ahole.reverse();
        }
      }
    }
    var faces = ShapeUtils.triangulateShape(vertices, holes);
    var contour = vertices;
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      vertices = vertices.concat(ahole);
    }
    function scalePt2(pt, vec, size) {
      if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }
    var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
    function getBevelVec(inPt, inPrev, inNext) {
      var v_trans_x, v_trans_y, shrink_by;
      var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
      var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
      if (Math.abs(collinear0) > Number.EPSILON) {
        var v_prev_len = Math.sqrt(v_prev_lensq);
        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
        var ptNextShift_y = inNext.y + v_next_x / v_next_len;
        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        var direction_eq = false;
        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }
        if (direction_eq) {
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }
      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }
    var contourMovements = [];
    for (var i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
      if (j === il) j = 0;
      if (k === il) k = 0;
      contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
    }
    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
    for (h = 0, hl = holes.length; h < hl; h++) {
      ahole = holes[h];
      oneHoleMovements = [];
      for (i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
      }
      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    }
    for (b = 0; b < bevelSegments; b++) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2);
      for (i2 = 0, il = contour.length; i2 < il; i2++) {
        vert = scalePt2(contour[i2], contourMovements[i2], bs);
        v(vert.x, vert.y, -z);
      }
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i2 = 0, il = ahole.length; i2 < il; i2++) {
          vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs);
          v(vert.x, vert.y, -z);
        }
      }
    }
    bs = bevelSize;
    for (i2 = 0; i2 < vlen; i2++) {
      vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    }
    var s;
    for (s = 1; s <= steps2; s++) {
      for (i2 = 0; i2 < vlen; i2++) {
        vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v(vert.x, vert.y, depth / steps2 * s);
        } else {
          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    }
    for (b = bevelSegments - 1; b >= 0; b--) {
      t = b / bevelSegments;
      z = bevelThickness * Math.cos(t * Math.PI / 2);
      bs = bevelSize * Math.sin(t * Math.PI / 2);
      for (i2 = 0, il = contour.length; i2 < il; i2++) {
        vert = scalePt2(contour[i2], contourMovements[i2], bs);
        v(vert.x, vert.y, depth + z);
      }
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = holesMovements[h];
        for (i2 = 0, il = ahole.length; i2 < il; i2++) {
          vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs);
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps2 - 1].y, extrudePts[steps2 - 1].x + z);
          }
        }
      }
    }
    buildLidFaces();
    buildSideFaces();
    function buildLidFaces() {
      var start2 = verticesArray.length / 3;
      if (bevelEnabled) {
        var layer = 0;
        var offset = vlen * layer;
        for (i2 = 0; i2 < flen; i2++) {
          face = faces[i2];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }
        layer = steps2 + bevelSegments * 2;
        offset = vlen * layer;
        for (i2 = 0; i2 < flen; i2++) {
          face = faces[i2];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        for (i2 = 0; i2 < flen; i2++) {
          face = faces[i2];
          f3(face[2], face[1], face[0]);
        }
        for (i2 = 0; i2 < flen; i2++) {
          face = faces[i2];
          f3(face[0] + vlen * steps2, face[1] + vlen * steps2, face[2] + vlen * steps2);
        }
      }
      scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
    }
    function buildSideFaces() {
      var start2 = verticesArray.length / 3;
      var layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        sidewalls(ahole, layeroffset);
        layeroffset += ahole.length;
      }
      scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
    }
    function sidewalls(contour2, layeroffset) {
      var j2, k3;
      i2 = contour2.length;
      while (--i2 >= 0) {
        j2 = i2;
        k3 = i2 - 1;
        if (k3 < 0) k3 = contour2.length - 1;
        var s2 = 0, sl = steps2 + bevelSegments * 2;
        for (s2 = 0; s2 < sl; s2++) {
          var slen1 = vlen * s2;
          var slen2 = vlen * (s2 + 1);
          var a = layeroffset + j2 + slen1, b2 = layeroffset + k3 + slen1, c = layeroffset + k3 + slen2, d = layeroffset + j2 + slen2;
          f4(a, b2, c, d);
        }
      }
    }
    function v(x, y, z2) {
      placeholder.push(x);
      placeholder.push(y);
      placeholder.push(z2);
    }
    function f3(a, b2, c) {
      addVertex(a);
      addVertex(b2);
      addVertex(c);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }
    function f4(a, b2, c, d) {
      addVertex(a);
      addVertex(b2);
      addVertex(d);
      addVertex(b2);
      addVertex(c);
      addVertex(d);
      var nextIndex = verticesArray.length / 3;
      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }
    function addVertex(index) {
      verticesArray.push(placeholder[index * 3 + 0]);
      verticesArray.push(placeholder[index * 3 + 1]);
      verticesArray.push(placeholder[index * 3 + 2]);
    }
    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}
ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
ExtrudeBufferGeometry.prototype.toJSON = function() {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  var options = this.parameters.options;
  return toJSON$1(shapes, options, data);
};
var WorldUVGenerator = {
  generateTopUV: function(geometry2, vertices, indexA, indexB, indexC) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry2, vertices, indexA, indexB, indexC, indexD) {
    var a_x = vertices[indexA * 3];
    var a_y = vertices[indexA * 3 + 1];
    var a_z = vertices[indexA * 3 + 2];
    var b_x = vertices[indexB * 3];
    var b_y = vertices[indexB * 3 + 1];
    var b_z = vertices[indexB * 3 + 2];
    var c_x = vertices[indexC * 3];
    var c_y = vertices[indexC * 3 + 1];
    var c_z = vertices[indexC * 3 + 2];
    var d_x = vertices[indexD * 3];
    var d_y = vertices[indexD * 3 + 1];
    var d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < 0.01) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = "TextGeometry";
  this.parameters = {
    text,
    parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}
TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry;
function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  var font = parameters.font;
  if (!(font && font.isFont)) {
    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
    return new Geometry();
  }
  var shapes = font.generateShapes(text, parameters.size);
  parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
  if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
  if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
  if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = "TextBufferGeometry";
}
TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "SphereGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}
SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry;
function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "SphereBufferGeometry";
  this.parameters = {
    radius,
    widthSegments,
    heightSegments,
    phiStart,
    phiLength,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== void 0 ? phiStart : 0;
  phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
  var thetaEnd = thetaStart + thetaLength;
  var ix, iy;
  var index = 0;
  var grid = [];
  var vertex = new Vector3();
  var normal = new Vector3();
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  for (iy = 0; iy <= heightSegments; iy++) {
    var verticesRow = [];
    var v = iy / heightSegments;
    for (ix = 0; ix <= widthSegments; ix++) {
      var u = ix / widthSegments;
      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normal.set(vertex.x, vertex.y, vertex.z).normalize();
      normals.push(normal.x, normal.y, normal.z);
      uvs.push(u, 1 - v);
      verticesRow.push(index++);
    }
    grid.push(verticesRow);
  }
  for (iy = 0; iy < heightSegments; iy++) {
    for (ix = 0; ix < widthSegments; ix++) {
      var a = grid[iy][ix + 1];
      var b = grid[iy][ix];
      var c = grid[iy + 1][ix];
      var d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "RingGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}
RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry;
function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "RingBufferGeometry";
  this.parameters = {
    innerRadius,
    outerRadius,
    thetaSegments,
    phiSegments,
    thetaStart,
    thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var segment;
  var radius = innerRadius;
  var radiusStep = (outerRadius - innerRadius) / phiSegments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var j, i;
  for (j = 0; j <= phiSegments; j++) {
    for (i = 0; i <= thetaSegments; i++) {
      segment = thetaStart + i / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    radius += radiusStep;
  }
  for (j = 0; j < phiSegments; j++) {
    var thetaSegmentLevel = j * (thetaSegments + 1);
    for (i = 0; i < thetaSegments; i++) {
      segment = i + thetaSegmentLevel;
      var a = segment;
      var b = segment + thetaSegments + 1;
      var c = segment + thetaSegments + 2;
      var d = segment + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = "LatheGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}
LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry;
function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = "LatheBufferGeometry";
  this.parameters = {
    points,
    segments,
    phiStart,
    phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2;
  phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
  var indices = [];
  var vertices = [];
  var uvs = [];
  var base;
  var inverseSegments = 1 / segments;
  var vertex = new Vector3();
  var uv = new Vector2();
  var i, j;
  for (i = 0; i <= segments; i++) {
    var phi = phiStart + i * inverseSegments * phiLength;
    var sin2 = Math.sin(phi);
    var cos2 = Math.cos(phi);
    for (j = 0; j <= points.length - 1; j++) {
      vertex.x = points[j].x * sin2;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos2;
      vertices.push(vertex.x, vertex.y, vertex.z);
      uv.x = i / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  }
  for (i = 0; i < segments; i++) {
    for (j = 0; j < points.length - 1; j++) {
      base = j + i * points.length;
      var a = base;
      var b = base + points.length;
      var c = base + points.length + 1;
      var d = base + 1;
      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  this.computeVertexNormals();
  if (phiLength === Math.PI * 2) {
    var normals = this.attributes.normal.array;
    var n1 = new Vector3();
    var n2 = new Vector3();
    var n = new Vector3();
    base = segments * points.length * 3;
    for (i = 0, j = 0; i < points.length; i++, j += 3) {
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2];
      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2];
      n.addVectors(n1, n2).normalize();
      normals[j + 0] = normals[base + j + 0] = n.x;
      normals[j + 1] = normals[base + j + 1] = n.y;
      normals[j + 2] = normals[base + j + 2] = n.z;
    }
  }
}
LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = "ShapeGeometry";
  if (typeof curveSegments === "object") {
    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
    curveSegments = curveSegments.curveSegments;
  }
  this.parameters = {
    shapes,
    curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}
ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;
ShapeGeometry.prototype.toJSON = function() {
  var data = Geometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON(shapes, data);
};
function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = "ShapeBufferGeometry";
  this.parameters = {
    shapes,
    curveSegments
  };
  curveSegments = curveSegments || 12;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var groupStart = 0;
  var groupCount = 0;
  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (var i = 0; i < shapes.length; i++) {
      addShape(shapes[i]);
      this.addGroup(groupStart, groupCount, i);
      groupStart += groupCount;
      groupCount = 0;
    }
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function addShape(shape) {
    var i2, l, shapeHole;
    var indexOffset = vertices.length / 3;
    var points = shape.extractPoints(curveSegments);
    var shapeVertices = points.shape;
    var shapeHoles = points.holes;
    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }
    for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
      shapeHole = shapeHoles[i2];
      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i2] = shapeHole.reverse();
      }
    }
    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
    for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
      shapeHole = shapeHoles[i2];
      shapeVertices = shapeVertices.concat(shapeHole);
    }
    for (i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
      var vertex = shapeVertices[i2];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y);
    }
    for (i2 = 0, l = faces.length; i2 < l; i2++) {
      var face = faces[i2];
      var a = face[0] + indexOffset;
      var b = face[1] + indexOffset;
      var c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}
ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
ShapeBufferGeometry.prototype.toJSON = function() {
  var data = BufferGeometry.prototype.toJSON.call(this);
  var shapes = this.parameters.shapes;
  return toJSON(shapes, data);
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
function EdgesGeometry(geometry2, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = "EdgesGeometry";
  this.parameters = {
    thresholdAngle
  };
  thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
  var vertices = [];
  var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
  var edge = [0, 0], edges = {}, edge1, edge2;
  var key, keys = ["a", "b", "c"];
  var geometry22;
  if (geometry2.isBufferGeometry) {
    geometry22 = new Geometry();
    geometry22.fromBufferGeometry(geometry2);
  } else {
    geometry22 = geometry2.clone();
  }
  geometry22.mergeVertices();
  geometry22.computeFaceNormals();
  var sourceVertices = geometry22.vertices;
  var faces = geometry22.faces;
  for (var i = 0, l = faces.length; i < l; i++) {
    var face = faces[i];
    for (var j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + "," + edge[1];
      if (edges[key] === void 0) {
        edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: void 0 };
      } else {
        edges[key].face2 = i;
      }
    }
  }
  for (key in edges) {
    var e = edges[key];
    if (e.face2 === void 0 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
      var vertex = sourceVertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
}
EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}
CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry;
function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CylinderBufferGeometry";
  this.parameters = {
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== void 0 ? radiusTop : 1;
  radiusBottom = radiusBottom !== void 0 ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== void 0 ? openEnded : false;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var index = 0;
  var indexArray = [];
  var halfHeight = height / 2;
  var groupStart = 0;
  generateTorso();
  if (openEnded === false) {
    if (radiusTop > 0) generateCap(true);
    if (radiusBottom > 0) generateCap(false);
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  function generateTorso() {
    var x, y;
    var normal = new Vector3();
    var vertex = new Vector3();
    var groupCount = 0;
    var slope = (radiusBottom - radiusTop) / height;
    for (y = 0; y <= heightSegments; y++) {
      var indexRow = [];
      var v = y / heightSegments;
      var radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);
        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, 1 - v);
        indexRow.push(index++);
      }
      indexArray.push(indexRow);
    }
    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < heightSegments; y++) {
        var a = indexArray[y][x];
        var b = indexArray[y + 1][x];
        var c = indexArray[y + 1][x + 1];
        var d = indexArray[y][x + 1];
        indices.push(a, b, d);
        indices.push(b, c, d);
        groupCount += 6;
      }
    }
    scope.addGroup(groupStart, groupCount, 0);
    groupStart += groupCount;
  }
  function generateCap(top) {
    var x, centerIndexStart, centerIndexEnd;
    var uv = new Vector2();
    var vertex = new Vector3();
    var groupCount = 0;
    var radius = top === true ? radiusTop : radiusBottom;
    var sign2 = top === true ? 1 : -1;
    centerIndexStart = index;
    for (x = 1; x <= radialSegments; x++) {
      vertices.push(0, halfHeight * sign2, 0);
      normals.push(0, sign2, 0);
      uvs.push(0.5, 0.5);
      index++;
    }
    centerIndexEnd = index;
    for (x = 0; x <= radialSegments; x++) {
      var u = x / radialSegments;
      var theta = u * thetaLength + thetaStart;
      var cosTheta = Math.cos(theta);
      var sinTheta = Math.sin(theta);
      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign2;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, sign2, 0);
      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign2 + 0.5;
      uvs.push(uv.x, uv.y);
      index++;
    }
    for (x = 0; x < radialSegments; x++) {
      var c = centerIndexStart + x;
      var i = centerIndexEnd + x;
      if (top === true) {
        indices.push(i, i + 1, c);
      } else {
        indices.push(i + 1, i, c);
      }
      groupCount += 3;
    }
    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
    groupStart += groupCount;
  }
}
CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry;
function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = "ConeBufferGeometry";
  this.parameters = {
    radius,
    height,
    radialSegments,
    heightSegments,
    openEnded,
    thetaStart,
    thetaLength
  };
}
ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = "CircleGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}
CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry;
function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = "CircleBufferGeometry";
  this.parameters = {
    radius,
    segments,
    thetaStart,
    thetaLength
  };
  radius = radius || 1;
  segments = segments !== void 0 ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== void 0 ? thetaStart : 0;
  thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
  var indices = [];
  var vertices = [];
  var normals = [];
  var uvs = [];
  var i, s;
  var vertex = new Vector3();
  var uv = new Vector2();
  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);
  for (s = 0, i = 3; s <= segments; s++, i += 3) {
    var segment = thetaStart + s / segments * thetaLength;
    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z);
    normals.push(0, 0, 1);
    uv.x = (vertices[i] / radius + 1) / 2;
    uv.y = (vertices[i + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  }
  for (i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
  }
  this.setIndex(indices);
  this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
  this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
}
CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
const Geometries = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BoxBufferGeometry,
  BoxGeometry,
  CircleBufferGeometry,
  CircleGeometry,
  ConeBufferGeometry,
  ConeGeometry,
  CylinderBufferGeometry,
  CylinderGeometry,
  DodecahedronBufferGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeBufferGeometry,
  ExtrudeGeometry,
  IcosahedronBufferGeometry,
  IcosahedronGeometry,
  LatheBufferGeometry,
  LatheGeometry,
  OctahedronBufferGeometry,
  OctahedronGeometry,
  ParametricBufferGeometry,
  ParametricGeometry,
  PlaneBufferGeometry,
  PlaneGeometry,
  PolyhedronBufferGeometry,
  PolyhedronGeometry,
  RingBufferGeometry,
  RingGeometry,
  ShapeBufferGeometry,
  ShapeGeometry,
  SphereBufferGeometry,
  SphereGeometry,
  TetrahedronBufferGeometry,
  TetrahedronGeometry,
  TextBufferGeometry,
  TextGeometry,
  TorusBufferGeometry,
  TorusGeometry,
  TorusKnotBufferGeometry,
  TorusKnotGeometry,
  TubeBufferGeometry,
  TubeGeometry,
  WireframeGeometry
}, Symbol.toStringTag, { value: "Module" }));
function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = "ShadowMaterial";
  this.color = new Color(0);
  this.transparent = true;
  this.setValues(parameters);
}
ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = "RawShaderMaterial";
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = { "STANDARD": "" };
  this.type = "MeshStandardMaterial";
  this.color = new Color(16777215);
  this.roughness = 0.5;
  this.metalness = 0.5;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = { "STANDARD": "" };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = { "PHYSICAL": "" };
  this.type = "MeshPhysicalMaterial";
  this.reflectivity = 0.5;
  this.clearCoat = 0;
  this.clearCoatRoughness = 0;
  this.setValues(parameters);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = { "PHYSICAL": "" };
  this.reflectivity = source.reflectivity;
  this.clearCoat = source.clearCoat;
  this.clearCoatRoughness = source.clearCoatRoughness;
  return this;
};
function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = "MeshPhongMaterial";
  this.color = new Color(16777215);
  this.specular = new Color(1118481);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshToonMaterial(parameters) {
  MeshPhongMaterial.call(this);
  this.defines = { "TOON": "" };
  this.type = "MeshToonMaterial";
  this.gradientMap = null;
  this.setValues(parameters);
}
MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
  MeshPhongMaterial.prototype.copy.call(this, source);
  this.gradientMap = source.gradientMap;
  return this;
};
function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = "MeshNormalMaterial";
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.lights = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = "MeshLambertMaterial";
  this.color = new Color(16777215);
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1;
  this.aoMap = null;
  this.aoMapIntensity = 1;
  this.emissive = new Color(0);
  this.emissiveIntensity = 1;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = "round";
  this.wireframeLinejoin = "round";
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}
MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = { "MATCAP": "" };
  this.type = "MeshMatcapMaterial";
  this.color = new Color(16777215);
  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.lights = false;
  this.setValues(parameters);
}
MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
  Material.prototype.copy.call(this, source);
  this.defines = { "MATCAP": "" };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = "LineDashedMaterial";
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};
const Materials = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineBasicMaterial,
  LineDashedMaterial,
  Material,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  PointsMaterial,
  RawShaderMaterial,
  ShaderMaterial,
  ShadowMaterial,
  SpriteMaterial
}, Symbol.toStringTag, { value: "Module" }));
var AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function(array, from, to2) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(array.subarray(from, to2 !== void 0 ? to2 : array.length));
    }
    return array.slice(from, to2);
  },
  // converts an array to a specific type
  convertArray: function(array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;
    if (typeof type.BYTES_PER_ELEMENT === "number") {
      return new type(array);
    }
    return Array.prototype.slice.call(array);
  },
  isTypedArray: function(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function(times) {
    function compareTime(i2, j) {
      return times[i2] - times[j];
    }
    var n = times.length;
    var result = new Array(n);
    for (var i = 0; i !== n; ++i) result[i] = i;
    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function(values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);
    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      var srcOffset = order[i] * stride;
      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
    var i = 1, key = jsonKeys[0];
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++];
    }
    if (key === void 0) return;
    var value = key[valuePropertyName];
    if (value === void 0) return;
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push.apply(values, value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    } else {
      do {
        value = key[valuePropertyName];
        if (value !== void 0) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== void 0);
    }
  }
};
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
  evaluate: function(t) {
    var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        var right;
        linear_scan: {
          forward_scan: if (!(t < t1)) {
            for (var giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t >= t0)) {
            var t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (var giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          var mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function(index) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  },
  // Template methods for derived classes:
  interpolate_: function() {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function() {
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function(i1, t0, t1) {
    var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    var sP = -wP * ppp + 2 * wP * pp - wP * p;
    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    var sN = wN * ppp - wN * pp;
    for (var i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
});
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (var i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
});
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function(i1) {
    return this.copySampleValue_(i1 - 1);
  }
});
function KeyframeTrack(name, times, values, interpolation) {
  if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
}
Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function(track) {
    var trackType = track.constructor;
    var json2;
    if (trackType.toJSON !== void 0) {
      json2 = trackType.toJSON(track);
    } else {
      json2 = {
        "name": track.name,
        "times": AnimationUtils.convertArray(track.times, Array),
        "values": AnimationUtils.convertArray(track.values, Array)
      };
      var interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json2.interpolation = interpolation;
      }
    }
    json2.type = track.ValueTypeName;
    return json2;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function(interpolation) {
    var factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function() {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function(timeOffset) {
    if (timeOffset !== 0) {
      var times = this.times;
      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function(timeScale) {
    if (timeScale !== 1) {
      var times = this.times;
      for (var i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function(startTime, endTime) {
    var times = this.times, nKeys = times.length, from = 0, to2 = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to2 !== -1 && times[to2] > endTime) {
      --to2;
    }
    ++to2;
    if (from !== 0 || to2 !== nKeys) {
      if (from >= to2) to2 = Math.max(to2, 1), from = to2 - 1;
      var stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to2);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to2 * stride);
    }
    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {
    var valid = true;
    var valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    var times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    var prevTime = null;
    for (var i = 0; i !== nKeys; i++) {
      var currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (var i = 0, n = values.length; i !== n; ++i) {
          var value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {
    var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
    for (var i = 1; i < lastIndex; ++i) {
      var keep2 = false;
      var time2 = times[i];
      var timeNext = times[i + 1];
      if (time2 !== timeNext && (i !== 1 || time2 !== time2[0])) {
        if (!smoothInterpolation) {
          var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (var j = 0; j !== stride; ++j) {
            var value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep2 = true;
              break;
            }
          }
        } else {
          keep2 = true;
        }
      }
      if (keep2) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          var readOffset = i * stride, writeOffset = writeIndex * stride;
          for (var j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    }
    return this;
  }
});
function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: "bool",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".
});
function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: "color"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.
});
function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: "number"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function(i1, t0, t, t1) {
    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha2 = (t - t0) / (t1 - t0);
    for (var end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha2);
    }
    return result;
  }
});
function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: "quaternion",
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: void 0
  // not yet implemented
});
function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: "string",
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: void 0,
  InterpolantFactoryMethodSmooth: void 0
});
function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: "vector"
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited
});
function AnimationClip(name, duration, tracks) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== void 0 ? duration : -1;
  this.uuid = _Math.generateUUID();
  if (this.duration < 0) {
    this.resetDuration();
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json2) {
  if (json2.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  var trackType = getTrackTypeForValueTypeName(json2.type);
  if (json2.times === void 0) {
    var times = [], values = [];
    AnimationUtils.flattenJSON(json2.keys, times, values, "value");
    json2.times = times;
    json2.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json2);
  } else {
    return new trackType(json2.name, json2.times, json2.values, json2.interpolation);
  }
}
Object.assign(AnimationClip, {
  parse: function(json2) {
    var tracks = [], jsonTracks = json2.tracks, frameTime = 1 / (json2.fps || 1);
    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    return new AnimationClip(json2.name, json2.duration, tracks);
  },
  toJSON: function(clip) {
    var tracks = [], clipTracks = clip.tracks;
    var json2 = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid
    };
    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json2;
  },
  CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];
    for (var i = 0; i < numMorphTargets; i++) {
      var times = [];
      var values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      var order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new AnimationClip(name, -1, tracks);
  },
  findByName: function(objectOrClipArray, name) {
    var clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      var o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (var i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  },
  CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
    var animationToMorphTargets = {};
    var pattern = /^([\w-]*?)([\d]+)$/;
    for (var i = 0, il = morphTargets.length; i < il; i++) {
      var morphTarget = morphTargets[i];
      var parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        var name = parts[1];
        var animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    var clips = [];
    for (var name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
      if (animationKeys2.length !== 0) {
        var times2 = [];
        var values2 = [];
        AnimationUtils.flattenJSON(animationKeys2, times2, values2, propertyName);
        if (times2.length !== 0) {
          destTracks.push(new trackType(trackName, times2, values2));
        }
      }
    };
    var tracks = [];
    var clipName = animation.name || "default";
    var duration = animation.length || -1;
    var fps = animation.fps || 30;
    var hierarchyTracks = animation.hierarchy || [];
    for (var h = 0; h < hierarchyTracks.length; h++) {
      var animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        var morphTargetNames = {};
        for (var k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (var morphTargetName in morphTargetNames) {
          var times = [];
          var values = [];
          for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            var animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * (fps || 1);
      } else {
        var boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    var clip = new AnimationClip(clipName, duration, tracks);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function() {
    var tracks = this.tracks, duration = 0;
    for (var i = 0, n = tracks.length; i !== n; ++i) {
      var track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  },
  trim: function() {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  },
  validate: function() {
    var valid = true;
    for (var i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  },
  optimize: function() {
    for (var i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
});
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
function LoadingManager(onLoad, onProgress, onError) {
  var scope = this;
  var isLoading = false;
  var itemsLoaded = 0;
  var itemsTotal = 0;
  var urlModifier = void 0;
  this.onStart = void 0;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;
  this.itemStart = function(url) {
    itemsTotal++;
    if (isLoading === false) {
      if (scope.onStart !== void 0) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }
    isLoading = true;
  };
  this.itemEnd = function(url) {
    itemsLoaded++;
    if (scope.onProgress !== void 0) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }
    if (itemsLoaded === itemsTotal) {
      isLoading = false;
      if (scope.onLoad !== void 0) {
        scope.onLoad();
      }
    }
  };
  this.itemError = function(url) {
    if (scope.onError !== void 0) {
      scope.onError(url);
    }
  };
  this.resolveURL = function(url) {
    if (urlModifier) {
      return urlModifier(url);
    }
    return url;
  };
  this.setURLModifier = function(transform2) {
    urlModifier = transform2;
    return this;
  };
}
var DefaultLoadingManager = new LoadingManager();
var loading = {};
function FileLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FileLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    var dataUriRegexResult = url.match(dataUriRegex);
    if (dataUriRegexResult) {
      var mimeType = dataUriRegexResult[1];
      var isBase64 = !!dataUriRegexResult[2];
      var data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);
      try {
        var response;
        var responseType = (this.responseType || "").toLowerCase();
        switch (responseType) {
          case "arraybuffer":
          case "blob":
            var view = new Uint8Array(data.length);
            for (var i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }
            if (responseType === "blob") {
              response = new Blob([view.buffer], { type: mimeType });
            } else {
              response = view.buffer;
            }
            break;
          case "document":
            var parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;
          case "json":
            response = JSON.parse(data);
            break;
          default:
            response = data;
            break;
        }
        setTimeout(function() {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        setTimeout(function() {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      loading[url] = [];
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      var request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.addEventListener("load", function(event) {
        var response2 = this.response;
        Cache.add(url, response2);
        var callbacks = loading[url];
        delete loading[url];
        if (this.status === 200 || this.status === 0) {
          if (this.status === 0) console.warn("THREE.FileLoader: HTTP Status 0 received.");
          for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
            var callback = callbacks[i2];
            if (callback.onLoad) callback.onLoad(response2);
          }
          scope.manager.itemEnd(url);
        } else {
          for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
            var callback = callbacks[i2];
            if (callback.onError) callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener("progress", function(event) {
        var callbacks = loading[url];
        for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
          var callback = callbacks[i2];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener("error", function(event) {
        var callbacks = loading[url];
        delete loading[url];
        for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
          var callback = callbacks[i2];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener("abort", function(event) {
        var callbacks = loading[url];
        delete loading[url];
        for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
          var callback = callbacks[i2];
          if (callback.onError) callback.onError(event);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== void 0) request.responseType = this.responseType;
      if (this.withCredentials !== void 0) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
      for (var header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }
      request.send(null);
    }
    scope.manager.itemStart(url);
    return request;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setResponseType: function(value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function(value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function(value) {
    this.mimeType = value;
    return this;
  },
  setRequestHeader: function(value) {
    this.requestHeader = value;
    return this;
  }
});
function AnimationLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(AnimationLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function(json2, onLoad) {
    var animations2 = [];
    for (var i = 0; i < json2.length; i++) {
      var clip = AnimationClip.parse(json2[i]);
      animations2.push(clip);
    }
    onLoad(animations2);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function CompressedTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(CompressedTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var images = [];
    var texture = new CompressedTexture();
    texture.image = images;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    function loadTexture(i2) {
      loader.load(url[i2], function(buffer2) {
        var texDatas = scope._parser(buffer2, true);
        images[i2] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1)
            texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      var loaded = 0;
      for (var i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(url, function(buffer2) {
        var texDatas = scope._parser(buffer2, true);
        if (texDatas.isCubemap) {
          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (var f = 0; f < faces; f++) {
            images[f] = { mipmaps: [] };
            for (var i2 = 0; i2 < texDatas.mipmapCount; i2++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function DataTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this._parser = null;
}
Object.assign(DataTextureLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var texture = new DataTexture();
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.load(url, function(buffer2) {
      var texData = scope._parser(buffer2);
      if (!texData) return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearMipMapLinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function ImageLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(ImageLoader.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    var image2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function onImageLoad() {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    image2.addEventListener("load", onImageLoad, false);
    image2.addEventListener("error", onImageError, false);
    if (url.substr(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image2.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image2.src = url;
    return image2;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function CubeTextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(CubeTextureLoader.prototype, {
  crossOrigin: "anonymous",
  load: function(urls2, onLoad, onProgress, onError) {
    var texture = new CubeTexture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    var loaded = 0;
    function loadTexture(i2) {
      loader.load(urls2[i2], function(image2) {
        texture.images[i2] = image2;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, void 0, onError);
    }
    for (var i = 0; i < urls2.length; ++i) {
      loadTexture(i);
    }
    return texture;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function TextureLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(TextureLoader.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    var texture = new Texture();
    var loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image2) {
      texture.image = image2;
      var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function Curve() {
  this.type = "Curve";
  this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function(u, optionalTarget) {
    var t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function(divisions) {
    if (divisions === void 0) divisions = 5;
    var points = [];
    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function(divisions) {
    if (divisions === void 0) divisions = 5;
    var points = [];
    for (var d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  },
  // Get total curve arc length
  getLength: function() {
    var lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function(divisions) {
    if (divisions === void 0) divisions = this.arcLengthDivisions;
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    var cache = [];
    var current, last = this.getPoint(0);
    var p, sum2 = 0;
    cache.push(0);
    for (p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum2 += current.distanceTo(last);
      cache.push(sum2);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  },
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function(u, distance2) {
    var arcLengths = this.getLengths();
    var i = 0, il = arcLengths.length;
    var targetArcLength;
    if (distance2) {
      targetArcLength = distance2;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    var low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    var lengthBefore = arcLengths[i];
    var lengthAfter = arcLengths[i + 1];
    var segmentLength = lengthAfter - lengthBefore;
    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    var t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function(t) {
    var delta = 1e-4;
    var t1 = t - delta;
    var t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    var pt1 = this.getPoint(t1);
    var pt2 = this.getPoint(t2);
    var vec = pt2.clone().sub(pt1);
    return vec.normalize();
  },
  getTangentAt: function(u) {
    var t = this.getUtoTmapping(u);
    return this.getTangent(t);
  },
  computeFrenetFrames: function(segments, closed) {
    var normal = new Vector3();
    var tangents = [];
    var normals = [];
    var binormals = [];
    var vec = new Vector3();
    var mat = new Matrix4();
    var i, u, theta;
    for (i = 0; i <= segments; i++) {
      u = i / segments;
      tangents[i] = this.getTangentAt(u);
      tangents[i].normalize();
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    var min2 = Number.MAX_VALUE;
    var tx = Math.abs(tangents[0].x);
    var ty = Math.abs(tangents[0].y);
    var tz = Math.abs(tangents[0].z);
    if (tx <= min2) {
      min2 = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min2) {
      min2 = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min2) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function() {
    var data = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function(json2) {
    this.arcLengthDivisions = json2.arcLengthDivisions;
    return this;
  }
});
function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = "EllipseCurve";
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}
EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;
EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var twoPi = Math.PI * 2;
  var deltaAngle = this.aEndAngle - this.aStartAngle;
  var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
  while (deltaAngle < 0) deltaAngle += twoPi;
  while (deltaAngle > twoPi) deltaAngle -= twoPi;
  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }
  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }
  var angle = this.aStartAngle + t * deltaAngle;
  var x = this.aX + this.xRadius * Math.cos(angle);
  var y = this.aY + this.yRadius * Math.sin(angle);
  if (this.aRotation !== 0) {
    var cos2 = Math.cos(this.aRotation);
    var sin2 = Math.sin(this.aRotation);
    var tx = x - this.aX;
    var ty = y - this.aY;
    x = tx * cos2 - ty * sin2 + this.aX;
    y = tx * sin2 + ty * cos2 + this.aY;
  }
  return point.set(x, y);
};
EllipseCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};
EllipseCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};
EllipseCurve.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.aX = json2.aX;
  this.aY = json2.aY;
  this.xRadius = json2.xRadius;
  this.yRadius = json2.yRadius;
  this.aStartAngle = json2.aStartAngle;
  this.aEndAngle = json2.aEndAngle;
  this.aClockwise = json2.aClockwise;
  this.aRotation = json2.aRotation;
  return this;
};
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = "ArcCurve";
}
ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
function CubicPoly() {
  var c0 = 0, c12 = 0, c22 = 0, c32 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c12 = t0;
    c22 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c32 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      var t2 = t * t;
      var t3 = t2 * t;
      return c0 + c12 * t + c22 * t2 + c32 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = "CatmullRomCurve3";
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || "centripetal";
  this.tension = tension || 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var points = this.points;
  var l = points.length;
  var p = (l - (this.closed ? 0 : 1)) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;
  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }
  var p0, p1, p2, p3;
  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }
  p1 = points[intPoint % l];
  p2 = points[(intPoint + 1) % l];
  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }
  if (this.curveType === "centripetal" || this.curveType === "chordal") {
    var pow2 = this.curveType === "chordal" ? 0.5 : 0.25;
    var dt0 = Math.pow(p0.distanceToSquared(p1), pow2);
    var dt1 = Math.pow(p1.distanceToSquared(p2), pow2);
    var dt2 = Math.pow(p2.distanceToSquared(p3), pow2);
    if (dt1 < 1e-4) dt1 = 1;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === "catmullrom") {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }
  point.set(
    px.calc(weight),
    py.calc(weight),
    pz.calc(weight)
  );
  return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }
  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }
  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.points = [];
  for (var i = 0, l = json2.points.length; i < l; i++) {
    var point = json2.points[i];
    this.points.push(new Vector3().fromArray(point));
  }
  this.closed = json2.closed;
  this.curveType = json2.curveType;
  this.tension = json2.tension;
  return this;
};
function CatmullRom(t, p0, p1, p2, p3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  var k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  var k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  var k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}
CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;
CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
  point.set(
    CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
    CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
  );
  return point;
};
CubicBezierCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v0.fromArray(json2.v0);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  this.v3.fromArray(json2.v3);
  return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = "CubicBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}
CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
  point.set(
    CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
    CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
    CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
  );
  return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v0.fromArray(json2.v0);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  this.v3.fromArray(json2.v3);
  return this;
};
function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve";
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;
LineCurve.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }
  return point;
};
LineCurve.prototype.getPointAt = function(u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};
LineCurve.prototype.getTangent = function() {
  var tangent = this.v2.clone().sub(this.v1);
  return tangent.normalize();
};
LineCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  return this;
};
function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = "LineCurve3";
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }
  return point;
};
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
LineCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
LineCurve3.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  return this;
};
function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve";
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}
QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
  point.set(
    QuadraticBezier(t, v0.x, v1.x, v2.x),
    QuadraticBezier(t, v0.y, v1.y, v2.y)
  );
  return point;
};
QuadraticBezierCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v0.fromArray(json2.v0);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = "QuadraticBezierCurve3";
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}
QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector3();
  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
  point.set(
    QuadraticBezier(t, v0.x, v1.x, v2.x),
    QuadraticBezier(t, v0.y, v1.y, v2.y),
    QuadraticBezier(t, v0.z, v1.z, v2.z)
  );
  return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.v0.fromArray(json2.v0);
  this.v1.fromArray(json2.v1);
  this.v2.fromArray(json2.v2);
  return this;
};
function SplineCurve(points) {
  Curve.call(this);
  this.type = "SplineCurve";
  this.points = points || [];
}
SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;
SplineCurve.prototype.getPoint = function(t, optionalTarget) {
  var point = optionalTarget || new Vector2();
  var points = this.points;
  var p = (points.length - 1) * t;
  var intPoint = Math.floor(p);
  var weight = p - intPoint;
  var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  var p1 = points[intPoint];
  var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(
    CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
    CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
  );
  return point;
};
SplineCurve.prototype.copy = function(source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];
  for (var i = 0, l = source.points.length; i < l; i++) {
    var point = source.points[i];
    this.points.push(point.clone());
  }
  return this;
};
SplineCurve.prototype.toJSON = function() {
  var data = Curve.prototype.toJSON.call(this);
  data.points = [];
  for (var i = 0, l = this.points.length; i < l; i++) {
    var point = this.points[i];
    data.points.push(point.toArray());
  }
  return data;
};
SplineCurve.prototype.fromJSON = function(json2) {
  Curve.prototype.fromJSON.call(this, json2);
  this.points = [];
  for (var i = 0, l = json2.points.length; i < l; i++) {
    var point = json2.points[i];
    this.points.push(new Vector2().fromArray(point));
  }
  return this;
};
const Curves = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
}, Symbol.toStringTag, { value: "Module" }));
function CurvePath() {
  Curve.call(this);
  this.type = "CurvePath";
  this.curves = [];
  this.autoClose = false;
}
CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function(curve) {
    this.curves.push(curve);
  },
  closePath: function() {
    var startPoint = this.curves[0].getPoint(0);
    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function(t) {
    var d = t * this.getLength();
    var curveLengths = this.getCurveLengths();
    var i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        var diff = curveLengths[i] - d;
        var curve = this.curves[i];
        var segmentLength = curve.getLength();
        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }
      i++;
    }
    return null;
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function() {
    var lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    var lengths = [], sums = 0;
    for (var i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function(divisions) {
    if (divisions === void 0) divisions = 40;
    var points = [];
    for (var i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  },
  getPoints: function(divisions) {
    divisions = divisions || 12;
    var points = [], last;
    for (var i = 0, curves = this.curves; i < curves.length; i++) {
      var curve = curves[i];
      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      var pts = curve.getPoints(resolution);
      for (var j = 0; j < pts.length; j++) {
        var point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  },
  copy: function(source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];
    for (var i = 0, l = source.curves.length; i < l; i++) {
      var curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function() {
    var data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];
    for (var i = 0, l = this.curves.length; i < l; i++) {
      var curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  },
  fromJSON: function(json2) {
    Curve.prototype.fromJSON.call(this, json2);
    this.autoClose = json2.autoClose;
    this.curves = [];
    for (var i = 0, l = json2.curves.length; i < l; i++) {
      var curve = json2.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
});
function Path(points) {
  CurvePath.call(this);
  this.type = "Path";
  this.currentPoint = new Vector2();
  if (points) {
    this.setFromPoints(points);
  }
}
Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function(points) {
    this.moveTo(points[0].x, points[0].y);
    for (var i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
  },
  moveTo: function(x, y) {
    this.currentPoint.set(x, y);
  },
  lineTo: function(x, y) {
    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    var curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    var curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
  },
  splineThru: function(pts) {
    var npts = [this.currentPoint.clone()].concat(pts);
    var curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
  },
  arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
  },
  absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  },
  ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var x0 = this.currentPoint.x;
    var y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
  },
  absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      var firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    var lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
  },
  copy: function(source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function() {
    var data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function(json2) {
    CurvePath.prototype.fromJSON.call(this, json2);
    this.currentPoint.fromArray(json2.currentPoint);
    return this;
  }
});
function Shape(points) {
  Path.call(this, points);
  this.uuid = _Math.generateUUID();
  this.type = "Shape";
  this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function(divisions) {
    var holesPts = [];
    for (var i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function(source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];
    for (var i = 0, l = source.holes.length; i < l; i++) {
      var hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  },
  toJSON: function() {
    var data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];
    for (var i = 0, l = this.holes.length; i < l; i++) {
      var hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  },
  fromJSON: function(json2) {
    Path.prototype.fromJSON.call(this, json2);
    this.uuid = json2.uuid;
    this.holes = [];
    for (var i = 0, l = json2.holes.length; i < l; i++) {
      var hole = json2.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
});
function Light(color2, intensity) {
  Object3D.call(this);
  this.type = "Light";
  this.color = new Color(color2);
  this.intensity = intensity !== void 0 ? intensity : 1;
  this.receiveShadow = void 0;
}
Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function(source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = "HemisphereLight";
  this.castShadow = void 0;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.matrix = new Matrix4();
}
Object.assign(LightShadow.prototype, {
  copy: function(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  toJSON: function() {
    var object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  update: function(light) {
    var camera = this.camera;
    var fov = _Math.RAD2DEG * 2 * light.angle;
    var aspect = this.mapSize.width / this.mapSize.height;
    var far = light.distance || camera.far;
    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
  }
});
function SpotLight(color2, intensity, distance2, angle, penumbra, decay) {
  Light.call(this, color2, intensity);
  this.type = "SpotLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * Math.PI;
    },
    set: function(power) {
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance2 !== void 0 ? distance2 : 0;
  this.angle = angle !== void 0 ? angle : Math.PI / 3;
  this.penumbra = penumbra !== void 0 ? penumbra : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new SpotLightShadow();
}
SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function PointLight(color2, intensity, distance2, decay) {
  Light.call(this, color2, intensity);
  this.type = "PointLight";
  Object.defineProperty(this, "power", {
    get: function() {
      return this.intensity * 4 * Math.PI;
    },
    set: function(power) {
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance2 !== void 0 ? distance2 : 0;
  this.decay = decay !== void 0 ? decay : 1;
  this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
}
PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = "OrthographicCamera";
  this.zoom = 1;
  this.view = null;
  this.left = left !== void 0 ? left : -1;
  this.right = right !== void 0 ? right : 1;
  this.top = top !== void 0 ? top : 1;
  this.bottom = bottom !== void 0 ? bottom : -1;
  this.near = near !== void 0 ? near : 0.1;
  this.far = far !== void 0 ? far : 2e3;
  this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function(source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function() {
    var dx = (this.right - this.left) / (2 * this.zoom);
    var dy = (this.top - this.bottom) / (2 * this.zoom);
    var cx = (this.right + this.left) / 2;
    var cy = (this.top + this.bottom) / 2;
    var left = cx - dx;
    var right = cx + dx;
    var top = cy + dy;
    var bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
      var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
      var scaleW = (this.right - this.left) / this.view.width;
      var scaleH = (this.top - this.bottom) / this.view.height;
      left += scaleW * (this.view.offsetX / zoomW);
      right = left + scaleW * (this.view.width / zoomW);
      top -= scaleH * (this.view.offsetY / zoomH);
      bottom = top - scaleH * (this.view.height / zoomH);
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function(meta) {
    var data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});
function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow
});
function DirectionalLight(color2, intensity) {
  Light.call(this, color2, intensity);
  this.type = "DirectionalLight";
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}
DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
function AmbientLight(color2, intensity) {
  Light.call(this, color2, intensity);
  this.type = "AmbientLight";
  this.castShadow = void 0;
}
AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
function RectAreaLight(color2, intensity, width, height) {
  Light.call(this, color2, intensity);
  this.type = "RectAreaLight";
  this.width = width !== void 0 ? width : 10;
  this.height = height !== void 0 ? height : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function(source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function(meta) {
    var data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
function MaterialLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.textures = {};
}
Object.assign(MaterialLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function(json2) {
    var textures = this.textures;
    function getTexture(name2) {
      if (textures[name2] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name2);
      }
      return textures[name2];
    }
    var material = new Materials[json2.type]();
    if (json2.uuid !== void 0) material.uuid = json2.uuid;
    if (json2.name !== void 0) material.name = json2.name;
    if (json2.color !== void 0) material.color.setHex(json2.color);
    if (json2.roughness !== void 0) material.roughness = json2.roughness;
    if (json2.metalness !== void 0) material.metalness = json2.metalness;
    if (json2.emissive !== void 0) material.emissive.setHex(json2.emissive);
    if (json2.specular !== void 0) material.specular.setHex(json2.specular);
    if (json2.shininess !== void 0) material.shininess = json2.shininess;
    if (json2.clearCoat !== void 0) material.clearCoat = json2.clearCoat;
    if (json2.clearCoatRoughness !== void 0) material.clearCoatRoughness = json2.clearCoatRoughness;
    if (json2.vertexColors !== void 0) material.vertexColors = json2.vertexColors;
    if (json2.fog !== void 0) material.fog = json2.fog;
    if (json2.flatShading !== void 0) material.flatShading = json2.flatShading;
    if (json2.blending !== void 0) material.blending = json2.blending;
    if (json2.combine !== void 0) material.combine = json2.combine;
    if (json2.side !== void 0) material.side = json2.side;
    if (json2.opacity !== void 0) material.opacity = json2.opacity;
    if (json2.transparent !== void 0) material.transparent = json2.transparent;
    if (json2.alphaTest !== void 0) material.alphaTest = json2.alphaTest;
    if (json2.depthTest !== void 0) material.depthTest = json2.depthTest;
    if (json2.depthWrite !== void 0) material.depthWrite = json2.depthWrite;
    if (json2.colorWrite !== void 0) material.colorWrite = json2.colorWrite;
    if (json2.wireframe !== void 0) material.wireframe = json2.wireframe;
    if (json2.wireframeLinewidth !== void 0) material.wireframeLinewidth = json2.wireframeLinewidth;
    if (json2.wireframeLinecap !== void 0) material.wireframeLinecap = json2.wireframeLinecap;
    if (json2.wireframeLinejoin !== void 0) material.wireframeLinejoin = json2.wireframeLinejoin;
    if (json2.rotation !== void 0) material.rotation = json2.rotation;
    if (json2.linewidth !== 1) material.linewidth = json2.linewidth;
    if (json2.dashSize !== void 0) material.dashSize = json2.dashSize;
    if (json2.gapSize !== void 0) material.gapSize = json2.gapSize;
    if (json2.scale !== void 0) material.scale = json2.scale;
    if (json2.polygonOffset !== void 0) material.polygonOffset = json2.polygonOffset;
    if (json2.polygonOffsetFactor !== void 0) material.polygonOffsetFactor = json2.polygonOffsetFactor;
    if (json2.polygonOffsetUnits !== void 0) material.polygonOffsetUnits = json2.polygonOffsetUnits;
    if (json2.skinning !== void 0) material.skinning = json2.skinning;
    if (json2.morphTargets !== void 0) material.morphTargets = json2.morphTargets;
    if (json2.dithering !== void 0) material.dithering = json2.dithering;
    if (json2.visible !== void 0) material.visible = json2.visible;
    if (json2.userData !== void 0) material.userData = json2.userData;
    if (json2.uniforms !== void 0) {
      for (var name in json2.uniforms) {
        var uniform = json2.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json2.defines !== void 0) material.defines = json2.defines;
    if (json2.vertexShader !== void 0) material.vertexShader = json2.vertexShader;
    if (json2.fragmentShader !== void 0) material.fragmentShader = json2.fragmentShader;
    if (json2.extensions !== void 0) {
      for (var key in json2.extensions) {
        material.extensions[key] = json2.extensions[key];
      }
    }
    if (json2.shading !== void 0) material.flatShading = json2.shading === 1;
    if (json2.size !== void 0) material.size = json2.size;
    if (json2.sizeAttenuation !== void 0) material.sizeAttenuation = json2.sizeAttenuation;
    if (json2.map !== void 0) material.map = getTexture(json2.map);
    if (json2.alphaMap !== void 0) {
      material.alphaMap = getTexture(json2.alphaMap);
      material.transparent = true;
    }
    if (json2.bumpMap !== void 0) material.bumpMap = getTexture(json2.bumpMap);
    if (json2.bumpScale !== void 0) material.bumpScale = json2.bumpScale;
    if (json2.normalMap !== void 0) material.normalMap = getTexture(json2.normalMap);
    if (json2.normalMapType !== void 0) material.normalMapType = json2.normalMapType;
    if (json2.normalScale !== void 0) {
      var normalScale = json2.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json2.displacementMap !== void 0) material.displacementMap = getTexture(json2.displacementMap);
    if (json2.displacementScale !== void 0) material.displacementScale = json2.displacementScale;
    if (json2.displacementBias !== void 0) material.displacementBias = json2.displacementBias;
    if (json2.roughnessMap !== void 0) material.roughnessMap = getTexture(json2.roughnessMap);
    if (json2.metalnessMap !== void 0) material.metalnessMap = getTexture(json2.metalnessMap);
    if (json2.emissiveMap !== void 0) material.emissiveMap = getTexture(json2.emissiveMap);
    if (json2.emissiveIntensity !== void 0) material.emissiveIntensity = json2.emissiveIntensity;
    if (json2.specularMap !== void 0) material.specularMap = getTexture(json2.specularMap);
    if (json2.envMap !== void 0) material.envMap = getTexture(json2.envMap);
    if (json2.envMapIntensity !== void 0) material.envMapIntensity = json2.envMapIntensity;
    if (json2.reflectivity !== void 0) material.reflectivity = json2.reflectivity;
    if (json2.lightMap !== void 0) material.lightMap = getTexture(json2.lightMap);
    if (json2.lightMapIntensity !== void 0) material.lightMapIntensity = json2.lightMapIntensity;
    if (json2.aoMap !== void 0) material.aoMap = getTexture(json2.aoMap);
    if (json2.aoMapIntensity !== void 0) material.aoMapIntensity = json2.aoMapIntensity;
    if (json2.gradientMap !== void 0) material.gradientMap = getTexture(json2.gradientMap);
    return material;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setTextures: function(value) {
    this.textures = value;
    return this;
  }
});
var LoaderUtils = {
  decodeText: function(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    var s = "";
    for (var i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    return decodeURIComponent(escape(s));
  },
  extractUrlBase: function(url) {
    var index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.substr(0, index + 1);
  }
};
function BufferGeometryLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(BufferGeometryLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function(text) {
      onLoad(scope.parse(JSON.parse(text)));
    }, onProgress, onError);
  },
  parse: function(json2) {
    var geometry2 = new BufferGeometry();
    var index = json2.data.index;
    if (index !== void 0) {
      var typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry2.setIndex(new BufferAttribute(typedArray, 1));
    }
    var attributes = json2.data.attributes;
    for (var key in attributes) {
      var attribute = attributes[key];
      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
      geometry2.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
    }
    var groups = json2.data.groups || json2.data.drawcalls || json2.data.offsets;
    if (groups !== void 0) {
      for (var i = 0, n = groups.length; i !== n; ++i) {
        var group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    var boundingSphere = json2.data.boundingSphere;
    if (boundingSphere !== void 0) {
      var center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry2.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json2.name) geometry2.name = json2.name;
    if (json2.userData) geometry2.userData = json2.userData;
    return geometry2;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function ObjectLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.resourcePath = "";
}
Object.assign(ObjectLoader.prototype, {
  crossOrigin: "anonymous",
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var path = this.path === void 0 ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    var loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.load(url, function(text) {
      var json2 = null;
      try {
        json2 = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0) onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      var metadata = json2.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json2, onLoad);
    }, onProgress, onError);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  },
  setResourcePath: function(value) {
    this.resourcePath = value;
    return this;
  },
  setCrossOrigin: function(value) {
    this.crossOrigin = value;
    return this;
  },
  parse: function(json2, onLoad) {
    var shapes = this.parseShape(json2.shapes);
    var geometries = this.parseGeometries(json2.geometries, shapes);
    var images = this.parseImages(json2.images, function() {
      if (onLoad !== void 0) onLoad(object);
    });
    var textures = this.parseTextures(json2.textures, images);
    var materials = this.parseMaterials(json2.materials, textures);
    var object = this.parseObject(json2.object, geometries, materials);
    if (json2.animations) {
      object.animations = this.parseAnimations(json2.animations);
    }
    if (json2.images === void 0 || json2.images.length === 0) {
      if (onLoad !== void 0) onLoad(object);
    }
    return object;
  },
  parseShape: function(json2) {
    var shapes = {};
    if (json2 !== void 0) {
      for (var i = 0, l = json2.length; i < l; i++) {
        var shape = new Shape().fromJSON(json2[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  },
  parseGeometries: function(json2, shapes) {
    var geometries = {};
    if (json2 !== void 0) {
      var bufferGeometryLoader = new BufferGeometryLoader();
      for (var i = 0, l = json2.length; i < l; i++) {
        var geometry2;
        var data = json2[i];
        switch (data.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            geometry2 = new Geometries[data.type](
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.segments,
              data.thetaStart,
              data.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded,
              data.thetaStart,
              data.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded,
              data.thetaStart,
              data.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.detail
            );
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.innerRadius,
              data.outerRadius,
              data.thetaSegments,
              data.phiSegments,
              data.thetaStart,
              data.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.radius,
              data.tube,
              data.tubularSegments,
              data.radialSegments,
              data.p,
              data.q
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.points,
              data.segments,
              data.phiStart,
              data.phiLength
            );
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            geometry2 = new Geometries[data.type](
              data.vertices,
              data.indices,
              data.radius,
              data.details
            );
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            var geometryShapes = [];
            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            geometry2 = new Geometries[data.type](
              geometryShapes,
              data.curveSegments
            );
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            var geometryShapes = [];
            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
              var shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }
            var extrudePath = data.options.extrudePath;
            if (extrudePath !== void 0) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }
            geometry2 = new Geometries[data.type](
              geometryShapes,
              data.options
            );
            break;
          case "BufferGeometry":
            geometry2 = bufferGeometryLoader.parse(data);
            break;
          case "Geometry":
            if ("THREE" in window && "LegacyJSONLoader" in THREE) {
              var geometryLoader = new THREE.LegacyJSONLoader();
              geometry2 = geometryLoader.parse(data, this.resourcePath).geometry;
            } else {
              console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            }
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }
        geometry2.uuid = data.uuid;
        if (data.name !== void 0) geometry2.name = data.name;
        if (geometry2.isBufferGeometry === true && data.userData !== void 0) geometry2.userData = data.userData;
        geometries[data.uuid] = geometry2;
      }
    }
    return geometries;
  },
  parseMaterials: function(json2, textures) {
    var cache = {};
    var materials = {};
    if (json2 !== void 0) {
      var loader = new MaterialLoader();
      loader.setTextures(textures);
      for (var i = 0, l = json2.length; i < l; i++) {
        var data = json2[i];
        if (data.type === "MultiMaterial") {
          var array = [];
          for (var j = 0; j < data.materials.length; j++) {
            var material = data.materials[j];
            if (cache[material.uuid] === void 0) {
              cache[material.uuid] = loader.parse(material);
            }
            array.push(cache[material.uuid]);
          }
          materials[data.uuid] = array;
        } else {
          materials[data.uuid] = loader.parse(data);
          cache[data.uuid] = materials[data.uuid];
        }
      }
    }
    return materials;
  },
  parseAnimations: function(json2) {
    var animations2 = [];
    for (var i = 0; i < json2.length; i++) {
      var data = json2[i];
      var clip = AnimationClip.parse(data);
      if (data.uuid !== void 0) clip.uuid = data.uuid;
      animations2.push(clip);
    }
    return animations2;
  },
  parseImages: function(json2, onLoad) {
    var scope = this;
    var images = {};
    function loadImage3(url2) {
      scope.manager.itemStart(url2);
      return loader.load(url2, function() {
        scope.manager.itemEnd(url2);
      }, void 0, function() {
        scope.manager.itemError(url2);
        scope.manager.itemEnd(url2);
      });
    }
    if (json2 !== void 0 && json2.length > 0) {
      var manager = new LoadingManager(onLoad);
      var loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (var i = 0, il = json2.length; i < il; i++) {
        var image2 = json2[i];
        var url = image2.url;
        if (Array.isArray(url)) {
          images[image2.uuid] = [];
          for (var j = 0, jl = url.length; j < jl; j++) {
            var currentUrl = url[j];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images[image2.uuid].push(loadImage3(path));
          }
        } else {
          var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image2.url) ? image2.url : scope.resourcePath + image2.url;
          images[image2.uuid] = loadImage3(path);
        }
      }
    }
    return images;
  },
  parseTextures: function(json2, images) {
    function parseConstant(value, type) {
      if (typeof value === "number") return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    var textures = {};
    if (json2 !== void 0) {
      for (var i = 0, l = json2.length; i < l; i++) {
        var data = json2[i];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        var texture;
        if (Array.isArray(images[data.image])) {
          texture = new CubeTexture(images[data.image]);
        } else {
          texture = new Texture(images[data.image]);
        }
        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== void 0) texture.name = data.name;
        if (data.mapping !== void 0) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== void 0) texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0) texture.center.fromArray(data.center);
        if (data.rotation !== void 0) texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0) texture.format = data.format;
        if (data.type !== void 0) texture.type = data.type;
        if (data.encoding !== void 0) texture.encoding = data.encoding;
        if (data.minFilter !== void 0) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== void 0) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  },
  parseObject: function(data, geometries, materials) {
    var object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0) return void 0;
      if (Array.isArray(name)) {
        var array = [];
        for (var i2 = 0, l2 = name.length; i2 < l2; i2++) {
          var uuid = name[i2];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0) object.focus = data.focus;
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        var geometry2 = getGeometry(data.geometry);
        var material = getMaterial(data.material);
        if (geometry2.bones && geometry2.bones.length > 0) {
          object = new SkinnedMesh(geometry2, material);
        } else {
          object = new Mesh(geometry2, material);
        }
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0) object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position);
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0) object.scale.fromArray(data.scale);
    }
    if (data.castShadow !== void 0) object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
      if (data.shadow.radius !== void 0) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0) object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0) object.visible = data.visible;
    if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
    if (data.userData !== void 0) object.userData = data.userData;
    if (data.layers !== void 0) object.layers.mask = data.layers;
    if (data.children !== void 0) {
      var children = data.children;
      for (var i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials));
      }
    }
    if (data.type === "LOD") {
      var levels = data.levels;
      for (var l = 0; l < levels.length; l++) {
        var level = levels[l];
        var child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance);
        }
      }
    }
    return object;
  }
});
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  SphericalReflectionMapping,
  CubeUVReflectionMapping,
  CubeUVRefractionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipMapNearestFilter,
  NearestMipMapLinearFilter,
  LinearFilter,
  LinearMipMapNearestFilter,
  LinearMipMapLinearFilter
};
function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === "undefined") {
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
  }
  if (typeof fetch === "undefined") {
    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
  }
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  this.options = void 0;
}
ImageBitmapLoader.prototype = {
  constructor: ImageBitmapLoader,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    var scope = this;
    var cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    fetch(url).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, scope.options);
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
  },
  setCrossOrigin: function() {
    return this;
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
};
function ShapePath() {
  this.type = "ShapePath";
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
  moveTo: function(x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
  },
  lineTo: function(x, y) {
    this.currentPath.lineTo(x, y);
  },
  quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
  },
  bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
  },
  splineThru: function(pts) {
    this.currentPath.splineThru(pts);
  },
  toShapes: function(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      var shapes2 = [];
      for (var i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
        var tmpPath2 = inSubpaths[i2];
        var tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      var polyLen = inPolygon.length;
      var inside = false;
      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        var edgeLowPt = inPolygon[p];
        var edgeHighPt = inPolygon[q];
        var edgeDx = edgeHighPt.x - edgeLowPt.x;
        var edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true;
          } else {
            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true;
            if (perpEdge < 0) continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
        }
      }
      return inside;
    }
    var isClockWise = ShapeUtils.isClockWise;
    var subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    var solid, tmpPath, tmpShape, shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    var holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    var betterShapeHoles = [];
    var newShapes = [];
    var newShapeHoles = [];
    var mainIdx = 0;
    var tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (var i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      var ambiguous = false;
      var toChange = [];
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        var sho = newShapeHoles[sIdx];
        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
          var ho = sho[hIdx];
          var hole_unassigned = true;
          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange.length > 0) {
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }
    var tmpHoles;
    for (var i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
});
function Font(data) {
  this.type = "Font";
  this.data = data;
}
Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function(text, size) {
    if (size === void 0) size = 100;
    var shapes = [];
    var paths = createPaths(text, size, this.data);
    for (var p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }
    return shapes;
  }
});
function createPaths(text, size, data) {
  var chars = Array.from ? Array.from(text) : String(text).split("");
  var scale2 = size / data.resolution;
  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale2;
  var paths = [];
  var offsetX = 0, offsetY = 0;
  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      var ret = createPath(char, scale2, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale2, offsetX, offsetY, data) {
  var glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) return;
  var path = new ShapePath();
  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (var i = 0, l = outline.length; i < l; ) {
      var action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale2 + offsetX;
          y = outline[i++] * scale2 + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale2 + offsetX;
          y = outline[i++] * scale2 + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale2 + offsetX;
          cpy = outline[i++] * scale2 + offsetY;
          cpx1 = outline[i++] * scale2 + offsetX;
          cpy1 = outline[i++] * scale2 + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale2 + offsetX;
          cpy = outline[i++] * scale2 + offsetY;
          cpx1 = outline[i++] * scale2 + offsetX;
          cpy1 = outline[i++] * scale2 + offsetY;
          cpx2 = outline[i++] * scale2 + offsetX;
          cpy2 = outline[i++] * scale2 + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale2, path };
}
function FontLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(FontLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var scope = this;
    var loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.load(url, function(text) {
      var json2;
      try {
        json2 = JSON.parse(text);
      } catch (e) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
        json2 = JSON.parse(text.substring(65, text.length - 2));
      }
      var font = scope.parse(json2);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function(json2) {
    return new Font(json2);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function Loader() {
}
Loader.Handlers = {
  handlers: [],
  add: function(regex, loader) {
    this.handlers.push(regex, loader);
  },
  get: function(file) {
    var handlers2 = this.handlers;
    for (var i = 0, l = handlers2.length; i < l; i += 2) {
      var regex = handlers2[i];
      var loader = handlers2[i + 1];
      if (regex.test(file)) {
        return loader;
      }
    }
    return null;
  }
};
Object.assign(Loader.prototype, {
  crossOrigin: "anonymous",
  onLoadStart: function() {
  },
  onLoadProgress: function() {
  },
  onLoadComplete: function() {
  },
  initMaterials: function(materials, texturePath, crossOrigin) {
    var array = [];
    for (var i = 0; i < materials.length; ++i) {
      array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
    }
    return array;
  },
  createMaterial: function() {
    var BlendingMode = {
      NoBlending,
      NormalBlending,
      AdditiveBlending,
      SubtractiveBlending,
      MultiplyBlending,
      CustomBlending
    };
    var color2 = new Color();
    var textureLoader = new TextureLoader();
    var materialLoader = new MaterialLoader();
    return function createMaterial(m, texturePath, crossOrigin) {
      var textures = {};
      function loadTexture(path, repeat, offset, wrap, anisotropy) {
        var fullPath = texturePath + path;
        var loader = Loader.Handlers.get(fullPath);
        var texture;
        if (loader !== null) {
          texture = loader.load(fullPath);
        } else {
          textureLoader.setCrossOrigin(crossOrigin);
          texture = textureLoader.load(fullPath);
        }
        if (repeat !== void 0) {
          texture.repeat.fromArray(repeat);
          if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
          if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
        }
        if (offset !== void 0) {
          texture.offset.fromArray(offset);
        }
        if (wrap !== void 0) {
          if (wrap[0] === "repeat") texture.wrapS = RepeatWrapping;
          if (wrap[0] === "mirror") texture.wrapS = MirroredRepeatWrapping;
          if (wrap[1] === "repeat") texture.wrapT = RepeatWrapping;
          if (wrap[1] === "mirror") texture.wrapT = MirroredRepeatWrapping;
        }
        if (anisotropy !== void 0) {
          texture.anisotropy = anisotropy;
        }
        var uuid = _Math.generateUUID();
        textures[uuid] = texture;
        return uuid;
      }
      var json2 = {
        uuid: _Math.generateUUID(),
        type: "MeshLambertMaterial"
      };
      for (var name in m) {
        var value = m[name];
        switch (name) {
          case "DbgColor":
          case "DbgIndex":
          case "opticalDensity":
          case "illumination":
            break;
          case "DbgName":
            json2.name = value;
            break;
          case "blending":
            json2.blending = BlendingMode[value];
            break;
          case "colorAmbient":
          case "mapAmbient":
            console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
            break;
          case "colorDiffuse":
            json2.color = color2.fromArray(value).getHex();
            break;
          case "colorSpecular":
            json2.specular = color2.fromArray(value).getHex();
            break;
          case "colorEmissive":
            json2.emissive = color2.fromArray(value).getHex();
            break;
          case "specularCoef":
            json2.shininess = value;
            break;
          case "shading":
            if (value.toLowerCase() === "basic") json2.type = "MeshBasicMaterial";
            if (value.toLowerCase() === "phong") json2.type = "MeshPhongMaterial";
            if (value.toLowerCase() === "standard") json2.type = "MeshStandardMaterial";
            break;
          case "mapDiffuse":
            json2.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
            break;
          case "mapDiffuseRepeat":
          case "mapDiffuseOffset":
          case "mapDiffuseWrap":
          case "mapDiffuseAnisotropy":
            break;
          case "mapEmissive":
            json2.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
            break;
          case "mapEmissiveRepeat":
          case "mapEmissiveOffset":
          case "mapEmissiveWrap":
          case "mapEmissiveAnisotropy":
            break;
          case "mapLight":
            json2.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
            break;
          case "mapLightRepeat":
          case "mapLightOffset":
          case "mapLightWrap":
          case "mapLightAnisotropy":
            break;
          case "mapAO":
            json2.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
            break;
          case "mapAORepeat":
          case "mapAOOffset":
          case "mapAOWrap":
          case "mapAOAnisotropy":
            break;
          case "mapBump":
            json2.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
            break;
          case "mapBumpScale":
            json2.bumpScale = value;
            break;
          case "mapBumpRepeat":
          case "mapBumpOffset":
          case "mapBumpWrap":
          case "mapBumpAnisotropy":
            break;
          case "mapNormal":
            json2.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
            break;
          case "mapNormalFactor":
            json2.normalScale = value;
            break;
          case "mapNormalRepeat":
          case "mapNormalOffset":
          case "mapNormalWrap":
          case "mapNormalAnisotropy":
            break;
          case "mapSpecular":
            json2.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
            break;
          case "mapSpecularRepeat":
          case "mapSpecularOffset":
          case "mapSpecularWrap":
          case "mapSpecularAnisotropy":
            break;
          case "mapMetalness":
            json2.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
            break;
          case "mapMetalnessRepeat":
          case "mapMetalnessOffset":
          case "mapMetalnessWrap":
          case "mapMetalnessAnisotropy":
            break;
          case "mapRoughness":
            json2.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
            break;
          case "mapRoughnessRepeat":
          case "mapRoughnessOffset":
          case "mapRoughnessWrap":
          case "mapRoughnessAnisotropy":
            break;
          case "mapAlpha":
            json2.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
            break;
          case "mapAlphaRepeat":
          case "mapAlphaOffset":
          case "mapAlphaWrap":
          case "mapAlphaAnisotropy":
            break;
          case "flipSided":
            json2.side = BackSide;
            break;
          case "doubleSided":
            json2.side = DoubleSide;
            break;
          case "transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
            json2.opacity = value;
            break;
          case "depthTest":
          case "depthWrite":
          case "colorWrite":
          case "opacity":
          case "reflectivity":
          case "transparent":
          case "visible":
          case "wireframe":
            json2[name] = value;
            break;
          case "vertexColors":
            if (value === true) json2.vertexColors = VertexColors;
            if (value === "face") json2.vertexColors = FaceColors;
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", name, value);
            break;
        }
      }
      if (json2.type === "MeshBasicMaterial") delete json2.emissive;
      if (json2.type !== "MeshPhongMaterial") delete json2.specular;
      if (json2.opacity < 1) json2.transparent = true;
      materialLoader.setTextures(textures);
      return materialLoader.parse(json2);
    };
  }()
});
var context;
var AudioContext = {
  getContext: function() {
    if (context === void 0) {
      context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return context;
  },
  setContext: function(value) {
    context = value;
  }
};
function AudioLoader(manager) {
  this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
}
Object.assign(AudioLoader.prototype, {
  load: function(url, onLoad, onProgress, onError) {
    var loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.load(url, function(buffer2) {
      var bufferCopy = buffer2.slice(0);
      var context2 = AudioContext.getContext();
      context2.decodeAudioData(bufferCopy, function(audioBuffer) {
        onLoad(audioBuffer);
      });
    }, onProgress, onError);
  },
  setPath: function(value) {
    this.path = value;
    return this;
  }
});
function StereoCamera() {
  this.type = "StereoCamera";
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
}
Object.assign(StereoCamera.prototype, {
  update: function() {
    var instance, focus, fov, aspect, near, far, zoom, eyeSep;
    var eyeRight = new Matrix4();
    var eyeLeft = new Matrix4();
    return function update2(camera) {
      var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
      if (needsUpdate) {
        instance = this;
        focus = camera.focus;
        fov = camera.fov;
        aspect = camera.aspect * this.aspect;
        near = camera.near;
        far = camera.far;
        zoom = camera.zoom;
        var projectionMatrix = camera.projectionMatrix.clone();
        eyeSep = this.eyeSep / 2;
        var eyeSepOnProjection = eyeSep * near / focus;
        var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
        var xmin, xmax;
        eyeLeft.elements[12] = -eyeSep;
        eyeRight.elements[12] = eyeSep;
        xmin = -ymax * aspect + eyeSepOnProjection;
        xmax = ymax * aspect + eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraL.projectionMatrix.copy(projectionMatrix);
        xmin = -ymax * aspect - eyeSepOnProjection;
        xmax = ymax * aspect - eyeSepOnProjection;
        projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
        projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
        this.cameraR.projectionMatrix.copy(projectionMatrix);
      }
      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
    };
  }()
});
function CubeCamera(near, far, cubeResolution, options) {
  Object3D.call(this);
  this.type = "CubeCamera";
  var fov = 90, aspect = 1;
  var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);
  options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
  this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
  this.renderTarget.texture.name = "CubeCamera";
  this.update = function(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderTarget.activeCubeFace = 0;
    renderer.render(scene, cameraPX, renderTarget);
    renderTarget.activeCubeFace = 1;
    renderer.render(scene, cameraNX, renderTarget);
    renderTarget.activeCubeFace = 2;
    renderer.render(scene, cameraPY, renderTarget);
    renderTarget.activeCubeFace = 3;
    renderer.render(scene, cameraNY, renderTarget);
    renderTarget.activeCubeFace = 4;
    renderer.render(scene, cameraPZ, renderTarget);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderTarget.activeCubeFace = 5;
    renderer.render(scene, cameraNZ, renderTarget);
    renderer.setRenderTarget(currentRenderTarget);
  };
  this.clear = function(renderer, color2, depth, stencil) {
    var currentRenderTarget = renderer.getRenderTarget();
    var renderTarget = this.renderTarget;
    for (var i = 0; i < 6; i++) {
      renderTarget.activeCubeFace = i;
      renderer.setRenderTarget(renderTarget);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  };
}
CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
function Clock(autoStart) {
  this.autoStart = autoStart !== void 0 ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}
Object.assign(Clock.prototype, {
  start: function() {
    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function() {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function() {
    var diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      var newTime = (typeof performance === "undefined" ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
});
function AudioListener() {
  Object3D.call(this);
  this.type = "AudioListener";
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0;
}
AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function() {
    return this.gain;
  },
  removeFilter: function() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  },
  getFilter: function() {
    return this.filter;
  },
  setFilter: function(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  },
  getMasterVolume: function() {
    return this.gain.gain.value;
  },
  setMasterVolume: function(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale2 = new Vector3();
    var orientation = new Vector3();
    var clock = new Clock();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      var listener = this.context.listener;
      var up = this.up;
      this.timeDelta = clock.getDelta();
      this.matrixWorld.decompose(position, quaternion, scale2);
      orientation.set(0, 0, -1).applyQuaternion(quaternion);
      if (listener.positionX) {
        var endTime = this.context.currentTime + this.timeDelta;
        listener.positionX.linearRampToValueAtTime(position.x, endTime);
        listener.positionY.linearRampToValueAtTime(position.y, endTime);
        listener.positionZ.linearRampToValueAtTime(position.z, endTime);
        listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
        listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
        listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
        listener.upX.linearRampToValueAtTime(up.x, endTime);
        listener.upY.linearRampToValueAtTime(up.y, endTime);
        listener.upZ.linearRampToValueAtTime(up.z, endTime);
      } else {
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
      }
    };
  }()
});
function Audio$1(listener) {
  Object3D.call(this);
  this.type = "Audio";
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.startTime = 0;
  this.offset = 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = "empty";
  this.filters = [];
}
Audio$1.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio$1,
  getOutput: function() {
    return this.gain;
  },
  setNodeSource: function(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  },
  setMediaElementSource: function(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  },
  setBuffer: function(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) this.play();
    return this;
  },
  play: function() {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    var source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.detune.value = this.detune;
    source.loop = this.loop;
    source.onended = this.onEnded.bind(this);
    source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
    this.startTime = this.context.currentTime;
    source.start(this.startTime, this.offset);
    this.isPlaying = true;
    this.source = source;
    return this.connect();
  },
  pause: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this.source.stop();
      this.source.onended = null;
      this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
      this.isPlaying = false;
    }
    return this;
  },
  stop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.source.stop();
    this.source.onended = null;
    this.offset = 0;
    this.isPlaying = false;
    return this;
  },
  connect: function() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    return this;
  },
  disconnect: function() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (var i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    return this;
  },
  getFilters: function() {
    return this.filters;
  },
  setFilters: function(value) {
    if (!value) value = [];
    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }
    return this;
  },
  setDetune: function(value) {
    this.detune = value;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  },
  getDetune: function() {
    return this.detune;
  },
  getFilter: function() {
    return this.getFilters()[0];
  },
  setFilter: function(filter2) {
    return this.setFilters(filter2 ? [filter2] : []);
  },
  setPlaybackRate: function(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  },
  getPlaybackRate: function() {
    return this.playbackRate;
  },
  onEnded: function() {
    this.isPlaying = false;
  },
  getLoop: function() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  },
  setLoop: function(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  },
  getVolume: function() {
    return this.gain.gain.value;
  },
  setVolume: function(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
});
function PositionalAudio(listener) {
  Audio$1.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain);
}
PositionalAudio.prototype = Object.assign(Object.create(Audio$1.prototype), {
  constructor: PositionalAudio,
  getOutput: function() {
    return this.panner;
  },
  getRefDistance: function() {
    return this.panner.refDistance;
  },
  setRefDistance: function(value) {
    this.panner.refDistance = value;
    return this;
  },
  getRolloffFactor: function() {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function(value) {
    this.panner.rolloffFactor = value;
    return this;
  },
  getDistanceModel: function() {
    return this.panner.distanceModel;
  },
  setDistanceModel: function(value) {
    this.panner.distanceModel = value;
    return this;
  },
  getMaxDistance: function() {
    return this.panner.maxDistance;
  },
  setMaxDistance: function(value) {
    this.panner.maxDistance = value;
    return this;
  },
  setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  },
  updateMatrixWorld: function() {
    var position = new Vector3();
    var quaternion = new Quaternion();
    var scale2 = new Vector3();
    var orientation = new Vector3();
    return function updateMatrixWorld(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      if (this.isPlaying === false) return;
      this.matrixWorld.decompose(position, quaternion, scale2);
      orientation.set(0, 0, 1).applyQuaternion(quaternion);
      var panner = this.panner;
      if (panner.positionX) {
        var endTime = this.context.currentTime + this.listener.timeDelta;
        panner.positionX.linearRampToValueAtTime(position.x, endTime);
        panner.positionY.linearRampToValueAtTime(position.y, endTime);
        panner.positionZ.linearRampToValueAtTime(position.z, endTime);
        panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
        panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
        panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
      } else {
        panner.setPosition(position.x, position.y, position.z);
        panner.setOrientation(orientation.x, orientation.y, orientation.z);
      }
    };
  }()
});
function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}
Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function() {
    var value = 0, data = this.getFrequencyData();
    for (var i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
});
function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  var bufferType = Float64Array, mixFunction;
  switch (typeName) {
    case "quaternion":
      mixFunction = this._slerp;
      break;
    case "string":
    case "bool":
      bufferType = Array;
      mixFunction = this._select;
      break;
    default:
      mixFunction = this._lerp;
  }
  this.buffer = new bufferType(valueSize * 4);
  this._mixBufferRegion = mixFunction;
  this.cumulativeWeight = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function(accuIndex, weight) {
    var buffer2 = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (var i = 0; i !== stride; ++i) {
        buffer2[offset + i] = buffer2[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      var mix2 = weight / currentWeight;
      this._mixBufferRegion(buffer2, offset, 0, mix2, stride);
    }
    this.cumulativeWeight = currentWeight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function(accuIndex) {
    var stride = this.valueSize, buffer2 = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
    this.cumulativeWeight = 0;
    if (weight < 1) {
      var originalValueOffset = stride * 3;
      this._mixBufferRegion(
        buffer2,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    for (var i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer2[i] !== buffer2[i + stride]) {
        binding.setValue(buffer2, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {
    var binding = this.binding;
    var buffer2 = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
    binding.getValue(buffer2, originalValueOffset);
    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer2[i] = buffer2[originalValueOffset + i % stride];
    }
    this.cumulativeWeight = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {
    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  // mix functions
  _select: function(buffer2, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (var i = 0; i !== stride; ++i) {
        buffer2[dstOffset + i] = buffer2[srcOffset + i];
      }
    }
  },
  _slerp: function(buffer2, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer2, dstOffset, buffer2, dstOffset, buffer2, srcOffset, t);
  },
  _lerp: function(buffer2, dstOffset, srcOffset, t, stride) {
    var s = 1 - t;
    for (var i = 0; i !== stride; ++i) {
      var j = dstOffset + i;
      buffer2[j] = buffer2[j] * s + buffer2[srcOffset + i] * t;
    }
  }
});
var RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
function Composite(targetGroup, path, optionalParsedPath) {
  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}
Object.assign(Composite.prototype, {
  getValue: function(array, offset) {
    this.bind();
    var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  },
  setValue: function(array, offset) {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function() {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function() {
    var bindings = this._bindings;
    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});
function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}
Object.assign(PropertyBinding, {
  Composite,
  create: function(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param  {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function() {
    var reservedRe = new RegExp("[" + RESERVED_CHARS_RE + "]", "g");
    return function sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(reservedRe, "");
    };
  }(),
  parseTrackName: function() {
    var wordChar = "[^" + RESERVED_CHARS_RE + "]";
    var wordCharOrDot = "[^" + RESERVED_CHARS_RE.replace("\\.", "") + "]";
    var directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", wordChar);
    var nodeRe = /(WCOD+)?/.source.replace("WCOD", wordCharOrDot);
    var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wordChar);
    var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wordChar);
    var trackRe = new RegExp(
      "^" + directoryRe + nodeRe + objectRe + propertyRe + "$"
    );
    var supportedObjectNames = ["material", "materials", "bones"];
    return function parseTrackName(trackName) {
      var matches = trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      var results = {
        // directoryName: matches[ 1 ], // (tschw) currently unused
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        // required
        propertyIndex: matches[6]
      };
      var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        var objectName = results.nodeName.substring(lastDot + 1);
        if (supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    };
  }(),
  findNode: function(root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      var bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      var searchNodeSubtree = function(children) {
        for (var i = 0; i < children.length; i++) {
          var childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          var result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      var subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {
  },
  _setValue_unavailable: function() {
  },
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [
    function getValue_direct(buffer2, offset) {
      buffer2[offset] = this.node[this.propertyName];
    },
    function getValue_array(buffer2, offset) {
      var source = this.resolvedProperty;
      for (var i = 0, n = source.length; i !== n; ++i) {
        buffer2[offset++] = source[i];
      }
    },
    function getValue_arrayElement(buffer2, offset) {
      buffer2[offset] = this.resolvedProperty[this.propertyIndex];
    },
    function getValue_toArray(buffer2, offset) {
      this.resolvedProperty.toArray(buffer2, offset);
    }
  ],
  SetterByBindingTypeAndVersioning: [
    [
      // Direct
      function setValue_direct(buffer2, offset) {
        this.targetObject[this.propertyName] = buffer2[offset];
      },
      function setValue_direct_setNeedsUpdate(buffer2, offset) {
        this.targetObject[this.propertyName] = buffer2[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_direct_setMatrixWorldNeedsUpdate(buffer2, offset) {
        this.targetObject[this.propertyName] = buffer2[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      // EntireArray
      function setValue_array(buffer2, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer2[offset++];
        }
      },
      function setValue_array_setNeedsUpdate(buffer2, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer2[offset++];
        }
        this.targetObject.needsUpdate = true;
      },
      function setValue_array_setMatrixWorldNeedsUpdate(buffer2, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer2[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      // ArrayElement
      function setValue_arrayElement(buffer2, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer2[offset];
      },
      function setValue_arrayElement_setNeedsUpdate(buffer2, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer2[offset];
        this.targetObject.needsUpdate = true;
      },
      function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer2, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer2[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ],
    [
      // HasToFromArray
      function setValue_fromArray(buffer2, offset) {
        this.resolvedProperty.fromArray(buffer2, offset);
      },
      function setValue_fromArray_setNeedsUpdate(buffer2, offset) {
        this.resolvedProperty.fromArray(buffer2, offset);
        this.targetObject.needsUpdate = true;
      },
      function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer2, offset) {
        this.resolvedProperty.fromArray(buffer2, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    ]
  ],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  },
  setValue: function getValue_unbound2(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function() {
    var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      var objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (var i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    var nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      var nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    var versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    var bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            return;
          }
          for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        } else {
          if (!targetObject.geometry.morphTargets) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
            return;
          }
          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
              propertyIndex = i;
              break;
            }
          }
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
});
//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
function AnimationObjectGroup() {
  this.uuid = _Math.generateUUID();
  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0;
  var indices = {};
  this._indicesByUUID = indices;
  for (var i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }
  this._paths = [];
  this._parsedPaths = [];
  this._bindings = [];
  this._bindingsIndicesByPath = {};
  var scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },
      get inUse() {
        return this.total - scope.nCachedObjects_;
      }
    },
    get bindingsPerObject() {
      return scope._bindings.length;
    }
  };
}
Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function() {
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = void 0;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (var j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function() {
    var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (var j = 0, m = nBindings; j !== m; ++j) {
          var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function() {
    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          var lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop();
          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function(path, parsedPath) {
    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
    if (index !== void 0) return bindings[index];
    var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
      var object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  },
  unsubscribe_: function(path) {
    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
function AnimationAction(mixer, clip, localRoot) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
  var interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };
  for (var i = 0; i !== nTracks; ++i) {
    var interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
  }
  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants;
  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null;
  this._byClipCacheIndex = null;
  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1;
  this._startTime = null;
  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity;
  this.paused = false;
  this.enabled = true;
  this.clampWhenFinished = false;
  this.zeroSlopeAtStart = true;
  this.zeroSlopeAtEnd = true;
}
Object.assign(AnimationAction.prototype, {
  // State & Scheduling
  play: function() {
    this._mixer._activateAction(this);
    return this;
  },
  stop: function() {
    this._mixer._deactivateAction(this);
    return this.reset();
  },
  reset: function() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  },
  isRunning: function() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function() {
    return this._mixer._isActiveAction(this);
  },
  startAt: function(time2) {
    this._startTime = time2;
    return this;
  },
  setLoop: function(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {
    return this._effectiveWeight;
  },
  fadeIn: function(duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function(duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  },
  crossFadeTo: function(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function() {
    var weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {
    return this._effectiveTimeScale;
  },
  setDuration: function(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function(startTimeScale, endTimeScale, duration) {
    var mixer = this._mixer, now2 = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function() {
    var timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  },
  // Object Accessors
  getMixer: function() {
    return this._mixer;
  },
  getClip: function() {
    return this._clip;
  },
  getRoot: function() {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function(time2, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time2);
      return;
    }
    var startTime = this._startTime;
    if (startTime !== null) {
      var timeRunning = (time2 - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        return;
      }
      this._startTime = null;
      deltaTime = timeDirection * timeRunning;
    }
    deltaTime *= this._updateTimeScale(time2);
    var clipTime = this._updateTime(deltaTime);
    var weight = this._updateWeight(time2);
    if (weight > 0) {
      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;
      for (var j = 0, m = interpolants.length; j !== m; ++j) {
        interpolants[j].evaluate(clipTime);
        propertyMixers[j].accumulate(accuIndex, weight);
      }
    }
  },
  _updateWeight: function(time2) {
    var weight = 0;
    if (this.enabled) {
      weight = this.weight;
      var interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time2)[0];
        weight *= interpolantValue;
        if (time2 > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function(time2) {
    var timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      var interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        var interpolantValue = interpolant.evaluate(time2)[0];
        timeScale *= interpolantValue;
        if (time2 > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function(deltaTime) {
    var time2 = this.time + deltaTime;
    var duration = this._clip.duration;
    var loop2 = this.loop;
    var loopCount = this._loopCount;
    var pingPong = loop2 === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time2;
      return pingPong && (loopCount & 1) === 1 ? duration - time2 : time2;
    }
    if (loop2 === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time2 >= duration) {
          time2 = duration;
        } else if (time2 < 0) {
          time2 = 0;
        } else break handle_stop;
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time2 >= duration || time2 < 0) {
        var loopDelta = Math.floor(time2 / duration);
        time2 -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        var pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time2 = deltaTime > 0 ? duration : 0;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            var atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      }
      if (pingPong && (loopCount & 1) === 1) {
        this.time = time2;
        return duration - time2;
      }
    }
    this.time = time2;
    return time2;
  },
  _setEndings: function(atStart, atEnd, pingPong) {
    var settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function(duration, weightNow, weightThen) {
    var mixer = this._mixer, now2 = mixer.time, interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
});
function AnimationMixer(root) {
  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function(action, prototypeAction) {
    var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (var i = 0; i !== nTracks; ++i) {
      var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
      if (binding !== void 0) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  },
  _deactivateAction: function(action) {
    if (this._isActiveAction(action)) {
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  },
  // Memory manager
  _initMemoryManager: function() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    var scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function(action) {
    var index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function(action, clipUuid, rootUuid) {
    var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      var knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function(action) {
    var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function(action) {
    var bindings = action._propertyBindings;
    for (var i = 0, n = bindings.length; i !== n; ++i) {
      var binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function(action) {
    var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function(binding, rootUuid, trackName) {
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function(binding) {
    var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    remove_empty_map: {
      for (var _ in bindingByName) break remove_empty_map;
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function(binding) {
    var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function() {
    var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        this._controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  },
  _takeBackControlInterpolant: function(interpolant) {
    var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
    if (actionsForClip !== void 0) {
      var existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    var newAction = new AnimationAction(this, clipObject, optionalRoot);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  },
  // get an existing action
  existingAction: function(clip, optionalRoot) {
    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function() {
    var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
    this._nActiveActions = 0;
    this._nActiveBindings = 0;
    for (var i = 0; i !== nActions; ++i) {
      actions[i].reset();
    }
    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].useCount = 0;
    }
    return this;
  },
  // advance the time and update apply the animation
  update: function(deltaTime) {
    deltaTime *= this.timeScale;
    var actions = this._actions, nActions = this._nActiveActions, time2 = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (var i = 0; i !== nActions; ++i) {
      var action = actions[i];
      action._update(time2, deltaTime, timeDirection, accuIndex);
    }
    var bindings = this._bindings, nBindings = this._nActiveBindings;
    for (var i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  },
  // return this mixer's root target object
  getRoot: function() {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function(clip) {
    var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      var actionsToRemove = actionsForClip.knownActions;
      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
        var action = actionsToRemove[i];
        this._deactivateAction(action);
        var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function(root) {
    var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (var clipUuid in actionsByClip) {
      var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (var trackName in bindingByName) {
        var binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function(clip, optionalRoot) {
    var action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
});
function Uniform(value) {
  if (typeof value === "string") {
    console.warn("THREE.Uniform: Type parameter is no longer needed.");
    value = arguments[1];
  }
  this.value = value;
}
Uniform.prototype.clone = function() {
  return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
};
function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = "InstancedBufferGeometry";
  this.maxInstancedCount = void 0;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function(source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.maxInstancedCount = source.maxInstancedCount;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  }
});
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function(source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === "number") {
    meshPerAttribute = normalized;
    normalized = false;
    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
  }
  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function(source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
});
function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction);
  this.near = near || 0;
  this.far = far || Infinity;
  this.params = {
    Mesh: {},
    Line: {},
    LOD: {},
    Points: { threshold: 1 },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function() {
        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
        return this.Points;
      }
    }
  });
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.visible === false) return;
  object.raycast(raycaster, intersects2);
  if (recursive === true) {
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true);
    }
  }
}
Object.assign(Raycaster.prototype, {
  linePrecision: 1,
  set: function(origin, direction) {
    this.ray.set(origin, direction);
  },
  setFromCamera: function(coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
    } else {
      console.error("THREE.Raycaster: Unsupported camera type.");
    }
  },
  intersectObject: function(object, recursive, optionalTarget) {
    var intersects2 = optionalTarget || [];
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  },
  intersectObjects: function(objects, recursive, optionalTarget) {
    var intersects2 = optionalTarget || [];
    if (Array.isArray(objects) === false) {
      console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
      return intersects2;
    }
    for (var i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
});
function Spherical(radius, phi, theta) {
  this.radius = radius !== void 0 ? radius : 1;
  this.phi = phi !== void 0 ? phi : 0;
  this.theta = theta !== void 0 ? theta : 0;
  return this;
}
Object.assign(Spherical.prototype, {
  set: function(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function() {
    var EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
    }
    return this;
  }
});
function Cylindrical(radius, theta, y) {
  this.radius = radius !== void 0 ? radius : 1;
  this.theta = theta !== void 0 ? theta : 0;
  this.y = y !== void 0 ? y : 0;
  return this;
}
Object.assign(Cylindrical.prototype, {
  set: function(radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
});
function Box2(min2, max2) {
  this.min = min2 !== void 0 ? min2 : new Vector2(Infinity, Infinity);
  this.max = max2 !== void 0 ? max2 : new Vector2(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
  set: function(min2, max2) {
    this.min.copy(min2);
    this.max.copy(max2);
    return this;
  },
  setFromPoints: function(points) {
    this.makeEmpty();
    for (var i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  },
  setFromCenterAndSize: function() {
    var v1 = new Vector2();
    return function setFromCenterAndSize(center, size) {
      var halfSize = v1.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    };
  }(),
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getCenter() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function(target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getSize() target is now required");
      target = new Vector2();
    }
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function(scalar2) {
    this.min.addScalar(-scalar2);
    this.max.addScalar(scalar2);
    return this;
  },
  containsPoint: function(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .getParameter() target is now required");
      target = new Vector2();
    }
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  },
  intersectsBox: function(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function(point, target) {
    if (target === void 0) {
      console.warn("THREE.Box2: .clampPoint() target is now required");
      target = new Vector2();
    }
    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function() {
    var v1 = new Vector2();
    return function distanceToPoint(point) {
      var clampedPoint = v1.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    };
  }(),
  intersect: function(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
function Line3(start2, end) {
  this.start = start2 !== void 0 ? start2 : new Vector3();
  this.end = end !== void 0 ? end : new Vector3();
}
Object.assign(Line3.prototype, {
  set: function(start2, end) {
    this.start.copy(start2);
    this.end.copy(end);
    return this;
  },
  clone: function() {
    return new this.constructor().copy(this);
  },
  copy: function(line3) {
    this.start.copy(line3.start);
    this.end.copy(line3.end);
    return this;
  },
  getCenter: function(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .getCenter() target is now required");
      target = new Vector3();
    }
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function(target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .delta() target is now required");
      target = new Vector3();
    }
    return target.subVectors(this.end, this.start);
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end);
  },
  distance: function() {
    return this.start.distanceTo(this.end);
  },
  at: function(t, target) {
    if (target === void 0) {
      console.warn("THREE.Line3: .at() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function() {
    var startP = new Vector3();
    var startEnd = new Vector3();
    return function closestPointToPointParameter(point, clampToLine) {
      startP.subVectors(point, this.start);
      startEnd.subVectors(this.end, this.start);
      var startEnd2 = startEnd.dot(startEnd);
      var startEnd_startP = startEnd.dot(startP);
      var t = startEnd_startP / startEnd2;
      if (clampToLine) {
        t = _Math.clamp(t, 0, 1);
      }
      return t;
    };
  }(),
  closestPointToPoint: function(point, clampToLine, target) {
    var t = this.closestPointToPointParameter(point, clampToLine);
    if (target === void 0) {
      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
      target = new Vector3();
    }
    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function(line3) {
    return line3.start.equals(this.start) && line3.end.equals(this.end);
  }
});
function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;
  this.render = function() {
  };
}
ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
function VertexNormalsHelper(object, size, hex2, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color2 = hex2 !== void 0 ? hex2 : 16711680;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length * 3;
  } else if (objGeometry && objGeometry.isBufferGeometry) {
    nNormals = objGeometry.attributes.normal.count;
  }
  var geometry2 = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry2.addAttribute("position", positions);
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color: color2, linewidth: width }));
  this.matrixAutoUpdate = false;
  this.update();
}
VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
VertexNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update2() {
    var keys = ["a", "b", "c"];
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;
      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          var vertex = vertices[face[keys[j]]];
          var normal = face.vertexNormals[j];
          v1.copy(vertex).applyMatrix4(matrixWorld);
          v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      var objPos = objGeometry.attributes.position;
      var objNorm = objGeometry.attributes.normal;
      var idx = 0;
      for (var j = 0, jl = objPos.count; j < jl; j++) {
        v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
        v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
        v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  };
}();
function SpotLightHelper(light, color2) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color2;
  var geometry2 = new BufferGeometry();
  var positions = [
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    -1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    -1,
    1
  ];
  for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
    var p1 = i / l * Math.PI * 2;
    var p2 = j / l * Math.PI * 2;
    positions.push(
      Math.cos(p1),
      Math.sin(p1),
      1,
      Math.cos(p2),
      Math.sin(p2),
      1
    );
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  var material = new LineBasicMaterial({ fog: false });
  this.cone = new LineSegments(geometry2, material);
  this.add(this.cone);
  this.update();
}
SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;
SpotLightHelper.prototype.dispose = function() {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
SpotLightHelper.prototype.update = function() {
  var vector = new Vector3();
  return function update2() {
    this.light.updateMatrixWorld();
    var coneLength = this.light.distance ? this.light.distance : 1e3;
    var coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    vector.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(vector);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  };
}();
function getBoneList(object) {
  var boneList = [];
  if (object && object.isBone) {
    boneList.push(object);
  }
  for (var i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
function SkeletonHelper(object) {
  var bones = getBoneList(object);
  var geometry2 = new BufferGeometry();
  var vertices = [];
  var colors3 = [];
  var color1 = new Color(0, 0, 1);
  var color2 = new Color(0, 1, 0);
  for (var i = 0; i < bones.length; i++) {
    var bone = bones[i];
    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors3.push(color1.r, color1.g, color1.b);
      colors3.push(color2.r, color2.g, color2.b);
    }
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors3, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });
  LineSegments.call(this, geometry2, material);
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}
SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.updateMatrixWorld = function() {
  var vector = new Vector3();
  var boneMatrix = new Matrix4();
  var matrixWorldInv = new Matrix4();
  return function updateMatrixWorld(force) {
    var bones = this.bones;
    var geometry2 = this.geometry;
    var position = geometry2.getAttribute("position");
    matrixWorldInv.getInverse(this.root.matrixWorld);
    for (var i = 0, j = 0; i < bones.length; i++) {
      var bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j, vector.x, vector.y, vector.z);
        boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
        vector.setFromMatrixPosition(boneMatrix);
        position.setXYZ(j + 1, vector.x, vector.y, vector.z);
        j += 2;
      }
    }
    geometry2.getAttribute("position").needsUpdate = true;
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };
}();
function PointLightHelper(light, sphereSize, color2) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color2;
  var geometry2 = new SphereBufferGeometry(sphereSize, 4, 2);
  var material = new MeshBasicMaterial({ wireframe: true, fog: false });
  Mesh.call(this, geometry2, material);
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
}
PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;
PointLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
};
PointLightHelper.prototype.update = function() {
  if (this.color !== void 0) {
    this.material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color);
  }
};
function RectAreaLightHelper(light, color2) {
  this.type = "RectAreaLightHelper";
  this.light = light;
  this.color = color2;
  var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry2.computeBoundingSphere();
  var material = new LineBasicMaterial({ fog: false });
  Line.call(this, geometry2, material);
  var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
  var geometry22 = new BufferGeometry();
  geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
  geometry22.computeBoundingSphere();
  this.add(new Mesh(geometry22, new MeshBasicMaterial({ side: THREE.BackSide, fog: false })));
  this.update();
}
RectAreaLightHelper.prototype = Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
RectAreaLightHelper.prototype.update = function() {
  this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
  if (this.color !== void 0) {
    this.material.color.set(this.color);
    this.children[0].material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    var c = this.material.color;
    var max2 = Math.max(c.r, c.g, c.b);
    if (max2 > 1) c.multiplyScalar(1 / max2);
    this.children[0].material.color.copy(this.material.color);
  }
};
RectAreaLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose();
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
function HemisphereLightHelper(light, size, color2) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color2;
  var geometry2 = new OctahedronBufferGeometry(size);
  geometry2.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({ wireframe: true, fog: false });
  if (this.color === void 0) this.material.vertexColors = VertexColors;
  var position = geometry2.getAttribute("position");
  var colors3 = new Float32Array(position.count * 3);
  geometry2.addAttribute("color", new BufferAttribute(colors3, 3));
  this.add(new Mesh(geometry2, this.material));
  this.update();
}
HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
HemisphereLightHelper.prototype.dispose = function() {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};
HemisphereLightHelper.prototype.update = function() {
  var vector = new Vector3();
  var color1 = new Color();
  var color2 = new Color();
  return function update2() {
    var mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      var colors3 = mesh.geometry.getAttribute("color");
      color1.copy(this.light.color);
      color2.copy(this.light.groundColor);
      for (var i = 0, l = colors3.count; i < l; i++) {
        var color3 = i < l / 2 ? color1 : color2;
        colors3.setXYZ(i, color3.r, color3.g, color3.b);
      }
      colors3.needsUpdate = true;
    }
    mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
}();
function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  var center = divisions / 2;
  var step2 = size / divisions;
  var halfSize = size / 2;
  var vertices = [], colors3 = [];
  for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step2) {
    vertices.push(-halfSize, 0, k, halfSize, 0, k);
    vertices.push(k, 0, -halfSize, k, 0, halfSize);
    var color3 = i === center ? color1 : color2;
    color3.toArray(colors3, j);
    j += 3;
    color3.toArray(colors3, j);
    j += 3;
    color3.toArray(colors3, j);
    j += 3;
    color3.toArray(colors3, j);
    j += 3;
  }
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors3, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
GridHelper.prototype = Object.create(LineSegments.prototype);
GridHelper.prototype.constructor = GridHelper;
function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== void 0 ? color1 : 4473924);
  color2 = new Color(color2 !== void 0 ? color2 : 8947848);
  var vertices = [];
  var colors3 = [];
  var x, z;
  var v, i, j, r, color3;
  for (i = 0; i <= radials; i++) {
    v = i / radials * (Math.PI * 2);
    x = Math.sin(v) * radius;
    z = Math.cos(v) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x, 0, z);
    color3 = i & 1 ? color1 : color2;
    colors3.push(color3.r, color3.g, color3.b);
    colors3.push(color3.r, color3.g, color3.b);
  }
  for (i = 0; i <= circles; i++) {
    color3 = i & 1 ? color1 : color2;
    r = radius - radius / circles * i;
    for (j = 0; j < divisions; j++) {
      v = j / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors3.push(color3.r, color3.g, color3.b);
      v = (j + 1) / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors3.push(color3.r, color3.g, color3.b);
    }
  }
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors3, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
function FaceNormalsHelper(object, size, hex2, linewidth) {
  this.object = object;
  this.size = size !== void 0 ? size : 1;
  var color2 = hex2 !== void 0 ? hex2 : 16776960;
  var width = linewidth !== void 0 ? linewidth : 1;
  var nNormals = 0;
  var objGeometry = this.object.geometry;
  if (objGeometry && objGeometry.isGeometry) {
    nNormals = objGeometry.faces.length;
  } else {
    console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
  }
  var geometry2 = new BufferGeometry();
  var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
  geometry2.addAttribute("position", positions);
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color: color2, linewidth: width }));
  this.matrixAutoUpdate = false;
  this.update();
}
FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
FaceNormalsHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var normalMatrix = new Matrix3();
  return function update2() {
    this.object.updateMatrixWorld(true);
    normalMatrix.getNormalMatrix(this.object.matrixWorld);
    var matrixWorld = this.object.matrixWorld;
    var position = this.geometry.attributes.position;
    var objGeometry = this.object.geometry;
    var vertices = objGeometry.vertices;
    var faces = objGeometry.faces;
    var idx = 0;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      var normal = face.normal;
      v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
      v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
      position.setXYZ(idx, v1.x, v1.y, v1.z);
      idx = idx + 1;
      position.setXYZ(idx, v2.x, v2.y, v2.z);
      idx = idx + 1;
    }
    position.needsUpdate = true;
  };
}();
function DirectionalLightHelper(light, size, color2) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color2;
  if (size === void 0) size = 1;
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute([
    -size,
    size,
    0,
    size,
    size,
    0,
    size,
    -size,
    0,
    -size,
    -size,
    0,
    -size,
    size,
    0
  ], 3));
  var material = new LineBasicMaterial({ fog: false });
  this.lightPlane = new Line(geometry2, material);
  this.add(this.lightPlane);
  geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry2, material);
  this.add(this.targetLine);
  this.update();
}
DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
DirectionalLightHelper.prototype.dispose = function() {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
DirectionalLightHelper.prototype.update = function() {
  var v1 = new Vector3();
  var v2 = new Vector3();
  var v3 = new Vector3();
  return function update2() {
    v1.setFromMatrixPosition(this.light.matrixWorld);
    v2.setFromMatrixPosition(this.light.target.matrixWorld);
    v3.subVectors(v2, v1);
    this.lightPlane.lookAt(v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(v2);
    this.targetLine.scale.z = v3.length();
  };
}();
function CameraHelper(camera) {
  var geometry2 = new BufferGeometry();
  var material = new LineBasicMaterial({ color: 16777215, vertexColors: FaceColors });
  var vertices = [];
  var colors3 = [];
  var pointMap = {};
  var colorFrustum = new Color(16755200);
  var colorCone = new Color(16711680);
  var colorUp = new Color(43775);
  var colorTarget = new Color(16777215);
  var colorCross = new Color(3355443);
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  function addLine(a, b, color2) {
    addPoint(a, color2);
    addPoint(b, color2);
  }
  function addPoint(id2, color2) {
    vertices.push(0, 0, 0);
    colors3.push(color2.r, color2.g, color2.b);
    if (pointMap[id2] === void 0) {
      pointMap[id2] = [];
    }
    pointMap[id2].push(vertices.length / 3 - 1);
  }
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors3, 3));
  LineSegments.call(this, geometry2, material);
  this.camera = camera;
  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}
CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;
CameraHelper.prototype.update = function() {
  var geometry2, pointMap;
  var vector = new Vector3();
  var camera = new Camera();
  function setPoint(point, x, y, z) {
    vector.set(x, y, z).unproject(camera);
    var points = pointMap[point];
    if (points !== void 0) {
      var position = geometry2.getAttribute("position");
      for (var i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], vector.x, vector.y, vector.z);
      }
    }
  }
  return function update2() {
    geometry2 = this.geometry;
    pointMap = this.pointMap;
    var w = 1, h = 1;
    camera.projectionMatrix.copy(this.camera.projectionMatrix);
    setPoint("c", 0, 0, -1);
    setPoint("t", 0, 0, 1);
    setPoint("n1", -w, -h, -1);
    setPoint("n2", w, -h, -1);
    setPoint("n3", -w, h, -1);
    setPoint("n4", w, h, -1);
    setPoint("f1", -w, -h, 1);
    setPoint("f2", w, -h, 1);
    setPoint("f3", -w, h, 1);
    setPoint("f4", w, h, 1);
    setPoint("u1", w * 0.7, h * 1.1, -1);
    setPoint("u2", -w * 0.7, h * 1.1, -1);
    setPoint("u3", 0, h * 2, -1);
    setPoint("cf1", -w, 0, 1);
    setPoint("cf2", w, 0, 1);
    setPoint("cf3", 0, -h, 1);
    setPoint("cf4", 0, h, 1);
    setPoint("cn1", -w, 0, -1);
    setPoint("cn2", w, 0, -1);
    setPoint("cn3", 0, -h, -1);
    setPoint("cn4", 0, h, -1);
    geometry2.getAttribute("position").needsUpdate = true;
  };
}();
function BoxHelper(object, color2) {
  this.object = object;
  if (color2 === void 0) color2 = 16776960;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = new Float32Array(8 * 3);
  var geometry2 = new BufferGeometry();
  geometry2.setIndex(new BufferAttribute(indices, 1));
  geometry2.addAttribute("position", new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color: color2 }));
  this.matrixAutoUpdate = false;
  this.update();
}
BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;
BoxHelper.prototype.update = function() {
  var box = new Box3();
  return function update2(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      box.setFromObject(this.object);
    }
    if (box.isEmpty()) return;
    var min2 = box.min;
    var max2 = box.max;
    var position = this.geometry.attributes.position;
    var array = position.array;
    array[0] = max2.x;
    array[1] = max2.y;
    array[2] = max2.z;
    array[3] = min2.x;
    array[4] = max2.y;
    array[5] = max2.z;
    array[6] = min2.x;
    array[7] = min2.y;
    array[8] = max2.z;
    array[9] = max2.x;
    array[10] = min2.y;
    array[11] = max2.z;
    array[12] = max2.x;
    array[13] = max2.y;
    array[14] = min2.z;
    array[15] = min2.x;
    array[16] = max2.y;
    array[17] = min2.z;
    array[18] = min2.x;
    array[19] = min2.y;
    array[20] = min2.z;
    array[21] = max2.x;
    array[22] = min2.y;
    array[23] = min2.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  };
}();
BoxHelper.prototype.setFromObject = function(object) {
  this.object = object;
  this.update();
  return this;
};
BoxHelper.prototype.copy = function(source) {
  LineSegments.prototype.copy.call(this, source);
  this.object = source.object;
  return this;
};
BoxHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function Box3Helper(box, hex2) {
  this.type = "Box3Helper";
  this.box = box;
  var color2 = hex2 !== void 0 ? hex2 : 16776960;
  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  var geometry2 = new BufferGeometry();
  geometry2.setIndex(new BufferAttribute(indices, 1));
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry2, new LineBasicMaterial({ color: color2 }));
  this.geometry.computeBoundingSphere();
}
Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;
Box3Helper.prototype.updateMatrixWorld = function(force) {
  var box = this.box;
  if (box.isEmpty()) return;
  box.getCenter(this.position);
  box.getSize(this.scale);
  this.scale.multiplyScalar(0.5);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
function PlaneHelper(plane, size, hex2) {
  this.type = "PlaneHelper";
  this.plane = plane;
  this.size = size === void 0 ? 1 : size;
  var color2 = hex2 !== void 0 ? hex2 : 16776960;
  var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry2.computeBoundingSphere();
  Line.call(this, geometry2, new LineBasicMaterial({ color: color2 }));
  var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  var geometry22 = new BufferGeometry();
  geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
  geometry22.computeBoundingSphere();
  this.add(new Mesh(geometry22, new MeshBasicMaterial({ color: color2, opacity: 0.2, transparent: true, depthWrite: false })));
}
PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;
PlaneHelper.prototype.updateMatrixWorld = function(force) {
  var scale2 = -this.plane.constant;
  if (Math.abs(scale2) < 1e-8) scale2 = 1e-8;
  this.scale.set(0.5 * this.size, 0.5 * this.size, scale2);
  this.children[0].material.side = scale2 < 0 ? BackSide : FrontSide;
  this.lookAt(this.plane.normal);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
var lineGeometry, coneGeometry;
function ArrowHelper(dir, origin, length, color2, headLength, headWidth) {
  Object3D.call(this);
  if (dir === void 0) dir = new THREE.Vector3(0, 0, 1);
  if (origin === void 0) origin = new THREE.Vector3(0, 0, 0);
  if (length === void 0) length = 1;
  if (color2 === void 0) color2 = 16776960;
  if (headLength === void 0) headLength = 0.2 * length;
  if (headWidth === void 0) headWidth = 0.2 * headLength;
  if (lineGeometry === void 0) {
    lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
    coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
    coneGeometry.translate(0, -0.5, 0);
  }
  this.position.copy(origin);
  this.line = new Line(lineGeometry, new LineBasicMaterial({ color: color2 }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color: color2 }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}
ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;
ArrowHelper.prototype.setDirection = function() {
  var axis = new Vector3();
  var radians;
  return function setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      axis.set(dir.z, 0, -dir.x).normalize();
      radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(axis, radians);
    }
  };
}();
ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
  if (headLength === void 0) headLength = 0.2 * length;
  if (headWidth === void 0) headWidth = 0.2 * headLength;
  this.line.scale.set(1, Math.max(0, length - headLength), 1);
  this.line.updateMatrix();
  this.cone.scale.set(headWidth, headLength, headWidth);
  this.cone.position.y = length;
  this.cone.updateMatrix();
};
ArrowHelper.prototype.setColor = function(color2) {
  this.line.material.color.copy(color2);
  this.cone.material.color.copy(color2);
};
ArrowHelper.prototype.copy = function(source) {
  Object3D.prototype.copy.call(this, source, false);
  this.line.copy(source.line);
  this.cone.copy(source.cone);
  return this;
};
ArrowHelper.prototype.clone = function() {
  return new this.constructor().copy(this);
};
function AxesHelper(size) {
  size = size || 1;
  var vertices = [
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size,
    0,
    0,
    0,
    0,
    0,
    0,
    size
  ];
  var colors3 = [
    1,
    0,
    0,
    1,
    0.6,
    0,
    0,
    1,
    0,
    0.6,
    1,
    0,
    0,
    0,
    1,
    0,
    0.6,
    1
  ];
  var geometry2 = new BufferGeometry();
  geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry2.addAttribute("color", new Float32BufferAttribute(colors3, 3));
  var material = new LineBasicMaterial({ vertexColors: VertexColors });
  LineSegments.call(this, geometry2, material);
}
AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
Curve.create = function(construct, getPoint) {
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
};
Object.assign(CurvePath.prototype, {
  createPointsGeometry: function(divisions) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function(divisions) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function(points) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    var geometry2 = new Geometry();
    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      geometry2.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }
    return geometry2;
  }
});
Object.assign(Path.prototype, {
  fromPoints: function(points) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    this.setFromPoints(points);
  }
});
Object.create(CatmullRomCurve3.prototype);
Object.create(CatmullRomCurve3.prototype);
function Spline(points) {
  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
  CatmullRomCurve3.call(this, points);
  this.type = "catmullrom";
}
Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function() {
    console.error("THREE.Spline: .initFromArray() has been removed.");
  },
  getControlPointsArray: function() {
    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
  },
  reparametrizeByArcLength: function() {
    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
  }
});
GridHelper.prototype.setColors = function() {
  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
};
SkeletonHelper.prototype.update = function() {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Object.assign(Loader.prototype, {
  extractUrlBase: function(url) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return LoaderUtils.extractUrlBase(url);
  }
});
Object.assign(ObjectLoader.prototype, {
  setTexturePath: function(value) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(value);
  }
});
Object.assign(Box2.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  },
  empty: function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  },
  isIntersectionBox: function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  },
  size: function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  }
});
Line3.prototype.center = function(optionalTarget) {
  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
  return this.getCenter(optionalTarget);
};
Object.assign(_Math, {
  random16: function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  },
  nearestPowerOfTwo: function(value) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return _Math.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function(value) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return _Math.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function(array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  },
  applyToBuffer: function(buffer2) {
    console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer2);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function(m) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function(array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: /* @__PURE__ */ function() {
    var v1;
    return function getPosition() {
      if (v1 === void 0) v1 = new Vector3();
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return v1.setFromMatrixColumn(this, 3);
    };
  }(),
  setRotationFromQuaternion: function(q) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  },
  multiplyVector3: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  },
  rotateAxis: function(v) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v.transformDirection(this);
  },
  crossVector: function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  },
  translate: function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  },
  rotateX: function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  },
  rotateY: function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  },
  rotateZ: function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  },
  rotateByAxis: function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  },
  applyToBuffer: function(buffer2) {
    console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
    return this.applyToBufferAttribute(buffer2);
  },
  applyToVector3Array: function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  },
  makeFrustum: function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});
Plane.prototype.isIntersectionLine = function(line3) {
  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
  return this.intersectsLine(line3);
};
Quaternion.prototype.multiplyVector3 = function(vector) {
  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
  return vector.applyQuaternion(this);
};
Object.assign(Ray.prototype, {
  isIntersectionBox: function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  },
  barycoordFromPoint: function(point, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(point, target);
  },
  midpoint: function(target) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(target);
  },
  normal: function(target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(target);
  },
  plane: function(target) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function(point, a, b, c, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function(a, b, c, target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function(divisions) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(divisions);
  },
  extrude: function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function(attribute, index, offset) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function(v) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  },
  setEulerFromQuaternion: function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  },
  getPositionFromMatrix: function(m) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function(m) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function(index, matrix) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function(m) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m);
  },
  fromAttribute: function(attribute, index, offset) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function(v) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function(attribute, index, offset) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  }
});
Object.assign(Geometry.prototype, {
  computeTangents: function() {
    console.error("THREE.Geometry: .computeTangents() has been removed.");
  },
  computeLineDistances: function() {
    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  },
  renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  },
  translate: function(distance2, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance2);
  },
  getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function() {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      return this.rotation.order;
    },
    set: function(value) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    },
    set: function() {
      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function() {
      console.warn("THREE.LOD: .objects has been renamed to .levels.");
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
  get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  },
  set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }
});
SkinnedMesh.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
  get: function() {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    return this.arcLengthDivisions;
  },
  set: function(value) {
    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
    this.arcLengthDivisions = value;
  }
});
PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== void 0) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
};
Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function() {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    }
  },
  shadowCameraFov: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function(value) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function() {
      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
    }
  },
  shadowBias: {
    set: function(value) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function() {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    }
  },
  shadowMapWidth: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function(value) {
      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
      this.shadow.mapSize.height = value;
    }
  }
});
Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function() {
      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
      return this.array.length;
    }
  },
  copyIndicesArray: function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function(index) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index);
  },
  addDrawCall: function(start2, count2, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start2, count2);
  },
  clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  },
  computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  },
  computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function() {
      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
      return this.groups;
    }
  },
  offsets: {
    get: function() {
      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
      return this.groups;
    }
  }
});
Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function() {
    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
  },
  addShapeList: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
  },
  addShape: function() {
    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
  }
});
Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function() {
      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
    }
  },
  onUpdate: {
    value: function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    }
  }
});
Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .wrapAround has been removed.");
    }
  },
  overdraw: {
    get: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function() {
      console.warn("THREE.Material: .overdraw has been removed.");
    }
  },
  wrapRGB: {
    get: function() {
      console.warn("THREE.Material: .wrapRGB has been removed.");
      return new Color();
    }
  },
  shading: {
    get: function() {
      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    },
    set: function(value) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      this.flatShading = value === FlatShading;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
      return false;
    },
    set: function() {
      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(value) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = value;
    }
  }
});
Object.assign(WebGLRenderer.prototype, {
  clearTarget: function(renderTarget, color2, depth, stencil) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(renderTarget);
    this.clear(color2, depth, stencil);
  },
  animate: function(callback) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  },
  resetGLState: function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  },
  supportsFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  },
  supportsHalfFloatTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  },
  supportsStandardDerivatives: function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  },
  supportsCompressedTextureS3TC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  },
  supportsCompressedTexturePVRTC: function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  },
  supportsBlendMinMax: function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  },
  supportsVertexTextures: function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  },
  enableScissorTest: function(boolean) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean);
  },
  initMaterial: function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },
  addPrePlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },
  addPostPlugin: function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },
  updateShadowMap: function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  },
  setFaceCulling: function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function() {
      return this.shadowMap.enabled;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function() {
      return this.shadowMap.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
    }
  },
  renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  },
  renderSingleSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      return void 0;
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
    }
  }
});
Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      return this.texture.wrapS;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      return this.texture.wrapT;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      return this.texture.minFilter;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      return this.texture.offset;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      return this.texture.repeat;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
      this.texture.repeat = value;
    }
  },
  format: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      return this.texture.format;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
      this.texture.format = value;
    }
  },
  type: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      return this.texture.type;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      return this.texture.generateMipmaps;
    },
    set: function(value) {
      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
      this.texture.generateMipmaps = value;
    }
  }
});
Object.defineProperties(WebVRManager.prototype, {
  standing: {
    set: function() {
      console.warn("THREE.WebVRManager: .standing has been removed.");
    }
  },
  userHeight: {
    set: function() {
      console.warn("THREE.WebVRManager: .userHeight has been removed.");
    }
  }
});
Audio$1.prototype.load = function(file) {
  console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
  var scope = this;
  var audioLoader = new AudioLoader();
  audioLoader.load(file, function(buffer2) {
    scope.setBuffer(buffer2);
  });
  return this;
};
AudioAnalyser.prototype.getData = function() {
  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
  return this.getFrequencyData();
};
CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
  return this.update(renderer, scene);
};
ImageUtils.crossOrigin = void 0;
ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  var loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(url, onLoad, void 0, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadTextureCube = function(urls2, mapping, onLoad, onError) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  var loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  var texture = loader.load(urls2, onLoad, void 0, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};
ImageUtils.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
};
ImageUtils.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
};
//! CONFIG
const uploadUrl = urls.photoUrl;
const uploadField = "file";
const videoUrl = urls.videoUrl;
var isAnimated = false;
var MainRender$1;
function dataURItoBlob(dataURI) {
  const byteString = atob(dataURI.split(",")[1]);
  const mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  const blob = new Blob([ab], { type: mimeString });
  return blob;
}
class GameRender {
  constructor() {
    __publicField(this, "requestScreenshot", (url, field) => new Promise(async (res) => {
      console.time("requestScreenshot");
      const originalCanvas = this.canvas;
      this.createTempCanvas();
      if (!this.canvas) {
        return res(false);
      }
      url = url || uploadUrl;
      field = field || uploadField;
      isAnimated = false;
      const ctx2 = this.canvas.getContext("2d");
      let pixelData = ctx2.getImageData(0, 0, 1, 1).data;
      if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {
        window.MainRender.renderToTarget(this.canvas);
        await new Promise((resolve) => setTimeout(resolve, 200));
        pixelData = ctx2.getImageData(0, 0, 1, 1).data;
        if (pixelData[0] === 0 && pixelData[1] === 0 && pixelData[2] === 0) {
          res(false);
          return;
        }
      }
      this.gameTexture.needsUpdate = true;
      const imageURL = this.canvas.toDataURL("image/jpeg", 0.8);
      const formData = new FormData();
      formData.append(field, dataURItoBlob(imageURL), "screenshot.jpg");
      try {
        const response = await fetch(url, { method: "POST", body: formData });
        const result = await response.json();
        if (result.url) {
          console.timeEnd("requestScreenshot");
          callNui("updateLastPhoto", {
            url: result.url,
            type: "photo"
          });
          res(result.url);
        } else {
          res(false);
        }
      } catch (error) {
        res(false);
      }
      this.canvas = originalCanvas;
      isAnimated = true;
      if (window.MainRender) {
        window.MainRender.renderToTarget(document.getElementById("gameview-canvas"));
      }
      requestAnimationFrame(this.animate);
    }));
    this.resize = this.resize.bind(this);
    window.addEventListener("resize", this.resize);
    window.addEventListener("resize", this.resize);
    this.recorder = null;
    this.recordedBlobs = [];
    this.isRecording = false;
    this.videoDuration = 5e3;
    this.lastRenderTime = 0;
    this.targetFPS = 30;
    this.frameInterval = 1e3 / this.targetFPS;
    const cameraRTT = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -1e4, 1e4);
    cameraRTT.position.z = 0;
    cameraRTT.setViewOffset(window.innerWidth, window.innerHeight, 0, 0, window.innerWidth, window.innerHeight);
    const sceneRTT = new Scene();
    const scaleFactor = 0.7;
    const rtWidth = Math.floor(window.innerWidth * scaleFactor);
    const rtHeight = Math.floor(window.innerHeight * scaleFactor);
    const rtTexture = new WebGLRenderTarget(rtWidth, rtHeight, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: UnsignedByteType,
      generateMipmaps: false
      // PERFORMANS
    });
    const gameTexture = new CfxTexture();
    gameTexture.needsUpdate = true;
    const material = new ShaderMaterial({
      uniforms: { "tDiffuse": { value: gameTexture } },
      vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = vec2(uv.x, 1.0-uv.y);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
      fragmentShader: `
                varying vec2 vUv;
                uniform sampler2D tDiffuse;
                void main() {
                    gl_FragColor = texture2D(tDiffuse, vUv);
                }
            `
    });
    const aspectRatio2 = 16 / 9;
    const plane = new PlaneBufferGeometry(window.innerWidth, window.innerWidth / aspectRatio2);
    const quad = new Mesh(plane, material);
    quad.position.z = -100;
    sceneRTT.add(quad);
    const renderer = new WebGLRenderer({
      powerPreference: "low-power",
      antialias: false,
      precision: "lowp",
      preserveDrawingBuffer: true
    });
    renderer.setPixelRatio(window.devicePixelRatio / 1.5);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.autoClear = false;
    let appendArea = document.createElement("div");
    appendArea.id = "three-game-render";
    document.body.append(appendArea);
    appendArea.appendChild(renderer.domElement);
    appendArea.style.display = "none";
    this.renderer = renderer;
    this.rtTexture = rtTexture;
    this.sceneRTT = sceneRTT;
    this.cameraRTT = cameraRTT;
    this.gameTexture = gameTexture;
    this.canvas = renderer.domElement;
    this.scaleFactor = scaleFactor;
    this.animate = this.animate.bind(this);
    requestAnimationFrame(this.animate);
  }
  resize() {
    if (this.rtTexture) this.rtTexture.dispose();
    if (this.renderer) this.renderer.dispose();
    const aspectRatio2 = 16 / 9;
    const width = window.innerHeight * aspectRatio2;
    const rtWidth = Math.floor(window.innerWidth * this.scaleFactor);
    const rtHeight = Math.floor(window.innerHeight * this.scaleFactor);
    const cameraRTT = new OrthographicCamera(
      -width / 2,
      width / 2,
      window.innerHeight / 2,
      -window.innerHeight / 2,
      -1e4,
      1e4
    );
    cameraRTT.setViewOffset(window.innerWidth, window.innerHeight, 0, 0, window.innerWidth, window.innerHeight);
    this.cameraRTT = cameraRTT;
    this.rtTexture = new WebGLRenderTarget(rtWidth, rtHeight, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: UnsignedByteType,
      generateMipmaps: false
      // PERFORMANS
    });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  startRecording() {
    if (this.isRecording) return;
    this.isRecording = true;
    this.recordedBlobs = [];
    const stream = this.canvas.captureStream(30);
    this.recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
    this.recorder.ondataavailable = (event) => {
      if (event.data.size > 0) this.recordedBlobs.push(event.data);
    };
    this.recorder.onstop = async () => {
      const blob = new Blob(this.recordedBlobs, { type: "video/webm" });
      this.uploadVideo(blob);
    };
    this.recorder.start();
    let elapsedTime = 0;
    if (this.setVideoTimer) this.setVideoTimer(elapsedTime);
    this.timerInterval = setInterval(() => {
      elapsedTime += 1;
      if (this.setVideoTimer) this.setVideoTimer(elapsedTime);
    }, 1e3);
  }
  stopRecording() {
    if (!this.isRecording) return;
    this.isRecording = false;
    clearInterval(this.timerInterval);
    if (this.setVideoTimer) this.setVideoTimer(0);
    this.recorder.stop();
  }
  async uploadVideo(blob) {
    const formData = new FormData();
    formData.append("file", blob, "video.webm");
    try {
      const response = await fetch(videoUrl, {
        method: "POST",
        body: formData
      });
      const result = await response.json();
      if (result.url) {
        callNui("SaveGalleryPhoto", {
          url: result.url,
          type: "video"
        });
      } else {
        console.error(" API baarsz yant dndrd:", JSON.stringify(result, null, 2));
      }
    } catch (error) {
      console.error(" Video ykleme hatas:", error);
    }
  }
  animate(currentTime) {
    if (currentTime - this.lastRenderTime < this.frameInterval) {
      requestAnimationFrame(this.animate);
      return;
    }
    this.lastRenderTime = currentTime;
    requestAnimationFrame(this.animate);
    if (isAnimated) {
      this.renderer.clear();
      this.renderer.render(this.sceneRTT, this.cameraRTT, this.rtTexture, true);
      const readWidth = this.rtTexture.width;
      const readHeight = this.rtTexture.height;
      const read = new Uint8Array(readWidth * readHeight * 4);
      this.renderer.readRenderTargetPixels(this.rtTexture, 0, 0, readWidth, readHeight, read);
      this.canvas.width = readWidth;
      this.canvas.height = readHeight;
      const d = new Uint8ClampedArray(read.buffer);
      const cxt = this.canvas.getContext("2d");
      const imageData = new ImageData(d, readWidth, readHeight);
      cxt.putImageData(imageData, 0, 0);
    }
  }
  createTempCanvas() {
    this.canvas = document.createElement("canvas");
    this.canvas.style.display = "inline";
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }
  renderToTarget(element) {
    this.resize(false);
    this.canvas = element;
    isAnimated = true;
  }
  stop() {
    isAnimated = false;
    if (this.canvas) {
      if (this.canvas.style.display != "none") {
        this.canvas.style.display = "none";
      }
    }
    this.resize(true);
  }
}
setTimeout(() => {
  MainRender$1 = new GameRender();
  window.MainRender = MainRender$1;
}, 1e3);
//# sourceMappingURL=index.js.map
